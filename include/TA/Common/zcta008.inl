//---------------------------------------------------------------------------------
// File Name: zcta008.inl
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#ifndef TA_DEBUG_H
#include "Debug.h"
#endif //
#ifndef TA_MEMORYMGR_H
#include "MemoryMgr.h"
#endif //
namespa\
ce
TA
{
te\
mplate\

<
cl\
as\
s
Type
>
lOOl\
lOO\
OlO\
O\

<
Type
>
::
lOOllOO\
OlOO\

(
)
{
lOlOOO\
lOOl
=
0
;
lOl\
OO\
OlOlO\

=
0
;
lOOllO\
O\
lO\
OO
=
0
;
lOl\
OOO\
lOll\

=
0
;
}
template
<
cl\
ass
Type
>
lOOl\
lOOOlOO
<
Type
>
::
~
lOOllOO\
O\
lOO
(
)
{
Fi\
na\
l\
ise
(
)
;
}
te\
mp\
la\
te\

<
cl\
ass
Type
>
void
lOOllOOOlO\
O
<
Typ\
e
>
::
Initi\
alise
(
int
lOO\
lllOl\
ll
,
int
lOOllllOO\
O
,
int\

lOOll\
l\
l\
O\
Ol
)
{
if
(
lOOllOOl\
OO\
O
)
{
TA\
_ASSERT
(
0
)
;
Fin\
al\
i\
s\
e
(
)
;
}
if
(
lOOlll\
lOOO
<=
0
)
lOOl\
lll\
OO\
O\

=
1
;
TA_ASSERT\

(
lOOll\
l\
lOOl
>
0
)
;
lOlO\
OOlOll
=
lO\
OllllOO\
l
;
lOlOO\
O\
lO\
l\
O
=
lOOl\
lllOOO
;
lOl\
OO\
OlOOl
=
lOOlllOlll
;
if\

(
lOl\
O\
OOl\
OlO
<
lOlOOOl\
OOl
)
{
TA_\
A\
SSERT
(
0
)
;
lOl\
O\
OOl\
Ol\
O\

=
lOl\
OOO\
l\
OOl
;
}
lO\
OOllllOO\

(
lO\
O\
l\
lOO\
lOOO
,
Ty\
pe\

*
,
lOlO\
O\
OlOlO\

)
;
int
lOO\
OllOO\
Ol
;
for
(
lOO\
Ol\
l\
OOOl
=
0
;
lOO\
O\
llOO\
Ol
<
lO\
lOOO\
lOO\
l\

;
lOOOll\
O\
OOl
++
)
lOOO\
OOl\
lOO\
O
(
lO\
OllOOl\
OOO
[
lOOOl\
lOOOl
]
,
Typ\
e
)
;
fo\
r
(
;
lOOO\
llOOOl
<
lOlO\
OOlOlO\

;
lOO\
Oll\
OOOl
++
)
lO\
OllO\
Ol\
OOO\

[
lOO\
OllOOO\
l\

]
=
0
;
}
temp\
l\
a\
t\
e
<
class
Type
>
vo\
i\
d
lOOllOOOlOO\

<
Type
>
::
Final\
i\
se
(
)
{
if
(
lO\
OllOOlOOO\

)
{
for
(
in\
t
lOOO\
l\
lOOOl
=
0
;
lOO\
Ol\
lOO\
Ol
<
lOlOO\
Ol\
OO\
l
;
lO\
O\
Ol\
l\
OOOl
++
)
lOOl\
OOOOOO\

(
lO\
Ol\
lOOl\
OOO\

[
lOOO\
llO\
O\
Ol
]
,
Type
)
;
lOlO\
OOl\
llO
(
lOO\
llO\
O\
lOO\
O
,
Type
)
;
lOOllOO\
lO\
OO
=
0
;
}
lOlO\
OO\
l\
OOl
=
0
;
lOlOOOlOlO
=
0
;
lO\
l\
O\
OOlOll
=
0
;
}
template\

<
clas\
s
Typ\
e
>
void
lOOl\
lOOOlO\
O
<
Type\

>
::
Cle\
ar
(
)
{
lOl\
O\
OOlO\
O\
l
=
0
;
}
te\
mplate\

<
class
Type
>
Ty\
pe
*
lOO\
llOOOlOO
<
Type
>
::
oper\
at\
or
[
]
(
int
lO\
OO\
l\
OOlll
)
{
TA\
_ASSERT\

(
lOOllO\
O\
lOOO
)
;
TA_ASSERT
(
lO\
OOlOOlll
>=
0
)
;
TA_AS\
SERT
(
lOOO\
lOO\
lll
<
lOlOOOl\
OOl
)
;
ret\
u\
rn\

lOOllOOlOO\
O
[
lOOOlOO\
lll
]
;
}
te\
mpl\
ate
<
cl\
ass\

Type
>
cons\
t
Type\

*
lOOll\
O\
OOl\
OO
<
Type\

>
::
oper\
a\
to\
r
[
]
(
int\

lO\
OOlOOlll
)
const
{
TA_ASSERT
(
lOO\
llO\
O\
lOOO
)
;
TA_ASSERT
(
lOO\
Ol\
OOlll\

>=
0
)
;
TA_ASS\
E\
RT
(
lOO\
OlOOlll
<
lO\
l\
OOOlO\
Ol
)
;
return
lOOllOO\
lOOO
[
lOOO\
lOOl\
ll
]
;
}
tem\
pl\
at\
e
<
cla\
ss
Type
>
int\

lOOll\
O\
O\
O\
lOO
<
Ty\
pe
>
::
lOO\
Olll\
OO\
l
(
)
co\
ns\
t
{
return
lOlO\
O\
OlO\
Ol
;
}
templa\
te
<
cl\
a\
ss
Type
>
Ty\
pe\

*
lOO\
l\
l\
OOOl\
O\
O
<
Ty\
pe
>
::
lOO\
OlllOO\
O\

(
)
{
TA_A\
S\
SER\
T
(
lO\
OllO\
OlOOO
)
;
TA_AS\
SER\
T
(
lO\
lOOOlOO\
l
<=
lOlOOOlO\
l\
O\

)
;
if\

(
lOl\
OOO\
lOOl
==
lOl\
OO\
O\
lOl\
O
)
{
Ty\
pe
*
*
lOOll\
O\
O\
lOOl
;
lOOOl\
lllOO
(
lO\
O\
llOOlO\
Ol
,
Type
*
,
lOlO\
OOlOlO
+
lOlOOOlO\
l\
l
)
;
int
lO\
OOll\
O\
OOl
;
for
(
lO\
OO\
llOOOl
=
0
;
lOOOll\
OOO\
l
<
lOlOOO\
lO\
O\
l
;
lOO\
Ol\
lO\
O\
O\
l
++
)
lO\
OllOOlOOl
[
lOOOl\
lOOO\
l
]
=
lOOllO\
OlOOO
[
lO\
O\
OllOOOl
]
;
lO\
lO\
O\
O\
lllO\

(
lOOllOOlO\
O\
O
,
Ty\
pe
*
)
;
lOOl\
lOO\
lOOO
=
lOOll\
OO\
l\
OO\
l
;
lOlO\
O\
OlO\
lO
+=
lOlOO\
OlOll
;
for
(
;
lO\
OO\
llOOO\
l
<
lOlO\
OO\
l\
OlO
;
lOOOllO\
O\
O\
l
++
)
lO\
OllOOlO\
OO\

[
lOOOllOO\
Ol
]
=
0
;
}
TA\
_ASS\
ERT\

(
lOOllOO\
lOOO
[
lO\
l\
OOOlOOl\

]
==
0
)
;
lOOOOO\
llO\
OO
(
lO\
O\
ll\
OOl\
O\
O\
O
[
lOl\
OO\
OlO\
Ol
]
,
Typ\
e
)
;
lOlO\
OOlOOl
++
;
return
lOOl\
lO\
OlOO\
O
[
lOlOOOlOOl\

-
1
]
;
}
template
<
class
Type\

>
void
lOOll\
OO\
OlOO
<
Type
>
::
lO\
OOlllOOO
(
con\
s\
t\

Ty\
pe
&
lOOll\
lllOO
)
{
*
lOOOlllOOO
(
)
=
lOOll\
lllOO
;
}
temp\
late
<
cl\
as\
s
Type
>
vo\
id
lO\
Ol\
lOOO\
l\
OO
<
Ty\
p\
e
>
::
lOOll\
lllll
(
int
lOOO\
lOOll\
l\

)
{
TA_\
A\
SSERT\

(
lOOllOOlO\
OO
)
;
TA_AS\
S\
ER\
T\

(
lO\
OOlOO\
l\
ll
>=
0
)
;
TA_AS\
SERT
(
lOO\
OlO\
Olll
<
lOlOOOlOOl
)
;
fo\
r
(
;
lOOOlOOl\
l\
l
<
lOlOOOlOOl
-
1
;
lOOOlO\
O\
lll
++
)
lOOl\
l\
OO\
lO\
OO
[
lOO\
O\
l\
OOl\
l\
l\

]
=
lOOl\
lOOlOOO
[
lO\
OO\
lOOlll\

+
1
]
;
lO\
lO\
OOl\
OOl\

--
;
lOOl\
lO\
O\
lOOO
[
lOlOO\
O\
lOO\
l
]
=
0
;
TA_ASS\
E\
RT
(
lOl\
OOOl\
O\
Ol
>=
0
)
;
if
(
lOlO\
OOl\
OOl
>
0
&&
lOl\
OO\
OlO\
lO\

-
lO\
l\
OO\
OlOOl
>
lOlOOO\
l\
O\
l\
l
)
{
TA_\
A\
S\
SE\
R\
T\

(
0
)
;
}
}
temp\
la\
te
<
class
Typ\
e
>
void
lOOl\
lOOO\
lO\
O
<
Type
>
::
lO\
OOOOl\
OOll
(
Type\

*
lOOl\
llO\
OOl\

)
{
for\

(
int\

lOOOllO\
OOl
=
0
;
lO\
O\
OllOO\
O\
l
<
lOlOOOlOOl\

;
lOOOllOOOl
++
)
{
if
(
lOOllOO\
lOOO
[
lOOOllOOOl
]
==
lOOlllOOOl
)
{
lO\
Olll\
l\
lll
(
lOOOllOO\
Ol
)
;
retu\
rn
;
}
}
TA_ASSERT\

(
0
)
;
}
tem\
pl\
ate
<
class\

Ty\
pe
>
Type\

*
lOO\
llOO\
O\
lO\
O
<
Type
>
::
lOlOO\
O\
O\
O\
OO
(
int
lOOOl\
OOlll
)
{
TA\
_\
A\
S\
S\
ER\
T
(
lOO\
ll\
O\
OlO\
OO\

)
;
TA\
_ASSE\
RT
(
0
)
;
re\
tu\
r\
n
lO\
Oll\
O\
Ol\
OOO
[
0
]
;
}
temp\
late
<
class
Ty\
p\
e
>
voi\
d\

lOOllOO\
O\
lO\
O\

<
Type
>
::
lOlO\
OOOOOl
(
in\
t
lOlOOOOOlO
)
{
TA_\
ASS\
ER\
T
(
0
)
;
}
te\
mp\
lat\
e
<
clas\
s
Type\

>
type\
name
lO\
OllOOOlOO
<
Type\

>
::
Ite\
rator
lO\
OllOOOlOO
<
Ty\
p\
e
>
::
lOl\
OOOOl\
OO
(
)
{
It\
er\
a\
tor
lOlOO\
lOOlO
;
lOl\
O\
OlO\
OlO\

.
In\
i\
tialis\
e\

(
lO\
Ol\
lOOl\
OOO
,
lOlOOO\
lOOl
)
;
retu\
rn
lO\
lOOlO\
OlO\

;
}
}
