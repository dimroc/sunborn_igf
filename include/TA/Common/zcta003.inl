//---------------------------------------------------------------------------------
// File Name: zcta003.inl
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

namespa\
ce\

TA
{
template
<
class
Typ\
e\

>
List
<
Typ\
e
>
::
Lis\
t
(
)
{
lO\
OO\
OOlOlOl
=
0
;
lOO\
OO\
O\
lOlll
=
0
;
}
te\
mp\
la\
te
<
class
Type\

>
Li\
st
<
Type
>
::
~
List
(
)
{
Final\
is\
e\

(
)
;
}
te\
mplate\

<
cl\
as\
s
Type\

>
voi\
d
Li\
st\

<
Type
>
::
Fi\
nalise
(
)
{
Clear
(
)
;
}
temp\
lat\
e\

<
cl\
a\
ss
Ty\
pe\

>
void
Lis\
t\

<
Type
>
::
Clear
(
)
{
while
(
lO\
O\
OO\
Ol\
OlOl
)
{
lOOllOOOOO
*
lO\
Olll\
O\
OOl\

=
lO\
OO\
OOlOl\
Ol
;
lOOOOOlOlO\
l
=
lO\
O\
OOO\
lOlOl
->
lOOOO\
OOl\
lll
;
lOOlOO\
OOOO\

(
lO\
Ol\
l\
l\
OO\
Ol
,
lOO\
llOOOOO
)
;
}
lO\
O\
OOOl\
O\
l\
l\
l
=
0
;
}
tem\
pl\
at\
e
<
cla\
ss\

Type
>
int
List\

<
Typ\
e
>
::
lO\
O\
OlllOOl
(
)
const
{
in\
t
lOOl\
llOl\
lO
=
0
;
for\

(
lOOOOO\
lOOO\
l
lOlOO\
l\
O\
O\
lO
=
lOOO\
OOlO\
l\
l\
O
(
)
;
!
lOl\
OOl\
OOlO\

.
AtEnd
(
)
;
++
lOlO\
O\
lOOlO\

)
lO\
Ol\
l\
lO\
llO\

++
;
return
lO\
Ol\
llOllO
;
}
te\
mpla\
te
<
class\

Ty\
p\
e
>
bool
Li\
st
<
Ty\
p\
e
>
::
lOOOOOlOO\
lO
(
)
cons\
t
{
return\

!
lOOO\
OO\
lO\
lOl
;
}
te\
mplate\

<
class\

Type
>
Type\

&
Li\
s\
t
<
Type\

>
::
operator
[
]
(
in\
t
lOOOlOOlll
)
{
lOO\
OOOOllO
(
lO\
OO\
lO\
Ol\
l\
l
>=
0
,
"List::operator []. Index out of bounds.")
;
Iter\
ator
lO\
lOO\
lO\
OlO\

=
lOlOOO\
O\
lO\
O\

(
)
;
fo\
r
(
int\

ll\
OllOOl\
Ol
=
0
;
llO\
l\
lOOlOl
!=
lOOO\
lO\
Olll
;
++
llO\
l\
l\
OOlOl
,
++
lO\
lOO\
lOO\
l\
O
)
{
lOOOOOOllO
(
!
lO\
lO\
OlOOlO
.
AtEn\
d
(
)
,
"List::operator []. Index out of bounds.")
;
}
return
*
lOlOO\
l\
OOlO
;
}
tem\
pl\
ate
<
cl\
ass\

Ty\
pe
>
con\
s\
t
Type
&
List
<
Type
>
::
op\
era\
t\
or
[
]
(
int
lOO\
OlO\
Ol\
ll
)
con\
st\

{
lOOOOOOllO
(
lO\
OO\
lOOlll
>=
0
,
"List::operator []. Index out of bounds.")
;
It\
era\
tor
lOlOOlOO\
lO
=
lO\
lOOOOlOO
(
)
;
fo\
r\

(
int
ll\
O\
l\
l\
OO\
lO\
l
=
0
;
llO\
l\
l\
OOlOl
!=
lO\
OOlOOll\
l
;
++
lO\
OOl\
OOlll
,
++
lO\
l\
OOlOOl\
O\

)
{
lO\
OOOOO\
llO
(
!
lO\
lO\
OlOOlO
.
AtEnd\

(
)
,
"List::operator []. Index out of bounds.")
;
}
return
*
lOlOO\
l\
O\
OlO\

;
}
te\
mplat\
e\

<
clas\
s
Type
>
Ty\
p\
e
&
Li\
st
<
Ty\
pe
>
::
lOOOll\
lO\
OO
(
)
{
if
(
lOOO\
O\
OlOll\
l
)
{
lOOOO\
O\
ll\
O\
O\
O\

(
lOOOOOlOlll
->
lOOOOO\
Ollll
,
lO\
OllO\
O\
OOO
)
;
lOO\
OOO\
l\
O\
lll\

=
lOOOOOlOll\
l\

->
lOO\
OOOOll\
ll
;
}
else
{
TA_ASSERT
(
lO\
OOOO\
lOlOl
==
0
)
;
lO\
OOOOl\
l\
O\
OO\

(
lO\
OO\
O\
OlOlll\

,
lOOllOOO\
OO
)
;
lO\
OOOO\
lOlOl
=
lO\
OOO\
OlO\
ll\
l
;
}
lO\
OOOO\
l\
Olll\

->
lOO\
OOOOll\
ll
=
0
;
ret\
urn
lO\
OO\
OOlOlll
->
lO\
O\
OOOlOO\
O\
O
;
}
templat\
e
<
clas\
s\

Typ\
e
>
voi\
d
List
<
Type
>
::
lOOOO\
O\
lOO\
ll
(
con\
st
Ty\
pe
&
lO\
OO\
lO\
Ol\
l\
O
)
{
lO\
Ol\
l\
OOO\
O\
O\

*
lOOlllOO\
O\
l\

=
lOOO\
OOlOlOl\

;
if
(
lOO\
lllO\
OOl
->
lOO\
O\
OO\
lOOOO
==
lOO\
O\
l\
OOl\
lO
)
{
lOO\
O\
OOlOlOl\

=
lOOlllOOOl\

->
lOOOOO\
Ollll\

;
if
(
lOO\
O\
O\
O\
lOlOl\

==
0
)
lO\
O\
OO\
O\
lOlll
=
0
;
lOOl\
OOO\
OOO
(
lO\
O\
lllOO\
Ol
,
lOO\
llOO\
OOO
)
;
return\

;
}
wh\
ile
(
lOOll\
lO\
O\
Ol\

->
lOOOOOOllll\

)
{
lOOl\
lO\
O\
O\
O\
O\

*
lOOO\
OOOllll
=
lOOlllOOOl\

->
lOOO\
OO\
O\
ll\
l\
l
;
if
(
lOO\
OOO\
Ollll
->
lOOOOOlOOOO
==
lOOOlO\
Ol\
lO
)
{
lO\
O\
lllOOOl
->
lO\
OO\
O\
OOl\
lll
=
lO\
OOOOO\
ll\
l\
l
->
lOO\
O\
O\
O\
Ol\
lll\

;
if\

(
lO\
OOO\
OO\
l\
lll
==
lOO\
OOOl\
Olll\

)
lOO\
OOO\
lOlll
=
lOOlllOOOl
;
lO\
OlO\
OOO\
OO
(
lO\
O\
OO\
OOll\
l\
l
,
lOO\
l\
l\
OO\
O\
O\
O
)
;
return
;
}
lO\
OlllOO\
Ol
=
lOOO\
OOO\
l\
lll
;
}
}
template
<
class
Ty\
p\
e
>
voi\
d
List
<
Type\

>
::
lOO\
lll\
l\
lll
(
co\
n\
st
Ty\
pe
*
lOO\
OO\
Ol\
Ol\
OO
)
{
lO\
OllOOO\
O\
O
*
lOOll\
lOOOl
=
lOOO\
OOlOlOl
;
if
(
&
lOOl\
ll\
OOOl
->
lOOO\
OOlOO\
OO
==
lO\
OOOOlOlOO
)
{
lO\
O\
OOOl\
O\
lO\
l\

=
lOOlll\
OOOl
->
lO\
OOOO\
O\
llll
;
if\

(
lO\
OOOO\
lO\
lOl\

==
0
)
lOOO\
OOlOlll\

=
0
;
lO\
Ol\
OOOOO\
O\

(
lO\
Ol\
llOOOl\

,
lOOllO\
O\
OOO\

)
;
re\
tur\
n
;
}
whi\
l\
e\

(
lOOlllOOOl
->
lOO\
OOOO\
llll
)
{
lOOllO\
O\
OOO
*
lO\
OO\
OOOllll
=
lOO\
l\
llOOOl\

->
lOOO\
O\
OO\
lll\
l
;
if\

(
&
lOOO\
O\
OOllll
->
lOOO\
OO\
lOOOO
==
lOOO\
OOlOlOO
)
{
lO\
Oll\
l\
OOOl\

->
lOOOOOOllll
=
lO\
O\
O\
OOOl\
l\
ll\

->
lO\
OO\
O\
O\
O\
l\
lll
;
if\

(
lOOOOO\
O\
l\
lll
==
lOOOOOlOl\
ll\

)
lOOOOOl\
Olll\

=
lOOlllO\
OOl
;
lOO\
lOO\
OO\
OO
(
lOOOOOOl\
l\
ll
,
lO\
OllO\
OOOO
)
;
return
;
}
lOOlllOOOl
=
lOOOOOOll\
ll\

;
}
}
}
