//---------------------------------------------------------------------------------
// File Name: zcta011.inl
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#ifndef TA_DEBUG_H
#include "Debug.h"
#endif //
na\
mespa\
c\
e\

TA\

{
inl\
i\
ne
Vec\
3
oper\
ator
*
(
float\

lOOO\
OOll\
lO
,
const
Ve\
c3\

&
llllOO\
O\
l\
ll
)
{
Ve\
c3
lO\
OOlOlOlO\
l
(
lO\
OO\
OO\
lllO
*
lll\
lOO\
Ol\
ll
.
x
,
lOO\
OO\
O\
lllO
*
llll\
OO\
Olll
.
y
,
lO\
OOOOlllO
*
llllO\
OOll\
l
.
z
)
;
re\
turn
lOOOlOlO\
lOl
;
}
inline
int
Vec3
::
Ge\
t\
Gr\
eat\
estAx\
is\

(
)
const
{
float
lOlO\
O\
OOOOOO
=
Fa\
bs
(
x
)
;
float\

lO\
lOOO\
OOO\
Ol\

=
Fa\
b\
s
(
y
)
;
float
lO\
lO\
O\
OOOOlO
=
Fabs
(
z
)
;
if
(
lOlOOOO\
OOO\
O
>
lO\
lOOO\
OOO\
Ol\

)
{
if
(
lO\
lO\
O\
OO\
O\
OOO\

>
lOlOOOOOO\
lO
)
ret\
urn
AXI\
S\
_\
X
;
els\
e
return\

AXIS_Z
;
}
else
{
if
(
lO\
lOOO\
OOOOl\

>
lO\
l\
O\
OOOOOlO
)
return
AX\
IS_\
Y
;
else
re\
turn
AXIS_Z
;
}
}
inlin\
e
void\

Vec3
::
GetA\
x\
i\
sOrde\
r
(
in\
t
llllO\
Ol\
OO\
l
[
3
]
)
co\
n\
s\
t
{
float
lOlOOOO\
OOOO\

=
Fa\
bs
(
x
)
;
float\

lOl\
OO\
OOOO\
O\
l
=
Fabs\

(
y
)
;
fl\
oat
lOlOO\
OOOOlO
=
Fab\
s\

(
z
)
;
if\

(
lOlOOO\
OOOOO\

>
lOl\
OOO\
O\
OOOl
)
{
if\

(
lO\
lOOOOO\
O\
OO
>
lOlO\
O\
OOO\
Ol\
O
)
{
llllO\
OlOOl
[
0
]
=
AXIS_\
X\

;
if
(
lO\
lOOO\
OO\
OO\
l
>
lOlOOOOOOlO
)
{
llllOOlOO\
l
[
1
]
=
AXIS_\
Y\

;
lll\
lOOlO\
Ol
[
2
]
=
AXIS\
_Z
;
}
else
{
llllOO\
lO\
Ol
[
1
]
=
AXI\
S_\
Z
;
lll\
l\
O\
OlO\
Ol
[
2
]
=
AXIS_\
Y\

;
}
}
el\
s\
e
{
llllO\
OlO\
Ol\

[
0
]
=
AXIS_Z
;
ll\
llOOlOOl
[
1
]
=
AXIS_\
X\

;
llllOOlOO\
l
[
2
]
=
AXIS\
_Y
;
}
}
else
{
if
(
lOlO\
OOOOOOl
>
lO\
l\
OO\
OOO\
Ol\
O\

)
{
ll\
ll\
OOlO\
Ol
[
0
]
=
AXI\
S_Y
;
if
(
lOl\
OOOOO\
OOO
>
lOlO\
OO\
OOO\
lO
)
{
ll\
ll\
O\
OlOOl
[
1
]
=
AXIS_X
;
ll\
l\
l\
O\
OlOOl
[
2
]
=
AXIS_Z
;
}
el\
se\

{
llllO\
Ol\
O\
Ol\

[
1
]
=
AX\
IS_Z
;
lll\
lOOlOOl
[
2
]
=
AXIS\
_\
X\

;
}
}
el\
se
{
llllOOl\
OOl
[
0
]
=
AX\
I\
S_Z
;
ll\
ll\
OOl\
OOl\

[
1
]
=
AXIS_Y
;
lll\
l\
OOlO\
Ol\

[
2
]
=
AXI\
S_X
;
}
}
TA_A\
SSE\
RT
(
Fa\
bs
(
Ge\
tAxi\
s
(
ll\
ll\
OOlO\
Ol
[
0
]
)
)
>=
Fabs\

(
Get\
Axis
(
llllOOl\
O\
Ol\

[
1
]
)
)
)
;
TA_\
AS\
S\
ER\
T
(
Fa\
bs\

(
Get\
A\
xis
(
llll\
OOlOO\
l\

[
1
]
)
)
>=
Fab\
s
(
Get\
Axi\
s
(
ll\
ll\
OOlOO\
l
[
2
]
)
)
)
;
}
inlin\
e
co\
nst
Vec3
&
Ve\
c3
::
Get\
UnitVecto\
r
(
int
lO\
OOlOOlll
)
{
switc\
h
(
lOOOlO\
Ol\
ll
)
{
case\

AXI\
S_X
:
re\
turn
k_v3Un\
i\
tX
;
break
;
ca\
s\
e
AXIS_Y\

:
return
k_v3\
Uni\
tY\

;
bre\
ak
;
cas\
e
AXIS_Z
:
retur\
n
k_v3UnitZ\

;
break
;
default
:
lllOOO\
ll\
lO\

;
return
k_v3UnitX\

;
}
}
in\
line\

bool
Vec3\

::
IsEqu\
a\
lW\
i\
thInEr\
ror
(
con\
s\
t
Vec3\

&
llllOOOl\
ll
,
float
llOllOlllO
)
con\
s\
t
{
Vec3
lO\
lOOOOO\
Ol\
l
=
*
thi\
s
-
llll\
O\
OOlll
;
retu\
rn
Fabs
(
lOlOOO\
OOO\
l\
l
.
x
)
<=
ll\
O\
llOlll\
O\

&&
Fabs\

(
lOl\
OOOOOOll
.
y
)
<=
llO\
l\
lO\
l\
llO\

&&
Fabs
(
lO\
lO\
OOOOOl\
l\

.
z
)
<=
llOl\
lOll\
lO
;
}
}
