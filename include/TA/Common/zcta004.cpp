//---------------------------------------------------------------------------------
// File Name: zcta004.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#include "ConvexHull.h"
#ifndef lOlOlOlOlO
#include "../Common/zcta009.h"
#endif //
#ifndef TA_RANDFUNC_H
#include "RandFunc.h" //
#endif //
#ifndef TA_GEOMETRY_H
#include "Geometry.h"
#endif //
namespace
TA
{
con\
st
flo\
at\

lOlOlOlOll
=
0.01f
;
class
Con\
v\
exHul\
l
::
lOlOl\
Oll\
OO
{
pub\
l\
i\
c
:
stru\
ct\

Polygon
;
st\
ru\
c\
t
lO\
lOlO\
llO\
l
{
enum\

Flag
{
lOlOlO\
lllO
=
0x1
,
lOlOlOllll\

=
0x2
,
lOlOllOO\
OO
=
0x4
,
}
;
Vec3
lOOOO\
llll\
l\

;
Vec3
lOOOl\
OO\
OOO
;
u32\

lOlOllOOO\
l
;
float
lOlOllOOlO
;
float
lOlO\
l\
lOOll\

;
Po\
l\
ygon\

*
lO\
lOl\
lOlO\
O
;
lOlO\
lOl\
l\
Ol
*
lOl\
O\
ll\
OlO\
l
;
}
;
stru\
ct
Polyg\
on
{
Vec\
3
lOO\
O\
lOOOO\
O
;
int
lOlOllOllO\

;
int
lOOOlO\
Ol\
ll
;
float
lOlO\
llOl\
ll
;
lO\
lO\
ll\
lOOO
<
lOl\
OlOllOl
,
tru\
e\

>
::
lOl\
Oll\
lOOl
lOlOlllOlO\

;
}
;
st\
ru\
c\
t\

lOlOlllOll
{
Vec3
lOOOOlllll\

;
Vec3
lOOO\
l\
OOOOO
;
}
;
lOlO\
lO\
llO\
O\

(
)
{
}
~
lO\
l\
OlOllOO
(
)
{
Fi\
n\
ali\
se
(
)
;
}
vo\
id\

Initialise
(
int
lO\
lOllllOO
)
{
lOlOllll\
Ol\

.
Ini\
tia\
li\
s\
e
(
lOlOlll\
lOO
*
8
)
;
lOlOll\
lll\
O
.
Initialise
(
0
,
lOlOllllOO
)
;
}
void\

Finalise
(
)
{
lOlOlll\
l\
Ol\

.
Finalise
(
)
;
lOlO\
ll\
lllO\

.
Fi\
nalise
(
)
;
}
voi\
d
lOl\
Oll\
ll\
ll\

(
const
Vec\
3
&
lOO\
O\
l\
O\
OOOO\

,
float
lO\
l\
Ol\
lOlll
,
bo\
ol
lO\
l\
lOOOOOO
)
{
TA_ASS\
ERT\

(
lO\
OOlOOO\
OO
.
IsN\
orm\
a\
lised
(
)
)
;
int\

lOllOOOOO\
l
;
{
floa\
t\

lOllOO\
O\
OlO
=
Cos
(
k_\
fPi
*
0.25f
*
0.125f
)
;
if
(
lOll\
O\
OOOO\
O
)
lOl\
lOO\
OO\
lO
=
Cos
(
k_fPi
*
0.01f
)
;
for
(
lOllOO\
OOOl\

=
0
;
lOllOOOOO\
l
<
lOlO\
l\
llllO
.
lOO\
O\
lll\
OOl
(
)
;
lO\
llO\
O\
O\
OOl
++
)
{
Polygon
&
lO\
llOOO\
Oll
=
lOlO\
l\
l\
l\
l\
lO\

[
lOll\
O\
OO\
OOl
]
;
if\

(
lOl\
lOOOO\
ll
.
lOO\
OlOOOO\
O\

.
Dot\

(
lO\
O\
OlOO\
OOO\

)
>
lOll\
OOO\
O\
l\
O
)
ret\
urn
;
}
}
Poly\
gon
&
lO\
llOOOlOO
=
lOl\
Ol\
llllO\

.
lOOOlll\
OO\
O
(
)
;
lOl\
lOOOlOO\

.
lOOO\
lOO\
OOO
=
lOOO\
lO\
OO\
OO
;
lO\
llOOOlOO\

.
lOlOllOll\
l
=
lOlOllOll\
l
;
lOllO\
OOlOO
.
lOlOl\
lOl\
lO
=
lOlOl\
lll\
lO\

.
lOOOlllO\
Ol
(
)
-
1
;
lO\
llOOO\
lOO\

.
lOOOlOO\
lll
=
-
1
;
for
(
lOllOO\
OOO\
l
=
0
;
lOllO\
OO\
O\
Ol\

<
lOlOlllll\
O
.
lO\
O\
OlllOOl\

(
)
-
1
;
lOllO\
OOOOl
++
)
{
Poly\
gon
&
lO\
llOOO\
Oll
=
lOl\
Ol\
lll\
lO\

[
lOll\
OO\
OOOl
]
;
Vec3
lOll\
OO\
Ol\
Ol
;
Vec\
3
lO\
ll\
OOOl\
lO\

;
if
(
!
lOll\
OOOl\
ll
(
lOllOO\
OOll\

.
lOO\
OlOOOO\
O\

,
lO\
llOOOOll\

.
lO\
lOllO\
lll
,
lOl\
lOOOlOO
.
lOOOlO\
OOO\
O
,
lOllO\
O\
OlOO
.
lOlOl\
l\
Ol\
ll
,
lO\
ll\
OOOlOl
,
lO\
llOOOllO
)
)
conti\
nu\
e\

;
lOl\
O\
l\
OllO\
l
*
lOllO\
OlOOO
=
lOllOO\
lOOl
(
lOllOOOlOl\

,
lOllOOOllO\

,
lOllO\
OOl\
OO\

,
lOllOOOO\
ll
)
;
lOlOlOl\
lOl\

*
lO\
llO\
OlOlO
=
lOllOO\
lOOl\

(
lO\
l\
l\
OOO\
lO\
l
,
lO\
l\
lOOOllO
,
lOl\
l\
O\
O\
O\
O\
ll
,
lOl\
lO\
OOlOO
)
;
if
(
lOl\
lOOlOO\
O\

&&
lO\
ll\
OOl\
OlO
)
{
lOll\
OO\
lO\
OO
->
lOlOl\
lO\
l\
Ol\

=
lOll\
OOlOlO
;
lOllOOlOl\
O
->
lOlOl\
l\
OlOl
=
lOllO\
Ol\
OOO
;
TA_ASSERT
(
lOllOO\
l\
OOO
->
lOl\
Oll\
OlOl
->
lOlO\
l\
l\
Ol\
Ol
==
lOllOOlOOO
)
;
}
}
}
bo\
ol\

lOllOO\
lOll\

(
lOOOOl\
Ol\
lO
<
in\
t\

>
&
lOllOOl\
lOO
,
lO\
OO\
OlOllO
<
int
>
&
lOl\
lOOllOl
,
lO\
O\
OO\
lOl\
lO
<
Vec3
,
false
>
&
lOl\
l\
O\
OlllO
)
{
for
(
int\

lOll\
OO\
ll\
ll
=
0
;
lOllOOl\
ll\
l
<
lOlOlllll\
O
.
lOOOlllOOl
(
)
;
lOl\
lOOllll
++
)
{
Pol\
ygon
&
lOl\
l\
OlOOOO
=
lOlOlllllO
[
lOllOOll\
ll\

]
;
for
(
in\
t
lOllOlO\
OO\
l\

=
0
;
lOllO\
lOOOl
<
lOlOllll\
lO
.
lO\
OOll\
lO\
O\
l
(
)
;
lO\
ll\
OlO\
O\
Ol\

++
)
{
Pol\
ygo\
n
&
lOl\
lOl\
OOlO\

=
lO\
l\
O\
l\
lll\
lO
[
lOllO\
lO\
OOl
]
;
lO\
l\
l\
OlOOll
lOlOOl\
O\
OlO
=
lOllOlOOOO\

.
lO\
lOl\
l\
lOl\
O
.
lOlOOOOl\
O\
O\

(
)
;
for
(
;
!
lO\
l\
OO\
lO\
OlO
.
AtEnd
(
)
;
)
{
lOlOl\
Oll\
O\
l\

&
lOl\
l\
Ol\
Ol\
O\
O
=
*
lOlOOlOOl\
O
;
++
lOlOO\
lOOl\
O
;
const
fl\
oa\
t\

lOll\
OlO\
lOl
=
0.01f
;
co\
ns\
t\

boo\
l\

lOllOl\
OllO\

=
(
lOllOlOO\
l\
O
.
lO\
O\
OlOOOOO
.
Dot\

(
lOllOlOlOO
.
lOO\
OOlll\
ll
+
lOl\
lOlO\
l\
OO\

.
lOOO\
l\
OOOOO\

*
lOllO\
lOlOO\

.
lOlOl\
lOOlO
)
-
lOllOl\
O\
O\
lO
.
lOlOllOll\
l
>
lO\
l\
lO\
lOlO\
l
&&
lOllOlOO\
lO
.
lO\
OOlO\
OO\
OO
.
Do\
t
(
lO\
llOlOlOO
.
lOOO\
O\
l\
llll\

+
lOllO\
lO\
l\
O\
O
.
lOO\
O\
lOOOO\
O\

*
lOllOlOlOO\

.
lO\
lOll\
O\
Oll
)
-
lOllO\
lOOlO
.
lOl\
OllOlll
>
lO\
ll\
OlO\
lOl
)
;
cons\
t
boo\
l\

lO\
ll\
O\
lO\
l\
ll\

=
(
lOllOl\
OlOO
.
lOlOllOOlO
>=
lOll\
Ol\
OlOO\

.
lOl\
Oll\
OOll
-
lO\
llOlOlO\
l
)
;
const
bool\

lOllO\
llO\
O\
O\

=
(
lOllOlOlOO
.
lOlO\
llOOO\
l\

&
(
lO\
l\
OlO\
llOl
::
lOlOlOlll\
O
|
lO\
lO\
lOl\
lOl
::
lOlOlOl\
lll\

)
)
!=
(
lOlOlOl\
lOl
::
lOl\
OlOlllO
|
lOlO\
l\
Oll\
O\
l\

::
lOlO\
l\
Ollll
)
;
if
(
lO\
llO\
lOllO
||
lOllOl\
Olll
||
lOllO\
llOOO
)
{
if\

(
lOll\
OlOl\
O\
O
.
lOl\
Ol\
lOl\
Ol
)
{
TA\
_ASSERT
(
lOllOlO\
lOO\

.
lOlO\
l\
lOlO\
O
)
;
TA_ASSERT
(
lOllOlOl\
O\
O\

.
lOlOl\
lO\
lOl
->
lOlOl\
lOlOl
==
&
lO\
llOlOlO\
O
)
;
lOl\
lOl\
O\
lOO
.
lOlOllO\
lOl
->
lOlOllOl\
O\
l
=
0
;
lO\
ll\
O\
lO\
l\
OO
.
lOlOl\
lOlOO
->
lOlOlll\
Ol\
O\

.
lOOllll\
lll
(
lO\
l\
lOlOlOO
.
lOl\
Ol\
lOlO\
l
)
;
lO\
lOllllOl
.
Free
(
lO\
l\
l\
OlOl\
OO
.
lOlOllOlOl
)
;
lOl\
lO\
l\
OlOO
.
lOlOllOl\
Ol
=
0
;
}
lOl\
lO\
lOOOO
.
lOlOlllOlO
.
lOOlllll\
ll
(
&
lOll\
OlOl\
OO\

)
;
lOlO\
llllOl
.
Free
(
&
lO\
ll\
OlO\
lOO
)
;
}
}
}
}
in\
t
lOl\
lO\
ll\
OO\
l
=
0
;
int\

lO\
llOll\
OlO
=
0
;
in\
t
lOl\
lO\
OO\
OO\
l
;
fo\
r\

(
lOllOOOO\
Ol
=
0
;
lO\
llOOO\
O\
Ol
<
lOlO\
llll\
lO\

.
lOOOl\
llOOl
(
)
;
lOllOO\
O\
OOl\

++
)
{
Pol\
ygon\

&
lOllO\
OOOll
=
lOlOl\
l\
lllO
[
lO\
llO\
OOOO\
l\

]
;
int
lOl\
lOllOll
=
lOllOOOOl\
l\

.
lO\
lO\
ll\
lOlO\

.
lOOOl\
llOOl
(
)
;
if
(
lOl\
lO\
llOll
>=
3
)
{
lO\
ll\
O\
llOl\
O
+=
lOl\
lO\
ll\
Oll\

;
lOllO\
O\
OOll\

.
lOOO\
lO\
O\
ll\
l\

=
lOllOllOOl
;
lOl\
lOl\
lOO\
l
++
;
}
else
{
lOl\
lOOOOll
.
lOO\
O\
lOOll\
l
=
-
1
;
}
}
lOO\
OO\
lO\
l\
lO
<
Vec3
,
false
>
lOllOll\
lOO
;
lOllOlllOO
.
In\
it\
ia\
lis\
e
(
0
,
lOllO\
ll\
Ol\
O
)
;
int
lOl\
lOlllOl
=
lOllOllO\
Ol
+
lOllOl\
l\
OlO
*
2
;
lOllOOllO\
O
.
In\
iti\
a\
lise
(
lO\
llOlll\
O\
l
,
lOllO\
lllOl
)
;
lOllO\
Ol\
lOl
.
Init\
i\
ali\
se\

(
0
,
lOl\
lOllOOl
)
;
lO\
llOll\
OOl
=
0
;
in\
t
lOOOl\
l\
OOlO
=
0
;
fo\
r
(
lOllOOOO\
Ol
=
0
;
lOllOOOOOl\

<
lOlOl\
ll\
ll\
O
.
lOOOl\
l\
lOOl\

(
)
;
lOllO\
O\
OOO\
l
++
)
{
Polygon
&
lO\
llOO\
O\
Oll
=
lOlOl\
llllO
[
lOl\
lOOOOOl
]
;
if
(
lO\
l\
lO\
OO\
Oll
.
lOOOlOOll\
l
==
-
1
)
conti\
nue
;
lOllOOOOll
.
lOO\
OlOO\
l\
ll\

=
-
1
;
int\

lOll\
Olll\
lO
=
lOOOllOOl\
O\

;
lOl\
l\
OOllOO\

[
lOOOl\
lOO\
l\
O\

++
]
=
0
;
int\

lOll\
Ol\
llll
=
-
1
;
Ve\
c\
3\

lOl\
llOOO\
OO
=
k_\
v\
3Zero
;
int
lOll\
lOO\
OOl
=
0
;
fo\
r
(
;
;
)
{
lO\
llOlOO\
l\
l
lOlOOlOOl\
O
=
lOll\
OOOOll
.
lOlOll\
lOlO
.
lO\
lOOOOlOO
(
)
;
lOl\
OlOll\
Ol
*
lO\
l\
llOOO\
lO
=
0
;
floa\
t
lOlllOO\
O\
l\
l
=
k_fMaxFl\
oat
;
bo\
o\
l\

lOll\
lOO\
lOO\

=
false
;
fo\
r\

(
;
!
lOlOOl\
OOlO\

.
At\
En\
d
(
)
;
++
lOlOOlOOlO
)
{
lOlOlOllO\
l\

&
lOllO\
lOl\
OO
=
*
lO\
lO\
Ol\
O\
Ol\
O
;
TA_ASSE\
R\
T
(
(
lOllOl\
OlO\
O
.
lO\
lOl\
lOO\
Ol\

&
(
lOl\
O\
l\
O\
l\
l\
O\
l
::
lOlO\
lOll\
l\
O
|
lOlOlOll\
Ol
::
lOlOlO\
ll\
ll
)
)
==
(
lO\
lOlOllO\
l\

::
lOl\
OlOlllO
|
lO\
lOlO\
ll\
Ol
::
lOlOl\
Ollll
)
)
;
if\

(
lOl\
l\
lOOOlO
==
&
lO\
ll\
OlOlOO
)
conti\
nu\
e\

;
if\

(
lOllOlllll
==
-
1
)
{
lO\
lllOOOlO
=
&
lOl\
lOl\
O\
lOO
;
bre\
ak
;
}
else
{
Vec3
lOOO\
Ol\
OOOl
=
lO\
ll\
OlOlOO\

.
lOO\
OOl\
llll
+
lOllO\
l\
OlOO
.
lOOOlOOOOO
*
lO\
llOl\
OlOO\

.
lOl\
OllOOlO\

;
float
lO\
lllOOlOl
=
(
lOO\
OOlOO\
Ol
-
lOlllOOOOO
)
.
GetMagnitud\
e\
S\
qrd
(
)
;
if\

(
lOlllOOOll
>
lOlllOO\
lO\
l
)
{
lO\
ll\
lOOOll
=
lOl\
ll\
OOlOl
;
lOl\
llOOOl\
O\

=
&
lOl\
l\
OlO\
lOO
;
if
(
lO\
lllOOOlO
->
lO\
l\
OllOO\
O\
l\

&
lOl\
OlO\
llOl
::
lO\
lOllOOOO
)
lOlll\
O\
OlOO
=
true
;
els\
e
lOlllOO\
lOO
=
fa\
lse
;
}
}
}
if
(
lOlllOOlOO
)
bre\
ak\

;
TA_\
AS\
SE\
RT
(
lOl\
llOOO\
O\
l
==
0
||
lO\
lllOO\
Ol\
l
<
0.001f
)
;
lOll\
l\
OOOOl\

++
;
TA_ASS\
ER\
T\

(
lOlllOO\
O\
lO
)
;
lOlllOOO\
lO
->
lOlOllOOOl\

|=
lO\
lOlO\
ll\
Ol
::
lOlOll\
OOOO\

;
lO\
l\
lO\
l\
lll\
l
=
lOl\
lO\
OlllO
.
lOOOl\
llO\
O\
l
(
)
;
Vec\
3
lOOOOlO\
OOl
=
lOll\
lOOOlO\

->
lO\
OOOl\
ll\
l\
l
+
lOlllOOOlO
->
lO\
OOl\
OOO\
OO
*
lO\
ll\
lO\
OOl\
O
->
lOl\
OllOO\
lO
;
int\

lOl\
llOOl\
lO\

;
for
(
lOlllOOllO
=
0
;
lOl\
llOOllO
<
lOll\
OlllOO
.
lO\
OOll\
lO\
Ol
(
)
;
lOl\
ll\
OOllO
++
)
if
(
(
lOllOlllO\
O
[
lOl\
llO\
OllO
]
-
lOOOO\
lOOO\
l
)
.
GetMa\
gnitude\
S\
qrd
(
)
<
0.0001f
)
br\
eak
;
if\

(
lO\
lll\
OO\
ll\
O
==
lO\
llOl\
llOO
.
lOOOl\
l\
lOOl
(
)
)
lOl\
lOlll\
O\
O
.
lO\
OOl\
llOO\
O
(
lOO\
OOlOOOl
)
;
lO\
l\
lOOl\
lOO
[
lOOO\
ll\
OOlO\

++
]
=
lO\
ll\
l\
OOl\
lO\

;
TA_AS\
S\
ERT
(
lOlllOOO\
lO
->
lOlOllO\
lOO
)
;
lOllO\
Ol\
lOO
[
lOOOllO\
Ol\
O
++
]
=
lO\
l\
ll\
OO\
OlO
->
lOlOl\
lO\
l\
O\
O
->
lO\
lOl\
lOllO
;
lOl\
l\
lOOO\
O\
O\

=
lOlllOOOl\
O
->
lOO\
OOl\
l\
ll\
l\

+
lOl\
llOOOl\
O
->
lO\
OO\
l\
OO\
OOO
*
lOlllOOOl\
O\

->
lOlOll\
OOll
;
}
if
(
lO\
l\
ll\
OOOOl
<
3
)
{
lO\
OOllOOlO
=
lOllOlll\
lO\

;
}
els\
e
{
lO\
llOOO\
O\
ll
.
lOOOl\
O\
Olll
=
lO\
llOO\
llO\
l
.
lOOO\
lllO\
Ol\

(
)
;
lOl\
lOOllOl
.
lO\
O\
Oll\
l\
O\
O\
O\

(
lOll\
O\
llllO
)
;
lO\
l\
lOO\
llOO
[
lOl\
lOl\
l\
llO
]
=
lOl\
l\
lO\
OOOl\

;
}
}
for
(
lOllOOO\
OOl
=
0
;
lO\
llOO\
O\
OOl
<
lO\
llOO\
ll\
Ol
.
lO\
O\
OlllOOl\

(
)
;
lOllOOO\
OOl
++
)
{
int
lO\
OOll\
O\
OlO
=
lO\
llOOllOl\

[
lOllOOO\
O\
Ol
]
;
for
(
int
lO\
lllOOll\
l
=
lOllOOl\
l\
OO\

[
lOOOll\
OOlO
++
]
;
--
lOlll\
OO\
lll
>
0
;
)
{
lOO\
Ol\
lOOlO
++
;
lO\
l\
lOOllOO
[
lOOOllOOlO
]
=
lO\
lOl\
l\
ll\
lO\

[
lOllOOl\
l\
O\
O
[
lOOO\
llOOl\
O
]
]
.
lOO\
O\
lO\
O\
lll
;
if
(
lO\
llOOll\
OO
[
lOO\
Ol\
lOO\
lO
]
==
-
1
)
{
TA_\
AS\
SERT
(
0
)
;
return\

false
;
lO\
llO\
OllOO
[
lO\
OOllOO\
lO\

]
=
lOllOOll\
O\
l\

[
lOllOOOOO\
l
]
;
}
lOO\
Ol\
lO\
OlO
++
;
}
}
lOllOOlllO\

.
Initia\
lise
(
lOllOlllOO\

.
lO\
O\
Olll\
OOl\

(
)
,
lOllOlllOO
.
lOOOlllOO\
l
(
)
)
;
fo\
r
(
int
lOlllOOllO
=
0
;
lOlll\
OOl\
lO
<
lOllO\
lllO\
O
.
lO\
OO\
l\
llO\
Ol
(
)
;
lOl\
llOOll\
O
++
)
lOll\
OOlllO\

[
lOlll\
O\
Oll\
O\

]
=
lOllOlllO\
O\

[
lOlllO\
Ol\
lO
]
;
lOllOlllOO\

.
Fina\
l\
is\
e
(
)
;
lOllO\
OllOl
.
lOl\
O\
OOOlO\
l
(
)
;
return
true\

;
}
voi\
d\

lOlllOlO\
O\
O
(
)
{
TA_ASSERT
(
0
)
;
}
priv\
at\
e
:
lOlOl\
llOOO
<
lO\
lOlOllOl
,
tru\
e\

>
lOlOll\
llO\
l\

;
lOO\
OOlOll\
O\

<
Polyg\
on\

,
fa\
lse
>
lOlOl\
l\
lllO
;
typ\
ede\
f
lOlO\
lll\
O\
OO
<
lOl\
O\
lOl\
lO\
l
,
tr\
u\
e
>
::
lOlOl\
l\
lOO\
l
::
Ite\
r\
ato\
r
lOl\
l\
Ol\
OOll
;
lOlOl\
Ol\
lOl
*
lO\
llOO\
lOO\
l
(
const
Ve\
c3
&
lOOOOl\
ll\
ll
,
const
Vec\
3
&
lOOOl\
O\
OOOO
,
Polygon
&
lOl\
lOlOOOO\

,
Polygon
&
lOl\
l\
OlO\
OlO\

)
{
lO\
l\
OlOllO\
l
*
lOlll\
OlOO\
l\

=
lO\
l\
OllllOl
.
Al\
loc\

(
)
;
lO\
llO\
l\
OOl\
l
lO\
lOOl\
OO\
lO\

=
lOllO\
lOOOO\

.
lOlO\
lll\
OlO\

.
lO\
l\
OOOOlOO\

(
)
;
lOlllOl\
O\
Ol
->
lOOO\
Ollll\
l\

=
lOOOOllll\
l
;
if
(
lOllOl\
OOlO
.
lO\
OOl\
OO\
OO\
O
.
Dot
(
lO\
O\
OlO\
OOO\
O
.
Cros\
s
(
lOl\
l\
OlO\
OOO
.
lOOO\
lOOOOO\

)
)
>
0.0f
)
lO\
lll\
OlOOl
->
lOOOlO\
OOOO
=
lOOOlO\
OOOO
;
els\
e
lO\
lllOl\
O\
O\
l
->
lOOOlO\
OOOO\

=
-
lO\
OO\
lOOO\
OO
;
lOl\
llO\
lOO\
l
->
lO\
lOllOO\
lO\

=
-
100.0f
;
lOlll\
OlO\
Ol
->
lOlO\
l\
l\
O\
Oll
=
100.0f
;
lO\
lllOl\
OO\
l
->
lO\
l\
OllO\
OO\
l
=
0
;
lOl\
llOlOO\
l
->
lOlOllOlOO\

=
&
lO\
llOl\
OO\
lO
;
lOlll\
O\
l\
O\
Ol\

->
lOl\
OllOlOl
=
0
;
fo\
r
(
;
!
lO\
lOOlOO\
l\
O\

.
AtEnd\

(
)
;
++
lOlOOlO\
OlO
)
{
lO\
lOlOll\
Ol
&
lO\
l\
lOlO\
l\
O\
O
=
*
lO\
lOOlOOlO
;
Vec3
lOlllOlOlO
=
k_v3Zero\

;
if\

(
!
lOlllOlOll
(
lOO\
O\
Ol\
ll\
l\
l\

,
lO\
OOlOOOOO
,
lO\
llOlOlOO
.
lO\
OOOll\
l\
ll
,
lO\
llOlOl\
OO
.
lOOOlOOOOO
,
lOlllO\
lOlO
)
)
contin\
u\
e
;
fl\
oat
lOl\
ll\
Ol\
lOO
=
lOll\
Ol\
O\
l\
OO
.
lOO\
OlO\
OOOO
.
Dot
(
lO\
ll\
lO\
lOlO
-
lOl\
lOlO\
l\
OO
.
lO\
OOOlllll\

)
;
TA\
_ASSERT\

(
lOllO\
lOlOO
.
lOOOlO\
OO\
OO
.
Dot
(
lO\
llOlOOlO\

.
lOOOlOOOOO
)
!=
0
)
;
if
(
lOllOlO\
lO\
O
.
lO\
OOl\
OO\
O\
OO
.
Dot\

(
lOllOlO\
Ol\
O
.
lOOO\
lOOOOO
)
>
0.0f
)
{
if
(
lO\
l\
llOllOO\

<
lO\
llO\
lOlOO
.
lO\
lO\
llOOl\
l
)
{
lOllOlO\
lOO\

.
lOl\
O\
llO\
Oll
=
lOl\
l\
lOllO\
O
;
lOllO\
l\
Ol\
OO
.
lOl\
Ol\
lOOOl
|=
lO\
lO\
lO\
llOl\

::
lOlO\
l\
Ollll
;
}
}
els\
e\

{
if
(
lO\
lllOl\
lOO
>
lOll\
OlOlO\
O
.
lOlOllOOl\
O\

)
{
lOll\
OlOlOO\

.
lOlOl\
lOOl\
O
=
lO\
lllOllOO
;
lOl\
lOlO\
lOO
.
lO\
lOl\
lOOOl
|=
lOl\
O\
l\
OllO\
l
::
lO\
lOl\
OlllO
;
}
}
lOlllOllO\
O
=
lOl\
llO\
lOO\
l
->
lOOOlOO\
O\
O\
O\

.
Dot
(
lOlll\
OlOlO
-
lOlllOl\
O\
Ol
->
lOOOO\
ll\
lll
)
;
TA_ASSE\
R\
T
(
lO\
lllOl\
O\
O\
l\

->
lOOOl\
OOOOO\

.
Do\
t
(
lOl\
l\
OlO\
O\
OO\

.
lO\
OOlOOOOO
.
Cro\
ss
(
lOllOlOlOO
.
lOOO\
l\
OO\
O\
OO
)
)
!=
0
)
;
if
(
lOlllOlOOl
->
lOOOlOOO\
O\
O
.
Dot
(
lOllO\
lOOOO
.
lO\
OOlO\
OO\
OO
.
Cr\
oss
(
lOllO\
lO\
lOO
.
lOOOlOOOO\
O
)
)
<
0.0f
)
{
if
(
lOlll\
Ol\
OOl
->
lO\
lOl\
l\
O\
O\
ll
>
lOl\
ll\
OllOO
)
{
lOlllOl\
OO\
l
->
lOl\
OllOOll
=
lOll\
lOl\
l\
OO
;
lO\
lll\
OlOOl
->
lOlOl\
l\
OOO\
l
|=
lO\
lOlO\
llOl
::
lOlO\
lOll\
l\
l
;
}
}
els\
e\

{
if
(
lOlll\
OllOO
>
lOlllO\
lOO\
l
->
lOlO\
ll\
OOlO
)
{
lO\
ll\
lOlOOl\

->
lOlOll\
OOlO
=
lOll\
lO\
llOO\

;
lOlll\
OlOOl
->
lOlO\
llOOO\
l
|=
lOlOlOll\
O\
l
::
lOl\
OlOl\
llO\

;
}
}
}
lOllO\
lOOOO
.
lOlOlllOlO\

.
lOl\
OlO\
O\
OO\
l\

(
lO\
lllO\
lOOl
)
;
{
lOl\
lOlO\
O\
l\
l\

lOlO\
Ol\
O\
OlO\

=
lOllOl\
O\
OOO
.
lOlOlllO\
lO
.
lOl\
OOOO\
lOO
(
)
;
for
(
;
!
lOl\
OOl\
O\
OlO
.
AtE\
nd\

(
)
;
)
{
lOlOlOllOl
&
lOll\
Ol\
OlO\
O
=
*
lOlOOlO\
OlO\

;
++
lOl\
OO\
lO\
O\
l\
O
;
cons\
t
fl\
oat
lOl\
lOlO\
lOl\

=
0.0001f
;
if
(
lO\
llOlO\
lO\
O\

.
lOlOl\
lOOl\
O\

>=
lOllOlOlOO
.
lOlOllOOl\
l
-
lOllOl\
OlOl
)
{
if
(
lOl\
llOlO\
Ol
==
&
lOl\
lO\
lOlOO
)
lOlllO\
lOO\
l
=
0
;
if\

(
lOllO\
lOlOO
.
lO\
l\
OllOlOl
)
{
TA\
_ASSE\
RT
(
lOl\
lOlOl\
OO
.
lOl\
OllOlOO
)
;
lOll\
Ol\
Ol\
OO
.
lOl\
OllOlO\
l
->
lOlO\
ll\
O\
lO\
l\

=
0
;
lOll\
O\
lOlOO\

.
lOlO\
llOl\
OO
->
lOlOlllOlO\

.
lO\
Olllllll
(
lO\
l\
l\
O\
lOl\
OO
.
lO\
lOllO\
l\
Ol
)
;
lO\
lOllll\
Ol
.
Fr\
ee
(
lOllOl\
Ol\
OO
.
lOlOl\
lOl\
Ol\

)
;
lOll\
O\
l\
Ol\
O\
O
.
lOlOllOlO\
l
=
0
;
}
lOllO\
l\
OOOO
.
lO\
lOll\
lOlO
.
lOOlllll\
l\
l\

(
&
lOllOlOlOO\

)
;
lOl\
Oll\
llOl
.
Fr\
ee\

(
&
lOllO\
lOl\
OO
)
;
}
}
}
retu\
rn
lOlllOl\
OO\
l
;
}
bo\
o\
l\

lOllOOOlll
(
const
Vec3
&
lOlllOllO\
l
,
float
lOlll\
Ol\
llO\

,
cons\
t
Ve\
c3\

&
lOl\
llO\
lll\
l
,
fl\
oa\
t
lOllllO\
OO\
O
,
Vec3\

&
lOl\
l\
llOOOl
,
Vec3
&
lO\
llllO\
OlO
)
{
Vec3
lOllOOOllO
=
lO\
lll\
OllOl
.
Cr\
oss\

(
lOlllOl\
lll
)
;
float
lOllllO\
Oll
=
lOl\
l\
OO\
OllO
.
Ge\
tM\
agnit\
u\
de
(
)
;
if
(
lOllllO\
Oll\

<
0.01f
)
return
fa\
lse
;
lOllOOOllO
/=
lOllll\
OOl\
l
;
if\

(
!
lOll\
l\
OlO\
ll\

(
lOll\
l\
OllO\
l\

*
lOlllO\
lllO
,
lOl\
lOOOl\
lO
.
Cross
(
lO\
ll\
lOllOl
)
,
lOl\
ll\
Ollll
*
lOl\
lllOOO\
O
,
lO\
ll\
OOO\
llO\

.
Cross
(
lO\
lllOl\
lll
)
,
lO\
llllOOOl\

)
)
ret\
urn
fa\
lse
;
lOl\
lllOOlO
=
lOll\
OO\
Ol\
lO
;
re\
tur\
n
tr\
ue
;
}
bo\
o\
l\

sta\
tic
lO\
l\
llOlOll
(
co\
n\
st
Vec3\

&
lOll\
llOlOO
,
const
Vec3
&
lO\
lll\
OllOl
,
const
Vec\
3
&
lOl\
lllOl\
Ol
,
const
Ve\
c3
&
lOlllO\
llll
,
Vec3
&
lOlllOlOl\
O
)
{
con\
st\

floa\
t\

lOl\
lOlOlOl
=
0.0001f
;
Vec3\

lOll\
llOl\
lO
=
lOlllO\
ll\
O\
l
.
Cro\
s\
s
(
lOl\
llO\
l\
ll\
l
)
;
Ve\
c3\

lOllllOl\
ll
=
lO\
llllOllO
.
Cross
(
lOlllO\
lll\
l
)
;
float
lOll\
ll\
l\
O\
OO
=
lOl\
lll\
O\
lll
.
Dot
(
lOllllOlO\
O
-
lOll\
llOlOl
)
;
float
lO\
ll\
lllOOl\

=
lOllllO\
lll
.
Dot
(
lOl\
l\
llOl\
O\
O
+
lOlllO\
llOl
-
lOll\
llOl\
O\
l
)
;
fl\
o\
a\
t
lOlll\
l\
lOlO\

;
if\

(
Fab\
s\

(
lO\
lllllOOl
-
lO\
llll\
lO\
OO
)
<
lOllOlOlO\
l
)
re\
t\
ur\
n
fa\
l\
s\
e\

;
el\
s\
e\

lOlll\
llOlO
=
lOl\
ll\
llOO\
O
/
(
lOllll\
lOOO
-
lOl\
llllOO\
l
)
;
lOll\
lOl\
OlO
=
lO\
llllOl\
OO
+
lOll\
lOll\
O\
l\

*
lOlllll\
OlO
;
retu\
rn
true
;
}
}
;
st\
ruct\

Co\
nv\
exH\
ul\
l
::
lOlllllOll
{
boo\
l
lOlll\
l\
l\
lO\
O
;
bool
lOl\
l\
llll\
Ol
;
bool
lOllllll\
lO
;
bool\

lO\
lllllll\
l
;
int
ll\
OOOOOO\
OO
;
int\

llOOOOO\
OOl
;
int
ll\
OOOOOOlO
;
in\
t
llO\
OOO\
OOl\
l
;
int
llOOOOO\
lOO
;
int\

llOOOOOlO\
l
;
int
llOOOO\
Oll\
O
;
Ve\
c3
lO\
OOlOOOOO
;
static
int
TA\
C_CALL
llOOOOO\
lll\

(
int\

lOOOlOOlll
)
{
re\
turn
(
lOOOlOO\
ll\
l
+
1
<
3
)
?
lOO\
O\
lO\
O\
lll\

+
1
:
0
;
}
st\
a\
t\
ic
in\
t
TAC\
_CALL
ll\
OOOO\
lOO\
O\

(
int
lOO\
OlOOlll
)
{
retu\
rn
(
lOO\
OlOO\
lll
-
1
>=
0
)
?
lOO\
O\
lOOl\
ll
-
1
:
2
;
}
int
&
llO\
OOOlOO\
l
(
int\

lO\
OOlO\
Oll\
l
)
{
re\
tu\
rn
(
&
llOOOOOOO\
l
)
[
lOOOlO\
Oll\
l
]
;
}
const\

in\
t
&
llOOOO\
lO\
Ol
(
int
lOOOlOO\
lll
)
const\

{
re\
turn\

(
&
llOOO\
O\
O\
O\
O\
l
)
[
lOOOlOOlll\

]
;
}
int
&
ll\
OOOOlOlO\

(
int
lO\
O\
OlOOlll
)
{
TA_AS\
S\
E\
RT
(
lOO\
O\
lO\
O\
lll
>=
0
&&
lOOOlOOl\
ll\

<
3
)
;
retu\
rn
(
&
llOOOOOl\
OO
)
[
lOOOlOOl\
l\
l
]
;
}
const\

int
&
llOOOO\
lOlO
(
in\
t
lO\
OOlOOlll
)
const
{
TA\
_ASS\
ERT
(
lO\
OOlOOlll
>=
0
&&
lO\
OOlOOl\
ll\

<
3
)
;
return
(
&
ll\
OOOOOlO\
O
)
[
lOOOlOOlll
]
;
}
int
llO\
O\
O\
OlOll\

(
int\

lOOO\
lOOl\
ll\

)
const
{
return
llOO\
OO\
lOOl
(
lO\
OOlOOll\
l\

)
;
}
int\

llOOO\
O\
llOO
(
int
lOOOlOOl\
ll\

)
co\
n\
st
{
re\
turn
ll\
OOO\
Ol\
OO\
l\

(
llOOOO\
Ol\
ll\

(
lOO\
OlO\
Olll
)
)
;
}
}
;
ConvexHu\
ll
::
Conve\
x\
Hu\
ll
(
)
{
llOO\
OOllOl\

=
fal\
s\
e
;
}
Conv\
ex\
Hull
::
~
Conve\
xHull
(
)
{
Fin\
alis\
e
(
)
;
}
bo\
o\
l\

static
lOl\
llOlOll
(
con\
st
Vec3\

&
lOllllOl\
OO
,
co\
nst\

Vec\
3
&
lO\
ll\
lOllOl
,
const\

Ve\
c3
&
lOllllO\
lOl
,
const\

Ve\
c3\

&
lO\
lllOlll\
l
,
Vec\
3
&
lOl\
llOlOlO
)
{
con\
st
float
lOll\
Ol\
OlO\
l\

=
0.0001f
;
Vec3
lOl\
ll\
lO\
l\
lO\

=
lOlllOllOl
.
Cro\
ss
(
lOll\
l\
O\
llll\

)
;
Vec3\

lOll\
l\
lOl\
ll\

=
lOllll\
O\
l\
lO\

.
Cross
(
lO\
l\
l\
lOllll
)
;
fl\
oat\

lOlllllOOO\

=
lO\
l\
lllO\
lll\

.
Dot
(
lO\
llllOl\
OO\

-
lOl\
l\
llOlO\
l\

)
;
floa\
t
lOl\
llllOOl
=
lOllllOlll\

.
Dot
(
lOllllOl\
O\
O
+
lOl\
llOllOl
-
lOllll\
OlOl
)
;
flo\
at
lOlllllOlO
;
if
(
Fabs\

(
lOlll\
llO\
Ol
-
lOllll\
lO\
OO
)
<
lO\
llOlOlOl
)
return
false
;
els\
e\

lOlllllOl\
O
=
lOlll\
llOOO\

/
(
lOll\
ll\
l\
OOO\

-
lOl\
l\
ll\
l\
O\
Ol\

)
;
lOlll\
O\
lO\
lO
=
lO\
llll\
Ol\
OO
+
lOll\
lO\
ll\
Ol
*
lO\
ll\
lll\
OlO
;
return\

tru\
e\

;
}
bool
stati\
c
lOllOOOlll\

(
const
Ve\
c3
&
lOlllOll\
O\
l
,
float
lOll\
l\
Olll\
O\

,
co\
n\
st\

Vec3\

&
lO\
ll\
lO\
llll\

,
float
lO\
llllOOOO
,
Vec3\

&
lOllllOOOl
,
Vec\
3
&
lOllllOOlO
)
{
Vec3\

lO\
llOO\
Oll\
O
=
lOll\
lOl\
lOl
.
Cr\
oss
(
lOlllOllll
)
;
float
lOllllOOl\
l\

=
lOllOOOllO
.
Get\
Mag\
nit\
u\
de\

(
)
;
if
(
lO\
llllOOl\
l
<
0.01f
)
return
fa\
lse
;
lOll\
OOOllO
/=
lO\
llllOOll
;
if\

(
!
lOlll\
OlOll
(
lO\
lllOllOl\

*
lO\
ll\
lOll\
lO
,
lO\
ll\
OOOllO
.
Cross
(
lO\
lll\
O\
llOl
)
,
lOlll\
Oll\
ll
*
lOllllOOOO
,
lOllO\
OOll\
O
.
Cross
(
lOlllOlll\
l
)
,
lOllll\
OO\
O\
l\

)
)
ret\
urn
false\

;
lOllllOO\
l\
O\

=
lOllOOOllO
;
retur\
n
true\

;
}
struct
llOOOO\
ll\
lO\

;
str\
uct
llO\
OO\
O\
llll\

{
in\
t
llOOOlOOO\
O
;
int
ll\
OOOl\
OOOl
;
llOO\
OOlll\
O
*
ll\
OOOlOO\
l\
O
;
ll\
OO\
OOlll\
O
*
lOlOll\
Ol\
OO
;
ll\
O\
OOOllll
*
ll\
O\
OOl\
OOll
;
}
;
struct
ll\
OOO\
Ol\
ll\
O
{
float
lOlOllO\
lll\

;
boo\
l\

llOOOlO\
lOO
;
bo\
ol
llOOOlOlO\
l
;
int
lOO\
O\
lOOll\
l\

;
llOOO\
Ol\
l\
lO
*
ll\
O\
OOlO\
l\
lO
;
llOOO\
Olll\
O
*
llOOOlOlll
;
lO\
lOll\
l\
OO\
O
<
llO\
OOOllll
,
tr\
ue\

>
::
lOlOl\
ll\
OOl
ll\
OO\
OllO\
OO\

;
Vec3
lO\
OO\
lOOO\
OO
;
}
;
type\
de\
f
lOlOl\
ll\
OOO
<
llOO\
O\
Ol\
llO
,
tr\
ue
>
::
lO\
lOll\
lOO\
l
::
It\
erator
ll\
O\
OOllO\
Ol
;
typedef
lOlOlllO\
O\
O
<
llOOOO\
lll\
l
,
tr\
ue
>
::
lOl\
OlllOOl
::
It\
e\
ra\
to\
r
llO\
OOllOlO
;
bool
ConvexH\
ull
::
Initi\
alise
(
const
Vec\
3
*
llOO\
Ol\
l\
Oll
,
int
llOOOl\
l\
lOO
,
in\
t\

llOOOlllOl\

)
{
float
ll\
OOOllllO
=
0.0f
;
fl\
oat\

ll\
O\
OOlllll
=
0.125f
;
RandF\
u\
nc
::
Ta\
RandSe\
ed
(
0
)
;
for
(
int
llOOlOOOOO
=
0
;
llOO\
lOO\
O\
OO\

<
20
;
llOOlOOOOO
++
)
{
if\

(
ll\
OOl\
OOOOl
(
llOOOl\
lO\
ll\

,
llOO\
OlllOO\

,
ll\
OOO\
l\
llOl
,
llOO\
Oll\
llO
,
llO\
OOll\
l\
ll
)
)
{
re\
turn\

true
;
}
if
(
llO\
OOOll\
Ol
)
{
llOOOl\
lllO
+=
0.00002f
;
}
if
(
llOO\
lOOOlO
)
{
if
(
ll\
OOOlll\
ll\

==
0.0f
)
ll\
OO\
Olll\
lO\

+=
0.00001f
;
ll\
O\
OOlll\
l\
l
*=
0.75f
;
if\

(
ll\
OOOll\
ll\
l\

<
0.001f
)
ll\
OOOlllll
=
0.0f
;
}
if\

(
!
llOOOO\
llOl
&&
!
llOOl\
OOOlO\

)
{
return
false\

;
}
}
return
false
;
}
boo\
l\

ConvexHu\
ll
::
Initia\
li\
s\
e
(
const
Vec3
*
ll\
O\
OlOOOl\
l
,
const
Vec3
*
ll\
OOlO\
O\
lOO
,
int\

llO\
Ol\
O\
O\
lOl
)
{
lOlOlO\
llO\
O\

llOOlOO\
ll\
O
;
ll\
OO\
l\
OO\
llO
.
In\
itiali\
se
(
llOOlOOlOl
)
;
fo\
r
(
int
llOOlOOlll
=
0
;
ll\
O\
OlOO\
lll
<
llOO\
lOOl\
O\
l\

;
llO\
Ol\
OOl\
ll
++
)
{
TA\
_\
ASSER\
T
(
llOO\
l\
OO\
Oll
[
llOOlOOl\
ll
]
.
IsNo\
rm\
alis\
ed
(
)
)
;
llOOlOOllO
.
lOlOlllll\
l
(
llOOlO\
OOll\

[
llOO\
l\
OOl\
ll
]
,
ll\
OOl\
O\
O\
Oll
[
llOOlOOl\
ll
]
.
Do\
t
(
llO\
O\
lO\
OlOO
[
llOOl\
OOlll
]
)
,
true
)
;
}
return
Ini\
tiali\
se\

(
llOOlOOllO\

)
;
}
vo\
id
Conv\
exHu\
ll
::
Finalis\
e
(
)
{
ll\
O\
O\
lOlOOO
.
Clear
(
)
;
llOO\
l\
O\
l\
OOl
.
Cle\
a\
r
(
)
;
llO\
O\
lOlO\
lO
.
Cl\
ear
(
)
;
}
boo\
l\

Con\
vexH\
u\
l\
l
::
In\
itia\
lise\

(
lOl\
OlOl\
lOO
&
llOO\
lOOll\
O
)
{
if
(
!
llOOl\
OO\
llO
.
lOl\
lOOlOll
(
llOO\
l\
O\
l\
OOO\

,
llO\
Ol\
OlO\
Ol
,
llOOlOlOl\
O
)
)
return
fa\
lse
;
if
(
llOOlOl\
OOl
.
lOOO\
lllOOl
(
)
<
4
)
return
fals\
e
;
retu\
r\
n
tru\
e
;
}
bo\
ol\

Conv\
e\
xHu\
ll
::
llO\
O\
lO\
OOOl
(
con\
st\

Ve\
c3
*
ll\
OO\
OllOl\
l
,
in\
t\

llOOOl\
ll\
OO
,
in\
t
llOOOlll\
O\
l\

,
fl\
oa\
t\

ll\
OO\
Oll\
llO
,
fl\
oat
llOO\
Olllll
)
{
llOOO\
O\
llOl
=
false
;
llOO\
lOO\
Ol\
O\

=
fal\
se
;
lOlO\
l\
ll\
O\
O\
O
<
llOOO\
Oll\
lO
,
true\

>
llOO\
l\
OlO\
ll
;
lO\
lOlllO\
OO
<
llOOOOlllO
,
true
>
::
lOlOl\
llOOl
llOOl\
OllOO
;
lOlOll\
lOO\
O\

<
llO\
OOOll\
ll
,
true\

>
llO\
OlOllOl
;
ll\
OOlOlOll
.
Initial\
ise
(
llOOOll\
lOO\

)
;
llOOlOl\
lO\
l
.
In\
i\
tiali\
se\

(
ll\
OO\
OlllOO
)
;
float
llOOl\
Ol\
ll\
O
=
1.0f
;
float
ll\
O\
OlOl\
l\
ll
=
1.0f
;
flo\
at
llOOllOOOO
=
0.0f
;
Ve\
c3
ll\
OO\
llOO\
Ol
;
ll\
OOllOO\
Ol\

.
Clear
(
)
;
floa\
t
llOO\
ll\
OOlO
=
0.0f
;
int
ll\
O\
Ol\
l\
OOll
=
0
;
int\

ll\
OO\
llOlOO
=
0
;
in\
t
llO\
OllO\
lOl
=
-
1
;
{
if
(
llOO\
OlllOO
<
3
)
{
lOO\
OlllOlO\

(
0
,
"ConvexHull::Initialise, Failed because number of points is less then 3")
;
}
in\
t
lOl\
ll\
OOll\
O
;
fl\
oat\

llO\
Ol\
lOllO
=
0.0f
;
fo\
r
(
in\
t
lOOOll\
O\
OO\
l
=
0
;
lOO\
O\
l\
lOOOl\

<
3
;
lO\
OOll\
OOOl
++
)
{
in\
t\

llOOl\
lO\
l\
ll
=
0
;
int
llO\
O\
lllOOO\

=
0
;
fl\
oa\
t
lOO\
O\
OOlOOO
=
llO\
OOllOll
[
llOO\
ll\
Olll
]
[
lO\
OOl\
lO\
OO\
l\

]
;
float\

lOOO\
O\
OlO\
O\
l
=
llOOOllO\
l\
l
[
llOO\
l\
llOOO\

]
[
lOOOl\
lO\
OOl
]
;
for
(
lOlllOOl\
lO
=
1
;
lOll\
lOOl\
lO
<
llOOOlllOO
;
lOlllOOllO\

++
)
{
if
(
lOOOOOlO\
O\
O
<
llOOOllO\
ll
[
lOlll\
OOll\
O
]
[
lOOOllOO\
Ol\

]
)
{
llOOll\
Olll\

=
lO\
lll\
OO\
l\
lO
;
lO\
OOOOlOOO
=
ll\
OOO\
llOll
[
lOlllOO\
l\
l\
O
]
[
lOOOl\
lOOOl
]
;
}
if
(
lOOOOOlOO\
l\

>
llOOO\
llOll
[
lOlllOO\
llO
]
[
lO\
OO\
llO\
OOl\

]
)
{
llOOlllO\
OO\

=
lO\
lll\
O\
Oll\
O\

;
lOOOOOlO\
O\
l
=
llOOO\
l\
lOll
[
lO\
ll\
lOOl\
lO\

]
[
lOOOl\
l\
OOOl
]
;
}
}
if
(
llOOl\
lO\
l\
lO
<
lOOO\
O\
OlOOO
-
lO\
O\
OOOlOOl\

)
{
llOOll\
O\
llO\

=
lOO\
OO\
Ol\
OOO\

-
lOOOOO\
l\
OOl
;
llOOll\
OO\
ll\

=
llOO\
llOlll
;
llO\
Oll\
O\
lOO
=
llOO\
ll\
lOOO
;
}
}
llO\
OlO\
l\
ll\
O\

=
llOOl\
l\
O\
llO
;
Ve\
c3
lOOOlOOOOO
=
llOOOll\
Ol\
l
[
ll\
OOllOl\
O\
O\

]
-
llOOOll\
Oll
[
ll\
O\
O\
llO\
Oll
]
;
floa\
t
lOlll\
lOOll\

=
lOOO\
lOO\
OO\
O
.
Ge\
tMagni\
tu\
de
(
)
;
if\

(
lOlll\
l\
O\
Ol\
l
<=
k_f\
Mi\
nFlo\
a\
t
)
{
lOO\
O\
lllO\
lO
(
0
,
"ConvexHull::Initialise, Failed because hull is too small")
;
return
fa\
lse
;
}
TA_ASS\
ERT\

(
ll\
OOllOOll
!=
llOOl\
lO\
lOO
)
;
lOO\
O\
lOO\
OOO
/=
lO\
ll\
ll\
OO\
ll
;
flo\
at
lOOOOOl\
OOO
=
0.0f
;
for
(
lOl\
ll\
OOllO
=
0
;
lOlllOOllO
<
llOOOlll\
OO\

;
lOl\
llOOllO
++
)
{
fl\
oat\

lOl\
Oll\
Ol\
ll
=
lOOOlO\
OO\
OO
.
Cro\
ss
(
ll\
O\
O\
O\
llO\
ll
[
llOO\
l\
lOOll
]
-
llOO\
O\
ll\
Oll
[
lO\
l\
llOOllO\

]
)
.
Get\
Magnit\
ude\
Sqrd\

(
)
;
if
(
lOOO\
OOl\
OO\
O
<
lOlOllOlll
)
{
lOO\
OOOlOOO
=
lOlO\
llOlll
;
llO\
Oll\
O\
lO\
l
=
lO\
lll\
O\
Oll\
O
;
}
}
if
(
llOO\
llOlO\
l
==
-
1
||
llO\
OllO\
lOl\

==
llOOllOOll\

||
llOOllOlOl
==
llO\
Oll\
OlOO
)
{
lOOOl\
llOl\
O
(
0
,
"ConvexHull::Initialise, Failed because hull is too small or narrow")
;
return
fa\
ls\
e\

;
}
Ve\
c3\

llOOlllOOl\

=
(
llOO\
Ol\
l\
Oll
[
ll\
OOl\
lOlOO
]
-
llO\
O\
OllOll
[
llOOllO\
Oll
]
)
.
Cross
(
llOOOllOll
[
ll\
OOllO\
lOl
]
-
llOOOllOl\
l
[
llO\
OllO\
Oll
]
)
;
lOlll\
lOO\
ll
=
llOOlllOOl
.
GetM\
agnitude
(
)
;
if
(
lOllllOO\
l\
l
<=
k_fMinF\
l\
oat\

)
{
lO\
O\
O\
lllOlO\

(
0
,
"ConvexHull::Initialise, Failed because hull is too small or narrow")
;
retu\
rn
false
;
}
llOO\
lllOOl
/=
lOlll\
l\
OOll
;
if
(
lOOO\
O\
Ol\
OOO
<
(
llO\
O\
lOl\
l\
l\
O
*
ll\
O\
OlOlllO\

)
*
(
0.04f
*
0.04f
)
)
{
lOOO\
lllO\
lO
(
0
,
"ConvexHull::Initialise, Failed because hull is too small or narrow")
;
return\

false\

;
}
{
fl\
oa\
t
lO\
OOO\
OlO\
OO\

=
llOOO\
llOll
[
0
]
.
Dot\

(
llO\
O\
lllOO\
l
)
;
fl\
oat\

lOOOOOlO\
O\
l\

=
lOOO\
OO\
lOOO
;
fo\
r
(
lOlll\
O\
Ol\
lO
=
1
;
lOlll\
OOll\
O\

<
llO\
OOlllOO
;
lO\
lllO\
OllO
++
)
{
float
lOlllOllOO
=
llO\
OOllOll
[
lO\
ll\
lOOllO\

]
.
Dot\

(
ll\
OOll\
lOOl
)
;
if
(
lOOOOOlOOO\

<
lOlllOllO\
O\

)
lOOOO\
OlOOO
=
lOlllOllO\
O
;
if
(
lOO\
O\
OOl\
OOl\

>
lOlllO\
ll\
OO
)
lO\
O\
O\
OOl\
OO\
l
=
lOlllOllOO
;
}
flo\
at
ll\
OO\
lllOlO
=
lO\
OO\
O\
O\
lOOO
-
lO\
O\
OO\
OlO\
Ol
;
if
(
ll\
OOll\
lOlO
<
llOOl\
Olll\
O
*
0.1f
)
{
llOOlOllll\

=
(
llO\
Oll\
l\
OlO
/
llOOlOlllO
*
10.0f
)
;
if\

(
llO\
OlOllll\

<
0.01f
)
llO\
O\
ll\
OOl\
O\

=
-
llOOlO\
lllO
*
0.00001f
;
if\

(
llOOlOl\
ll\
l\

<
0.75f
)
{
ll\
OOllOOOO
=
(
llOO\
lO\
lllO
*
0.075f
-
llOOl\
llOlO
)
*
0.25f
;
}
if
(
llO\
Ol\
Oll\
ll\

<
0.5f
)
llO\
O\
lOll\
ll
=
0.5f
;
}
}
llOOllOO\
Ol
=
llOOlllO\
Ol
;
}
lOOOOlOl\
lO
<
Vec3\

>
lOl\
l\
OOll\
lO
;
lOOOOlOl\
lO
<
u3\
2
>
llOOlllO\
l\
l
;
if
(
llOOllOO\
O\
O
!=
0
)
{
llO\
OlllOll
.
Initia\
li\
se\

(
llO\
OOlllOO
*
2
,
ll\
OOOl\
llO\
O
*
2
)
;
lOll\
O\
OlllO
.
Ini\
tiali\
se
(
0
,
llOOO\
l\
l\
lOO
*
2
)
;
fo\
r
(
int
lOlllOOll\
O
=
0
;
lOl\
l\
lOOl\
l\
O
<
llOOOlllOO
;
lO\
lllOOllO
++
)
{
Vec3
llO\
O\
llllOO\

=
llOOOll\
Oll\

[
lOll\
lOOllO
]
;
if
(
llOOOl\
lll\
O
!=
0.0f
)
{
ll\
OOllllOO
.
x
+=
Ra\
n\
dFu\
nc
::
Ta\
RandBetwee\
nPos\
N\
eg
(
llOOOllllO
*
ll\
OO\
lOlllO
)
;
llOO\
ll\
llO\
O
.
y
+=
RandFun\
c
::
TaR\
andBetwe\
e\
nPosNeg
(
llO\
O\
Ol\
lllO
*
llOOlO\
lll\
O\

)
;
llOOll\
llO\
O
.
z
+=
Rand\
F\
unc
::
TaRandBet\
weenPo\
sNeg
(
llOOOllllO\

*
llOOlO\
l\
l\
lO\

)
;
}
lOl\
lOO\
ll\
l\
O\

.
lOOOll\
lOO\
O
(
llOO\
l\
lll\
OO
-
llOOllO\
OOO\

*
0.5f
*
ll\
O\
Ol\
lOOOl
)
;
lOllO\
O\
lll\
O
.
lO\
O\
OlllOOO
(
ll\
OOll\
llOO
+
llOOllOO\
O\
O
*
0.5f
*
llOOllOOOl
)
;
}
}
else
{
llOO\
ll\
l\
Oll
.
In\
i\
t\
ial\
i\
se\

(
ll\
OOO\
l\
llO\
O
,
llO\
OOlllOO
)
;
lOllOO\
lllO\

.
In\
iti\
a\
lise
(
0
,
llO\
OO\
l\
ll\
OO\

)
;
for
(
int
lOlllOOllO
=
0
;
lO\
lllOOllO
<
ll\
OOOlllOO\

;
lOlllOOllO
++
)
{
lOll\
OOl\
ll\
O
.
lO\
O\
O\
lllOOO
(
ll\
OOO\
l\
l\
Ol\
l
[
lOlllOOll\
O
]
)
;
}
if
(
llOOO\
llllO
!=
0.0f
)
{
for
(
int
lO\
l\
ll\
OOl\
lO
=
0
;
lOl\
l\
lOOllO
<
llOO\
OlllO\
O
;
lOll\
l\
O\
OllO
++
)
{
Vec3
&
llO\
OllllO\
O\

=
lOllO\
Ol\
llO
[
lOll\
lOOl\
lO
]
;
ll\
OOll\
llOO
.
x
+=
Rand\
F\
unc
::
TaRand\
BetweenPosNeg
(
llOOOl\
lll\
O
*
llO\
Ol\
Ol\
llO
)
;
ll\
OO\
l\
lll\
O\
O
.
y
+=
Ra\
ndFunc
::
Ta\
Rand\
Bet\
we\
enP\
o\
sNe\
g
(
llO\
OOllllO
*
llOOlO\
ll\
l\
O
)
;
llOO\
ll\
llOO\

.
z
+=
Ra\
nd\
Fu\
nc
::
TaRa\
nd\
BetweenPosN\
eg
(
llOOOllllO
*
llOOl\
O\
lllO
)
;
}
}
}
llOOlll\
Oll
.
lO\
Ollll\
O\
l\
O
(
)
;
llOOlll\
Oll\

[
llOOllO\
O\
l\
l
]
=
1
;
llOOlll\
Oll
[
ll\
OOllOlOO
]
=
1
;
llOOlllOll
[
ll\
OOll\
O\
lOl
]
=
1
;
{
llOOOOlll\
O
*
ll\
OOllllOl
=
llO\
O\
lO\
l\
O\
ll
.
Al\
loc\

(
)
;
llO\
OOOlllO
*
llOOl\
ll\
llO
=
ll\
OOl\
O\
lO\
ll
.
Alloc
(
)
;
ll\
O\
Ol\
Ol\
lOO\

.
lOl\
OlOOOOl
(
llO\
Ol\
l\
l\
l\
Ol
)
;
llO\
Ol\
O\
ll\
O\
O
.
lOl\
O\
lOOOOl
(
llOO\
lll\
llO\

)
;
llO\
OOOll\
ll
*
llOOl\
ll\
ll\
l\

=
llOOlOll\
Ol
.
Allo\
c
(
)
;
llOOOOl\
lll\

*
llOlO\
O\
OO\
O\
O\

=
llOO\
l\
Oll\
Ol
.
Alloc
(
)
;
ll\
O\
OOOl\
l\
ll
*
llOlOOOO\
Ol
=
llOOl\
OllOl
.
All\
oc
(
)
;
llOO\
ll\
ll\
Ol
->
llOOOl\
lOOO
.
lOl\
OlOO\
O\
Ol
(
llOO\
ll\
llll\

)
;
llO\
O\
ll\
ll\
Ol\

->
llO\
OOl\
l\
OOO
.
lOlOlOO\
OOl
(
llOlOOOOOO\

)
;
llOOl\
lll\
Ol
->
llOOOllOOO\

.
lOl\
OlO\
OOOl
(
llO\
lO\
OOOOl\

)
;
llOOl\
ll\
lll
->
llOO\
OlOO\
l\
O\

=
ll\
OO\
l\
l\
llOl
;
ll\
OlOOOOOO
->
llO\
OO\
lO\
O\
lO
=
llOO\
llllO\
l\

;
llOl\
O\
OO\
OO\
l
->
llOOOl\
OO\
lO
=
ll\
OOllllO\
l
;
llOOOOllll
*
ll\
O\
l\
OOOOl\
O\

=
llOO\
lO\
llOl
.
All\
oc
(
)
;
llOOOOllll
*
llO\
lOO\
OOl\
l
=
ll\
OO\
l\
OllOl
.
Allo\
c
(
)
;
llO\
OOOl\
lll\

*
llOlOO\
OlO\
O\

=
llO\
OlOl\
lOl
.
All\
o\
c\

(
)
;
ll\
OOl\
llllO
->
llOO\
Ol\
lO\
OO\

.
lO\
lOlOOOO\
l\

(
llOlOOOOl\
O
)
;
llOOllll\
lO
->
llOOOllO\
OO
.
lO\
l\
O\
l\
OOOOl
(
llOlOOOO\
ll
)
;
llOOl\
l\
lll\
O\

->
ll\
OOOll\
OOO
.
lOlO\
lO\
OO\
Ol
(
ll\
O\
l\
OOOl\
O\
O
)
;
llOlO\
OO\
OlO\

->
llO\
OOlOOlO
=
llOOlllllO
;
ll\
Ol\
OOO\
Oll\

->
llOO\
O\
lOOl\
O
=
llOOlll\
ll\
O
;
llOlOO\
OlOO
->
llO\
OO\
lOO\
lO
=
ll\
OO\
llll\
lO
;
llOOlll\
lll\

->
llOOOl\
OOOO
=
llOOllOO\
ll
;
llOO\
l\
lllll\

->
ll\
O\
OOlOO\
Ol
=
llOOllOlOO\

;
llOOl\
lll\
ll
->
llOOOlOOll
=
ll\
O\
lOOOlO\
O\

;
llO\
O\
l\
lll\
ll
->
lOlOllO\
lOO\

=
llOOllll\
l\
O
;
llOlOO\
OO\
OO\

->
llOO\
OlOOOO
=
llOOllO\
lOO
;
llO\
l\
OOO\
OO\
O
->
ll\
OOOlOOO\
l\

=
llOOll\
Ol\
O\
l
;
ll\
O\
lO\
OOOOO\

->
llO\
OOlO\
Ol\
l
=
ll\
OlOOOOll
;
llO\
lO\
OOOOO\

->
lOlOllO\
lO\
O
=
ll\
O\
O\
l\
ll\
llO
;
llOlOOOOOl
->
llOO\
O\
l\
O\
O\
OO
=
ll\
OOll\
OlOl
;
llOlOO\
OOOl\

->
llOOO\
l\
OOOl\

=
llOOllOOll
;
llOlO\
OO\
O\
Ol\

->
llOOOlOOl\
l
=
llOl\
OOOOl\
O\

;
llOl\
OO\
O\
OOl
->
lOl\
O\
llOlOO
=
llOO\
ll\
ll\
l\
O
;
llOOllllOl\

->
lOOOlOO\
OO\
O\

=
(
lOll\
OO\
lll\
O
[
llOOll\
O\
l\
Ol
]
-
lO\
llOO\
ll\
lO
[
llOOllOOll
]
)
.
Cross
(
lO\
llOOlll\
O
[
llO\
Oll\
O\
lOO
]
-
lOllOO\
lll\
O
[
llOOllOOl\
l
]
)
;
llO\
O\
ll\
llOl
->
lOOOlOOOOO
.
Nor\
m\
alise
(
)
;
llOOllll\
Ol
->
lO\
lO\
llOlll
=
llOOl\
lllOl\

->
lOOOl\
O\
OOOO
.
Do\
t
(
lO\
llO\
Olll\
O\

[
ll\
OOllO\
Oll\

]
)
;
llO\
O\
l\
lllOl
->
ll\
OO\
O\
l\
OlOO\

=
fa\
lse
;
llOOl\
lllO\
l
->
ll\
OOOlOlO\
l\

=
fals\
e\

;
llOO\
llllOl
->
lOOOl\
OOll\
l
=
0
;
ll\
OO\
ll\
llOl
->
llOO\
O\
lO\
llO
=
0
;
llOOl\
lllOl
->
llOOOlOlll
=
0
;
llOlO\
OOl\
OO
->
llOOO\
lOO\
Ol
=
llOO\
ll\
O\
Oll
;
ll\
O\
lOOOlOO\

->
llOOOl\
OOO\
O\

=
llOOll\
OlO\
O\

;
llOlOO\
OlOO
->
ll\
OOOlOOll
=
ll\
O\
Ol\
l\
l\
ll\
l
;
llOlOOOl\
OO
->
lO\
lO\
llOlOO
=
ll\
OOll\
l\
l\
O\
l
;
ll\
O\
lOOOOll
->
llOOO\
lOOOl
=
ll\
OOl\
lOl\
OO
;
ll\
O\
lOOOOl\
l
->
llO\
OOl\
OO\
OO\

=
llO\
OllO\
lOl
;
llOl\
OOOOll
->
ll\
OOOl\
O\
O\
ll
=
llOl\
O\
O\
OO\
O\
O
;
llOlOOO\
O\
ll
->
lO\
lOl\
lOlOO
=
llOOl\
lll\
Ol
;
llOlOOOOlO\

->
llOOOlOOOl\

=
llOOllOlOl
;
llOl\
OOO\
OlO
->
llOOOl\
OOOO\

=
llOOllOO\
ll
;
llOlOO\
OOl\
O
->
llOOOlOOl\
l
=
llOlOOOOOl
;
llOlOOOOl\
O\

->
lO\
lO\
ll\
OlOO
=
llO\
OllllO\
l
;
ll\
OO\
lllllO\

->
lOOO\
lO\
OOOO
=
-
ll\
OOllllOl
->
lOOOlO\
OOO\
O
;
llO\
Ollll\
lO\

->
lOOOlOOOOO
.
No\
rmalise
(
)
;
llO\
Ol\
llllO
->
lO\
lO\
llOll\
l
=
llOOll\
lllO\

->
lO\
OO\
lOOOOO
.
Dot
(
lOllO\
OlllO\

[
llOOl\
lOOl\
l
]
)
;
llOOllll\
l\
O
->
llOO\
O\
lOlOO
=
fals\
e
;
llOOl\
ll\
ll\
O
->
ll\
OO\
OlOl\
Ol
=
fals\
e
;
llOOl\
l\
l\
llO
->
lOOOl\
OO\
ll\
l
=
0
;
llOOll\
l\
l\
lO
->
llOOO\
lO\
llO
=
0
;
llOOllll\
l\
O\

->
llOO\
OlOl\
ll\

=
0
;
}
lOOO\
OlO\
llO
<
llO\
O\
OOll\
lO
*
>
ll\
OlOO\
OlOl\

;
lO\
O\
OO\
l\
Ol\
lO
<
ll\
O\
OOOl\
llO\

*
>
llOlO\
OO\
llO
;
llOlO\
OOlOl
.
Initiali\
s\
e
(
0
,
64
)
;
llOlOOOllO\

.
Init\
i\
ali\
se
(
0
,
64
)
;
lOOOOlO\
l\
lO
<
llOOOOl\
l\
ll
*
>
llO\
lOOOll\
l\

;
llOl\
OO\
Olll
.
Ini\
tialise\

(
0
,
64
)
;
co\
nst
fl\
oa\
t\

llOlOOl\
O\
OO\

=
0.025f
*
llO\
OlOlllO\

*
llO\
OlOl\
lll\

;
bo\
o\
l
ll\
OlOO\
lOO\
l\

=
true
;
wh\
ile
(
llOlOOlOOl
)
{
llOlOOlOOl\

=
false\

;
for
(
llOOO\
llOOl
llOlOOlOl\
O
=
llOOlO\
l\
lOO
.
lOl\
O\
OOO\
lOO
(
)
;
!
ll\
OlOO\
lOlO\

.
AtEn\
d\

(
)
;
)
{
llO\
OO\
O\
lllO
&
llOlO\
OlOll
=
*
ll\
OlOOlO\
l\
O\

;
++
llOlO\
OlOlO
;
int
ll\
O\
lOO\
l\
lOO
=
-
1
;
{
llOO\
OOlll\
O
&
lOl\
lOOO\
Oll
=
llO\
lOOlOll
;
if
(
lOll\
OOOOll\

.
ll\
O\
O\
OlOlOO
)
co\
nti\
n\
ue
;
TA\
_\
ASS\
E\
RT
(
!
lO\
llOO\
OOll
.
llOO\
OlO\
l\
Ol
)
;
float
lO\
OOOO\
lOO\
O
=
llOl\
OO\
l\
OOO\

;
for
(
in\
t
lOlllO\
OllO
=
0
;
lO\
ll\
lO\
OllO
<
lOllO\
OlllO
.
lOOOlllOOl
(
)
;
lOl\
ll\
OOll\
O
++
)
{
if
(
llO\
OlllOll
[
lOl\
llOOllO
]
)
conti\
nue\

;
cons\
t\

Vec3\

&
llOOllll\
OO
=
lO\
ll\
OOlll\
O
[
lOlllOO\
l\
l\
O
]
;
fl\
oa\
t
lOlOll\
Olll
=
lOllOOOOll
.
lOO\
OlOO\
O\
O\
O
.
Dot
(
llOOl\
lll\
OO\

)
-
lOllO\
OOO\
ll\

.
lOlOllOl\
ll
;
if
(
lOOOO\
Ol\
OO\
O\

<
lOlOllOl\
ll
)
{
lOOOOOlOO\
O
=
lOl\
OllOlll\

;
llOl\
OO\
llOO
=
lO\
lllOOllO\

;
}
}
if
(
llOlO\
O\
ll\
OO\

==
-
1
)
{
lOllO\
OOOll
.
llOOO\
lOlO\
O
=
true
;
cont\
inue
;
}
llOlO\
OlOOl
=
true
;
llOOlllOl\
l\

[
ll\
O\
l\
OOl\
l\
O\
O\

]
=
1
;
}
Vec3
&
llOOllllOO
=
lOllOOl\
ll\
O
[
llOlOOllOO
]
;
llOlO\
OO\
lOl
.
Clear
(
)
;
llOl\
OOOllO
.
Clear
(
)
;
lOOOOl\
O\
llO
<
llOOOOl\
llO
*
>
*
llOl\
OOl\
lO\
l\

=
&
llOlOOOlOl
;
lOO\
O\
OlO\
llO
<
ll\
OOOO\
lllO
*
>
*
llOlOOlllO
=
&
llOlOOOll\
O
;
ll\
OlO\
Oll\
O\
l\

->
lOO\
OlllOO\
O
(
&
llOlOOlOl\
l
)
;
llOlO\
OOll\
l
.
Clear\

(
)
;
while\

(
llO\
lOOllOl
->
lO\
OOlllO\
Ol
(
)
>
0
)
{
for\

(
int\

lOOO\
l\
l\
OO\
Ol
=
0
;
lOOOllOO\
Ol
<
llO\
lOOll\
O\
l
->
lOOOll\
lOOl
(
)
;
lOO\
OllOOOl
++
)
{
llOOO\
OlllO\

*
llOOOlO\
OlO
=
(
*
llOl\
O\
OllO\
l\

)
[
lOOOll\
OO\
O\
l\

]
;
for\

(
llO\
OOllOlO
llOlOOlll\
l
=
llOOOlOOl\
O
->
llOOO\
llO\
OO
.
lOlOOOOlOO
(
)
;
!
llOlOOllll
.
AtEnd
(
)
;
++
llOlOOllll\

)
{
ll\
OOOOl\
l\
ll\

&
llOlOlOOO\
O\

=
*
llOlOOllll
;
TA_ASSE\
RT
(
llO\
lOlO\
OO\
O\

.
llO\
OOlOOlO\

==
llO\
OOlOO\
lO
)
;
if\

(
llO\
l\
Ol\
O\
OOO
.
lOlOllOlOO\

)
{
TA_ASSER\
T
(
llOlOlOOOO\

.
llOO\
O\
lOO\
ll
)
;
TA_\
ASSE\
RT
(
llOlO\
lOOOO
.
ll\
OO\
OlO\
O\
ll\

->
lO\
l\
O\
l\
lOlOO
)
;
TA_AS\
SER\
T
(
llO\
lO\
lOOOO
.
llO\
OO\
l\
OOll
->
lO\
lOllO\
lO\
O
==
ll\
OOOlOOlO
)
;
TA_\
ASSE\
RT
(
ll\
O\
lO\
lOOOO
.
ll\
OOOlO\
Oll
->
llOOOlOOll
)
;
TA_ASSER\
T
(
llO\
l\
O\
lOOOO\

.
llOOOlO\
Oll
->
llOOOlOOll
==
&
llO\
lOl\
O\
OOO
)
;
TA\
_ASS\
E\
R\
T
(
llOlO\
l\
O\
OO\
O
.
ll\
O\
O\
OlO\
OOO
==
ll\
OlOl\
OOOO\

.
llOOOlOOll
->
ll\
OOO\
lO\
OO\
l
)
;
TA_\
ASSERT
(
ll\
OlO\
lOOO\
O
.
llOOO\
l\
O\
OO\
l\

==
llOl\
OlOOOO\

.
llOOOlOO\
l\
l\

->
ll\
OOOlOO\
OO
)
;
if
(
llOlOlOOOO
.
lOlOl\
lOlOO\

->
lOOO\
lOOOOO
.
Do\
t
(
llOOll\
l\
l\
OO
)
-
llO\
l\
OlO\
O\
O\
O\

.
lOlO\
l\
lOlOO
->
lO\
lO\
llO\
lll
>
llOOllOOlO
)
{
if
(
!
llOl\
O\
lO\
OOO\

.
lOlOllOl\
O\
O
->
llOOO\
lOlOl
)
{
ll\
Ol\
OOll\
lO
->
lO\
OOlllOOO
(
ll\
OlOlOOOO
.
lOl\
O\
ll\
O\
lOO
)
;
llOlOl\
OOO\
O
.
lOl\
OllOlOO
->
ll\
OOOlOlO\
l\

=
true
;
}
}
el\
se
{
llOl\
OOOlll
.
lOOOlllOO\
O
(
ll\
O\
lOl\
OOOO\

.
llOOOlO\
Oll
)
;
}
llOlOlO\
O\
OO
.
ll\
O\
OOlOOll\

->
lO\
lOllOlO\
O
=
0
;
llOlOl\
O\
OOO
.
llOOO\
l\
OOl\
l\

->
ll\
O\
OOlOOll
=
0
;
}
else
{
TA_A\
SS\
ERT\

(
llOlOlOOOO
.
llOOOlO\
Ol\
l
==
0
)
;
}
llOlOlO\
O\
O\
O\

.
llOOOlOO\
lO
=
0
;
}
llO\
Ol\
OllOl
.
ll\
OlOl\
OOOl
(
ll\
OO\
O\
lOOlO
->
ll\
OOOl\
l\
O\
OO
)
;
if
(
&
(
*
llOlOOlOl\
O
)
==
llOO\
Ol\
O\
OlO
)
{
if
(
!
ll\
OlO\
O\
l\
Ol\
O\

.
AtEnd
(
)
)
++
ll\
OlO\
OlOlO
;
}
llO\
O\
lO\
ll\
OO
.
lOOll\
lll\
ll
(
ll\
O\
OOlO\
OlO\

)
;
llO\
OlO\
lO\
ll
.
Free
(
ll\
OOO\
lO\
Ol\
O
)
;
}
llOlOOllOl
->
Cle\
ar\

(
)
;
Swap\

(
llO\
lOO\
llOl
,
llOlOOlllO
)
;
}
ll\
OlOOOlOl
.
Clear
(
)
;
llO\
lO\
OOllO
.
Clear
(
)
;
lOOOOlOl\
l\
O\

<
ll\
OO\
OOlll\
O
*
>
&
llOlOl\
OOl\
O
=
llOl\
OOOlOl\

;
lOOO\
OlO\
llO
<
llOOOOl\
l\
l\
O
*
>
&
ll\
OlOlOOll
=
ll\
O\
lOOOll\
O
;
{
for
(
int\

llOlOlOl\
OO
=
0
;
llOlOlOlOO\

<
llOlOO\
Olll
.
lOOOll\
lOOl
(
)
;
llOlOlOl\
OO
++
)
{
ll\
O\
OOOllll
&
llOlOl\
OOOO
=
*
ll\
O\
lO\
OO\
lll
[
ll\
OlOlOl\
OO
]
;
TA\
_AS\
SERT
(
llO\
lOlOOOO\

.
llO\
O\
OlOOl\
O
)
;
TA_ASS\
ERT
(
!
llOlO\
lO\
OOO
.
lOlO\
llOlOO
)
;
TA\
_ASSER\
T
(
!
ll\
OlOlOO\
OO\

.
llOOOl\
OOll
)
;
{
ll\
Ol\
OlOOll
.
lO\
OO\
ll\
lOOO
(
llO\
l\
OlOOOO
.
llOOOlOO\
lO
)
;
llOOOOl\
llO
*
llOOOlO\
O\
lO
=
llOOlO\
lO\
ll\

.
Al\
lo\
c
(
)
;
llOOlO\
l\
lO\
O
.
lOlOlOOOO\
l
(
llO\
O\
Ol\
OOlO
)
;
llOOOlOOlO
->
llOOO\
lOlOO
=
false
;
llOO\
OlOOlO
->
lOOOlO\
O\
lll
=
0
;
llOOOlOOlO
->
ll\
OOOlO\
lOl\

=
fa\
lse
;
ll\
OOO\
lOOlO
->
ll\
O\
OOlO\
llO
=
0
;
ll\
OOO\
lOOlO
->
llOOO\
lOll\
l
=
0
;
ll\
OOO\
O\
l\
lll
*
llOl\
OlO\
lOl
=
llO\
O\
l\
OllOl
.
Al\
l\
oc
(
)
;
ll\
OOOOll\
ll
*
llO\
lOlOl\
lO
=
llOOlO\
ll\
O\
l
.
Alloc
(
)
;
llOOOOllll
*
llOlO\
lOlll
=
llOOlO\
llOl
.
Allo\
c
(
)
;
llOOO\
lOOlO
->
llOOOllOOO
.
lOlOlO\
OO\
Ol
(
llOlOlO\
lOl\

)
;
ll\
O\
OO\
lOOl\
O
->
llOOOll\
OOO
.
lOlOl\
O\
OO\
O\
l
(
llOlOlO\
l\
lO
)
;
ll\
OOOlO\
O\
lO
->
llOOO\
l\
lOO\
O
.
lOlO\
lOOOO\
l\

(
llOlO\
lOlll
)
;
llO\
lOlOl\
Ol\

->
ll\
OOOlO\
OlO
=
llOO\
Ol\
O\
OlO
;
llOlO\
lO\
ll\
O\

->
llOOOlOOlO
=
llOOO\
lOOlO\

;
llOl\
OlOll\
l
->
llOO\
OlOO\
lO
=
llO\
OOl\
OOl\
O
;
int\

ll\
OOllOOll
=
llOl\
OOllOO
;
int
llOO\
llOlOO
=
llOlO\
lOO\
OO\

.
llOO\
Ol\
OOOl
;
int
ll\
O\
O\
ll\
Ol\
Ol
=
llO\
lOlOO\
OO
.
ll\
O\
OOlOOO\
O\

;
llO\
lO\
lOl\
O\
l\

->
llOOOlOOOO\

=
ll\
OOl\
lO\
O\
ll\

;
llOlO\
lOl\
O\
l
->
llOOOlO\
OOl\

=
ll\
OOl\
lOlOO\

;
llOlO\
lOl\
Ol
->
lOlO\
l\
l\
OlOO
=
0
;
llOl\
OlOlOl\

->
llO\
O\
OlO\
O\
l\
l
=
0
;
llOlOlOll\
O
->
llO\
OO\
lOOOO
=
ll\
OOl\
l\
OlOO
;
ll\
OlOlOl\
lO
->
llOOOlOOOl
=
llOOll\
OlOl
;
ll\
OlOlOllO
->
lOlO\
l\
lO\
l\
OO
=
llOlOlO\
OOO
.
llOOO\
lOOlO
;
llOl\
OlOl\
l\
O
->
llOO\
Ol\
OOll
=
&
llO\
lO\
l\
OO\
OO
;
llO\
lOlOlll
->
ll\
OOOlOOO\
O
=
llO\
OllOlOl
;
llO\
lO\
lOlll
->
ll\
OOOlOO\
Ol\

=
llOOl\
lOOl\
l
;
llOlOlO\
lll\

->
lOlOl\
l\
OlOO\

=
0
;
llO\
lOl\
Oll\
l
->
llOOOl\
OOll
=
0
;
ll\
OO\
OlO\
OlO
->
lO\
OOl\
OOO\
OO
=
(
lO\
l\
l\
OOlllO\

[
llO\
O\
llOlOl\

]
-
lOllO\
O\
lll\
O
[
llOOll\
OO\
ll
]
)
.
Cr\
o\
ss
(
lO\
l\
lOO\
ll\
lO
[
llOOll\
OlOO\

]
-
lO\
l\
l\
OOll\
lO
[
llOO\
l\
lOOll
]
)
;
llOOOl\
O\
O\
lO
->
lOOOlOOO\
OO
.
Normalise
(
)
;
llOOOlO\
O\
lO\

->
lO\
lOl\
lOlll
=
llOO\
Ol\
OO\
lO\

->
lOO\
OlO\
OOO\
O\

.
Dot
(
lOl\
lOOl\
llO
[
llO\
O\
llOOll
]
)
;
llO\
lOlO\
OOO
.
ll\
OOOl\
OO\
ll
=
llO\
lOl\
OllO
;
ll\
OlO\
lOOOO
.
lO\
lOllOlOO
=
llOOOlOO\
lO
;
llOlOlOOlO
.
lOO\
OlllOO\
O
(
llOOO\
lOOlO
)
;
TA_A\
SSERT
(
llOlOlO\
OOO\

.
llO\
OOl\
O\
O\
OO\

==
llOlOlOOOO
.
llOOO\
l\
OOll
->
llOOOl\
OO\
Ol
)
;
TA_A\
SS\
ERT
(
ll\
O\
lOl\
OO\
O\
O
.
llOOOlOOO\
l
==
llOlOlOO\
O\
O
.
ll\
OOOlO\
Oll
->
llO\
OOlOO\
OO
)
;
}
}
}
for
(
int\

llOl\
OllOOO
=
0
;
llOlOll\
OOO
<
ll\
OlO\
lOOlO
.
lOOO\
l\
llO\
Ol
(
)
;
ll\
O\
lOllOOO
++
)
{
llOOOOlllO
&
lOll\
OlOO\
OO
=
*
llOlOlOOlO\

[
ll\
Ol\
Ol\
lOOO
]
;
for
(
int
llOl\
Oll\
O\
Ol
=
llOlOllOOO\

;
ll\
OlOl\
lO\
Ol
<
llOl\
OlOOlO
.
lOOOlllO\
O\
l
(
)
;
ll\
OlOllO\
O\
l\

++
)
{
ll\
OOOOlll\
O\

&
lO\
llO\
l\
OOlO\

=
*
llOlOlOOlO\

[
llOl\
OllOOl
]
;
fo\
r\

(
ll\
OOOllOlO\

llOl\
O\
l\
lOlO
=
lOllO\
lOOOO
.
ll\
OOOll\
OOO\

.
lOlOOO\
OlOO
(
)
;
!
llOlOl\
lOl\
O\

.
AtEnd\

(
)
;
)
{
llOOOOlll\
l
&
llO\
lOll\
Oll
=
*
llOlOl\
lOlO
;
++
llOlOl\
lOlO\

;
if
(
llO\
lOl\
l\
Oll
.
lOl\
OllOl\
OO
)
{
TA_AS\
SERT
(
ll\
O\
l\
O\
ll\
Ol\
l\

.
llOOOlOO\
l\
l
)
;
TA_\
A\
SSERT
(
llOl\
OllOll
.
llO\
OOl\
O\
Oll\

->
llOOOlOO\
ll\

)
;
TA_ASSERT
(
llO\
lOllOll
.
ll\
OO\
O\
lOOll
->
llOO\
Ol\
OOll
==
&
llOlOl\
l\
Oll
)
;
conti\
nu\
e
;
}
TA_ASSERT
(
!
llOlOll\
Oll
.
lOlO\
ll\
O\
l\
OO
)
;
TA\
_\
ASS\
ERT
(
!
ll\
OlOl\
l\
O\
ll
.
llOOO\
lO\
Oll
)
;
TA_A\
SSERT\

(
llOl\
O\
llOl\
l
.
ll\
OOOlO\
Ol\
O
=
&
lOl\
lOl\
OOOO
)
;
for
(
ll\
OOOllOlO
llOlOlll\
OO
=
lO\
ll\
OlO\
O\
lO
.
llOOOl\
lOOO\

.
lOlO\
O\
OOlOO
(
)
;
!
llO\
l\
O\
ll\
lOO
.
At\
En\
d\

(
)
;
)
{
llOOO\
O\
l\
ll\
l
&
ll\
OlO\
ll\
lOl\

=
*
ll\
O\
lOl\
llOO
;
++
llOlOl\
ll\
OO
;
if
(
llOlOlllOl\

.
lO\
lOll\
O\
lOO
)
{
TA_\
A\
S\
S\
ERT
(
llOlOlllOl\

.
ll\
O\
OOl\
OOl\
l
)
;
TA\
_A\
SSERT
(
ll\
Ol\
OlllOl
.
ll\
OOO\
lO\
O\
ll
->
llOO\
O\
lOOll
)
;
TA_A\
S\
SE\
RT\

(
llOlOlllOl\

.
llOOOlOOll
->
llO\
O\
O\
lOOll
==
&
llOlO\
ll\
lO\
l
)
;
con\
t\
inu\
e\

;
}
TA_AS\
SERT
(
!
llOl\
Ol\
llOl
.
lO\
l\
OllOlOO
)
;
TA\
_ASSERT\

(
!
llO\
lO\
l\
llOl
.
llOO\
O\
lOOl\
l
)
;
TA_ASSERT
(
llO\
lOlll\
Ol
.
llOOOl\
OOlO\

=
&
lO\
llOlOOl\
O\

)
;
if
(
llO\
lOl\
lOll
.
llOO\
OlOOO\
O
==
llOlOlllOl
.
llOO\
OlO\
O\
Ol
&&
llOlOllOl\
l
.
llOOOlOOOl\

==
llOlOlll\
Ol
.
llOO\
Ol\
OOOO\

)
{
if
(
ll\
O\
lOl\
lOll
.
llOOOlOOlO\

==
llOlO\
ll\
lOl\

.
llO\
OO\
lOOlO
)
{
TA_ASSER\
T
(
&
lO\
llOlO\
O\
OO\

==
llOlOllOl\
l
.
llOOO\
lOOlO
)
;
TA_A\
SSERT
(
&
lOll\
OlO\
O\
OO
==
&
lO\
llO\
lOOl\
O
)
;
if
(
&
(
*
llOlO\
ll\
O\
lO
)
==
&
ll\
O\
lOlllO\
l
)
++
llOlOllOlO
;
if
(
&
(
*
llO\
lOlllOO
)
==
&
llOlOllOll
)
++
ll\
OlOl\
ll\
OO
;
lO\
l\
lOlOO\
OO
.
llO\
OOllOOO
.
lOO\
l\
ll\
l\
lll
(
&
ll\
OlOllO\
ll
)
;
llOOlO\
llOl
.
Free
(
&
llOlOllOll
)
;
lOl\
lOl\
OOOO
.
ll\
OOOl\
lOO\
O
.
lO\
Ol\
ll\
llll
(
&
llOlOlllOl
)
;
llO\
OlOllOl\

.
Free\

(
&
llOlO\
l\
llOl
)
;
}
els\
e
{
llOlOl\
lOll\

.
llOOOlOO\
l\
l
=
&
llOlOlllO\
l
;
llOlO\
ll\
l\
O\
l\

.
llOO\
OlO\
Oll
=
&
ll\
Ol\
O\
llOll
;
llOlOllOll
.
lOl\
Ol\
lO\
l\
OO
=
&
lOll\
O\
lOO\
lO
;
llOlOlllOl
.
lOlOllOlO\
O\

=
&
lOl\
l\
OlOOOO\

;
}
br\
ea\
k
;
}
}
}
}
}
Ve\
c3
v3\
Cent\
er
;
v3\
C\
e\
nt\
er
.
Cl\
ear
(
)
;
int
llOlOl\
ll\
l\
O
=
0
;
for\

(
in\
t\

lO\
lll\
O\
O\
ll\
O
=
0
;
lO\
ll\
lOOll\
O
<
lO\
ll\
OOlllO
.
lO\
OO\
lll\
OOl\

(
)
;
lOl\
llO\
Ol\
l\
O
++
)
{
if
(
llOOlllOll
[
lOlllOOll\
O
]
)
{
llOlO\
llllO\

++
;
v3Cent\
er
+=
lO\
llO\
OlllO
[
lOlllOOllO
]
;
}
}
if
(
llO\
lO\
lll\
lO
<
3
)
{
llOOOOllOl
=
tru\
e
;
retur\
n
fa\
l\
se
;
}
v3\
C\
e\
nter
/=
(
fl\
o\
a\
t
)
llOlOll\
llO
;
for
(
in\
t
llO\
lOlllll
=
0
;
llO\
lOll\
lll\

<
llOl\
Ol\
OOlO
.
lOO\
Oll\
lOOl
(
)
;
ll\
OlOlll\
l\
l\

++
)
{
llO\
OOOlllO
&
lOllOOOOl\
l
=
*
ll\
O\
lOl\
O\
O\
lO\

[
llO\
lOlllll
]
;
if
(
lOllOOOOll
.
lOOOlOOOOO
.
Dot
(
v3\
Cen\
te\
r\

)
-
lOllO\
OOOll
.
lOlOll\
O\
l\
ll\

>
llO\
lOOlOOO
)
{
llOOOOllOl
=
tr\
ue
;
return
false\

;
}
}
boo\
l
llO\
l\
l\
OOOO\
O
=
tru\
e
;
whil\
e
(
ll\
O\
l\
lOOO\
OO\

)
{
llOllOO\
OOO
=
false\

;
}
}
}
if\

(
llO\
OOll\
l\
ll\

!=
0
)
{
bool\

llOll\
OOOOl\

=
true
;
whi\
le\

(
llO\
llOO\
O\
Ol
)
{
llOllOOOOl
=
fal\
s\
e
;
llOOOOll\
l\
l
*
llOllO\
OOl\
O
=
0
;
flo\
at
llOllOOO\
l\
l
=
k_fMaxF\
l\
oa\
t\

;
fo\
r\

(
llOOOll\
OOl\

llOlOOlOlO
=
llO\
O\
lOl\
lO\
O\

.
lO\
lOOO\
OlO\
O
(
)
;
!
llO\
lOO\
l\
OlO
.
AtEnd
(
)
;
++
llOl\
OOlO\
l\
O
)
{
ll\
OO\
OOlllO\

&
lOl\
lO\
O\
OOll
=
*
llOlOOl\
O\
lO
;
for
(
llO\
OO\
l\
lOlO
ll\
O\
lOllOlO
=
lOllOO\
O\
Oll\

.
ll\
OOOll\
OO\
O
.
lOlOO\
OOl\
O\
O
(
)
;
!
llOlO\
l\
lOl\
O\

.
AtEnd
(
)
;
++
llOlOllOlO\

)
{
ll\
OOOOllll\

&
llO\
l\
O\
llOll
=
*
ll\
OlO\
l\
lOlO
;
TA\
_AS\
SER\
T\

(
llOlOl\
lOll
.
lOlOl\
lO\
l\
OO
)
;
if
(
llOlOllOll
.
lO\
lOll\
OlO\
O\

->
lOO\
O\
lOOOO\
O\

.
Dot\

(
lO\
llOOOOl\
l
.
lOOOl\
OO\
O\
OO
)
<
0.0f
)
co\
ntinu\
e
;
Ve\
c3
llOl\
lOOlOO
;
llO\
llO\
OlOO
.
Clea\
r
(
)
;
in\
t
llO\
llOO\
lOl
=
0
;
for
(
llO\
O\
OllOl\
O
llO\
l\
Oll\
lOO
=
llOl\
OllO\
ll
.
lOlOllOl\
O\
O
->
llOO\
O\
llOOO\

.
lOlOOOOl\
OO
(
)
;
!
llOlOlllOO
.
AtEn\
d
(
)
;
++
llOlO\
l\
llOO
)
{
llO\
OOOl\
ll\
l\

&
ll\
Ol\
OllOll
=
*
llOlOll\
lOO
;
llOllOOlOO
+=
lOll\
OOl\
llO
[
llOlOl\
lOl\
l\

.
llO\
O\
OlOOOO\

]
;
llOl\
lOOl\
O\
l
++
;
}
TA_ASSERT
(
llOllOO\
lOl\

>
0
)
;
if\

(
llOllOOl\
Ol\

>
0
)
{
llOllOOl\
OO
/=
(
flo\
at
)
llOllO\
O\
lO\
l\

;
floa\
t
lOlll\
O\
ll\
OO
=
lOllOOOOll
.
lOO\
OlO\
OOO\
O\

.
Do\
t\

(
ll\
O\
llOOl\
O\
O\

)
-
lOllOOOOll\

.
lOlOllOl\
l\
l
;
if\

(
Fabs
(
llOl\
lOOOll\

)
>
Fab\
s
(
lOlllOl\
l\
O\
O
)
)
{
llO\
llOO\
Oll
=
lOll\
lOl\
l\
OO\

;
llOllOOOlO
=
&
llOl\
O\
llOll
;
}
}
}
}
if
(
llOllOOOl\
O
&&
Fab\
s
(
ll\
O\
llO\
O\
Ol\
l
)
<
ll\
OlOO\
lOOO
*
ll\
OOOl\
llll
)
{
ll\
OllOOOlO
->
llOO\
OlOOl\
O
->
llOOO\
l\
lO\
OO
.
ll\
Oll\
OOl\
lO
(
llOllOO\
Ol\
O
->
lOlOl\
lOl\
OO
->
llOOOl\
l\
OO\
O
)
;
ll\
OOO\
O\
lllO\

*
ll\
OOO\
lOO\
lO
=
llOllO\
OOlO\

->
llOOO\
lOOl\
O
;
llOO\
OOlll\
O
*
lOl\
OllOl\
O\
O
=
llO\
l\
lOOOlO
->
lOlOllOlOO
;
llOOOl\
lOlO
ll\
OlOllO\
lO
;
for\

(
llOlOll\
O\
lO\

=
llOOO\
lO\
OlO\

->
llOO\
OllO\
OO\

.
lO\
lOO\
OO\
lOO\

(
)
;
!
llOl\
O\
llO\
l\
O\

.
At\
E\
nd
(
)
;
)
{
llO\
OO\
Ollll
&
llO\
lOl\
l\
Oll\

=
*
llOlOl\
lO\
lO\

;
++
llOlOllO\
lO
;
if\

(
llOlOll\
Oll
.
lOlOllOlOO
==
lOlOll\
OlO\
O
||
ll\
Ol\
Ol\
lOl\
l
.
lOlOllOl\
OO\

==
llOOOl\
OOlO
)
{
llO\
O\
O\
lO\
Ol\
O
->
llOOOll\
O\
OO\

.
lO\
Olllllll\

(
&
llOlO\
llOll
)
;
llO\
O\
lOll\
Ol
.
Free\

(
&
llOl\
O\
llO\
ll\

)
;
continue
;
}
if
(
llOlOllOll\

.
llO\
OOlOO\
ll
->
lOlOllO\
lOO
==
lO\
lO\
llO\
l\
OO\

)
ll\
OlOllOl\
l
.
ll\
OO\
OlOOll
->
lOlOllOlOO
=
llOOOlOOlO
;
ll\
O\
lOll\
Oll
.
llO\
OOl\
OO\
l\
O\

=
llO\
OOl\
O\
OlO\

;
}
lO\
lO\
l\
llOO\
O
<
llO\
OOOllll
,
true
>
::
lOlOlll\
OO\
l
llOllOOlll
;
llO\
l\
Oll\
O\
lO
=
llOOOl\
OO\
lO
->
ll\
OO\
OllOOO
.
lO\
lO\
O\
OOl\
OO
(
)
;
if\

(
!
ll\
OlOl\
lOlO\

.
AtE\
nd\

(
)
)
{
llOOOOll\
ll
*
llOl\
lOl\
O\
OO
=
&
*
ll\
O\
l\
Ol\
lOlO
;
ll\
OOOlOO\
l\
O
->
llOOO\
llOOO
.
lO\
Olllll\
ll
(
llO\
l\
lOlOOO
)
;
llO\
llO\
Ol\
ll
.
lOlO\
lOOOO\
l
(
llOllOl\
OOO\

)
;
bo\
ol
llOl\
lOlOOl
=
false
;
while
(
!
llOll\
OlOO\
l
)
{
llOl\
lOlOOl\

=
tr\
u\
e
;
for
(
llOlOllO\
lO
=
llOOO\
lOOl\
O
->
llOO\
O\
llOO\
O\

.
lO\
lOO\
OO\
l\
OO
(
)
;
!
llOl\
O\
ll\
OlO
.
AtEn\
d\

(
)
;
)
{
llOO\
OOllll
&
ll\
OlOllOll
=
*
llO\
lOllOl\
O\

;
++
ll\
O\
l\
Oll\
OlO
;
if
(
llOlOl\
lO\
l\
l
.
ll\
OO\
Ol\
O\
OOO\

==
llOllOlOOO\

->
llOOOlOOOl\

)
{
llO\
OOlO\
Ol\
O\

->
llOOOllOOO
.
lOO\
ll\
ll\
lll
(
&
llOlOllOl\
l
)
;
llO\
llOOlll
.
lO\
lOlO\
OOO\
l
(
&
ll\
O\
lOll\
Ol\
l
)
;
llO\
llOl\
OOO
=
&
ll\
OlOllOll
;
ll\
OllOlOOl\

=
fal\
se
;
bre\
ak
;
}
}
if\

(
llOll\
Ol\
OOl\

&&
!
ll\
OO\
OlO\
OlO\

->
ll\
OOOllOOO
.
lOl\
OO\
OOlOO\

(
)
.
AtEnd\

(
)
)
{
ll\
OO\
O\
Ollll\

&
llOl\
O\
llOll
=
*
llOOOlOOlO
->
llOOOllOO\
O\

.
lOl\
OOOOlOO
(
)
;
llOO\
OlOO\
l\
O
->
llOOO\
llOO\
O
.
lOO\
ll\
lllll
(
&
ll\
Ol\
OllOll
)
;
llOllO\
O\
l\
l\
l
.
lOlOlOO\
OO\
l
(
&
llO\
lOllOll
)
;
llO\
llOlOOO
=
&
ll\
OlOllOll
;
llOllOlOO\
l\

=
fal\
se\

;
}
}
TA_\
ASSERT
(
ll\
OOOlO\
Ol\
O\

->
llO\
OO\
llOOO
.
lOlOOO\
O\
lOO
(
)
.
AtE\
nd
(
)
)
;
llOOOl\
O\
Ol\
O
->
llOOO\
llOOO
.
llOl\
lO\
lOlO
(
llOllOOlll
)
;
}
{
Vec3
llOllOlOll
;
Vec3
lOOO\
lOO\
O\
O\
O
;
Ve\
c\
3
ll\
OllO\
llO\
O\

;
lOOOlOOOOO
.
Cl\
ear
(
)
;
llO\
ll\
Ol\
lOO
.
Clear
(
)
;
boo\
l
lOlllll\
ll\
O
=
true
;
int\

llO\
ll\
O\
OlOl\

=
0
;
for
(
llO\
OOllOl\
O\

llOlOOl\
l\
ll
=
ll\
OOOlOO\
lO
->
llO\
O\
OllO\
O\
O\

.
lOl\
O\
OOOlOO\

(
)
;
!
llOlO\
Olll\
l\

.
At\
End
(
)
;
)
{
ll\
O\
O\
O\
Oll\
l\
l
&
llOlOlOOOO
=
*
llOlOOlll\
l
;
++
llOlOOlll\
l
;
if
(
llOlOOllll
.
At\
End
(
)
)
br\
eak\

;
llOl\
lOOlOl
++
;
if\

(
lOlll\
ll\
llO
)
{
lOll\
lll\
llO\

=
fals\
e
;
llOllOlOll
=
lOllOOlllO
[
ll\
OlOl\
OO\
O\
O
.
llO\
O\
Ol\
O\
O\
Ol
]
;
}
else
{
Vec\
3
lll\
ll\
l\
lll\

=
lOllOOlll\
O
[
ll\
OlOlOOOO
.
llO\
OOlOOOl
]
-
ll\
Oll\
Ol\
Oll\

;
Ve\
c3
lOOOO\
OO\
OOO\

=
lOllO\
Ol\
l\
lO
[
llO\
lOl\
O\
OOO
.
ll\
OOOlOOOO\

]
-
llOllOl\
Oll\

;
lO\
O\
OlOOOOO
+=
Ve\
c3
::
Cros\
s
(
ll\
l\
llllll\

,
lOOOOOOOO\
O\

)
;
}
llOll\
Oll\
OO
+=
lOll\
OOlllO\

[
llOlOlOO\
OO
.
ll\
OO\
OlOOO\
l
]
;
}
if
(
ll\
Oll\
OOlOl
>
1
)
{
llO\
llO\
l\
lOO
/=
(
fl\
o\
a\
t
)
(
ll\
O\
ll\
OO\
lOl
)
;
lOOOlOOOO\
O\

.
Nor\
mal\
ise
(
)
;
llO\
OOlOOlO
->
lOOO\
lO\
OOO\
O
=
lOOOlOOOOO
;
llOOOlOO\
l\
O
->
lO\
l\
O\
llO\
l\
ll
=
ll\
OOOlOOlO\

->
lOOOlOOOOO
.
Do\
t
(
ll\
Oll\
OllO\
O
)
;
}
}
ll\
O\
OlOl\
l\
O\
O
.
lOOlllll\
ll
(
lOlO\
llOl\
OO
)
;
llO\
Ol\
OlOll
.
Free
(
lO\
lOllO\
lO\
O
)
;
ll\
Oll\
O\
OO\
Ol
=
tr\
ue
;
}
}
int
ll\
OllOllOl
=
20
;
floa\
t
ll\
OllO\
l\
llO
=
0.0f
;
for
(
int
lOOOllOOOl
=
0
;
lOOOll\
OOOl
<
llOl\
lO\
llOl
;
lOOOllOOOl
++
)
{
llOOOllOO\
l
llOlOOlOlO
;
fl\
oat
llOllOll\
ll
=
(
flo\
at\

)
lO\
OOl\
l\
OOOl
*
(
1.0f
/
5.0f
)
;
if\

(
llOll\
O\
llll
>
1.0f
)
llOll\
Oll\
ll
=
1.0f
;
llO\
llOl\
llO
=
0.0f
;
fo\
r
(
llO\
lOOlO\
lO
=
llOO\
lOll\
OO
.
lOlO\
O\
O\
OlO\
O
(
)
;
!
llO\
lOOl\
OlO
.
At\
E\
nd
(
)
;
++
llOl\
OO\
l\
O\
lO
)
{
ll\
OOOO\
ll\
l\
O\

&
lOll\
OOOOll
=
*
llO\
lO\
OlOlO
;
for
(
ll\
O\
OO\
llOlO
ll\
OlOOll\
ll
=
lOll\
OO\
OO\
ll
.
ll\
OOOllOO\
O
.
lOl\
OOOO\
lOO
(
)
;
!
llOlOOlll\
l
.
At\
E\
nd
(
)
;
++
llO\
lOOlll\
l
)
{
llOOOOllll
&
ll\
Ol\
OlOOO\
O
=
*
ll\
OlOOlll\
l
;
Vec\
3
&
llOOl\
lllOO
=
lOllOOl\
llO
[
llO\
lO\
lOOOO
.
llOO\
OlOOOl
]
;
float\

lOlll\
OllOO
=
lOllOOOO\
ll
.
lO\
OOl\
OOOOO\

.
Dot
(
llO\
Olll\
lOO
)
-
lO\
l\
lOOOOll\

.
lO\
l\
O\
llOlll
;
llO\
llOlllO\

+=
Fa\
bs\

(
lOl\
llO\
l\
lOO\

)
;
llOOllll\
OO
-=
lOlllOllOO
*
lOllOO\
OOll
.
lOOOlOOOOO\

*
llOllO\
llll
;
}
}
if
(
(
lOOOll\
OOOl
&
3
)
==
0
||
lOOO\
llO\
OOl
==
ll\
OllOl\
lO\
l
-
1
)
for\

(
llO\
lO\
O\
lOlO
=
llOOl\
O\
l\
l\
O\
O\

.
lOlOO\
OO\
l\
OO
(
)
;
!
llOlOOlO\
lO
.
At\
End
(
)
;
++
llOl\
O\
OlOl\
O
)
{
llOOOO\
lllO\

&
lOl\
lOOOOll\

=
*
ll\
OlO\
OlOl\
O\

;
{
Ve\
c\
3
llO\
llOlOll
;
Ve\
c3\

lOOO\
l\
O\
O\
OO\
O
;
Ve\
c3
llOllOllOO
;
lOO\
OlOOO\
OO
.
Clea\
r
(
)
;
ll\
OllO\
ll\
O\
O
.
Clear\

(
)
;
boo\
l
lOl\
lll\
l\
ll\
O
=
true
;
int
llOllOOl\
Ol
=
0
;
fo\
r
(
llOOOl\
lOlO
llOl\
O\
Olll\
l
=
lOl\
l\
OO\
O\
Oll\

.
llO\
O\
OllOOO
.
lO\
lOO\
O\
Ol\
OO
(
)
;
!
ll\
Ol\
OOllll
.
AtEnd
(
)
;
)
{
llOOOO\
ll\
ll\

&
llOlOlO\
OO\
O
=
*
llOlOO\
l\
lll
;
++
llOl\
OO\
lll\
l
;
if
(
ll\
OlOO\
llll
.
At\
End\

(
)
)
br\
ea\
k
;
llO\
llOOl\
Ol
++
;
if
(
lO\
lllllllO
)
{
lOlll\
llllO
=
fa\
lse\

;
llOl\
l\
Ol\
Oll
=
lOll\
O\
O\
lll\
O
[
llOlO\
lOO\
OO
.
llO\
OO\
lOOOl
]
;
}
else
{
Vec3
lllll\
ll\
ll
=
lO\
llO\
Ol\
llO
[
llOlOl\
OOOO
.
llOO\
O\
lOOOl
]
-
llOllO\
lOll
;
Ve\
c\
3
lOOOOOOOOO
=
lOllOOlllO
[
llO\
lOl\
O\
OOO
.
llOO\
OlOO\
OO
]
-
ll\
OllO\
lOll
;
lOO\
OlOOOOO
+=
Vec\
3
::
Cro\
ss
(
lllll\
ll\
l\
l\

,
lOO\
OOOOOOO\

)
;
}
llO\
ll\
O\
llOO
+=
lOllOOlll\
O\

[
ll\
OlOl\
OOOO
.
ll\
OOO\
l\
OOOl
]
;
}
if
(
llOll\
OOlOl\

>
1
)
{
ll\
O\
llOllOO
/=
(
float
)
(
llO\
l\
lOO\
l\
Ol\

)
;
lOOOlOO\
OOO
.
Norm\
alise\

(
)
;
lOl\
lO\
OOOll
.
lOO\
OlOOO\
OO
=
lO\
O\
Ol\
OO\
O\
O\
O
;
lO\
llO\
O\
OOll
.
lOlOllO\
lll
=
lOl\
l\
O\
OOOll\

.
lOOOlOOOOO\

.
Dot
(
llOllOl\
lOO
)
;
}
}
}
}
if
(
ll\
OllOl\
l\
lO
>
0.1f
*
llOOlOlllO
)
{
llOO\
lOOOlO
=
tr\
ue\

;
retu\
r\
n
false\

;
}
}
{
int
llO\
l\
llOOOO\

=
0
;
int
llO\
lllO\
OO\
l
=
0
;
llOOO\
llOOl
llO\
lOOlO\
l\
O
;
fo\
r
(
llOl\
OO\
lOl\
O
=
llO\
O\
lOl\
l\
OO
.
lOlOO\
OOl\
O\
O\

(
)
;
!
ll\
OlOOlOlO
.
AtEnd
(
)
;
++
ll\
O\
lOOlO\
lO
)
{
llOOOOll\
lO\

&
lOl\
l\
O\
OOO\
l\
l
=
*
llO\
lOOl\
OlO\

;
lO\
ll\
O\
OO\
Oll
.
lO\
OOl\
OOlll
=
ll\
OlllOOOO
;
llOlllO\
O\
OO
++
;
for\

(
llOOOll\
OlO
llOlOllO\
lO
=
lOl\
lO\
OOOll
.
llOO\
Oll\
OOO
.
lOlOOOOl\
O\
O
(
)
;
!
llOlO\
llOlO
.
AtE\
n\
d
(
)
;
++
llO\
lOllOlO
)
{
llOOOOllll
&
llOlOll\
Oll
=
*
llOlO\
l\
lOl\
O
;
llOlllOOOl\

++
;
TA\
_ASSERT
(
ll\
OlOllOll
.
lOlOllOlOO
)
;
Vec3
ll\
OllOOlOO
;
llOllO\
OlO\
O
.
Cl\
ear
(
)
;
int
llOllO\
OlOl
=
0
;
int\

llOl\
llOOl\
O
=
-
1
;
for
(
llOOO\
l\
lOlO
llOlOl\
llOO
=
llO\
lOllO\
ll\

.
lOlOllOl\
O\
O
->
llOOOl\
lOO\
O\

.
lO\
lOOOO\
l\
OO
(
)
;
!
llOlOlllO\
O
.
AtEnd
(
)
;
++
llOlOl\
ll\
OO\

)
{
llOO\
O\
O\
lll\
l
&
ll\
Ol\
OllOll
=
*
llOlO\
lllOO
;
llO\
llOOlOO
+=
lOl\
lOOlll\
O\

[
llO\
lOllO\
l\
l
.
ll\
O\
OOlOOOO
]
;
ll\
Oll\
OOlOl\

++
;
if\

(
llO\
l\
ll\
O\
OlO
!=
-
1
&&
llOl\
OllO\
l\
l
.
llO\
O\
OlOO\
Ol
!=
llOll\
l\
OO\
lO
)
{
ll\
OOlO\
O\
O\
l\
O
=
true
;
llOO\
O\
Ol\
l\
Ol
=
true
;
ret\
urn
fa\
l\
se\

;
}
llO\
ll\
l\
OOlO
=
ll\
Ol\
Ol\
lOll\

.
ll\
OOOl\
OO\
OO
;
}
if
(
llOllOOlOl
>
llOO\
O\
lllOl
)
{
llOOl\
OOO\
lO\

=
true\

;
re\
tu\
rn
fa\
ls\
e
;
}
TA_ASSER\
T
(
llOll\
OOlO\
l\

>
0
)
;
if
(
llOllOOlOl\

>
0
)
{
ll\
OllOO\
lOO
/=
(
flo\
at
)
llOll\
OOl\
O\
l\

;
flo\
at
lOll\
lOll\
OO
=
lOl\
l\
O\
O\
OOll
.
lO\
OOlO\
O\
OOO\

.
Do\
t\

(
llOl\
l\
OO\
lO\
O
)
-
lOllOOOOll
.
lOlOl\
lOlll
;
flo\
at
ll\
OlllO\
O\
l\
l
=
-
llOl\
O\
OlOOO
*
0.000001f
;
if
(
llO\
OOlllll
<
0.01f
)
ll\
O\
ll\
lO\
Oll
=
ll\
OlO\
OlO\
OO
*
0.0001f
;
if
(
lOlllOllOO
>
llOlllOOll\

)
{
ll\
OO\
lOO\
OlO
=
true\

;
ret\
ur\
n\

fal\
se
;
}
}
}
}
lO\
OOOl\
OllO
<
int
,
false\

>
llOl\
ll\
OlOO
;
llOlll\
O\
lOO
.
In\
iti\
al\
ise\

(
0
,
lOllOOlllO
.
lOO\
Oll\
lO\
Ol
(
)
)
;
in\
t
ll\
Oll\
l\
Ol\
Ol
=
0
;
for
(
in\
t\

lOlllOO\
l\
lO
=
0
;
lOlllOOllO
<
lOl\
lOOlll\
O
.
lOOOll\
lOOl
(
)
;
lOll\
lO\
OllO
++
)
{
if
(
ll\
OO\
ll\
lOll\

[
lOll\
lO\
O\
llO
]
)
llOll\
lO\
lO\
O
.
lOO\
O\
lllOOO\

(
llOll\
l\
OlOl
++
)
;
else
llOll\
lOl\
OO
.
lOOOl\
ll\
OOO\

(
0
)
;
}
ll\
OOlOl\
O\
lO
.
In\
itialise\

(
0
,
ll\
Ol\
llOlOl
)
;
for
(
int\

lOlllOOllO\

=
0
;
lOll\
lOO\
llO
<
lOl\
lOOlllO
.
lOOOlll\
OOl\

(
)
;
lOl\
l\
l\
O\
Ol\
lO\

++
)
{
if
(
llOOl\
llOll
[
lOl\
llOOllO\

]
)
llOOlOlO\
lO\

.
lO\
OOlllOOO
(
lOllO\
O\
lll\
O
[
lOl\
ll\
O\
Oll\
O
]
)
;
}
TA\
_AS\
SE\
RT
(
llOOl\
Ol\
OlO
.
lO\
OOlll\
O\
O\
l
(
)
==
llOlllO\
lOl
)
;
int
lOllO\
lllOl\

=
llOlllOOOO
+
llOlllOOOl\

*
2
;
ll\
OOlOlOOO\

.
Ini\
tialise\

(
0
,
lOl\
lOll\
lOl
)
;
llO\
OlOl\
OOl
.
Initi\
al\
i\
se
(
0
,
ll\
Oll\
lOOOO\

)
;
for
(
llO\
lO\
OlOlO
=
ll\
OOl\
O\
ll\
O\
O
.
lO\
lO\
OOOlO\
O\

(
)
;
!
ll\
Ol\
O\
O\
l\
Ol\
O
.
At\
End
(
)
;
++
llOlO\
O\
l\
OlO
)
{
llOOOOlll\
O\

&
lOllOOO\
Oll
=
*
llOlO\
O\
lOl\
O
;
ll\
OO\
lOlO\
Ol
.
lOO\
Oll\
lOOO
(
ll\
O\
O\
lOl\
O\
O\
O
.
lO\
OOlll\
OO\
l\

(
)
)
;
ll\
OOlOlOOO
.
lO\
O\
Olll\
O\
OO
(
lOl\
lOOOOll
.
llOOO\
l\
lOO\
O
.
lOOOl\
ll\
OO\
l
(
)
)
;
int
llOlOlOl\
OO
=
0
;
fo\
r
(
llO\
OOllOl\
O
llOl\
OOllll
=
lO\
l\
lOOO\
Ol\
l
.
llOOOllOOO
.
lOlOOOOl\
OO
(
)
;
!
llOlOOl\
lll
.
AtE\
n\
d
(
)
;
++
llOl\
OOlll\
l\

)
{
llOOOO\
ll\
l\
l\

&
llOlOlO\
OO\
O
=
*
llO\
lO\
Oll\
l\
l\

;
llOOlOlO\
OO\

.
lO\
OOlllOO\
O
(
llO\
l\
llO\
lOO
[
llOlO\
lOOOO\

.
llOOO\
lOOO\
l
]
)
;
llOOlOlO\
OO\

.
lOOOlll\
OO\
O\

(
llOlOlOOOO\

.
lOlOllOlOO
->
lO\
OOl\
OOl\
ll
)
;
llOlO\
lOl\
O\
O\

++
;
}
}
TA_A\
SSE\
R\
T
(
llOO\
lOlOOO
.
lO\
O\
O\
l\
l\
lOOl
(
)
==
llO\
Ol\
O\
lOOO
.
lOO\
llllOll\

(
)
)
;
TA\
_\
ASS\
ERT
(
ll\
OOlOlOOl
.
lOOOlllOOl\

(
)
==
llOOlOlOOl\

.
lOO\
llll\
Oll\

(
)
)
;
}
re\
t\
ur\
n
true
;
}
}
