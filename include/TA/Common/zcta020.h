//---------------------------------------------------------------------------------
// File Name: zcta020.h
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#ifndef DOXYGEN
#include <xmmintrin.h>
#include <emmintrin.h>
#pragma inline_recursion(on)
#pragma inline_depth(255)
#ifdef TA_SSE2
#define lOlOOlOOllO(x, y) ((__m128&)_mm_shuffle_epi32((__m128i&)(x), (y)))
#else
#define lOlOOlOOllO(x, y) (_mm_shuffle_ps((x), (x), (y)))
#endif 
namespa\
ce
TA
{
nam\
espace\

lO\
l\
OO\
OOOlOO
{
st\
ruct
lO\
lO\
OO\
OOlOl
{
unio\
n
{
st\
r\
uct
{
floa\
t\

x
;
flo\
at
y
;
float
z
;
fl\
oat
w
;
}
;
__m1\
28\

lOl\
OOlOOll\
l
;
}
;
}
;
templ\
ate\

<
class\

Type
>
struc\
t\

lOl\
OOl\
OlOOO\

{
__\
f\
orceinlin\
e
lOlOO\
O\
O\
OlO\
l
lO\
lOOl\
Ol\
OOl
(
)
co\
n\
st
{
re\
turn\

(
(
Ty\
p\
e
&
)
*
th\
is
)
.
lO\
lOOlOlOOl
(
)
;
}
__f\
orceinl\
in\
e
fl\
oat\

lOlOOlOlOlO\

(
)
cons\
t
{
ret\
u\
rn
(
(
Ty\
p\
e
&
)
*
this
)
.
lO\
lOOlOlOlO
(
)
;
}
}
;
__f\
orceinline
__m12\
8\

lOlOO\
lOlOll\

(
__m1\
28\

lllO\
O\
llOlO\

,
__m128
ll\
lO\
OllllO
)
{
__m\
128
lOlOO\
lO\
l\
l\
OO
=
_mm_m\
ul_\
ps
(
lllO\
Ol\
lO\
lO\

,
lllOOllllO
)
;
__m12\
8
lOlOO\
lOl\
lO\
l
=
lOlOO\
l\
O\
O\
l\
lO
(
lO\
lO\
OlOll\
OO\

,
_MM_SH\
UFF\
L\
E
(
3
,
0
,
2
,
1
)
)
;
lO\
l\
OOl\
OllOl\

=
_mm\
_add_ps
(
lOlOOlOllO\
l
,
lOlO\
Ol\
Ol\
l\
OO
)
;
lO\
l\
OOlOl\
lOO
=
lOlO\
OlOOllO
(
lOlOOlOll\
OO
,
_M\
M_SHUFF\
LE
(
3
,
1
,
0
,
2
)
)
;
lOlO\
OlO\
ll\
OO\

=
_m\
m_ad\
d_ps\

(
lOlO\
O\
lOllOO\

,
lO\
lOO\
lOll\
Ol\

)
;
re\
t\
ur\
n
lOlO\
Ol\
OllOO
;
}
st\
ruct
lOlO\
Ol\
Ol\
llO
:
public\

lOlOO\
lOl\
OOO
<
lOlOO\
lO\
ll\
lO\

>
{
const\

lOlOOOO\
OlOl
&
lOl\
OO\
Oll\
lO\
O
;
cons\
t\

lOlOOOO\
OlOl
&
lOlOOOlllOl
;
lOl\
OO\
lOlllO\

(
const
lOl\
OOO\
OOlO\
l\

&
ll\
lOOllOlO
,
const
lOlOOOO\
OlOl
&
ll\
lO\
Oll\
ll\
O
)
:
lO\
lOO\
Ol\
llOO
(
lllOO\
l\
lOlO\

)
,
lOlOOO\
lllOl
(
lllOOl\
l\
llO\

)
{
}
__f\
orceinline
lO\
lOOOOOlOl
lOlOOlOlO\
Ol\

(
)
co\
ns\
t
{
return\

(
lO\
lOOOOOlOl\

&
)
lOlOOl\
OlOll
(
(
__m12\
8\

&
)
lO\
lOOOl\
llOO
,
(
__\
m1\
28
&
)
lOlOOOlllOl
)
;
}
__forc\
ein\
l\
ine\

floa\
t\

lOlO\
OlOlOlO
(
)
con\
st
{
#ifdef TA_SSE2
__m128
lOlO\
OlOllO\
O
=
_m\
m\
_mu\
l_ps\

(
(
__m\
128\

&
)
lOl\
O\
OOl\
l\
lOO
,
(
__m1\
2\
8\

&
)
lOlOOOlllOl
)
;
__m12\
8
lO\
lOOl\
O\
l\
lOl\

=
(
__\
m128
&
)
_mm_s\
hu\
ffle_\
e\
pi32\

(
(
__m12\
8i
&
)
lO\
l\
O\
O\
lOllOO
,
_MM_S\
H\
UFF\
LE\

(
0
,
0
,
0
,
1
)
)
;
__m128\

lOlO\
Ol\
Oll\
ll
=
(
__m128\

&
)
_mm_s\
h\
uffle_epi32\

(
(
__m128i\

&
)
lOlOOlOllO\
O\

,
_MM_SHUF\
FLE
(
0
,
0
,
0
,
2
)
)
;
lOlOOlOllOl\

=
_mm_add_ss\

(
lOlOOlO\
l\
l\
Ol
,
lO\
l\
OO\
l\
OllOO
)
;
lOlOOlO\
l\
lOl
=
_mm_ad\
d\
_ss\

(
lOlOO\
lOllO\
l
,
lO\
lOOl\
Olll\
l
)
;
retur\
n
(
(
lOl\
OOOO\
OlOl
&
)
lOl\
OOlOllOl
)
.
x
;
#else
lO\
lOOO\
OOl\
O\
l
lO\
l\
OOllOOOO
;
(
__m\
128
&
)
lOl\
O\
Ol\
lOOO\
O\

=
_mm_m\
ul_p\
s
(
(
__m1\
28
&
)
lOlOOOl\
llO\
O
,
(
__m128\

&
)
lOlOO\
OlllOl
)
;
return
lOlO\
Ol\
lOO\
OO
.
x
+
lOlOO\
llO\
OO\
O
.
y
+
lOl\
OOl\
l\
OOOO\

.
z
;
#endif
}
__forcei\
nl\
ine
oper\
ator
float
(
)
const
{
re\
turn
lOlOO\
l\
O\
lOlO
(
)
;
}
}
;
struct
lOlOOl\
lOOOl
:
pu\
blic\

lOlOOlOlOOO
<
lO\
lOOllOOOl
>
{
const
lO\
lOO\
OOOlO\
l
&
lO\
lO\
OOlllOO
;
lOl\
O\
Ol\
lO\
OOl
(
const
lOlOOOOO\
lOl
&
lll\
OOllOl\
O\

)
:
lOl\
OOOll\
lOO
(
ll\
lOOl\
lOlO\

)
{
}
__forcei\
nli\
n\
e
lO\
lOOO\
O\
OlOl
lOl\
OOlOlOOl
(
)
co\
nst\

{
__\
m12\
8
lOlOO\
lOl\
l\
OO
=
(
__m128
&
)
lOlO\
OO\
lllO\
O
;
lO\
lOOl\
OllO\
O
=
lOl\
OOlO\
lOl\
l
(
(
__\
m128
&
)
lOlO\
Ol\
O\
llOO\

,
(
__\
m\
12\
8\

&
)
lO\
l\
OO\
lO\
llOO
)
;
re\
tur\
n
(
lO\
l\
OOO\
OOl\
Ol
&
)
lOlOOlO\
llOO
;
}
__f\
orceinline
flo\
at
lOlOOl\
O\
lOlO
(
)
cons\
t
{
lOl\
OOOOOl\
Ol
lOl\
OOllOOOO\

=
lOlO\
OOlllOO\

;
#ifdef TA_SSE2
__m\
128
lOlO\
OlOl\
l\
OO
=
_m\
m_mul_\
p\
s
(
(
__m1\
28
&
)
lOlOOl\
lOOOO\

,
(
__m\
1\
28
&
)
lOl\
OOllOOOO
)
;
__m12\
8\

lO\
lO\
O\
lOllOl\

=
(
__m\
128
&
)
_mm_\
s\
h\
uffl\
e_\
epi32\

(
(
__m\
12\
8i
&
)
lO\
lOOl\
OllOO\

,
_MM_\
SHUFFL\
E
(
0
,
0
,
0
,
1
)
)
;
__m\
1\
28\

lOlOO\
lOl\
l\
ll
=
(
__m1\
28
&
)
_mm_s\
huff\
l\
e_ep\
i32\

(
(
__\
m128i
&
)
lOl\
O\
OlOllOO
,
_MM_SHUFF\
L\
E\

(
0
,
0
,
0
,
2
)
)
;
lOlO\
OlOll\
O\
l
=
_mm\
_a\
dd_ss
(
lOlOO\
lO\
llOl\

,
lO\
l\
OOlOll\
O\
O
)
;
lO\
l\
OOl\
O\
llOl
=
_mm_ad\
d_ss\

(
lOlOOl\
O\
l\
l\
Ol
,
lO\
lOOlOllll\

)
;
retu\
rn
(
(
lO\
l\
OO\
OOOlOl
&
)
lOlOO\
l\
Oll\
O\
l
)
.
x
;
#else
(
__m128
&
)
lO\
lOOl\
lOOOO
=
_mm_mul_\
ps
(
(
__m\
128
&
)
lOlO\
O\
llOOOO\

,
(
__m\
1\
28
&
)
lO\
l\
OOllO\
OOO
)
;
re\
t\
u\
r\
n
lO\
lOOllO\
OOO\

.
x
+
lOlOOl\
lOOOO
.
y
+
lOlO\
OllOOO\
O
.
z
;
#endif
}
__for\
cein\
l\
ine
operator
floa\
t
(
)
con\
st
{
re\
t\
urn
lOlOOlOlOl\
O
(
)
;
}
}
;
struct
lOlOOllOOlO\

:
pu\
blic\

lO\
l\
O\
OlOlO\
OO\

<
lOlOOllOOlO
>
{
const
lOlOO\
O\
O\
Ol\
O\
l
&
lOlOOOl\
l\
l\
OO
;
lO\
lO\
Oll\
O\
O\
l\
O
(
co\
nst
lOlO\
OOOOl\
Ol\

&
lllOO\
ll\
O\
lO
)
:
lOlOOO\
lllO\
O
(
lll\
OOllOlO
)
{
}
__\
for\
cein\
l\
i\
ne\

lOlOOOOOlOl\

lOl\
OOlOlOOl\

(
)
co\
n\
st
{
__m12\
8
lOlO\
Ol\
O\
ll\
OO
=
lO\
lO\
OlOlOll\

(
(
__\
m12\
8
&
)
lO\
l\
OO\
O\
lll\
OO
,
(
__m128
&
)
lOl\
OOOlllOO
)
;
ret\
urn
(
lO\
lOOOOOlOl
&
)
_mm\
_sqrt_ps\

(
lOlOO\
l\
OllOO
)
;
}
__\
fo\
rce\
inl\
i\
ne\

float\

lO\
lOOlOl\
OlO\

(
)
const
{
lO\
lOOOOOlO\
l
lOlOOllOOOO\

;
(
__m\
128
&
)
lOlOO\
ll\
OOOO\

=
_mm_mu\
l_\
ps
(
(
__m\
1\
2\
8
&
)
lOlO\
OOlll\
OO
,
(
__\
m1\
28
&
)
lOl\
O\
OO\
lllOO
)
;
re\
tu\
rn\

sq\
rtf\

(
lO\
lOOllOO\
OO
.
x
+
lOlOOllOOOO
.
y
+
lOl\
OOllOOOO
.
z
)
;
}
__\
f\
orce\
inl\
ine
opera\
to\
r\

fl\
o\
at
(
)
const
{
re\
tur\
n\

lOlO\
OlOlOlO
(
)
;
}
}
;
}
TA\
_ALI\
G\
N\
_16
stru\
ct
TACOMM\
ON_\
C\
LASS
Vec\
3
:
public
lOlOO\
OOOlOO
::
lOlO\
OO\
O\
OlOl
{
enum\

Axis
{
AX\
IS_X
=
0
,
AXIS_Y
,
AXIS_\
Z
,
}
;
__for\
ceinli\
ne
Ve\
c3
(
)
{
(
__m\
128
&
)
*
th\
is
=
_mm_s\
e\
t\
zer\
o_ps
(
)
;
}
__fo\
rceinli\
n\
e\

Vec3
(
int
lO\
lOOllOOll
)
{
}
__\
f\
orceinl\
ine\

Vec3
(
const
Vec3
&
llll\
OO\
Olll\

)
{
lOlOOlOOl\
l\
l
=
llllOO\
Olll\

.
lOlOOlOOl\
ll
;
}
__f\
o\
r\
ceinli\
ne
Ve\
c3\

(
floa\
t
lOlOOOlOOO\
l
,
float
lOlOO\
Ol\
OOll\

,
float
lOlO\
OOlOlOO
)
{
lO\
lOOlOOl\
l\
l\

=
_m\
m_setr_p\
s\

(
lOl\
OOOlOOOl
,
lOlO\
O\
Ol\
OOll\

,
lOlOOOlO\
l\
OO
,
0.0f
)
;
}
__f\
o\
r\
cein\
line
vo\
i\
d\

In\
itial\
i\
se
(
floa\
t
lOlO\
OO\
lOO\
Ol
,
float
lOlO\
OOl\
OOll
,
float
lOlOO\
O\
l\
O\
lOO
)
{
lOlO\
OlOO\
ll\
l
=
_m\
m_\
setr_p\
s
(
lOl\
OO\
Ol\
OO\
Ol\

,
lOlOO\
OlOOll\

,
lOlOOOlOlOO
,
0.0f
)
;
}
__forceinline\

ope\
ra\
t\
o\
r
float
*
(
)
{
ret\
urn
(
fl\
o\
at
*
)
&
x
;
}
__forceinli\
n\
e
op\
erator
const
flo\
a\
t
*
(
)
const
{
return\

(
float
*
)
&
x
;
}
__force\
inl\
ine\

float
&
ope\
rator
[
]
(
in\
t
lOO\
O\
lOOl\
ll
)
{
return
(
(
floa\
t
*
)
&
x
)
[
lO\
OOlO\
Olll\

]
;
}
__forceinline
const
flo\
at
&
op\
erator
[
]
(
int
lO\
OOlOOlll
)
const
{
re\
turn
(
(
flo\
at
*
)
&
x
)
[
lOO\
OlOOlll
]
;
}
__force\
inli\
ne
Ve\
c3
&
ope\
rator\

+=
(
cons\
t
Vec3
&
lll\
lOOOlll
)
{
(
__m\
128
&
)
(
*
this\

)
=
_m\
m_add_\
ps
(
(
__m12\
8
&
)
(
*
this
)
,
(
__\
m128
&
)
ll\
l\
lO\
O\
Olll
)
;
retur\
n
*
this
;
}
__fo\
rceinline\

Vec3
&
operator
-=
(
cons\
t
Vec\
3
&
ll\
llOOOlll
)
{
(
__m128
&
)
(
*
th\
is
)
=
_mm_su\
b_p\
s\

(
(
__\
m128
&
)
(
*
this\

)
,
(
__m128
&
)
lll\
l\
OOOlll\

)
;
return
*
this\

;
}
te\
mp\
l\
ate
<
cl\
ass\

Type
>
__for\
ceinline
co\
n\
st\

Vec3
&
oper\
at\
or
=
(
cons\
t
lOlOOOO\
OlOO
::
lOlOOlO\
lO\
OO
<
Type
>
&
lOlOOOlOOO\
O\

)
{
*
this
=
lO\
lOOOlOOOO\

.
lOlO\
OllOlOO
(
)
;
ret\
urn
*
this\

;
}
__for\
ceinline
con\
s\
t
Ve\
c\
3
&
operator
=
(
const
Vec3
&
lOlO\
OOlOOOO\

)
{
lOlOOl\
O\
Ol\
l\
l
=
lO\
lOOOlOOOO\

.
lOlOOl\
OOl\
ll\

;
return\

*
thi\
s\

;
}
__fo\
rce\
i\
nline\

Vec\
3
ope\
ra\
tor
+
(
)
const
{
retur\
n
*
this\

;
}
;
__fo\
rceinline
Vec3
op\
er\
at\
or
-
(
)
const
{
retur\
n
(
Vec\
3
&
)
_mm_su\
b\
_ps
(
_m\
m_setz\
ero\
_ps
(
)
,
lOlOOlOO\
lll\

)
;
}
;
__f\
orce\
in\
li\
ne
bo\
o\
l
ope\
ra\
t\
or
==
(
cons\
t
Vec3
&
llllO\
OOll\
l
)
const
{
re\
tu\
rn
x
==
lll\
l\
OOOlll
.
x
&&
y
==
lll\
lOO\
Olll
.
y
&&
z
==
llllOOOlll\

.
z
;
}
__\
f\
orce\
inline
bo\
ol
ope\
rator
!=
(
co\
ns\
t
Vec3\

&
ll\
l\
lOOOll\
l
)
co\
nst
{
ret\
u\
rn
x
!=
lll\
lOO\
Olll
.
x
||
y
!=
llllOOO\
l\
ll
.
y
||
z
!=
llllOOOl\
l\
l\

.
z
;
}
__\
forceinli\
n\
e
Vec3
Cr\
o\
s\
s
(
const
Vec3\

&
lll\
l\
OOOll\
l\

)
const
{
return\

Cr\
o\
ss
(
*
thi\
s
,
llllO\
OOll\
l
)
;
}
sta\
tic\

__f\
orce\
in\
l\
ine
Vec\
3
Cro\
ss
(
cons\
t
Vec3\

&
ll\
l\
llllll\

,
con\
st
Vec3
&
lOOOOOOOOO\

)
{
__\
m\
128
lOlO\
OlOllOO\

=
*
(
__m12\
8
*
)
&
lllllllll
;
__m128\

lOlOOl\
O\
l\
lOl
=
*
(
__m1\
28\

*
)
&
lO\
OOOOOO\
OO
;
__\
m\
1\
28
lOlOOllO\
l\
O\
l
=
lOlOOlOO\
llO
(
lOl\
OOlOl\
l\
O\
O
,
_MM_\
S\
HU\
FFL\
E\

(
3
,
0
,
2
,
1
)
)
;
__m1\
28
lO\
lO\
Oll\
OllO
=
lOlO\
OlOOl\
lO
(
lO\
l\
OOlOllOl
,
_MM_\
SH\
UFFLE
(
3
,
1
,
0
,
2
)
)
;
lOlO\
Oll\
O\
ll\
O
=
_mm_mul_ps
(
lOlO\
O\
ll\
O\
llO
,
lOlOOl\
lOl\
Ol\

)
;
__\
m\
1\
28\

lOlOOll\
Ol\
ll
=
lOlO\
OlO\
Oll\
O
(
lO\
lOOllOlOl\

,
_M\
M_S\
HUFFLE
(
3
,
0
,
2
,
1
)
)
;
__m128\

lO\
l\
O\
Ol\
ll\
OOO
=
lOlO\
OlOOl\
l\
O
(
lO\
l\
OOlOll\
Ol
,
_M\
M_\
SHUFFLE
(
3
,
0
,
2
,
1
)
)
;
lOl\
OOl\
lOlll\

=
_mm_mul_ps
(
lOlO\
OllO\
lll\

,
lOl\
O\
Oll\
lOO\
O
)
;
lOlOOllOl\
l\
O
=
_mm_sub\
_ps
(
lOlOO\
llOll\
O
,
lOlO\
Oll\
Olll
)
;
retu\
rn\

(
Vec3
&
)
lO\
lOOll\
OllO
;
}
st\
at\
ic
__\
force\
inline
Vec3
TA_VEC3_CALL\

Cros\
s\
Wit\
hUnitX\

(
co\
ns\
t\

Vec3
&
lll\
l\
OOOlll
)
{
retu\
rn
Ve\
c3\

(
0.0f
,
llllO\
OO\
lll
.
z
,
-
ll\
l\
l\
OOO\
l\
ll
.
y
)
;
}
__f\
orce\
i\
nline
Ve\
c3
CrossW\
ithU\
n\
itX
(
)
const
{
ret\
urn
CrossWit\
hUnitX
(
*
thi\
s\

)
;
}
static
__forceinline
Vec\
3\

TA_VEC\
3_CA\
L\
L
Cr\
os\
sW\
i\
th\
Un\
itY
(
const
Vec\
3\

&
llllOOOl\
l\
l
)
{
return
Ve\
c\
3
(
-
llllOO\
Ol\
l\
l
.
z
,
0.0f
,
llllOO\
Olll
.
x
)
;
}
__force\
in\
line\

Vec3\

CrossW\
ithUni\
tY
(
)
const
{
re\
t\
ur\
n
CrossWithUni\
tY
(
*
th\
is\

)
;
}
sta\
tic
__f\
o\
rc\
e\
inli\
n\
e
Ve\
c3
TA_VEC3\
_\
CALL
CrossW\
ith\
U\
n\
i\
tZ
(
const
Vec3
&
ll\
llOO\
Oll\
l
)
{
re\
turn
Ve\
c3
(
llllOO\
Ol\
ll
.
y
,
-
ll\
llOOOll\
l\

.
x
,
0.0f
)
;
}
__force\
inline
Vec3\

Cros\
sWit\
hUni\
tZ
(
)
cons\
t
{
re\
turn
Cro\
ssWi\
thU\
nitZ
(
*
th\
is
)
;
}
st\
atic
__forcein\
l\
i\
ne
fl\
oat\

TA_\
V\
EC\
3_\
CA\
LL
Cr\
ossX\

(
cons\
t
Vec3
&
lll\
llllll
,
co\
nst
Vec3
&
lOOOOOO\
OO\
O
)
{
ret\
u\
rn
ll\
ll\
lll\
ll
.
y
*
lOO\
OOOOOOO\

.
z
-
lllllllll\

.
z
*
lO\
O\
OOOOOOO
.
y
;
}
__\
forcei\
nl\
ine
float
Cr\
os\
sX\

(
co\
ns\
t
Ve\
c3
&
llllOOOlll
)
const
{
re\
turn\

Cros\
sX
(
*
this
,
lll\
lOO\
Ol\
ll
)
;
}
st\
atic
__forceinl\
ine
float
TA_V\
EC\
3_C\
ALL
Cr\
o\
ssY
(
const
Vec\
3
&
lllllllll
,
co\
n\
st
Vec3\

&
lOOO\
OOOOOO
)
{
ret\
urn
llllllll\
l
.
z
*
lOO\
OOO\
OO\
OO\

.
x
-
llllllll\
l
.
x
*
lOOOO\
OOOO\
O
.
z
;
}
__forceinl\
ine
float\

Cros\
s\
Y\

(
con\
st
Ve\
c3\

&
llllOOOlll\

)
cons\
t
{
retu\
rn
Cross\
Y
(
*
this
,
llllOOOlll
)
;
}
stati\
c
__fo\
rce\
i\
nline\

float
TA_VEC3_CALL
CrossZ
(
const
Ve\
c3
&
ll\
ll\
l\
lll\
l
,
cons\
t
Vec3
&
lOOOO\
OOOOO
)
{
return
llllllll\
l
.
x
*
lO\
OO\
O\
OOOOO\

.
y
-
lllllll\
l\
l
.
y
*
lOOOOOOOOO
.
x
;
}
__forceinl\
ine
float
Cross\
Z\

(
cons\
t
Vec\
3\

&
lll\
lOOOl\
ll\

)
co\
ns\
t
{
ret\
urn
Cr\
o\
s\
sZ
(
*
thi\
s
,
lll\
l\
OO\
O\
lll\

)
;
}
st\
ati\
c\

__\
forceinline\

lOl\
OOO\
O\
O\
lOO
::
lOl\
OO\
lOlllO
TA_VEC3_CALL
Dot
(
con\
s\
t
Vec3
&
lllll\
llll
,
con\
st
Vec3
&
lO\
OO\
O\
O\
OO\
OO
)
{
re\
tu\
rn
lO\
lOOOOOlO\
O
::
lOlOOl\
Ol\
l\
lO
(
lllllllll\

,
lOO\
OOOOOOO\

)
;
}
__for\
ce\
i\
nline
lOlO\
OOOOlOO
::
lOl\
O\
OlOlllO
Dot
(
co\
nst\

Ve\
c3
&
llllO\
OOlll
)
const
{
re\
turn
lOl\
OOOOO\
lO\
O\

::
lOlOO\
lOlllO\

(
*
this
,
lll\
l\
OOOll\
l
)
;
}
static
__for\
cein\
lin\
e\

Vec\
3\

TA_\
VE\
C\
3_C\
AL\
L
Min
(
con\
st
Vec3\

&
llllllll\
l\

,
cons\
t
Vec3\

&
lOOOO\
OOOO\
O
)
{
re\
t\
urn
(
Vec3\

&
)
_m\
m_\
m\
in_ps
(
(
__m128\

&
)
lll\
ll\
ll\
ll\

,
(
__m1\
2\
8
&
)
lO\
OOOOOOOO
)
;
}
sta\
t\
ic
__f\
orc\
ei\
nline
Vec3\

TA\
_VEC3_CAL\
L
Max
(
const
Vec3
&
lllll\
lll\
l
,
const\

Vec\
3
&
lO\
O\
OO\
OOOOO
)
{
retu\
r\
n\

(
Ve\
c\
3\

&
)
_mm_max\
_ps
(
(
__m\
128\

&
)
llllll\
lll
,
(
__m\
1\
28
&
)
lOO\
OOOOOOO\

)
;
}
static
__f\
orceinline
lO\
l\
OOO\
O\
OlOO
::
lOlOO\
llOOl\
O
TA_VEC3\
_\
C\
AL\
L
GetMa\
g\
nit\
u\
de
(
const\

Vec\
3\

&
llllO\
O\
O\
l\
ll
)
{
re\
turn\

lO\
lO\
OOOOlOO\

::
lOlOOl\
l\
OOlO\

(
llllOOOl\
l\
l
)
;
}
__\
for\
ceinl\
ine
lOlOO\
OO\
O\
lO\
O
::
lOlO\
OllOOlO\

Ge\
tM\
ag\
n\
it\
ude
(
)
con\
s\
t
{
retur\
n
lOl\
OOOO\
OlOO
::
lOlOOll\
OOlO\

(
*
thi\
s
)
;
}
sta\
tic
__forc\
e\
i\
n\
li\
ne\

lO\
l\
O\
O\
OOOlO\
O
::
lO\
lOOllOOOl\

TA_VEC3\
_\
CAL\
L
GetM\
a\
g\
n\
i\
t\
udeSq\
rd\

(
const
Vec\
3
&
llllOO\
Oll\
l
)
{
ret\
urn
lOl\
OOOOOlOO\

::
lO\
lO\
OllOOOl
(
llllOOOlll
)
;
}
__forc\
ei\
nline\

lOlOOO\
OO\
lOO\

::
lOlOO\
l\
lO\
O\
Ol
GetMagni\
tude\
S\
q\
rd\

(
)
const
{
ret\
ur\
n
lOlOOO\
OO\
l\
O\
O
::
lOlO\
Ol\
lOOOl
(
*
thi\
s
)
;
}
stat\
ic
__forceinline
Vec3\

TA\
_VEC3\
_\
CALL
Get\
Norm\
al
(
const
Vec\
3\

&
ll\
l\
l\
OOOlll
)
{
re\
turn
llllO\
OOlll\

.
GetNorm\
al\

(
)
;
}
__\
forcein\
li\
ne
Vec3
Ge\
tN\
or\
mal\

(
)
const\

{
__m\
12\
8
lOl\
O\
OlllO\
O\
l
=
lOl\
OOlOOl\
ll
;
__m\
128\

lOlOO\
lOllOO
=
_m\
m_mu\
l\
_\
ps\

(
lOlOOlllOOl
,
lOlOOlllOO\
l
)
;
__m1\
2\
8
lOlOOlOllO\
l
=
lOlO\
OlO\
Ol\
l\
O
(
lOl\
O\
OlOl\
lOO
,
_MM_\
SHUF\
FL\
E\

(
3
,
3
,
3
,
1
)
)
;
__m12\
8
lOlOOlO\
llll
=
lO\
l\
OO\
l\
OO\
llO
(
lOlOOl\
OllO\
O
,
_MM_\
SHUFF\
LE
(
3
,
3
,
3
,
2
)
)
;
lOlO\
Ol\
OllOO
=
_mm_\
add_ss
(
lOlO\
OlO\
llOO
,
lO\
lOOlOllOl
)
;
lO\
lOO\
lOllOO
=
_m\
m_ad\
d_s\
s
(
lOl\
OOl\
OllOO\

,
lOl\
O\
O\
lO\
llll
)
;
lOlOOlO\
llOO
=
_mm_\
rsq\
rt_ss
(
lOlOOlOll\
O\
O\

)
;
lOlO\
O\
lO\
llOO
=
lOlOOlO\
OllO
(
lOlOOlOllOO\

,
_M\
M_\
S\
HUFF\
L\
E\

(
0
,
0
,
0
,
0
)
)
;
lO\
lOO\
lll\
OOl\

=
_m\
m_mul_\
ps
(
lOl\
O\
O\
ll\
l\
OOl
,
lOlOO\
l\
Oll\
OO\

)
;
return\

(
Ve\
c\
3
&
)
lOlOOlll\
O\
O\
l
;
}
__\
forc\
e\
inline
void
Norm\
ali\
se
(
)
{
__\
m128
lOlOOl\
llOOl
=
lOlOOl\
O\
Olll
;
__m1\
28
lOlO\
O\
l\
OllOO
=
_mm_mul_ps
(
lOlOOlllOOl
,
lO\
lO\
Oll\
lOO\
l\

)
;
__m1\
28
lOlOOl\
OllOl
=
lO\
lOOl\
O\
OllO
(
lOlO\
OlO\
llOO
,
_MM_S\
HUFF\
LE
(
3
,
3
,
3
,
1
)
)
;
__m128
lO\
lOOlO\
l\
lll
=
lOlOOlOOll\
O\

(
lOlO\
OlOllOO
,
_MM_SHUFF\
LE
(
3
,
3
,
3
,
2
)
)
;
lOlO\
OlOllOO
=
_m\
m\
_add_\
ss
(
lO\
lO\
Ol\
Oll\
OO
,
lOlO\
OlOllOl
)
;
lOlOOlO\
l\
lO\
O
=
_mm\
_add_ss
(
lO\
lOO\
lO\
l\
l\
O\
O\

,
lOl\
O\
OlOl\
lll
)
;
lO\
lOOlOl\
lO\
O
=
_mm_\
rs\
qrt_ss
(
lOlOOlO\
l\
lOO
)
;
lOl\
OOlO\
llO\
O
=
lOlO\
OlOO\
llO
(
lOlO\
O\
l\
O\
ll\
OO\

,
_MM_SHUFFL\
E\

(
0
,
0
,
0
,
0
)
)
;
lOl\
OOll\
lOOl\

=
_m\
m_m\
ul_ps\

(
lOlOOl\
llOOl
,
lO\
lOOlO\
llOO
)
;
lO\
lOO\
l\
OOll\
l\

=
lOlOOll\
lOO\
l
;
}
__fo\
r\
ceinline
void\

Cl\
e\
ar
(
)
{
(
__\
m12\
8\

&
)
*
this
=
_mm\
_\
setz\
ero\
_ps\

(
)
;
}
__\
forc\
einli\
ne
bool
IsNo\
rma\
li\
se\
d
(
)
con\
st
{
flo\
at
lOllllOOl\
l
=
GetMagn\
it\
u\
de\
Sqrd
(
)
;
re\
t\
u\
rn\

Is\
E\
qu\
alToOneWithInError
(
lOl\
lllOOl\
l
)
;
}
__fo\
r\
cei\
nlin\
e
bool
Is\
Zer\
o
(
)
cons\
t\

{
re\
turn
GetMagn\
itudeSqrd
(
)
==
0.0f
;
}
__forceinl\
i\
n\
e\

in\
t
Ge\
tGre\
a\
test\
A\
xis\

(
)
co\
nst
;
__forceinl\
ine
float
Get\
M\
ax
(
)
const
{
ret\
ur\
n
TA
::
Max
(
TA
::
Max
(
x
,
y
)
,
z
)
;
}
__\
force\
inline
float
Get\
Mi\
n
(
)
con\
st
{
return
TA
::
Min
(
TA
::
Mi\
n
(
x
,
y
)
,
z
)
;
}
__forc\
e\
inline\

vo\
id
GetAx\
i\
sOrde\
r\

(
int
llllO\
O\
lOOl
[
3
]
)
con\
s\
t\

;
__forceinline
flo\
at
Ge\
tAxis
(
int
lOOOlOOl\
ll
)
co\
n\
st
{
return\

(
*
th\
is
)
[
lOOOlOOlll
]
;
}
__for\
c\
ein\
line
static
const
Ve\
c3\

&
TA\
_V\
EC3_C\
ALL
GetUnit\
V\
e\
ctor
(
int\

lO\
OOlOO\
lll\

)
;
inline
bool
IsEqu\
a\
l\
With\
InError\

(
co\
nst
Vec3\

&
llllO\
O\
Olll\

,
float
llOllOlllO
)
const\

;
inline
bo\
ol\

IsV\
alid
(
)
con\
st
{
return
Float\
Is\
OK\

(
x
)
&&
Fl\
oatIsOK\

(
y
)
&&
Flo\
at\
IsOK\

(
z
)
;
}
}
;
cons\
t
Vec3
k_v\
3Z\
e\
ro
(
0.0f
,
0.0f
,
0.0f
)
;
cons\
t
Ve\
c3
k_v3U\
nitX
(
1.0f
,
0.0f
,
0.0f
)
;
const
Vec\
3
k_v3Unit\
Y
(
0.0f
,
1.0f
,
0.0f
)
;
co\
n\
st
Vec3
k_v3\
UnitZ
(
0.0f
,
0.0f
,
1.0f
)
;
}
#include "../Common/zcta013.inl"
#endif //
