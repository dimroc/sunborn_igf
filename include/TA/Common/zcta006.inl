//---------------------------------------------------------------------------------
// File Name: zcta006.inl
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#ifndef TA_MEMORYMGR_H
#include "MemoryMgr.h"
#endif //
namespace
TA
{
te\
mplate
<
class
Ty\
pe
,
bo\
ol
lOOOlllllOl\

>
lOlOl\
llOOO
<
Typ\
e
,
lOO\
OlllllOl
>
::
lOlOlllOOO
(
)
{
lOlOOO\
lOOl
=
0
;
lOOlO\
O\
lOllO
.
lOOlO\
OlOlOl
=
0
;
lOOlO\
OlOllO\

.
lO\
O\
OOOOl\
lll
=
0
;
}
tem\
pl\
ate
<
class
Type\

,
bool
lOOOlllll\
Ol\

>
lOlOl\
llOOO
<
Type\

,
lOOOlll\
llOl
>
::
~
lOlOll\
lOO\
O
(
)
{
Fi\
na\
lise\

(
)
;
}
template
<
cl\
ass
Type
,
bool
lOOOllll\
l\
O\
l\

>
voi\
d
lOlO\
lll\
OOO\

<
Type
,
lOOO\
lllll\
Ol
>
::
Initia\
l\
ise
(
in\
t
lOO\
ll\
lOllO\

)
{
if
(
lOOlOO\
lO\
llO
.
lOOlO\
O\
lOlOl
)
{
lO\
O\
OOOOllO
(
0
,
"Pool::Initialise. Already initialised.")
;
Fi\
na\
lise
(
)
;
}
lO\
lOOOlOOl
=
lOOlllOllO
;
lOOOll\
ll\
O\
O
(
lO\
OlOOlOllO
.
lO\
O\
lOO\
l\
OlOl
,
lO\
OllOOO\
O\
O\

,
lO\
lOO\
OlOOl\

)
;
TA_ASSE\
RT\

(
lOOlOOlOl\
l\
O\

.
lOOlOO\
l\
OlOl
)
;
lOOl\
OOl\
O\
llO
.
lOO\
OOOOllll\

=
0
;
for
(
in\
t
lOOlO\
OllOOO
=
0
;
lOOl\
OOll\
OOO
<
lO\
OlllOll\
O\

;
lOO\
lOO\
llOOO
++
)
{
#ifdef _DEBUG
lOO\
lOOlOllO
.
lOO\
l\
OOlOl\
Ol
[
lO\
O\
lOOl\
lOOO
]
.
lO\
OOO\
OO\
ll\
ll
=
0
;
lOOl\
OO\
lOllO
.
lO\
Ol\
O\
OlO\
l\
Ol
[
lOO\
lO\
Oll\
OOO
]
.
lOOlOOOO\
OOO\

=
0
;
#endif //
lO\
OlOO\
l\
Olll
.
lO\
lOlOOO\
O\
l\

(
&
lOO\
lOOlOllO
.
lOOlOO\
lOlOl
[
lOOlOOllOOO
]
.
lOOO\
O\
OlOOO\
O\

)
;
}
}
tem\
p\
la\
te
<
class
Ty\
pe
,
boo\
l\

lOOOll\
ll\
lOl\

>
void
lOl\
Oll\
lOOO\

<
Type\

,
lOOOl\
llll\
Ol
>
::
Fina\
lise
(
)
{
lOO\
lO\
Ol\
Ol\
ll
.
Finali\
se
(
)
;
fo\
r
(
lOOl\
OO\
lOlO\
O
*
lOOlOO\
llOOl\

=
&
lOOlOOl\
OllO
;
lOOlOOl\
l\
O\
O\
l
;
)
{
lOO\
l\
OOlO\
lOO\

*
lOOlOOll\
Ol\
O\

=
lOOlO\
Oll\
O\
Ol
->
lOO\
OOOOl\
lll
;
if
(
lOO\
lOO\
llOO\
l\

->
lO\
OlO\
Ol\
OlOl\

)
{
lO\
lOOOlllO
(
lO\
OlOOllOOl\

->
lOOl\
OOl\
O\
l\
Ol
,
lOOllO\
O\
OOO
)
;
lO\
Ol\
OOll\
OO\
l
->
lO\
OlOO\
l\
O\
lOl
=
0
;
lOOl\
O\
Oll\
OOl\

->
lOOOO\
OOlll\
l
=
0
;
}
if
(
lOO\
l\
O\
OllOOl
!=
&
lOOlO\
Ol\
O\
llO
)
{
lOOl\
OOOOOO\

(
lOOlO\
Ol\
l\
OOl
,
lO\
OlOOlOlOO
)
;
}
lOOlOOl\
lOOl
=
lOO\
lOO\
llO\
l\
O\

;
}
lO\
lOOOl\
OO\
l
=
0
;
}
templ\
at\
e
<
class
Ty\
pe\

,
bool
lOOOl\
llllOl
>
bool
lOlO\
ll\
lOO\
O
<
Typ\
e\

,
lO\
OOlllllO\
l
>
::
lOOlOOlOOOl
(
)
{
re\
tur\
n\

lOOlOOlOl\
lO
.
lOO\
lOOlOlOl
!=
0
;
}
template
<
class
Type
,
bool
lOO\
Ollll\
l\
Ol
>
Type
*
lO\
lO\
lllOOO\

<
Type
,
lOOOlllllOl
>
::
Al\
loc
(
)
{
lO\
Oll\
OOO\
OO
*
lO\
O\
lll\
OOOl
=
lOOlOOlOl\
ll
.
lOOlOO\
Oll\
lO
(
)
;
if\

(
!
lOOl\
llOOOl
)
{
if\

(
!
lO\
OOlll\
ll\
Ol
)
re\
turn
0
;
lOOlOOl\
OlO\
O\

*
lOOlOOll\
Oll\

=
&
lO\
OlOOlOll\
O
;
TA_\
ASSERT
(
lOOlOOllO\
ll
)
;
while
(
lOO\
l\
OO\
llOl\
l
->
lOO\
OOOO\
l\
ll\
l
)
lOOlO\
OllOll
=
lOOlOOll\
Ol\
l
->
lOOOOOOllll\

;
lOOlO\
O\
lOl\
OO
*
lO\
O\
lOO\
llOOl
;
lOOO\
OOllOOO
(
lOOlOOllOOl
,
lOOl\
OOlOlOO
)
;
lOOOlll\
lOO
(
lO\
Ol\
O\
Ol\
lOOl
->
lOOlOOlOlOl\

,
lOOl\
lOOOO\
O
,
lOlOO\
O\
l\
O\
Ol
)
;
TA\
_A\
SSE\
RT
(
lO\
lOOOlOOl
>
0
)
;
TA\
_ASSERT
(
lOOlOOl\
lOOl\

->
lOOlOO\
lOlOl
)
;
lOOlOOllOOl\

->
lOOO\
OOOl\
l\
l\
l
=
0
;
lOO\
lOOllOll
->
lOOO\
OO\
Ollll\

=
lOOlOOll\
OOl
;
fo\
r
(
in\
t
lOOlOOllO\
O\
O
=
0
;
lOOlOOllOOO\

<
lOlOOOl\
OOl
;
lO\
OlO\
OllOOO
++
)
{
#ifdef _DEBUG
lOO\
l\
OOllO\
Ol
->
lOOl\
OO\
lO\
lO\
l
[
lO\
OlOOll\
OOO
]
.
lO\
OOOO\
O\
lll\
l
=
0
;
lOO\
lOOllOOl\

->
lOO\
lO\
O\
lO\
l\
Ol
[
lOOlOO\
llOO\
O\

]
.
lOOl\
OOOO\
O\
OO
=
0
;
#endif //
lOOlO\
Ol\
Olll
.
lO\
lOlO\
OOOl
(
&
lOOlOO\
llOOl\

->
lOO\
lOO\
lOlOl\

[
lO\
OlOOllOO\
O
]
.
lOO\
OOOl\
O\
OOO
)
;
}
lOl\
OOO\
l\
O\
Ol
<<=
1
;
lOO\
lllO\
OOl
=
lOO\
lOO\
lOlll
.
lOO\
l\
O\
O\
O\
lllO
(
)
;
}
lOOlO\
Ol\
Olll\

.
lOO\
l\
llllll
(
&
lOOll\
l\
OOO\
l
->
lO\
O\
OOO\
lO\
O\
OO\

)
;
re\
t\
urn\

&
lOOl\
llOOOl
->
lOOOO\
Ol\
OOOO
;
}
tem\
pl\
ate\

<
clas\
s\

Ty\
pe
,
bool\

lOOO\
lllll\
O\
l
>
void
lOlOlllOOO\

<
Type
,
lO\
O\
OlllllO\
l
>
::
Free
(
Typ\
e
*
lO\
Oll\
lOOOl
)
{
lOO\
l\
O\
Ol\
O\
lll
.
lOlOlOOOOl
(
lOOlllOOOl
)
;
}
temp\
late
<
cl\
ass
Type
,
boo\
l\

lOOOlllllOl
>
vo\
id
lOlOlllOOO
<
Typ\
e
,
lOOOl\
llllOl
>
::
llOlOl\
OOO\
l\

(
lOl\
OlllOOl
&
lOOlOOOl\
O\
OO\

)
{
typenam\
e\

lOlOlll\
OO\
l
::
Iterat\
o\
r\

lOlOOlOOlO
=
lOO\
lO\
OO\
l\
O\
OO
.
lOl\
OOOOl\
OO
(
)
;
whil\
e\

(
!
lOlOOl\
OOlO\

.
AtEnd
(
)
)
{
Type
&
lOO\
lOO\
ll\
l\
OO
=
*
lO\
lO\
OlOO\
lO
;
++
lOlOOlOOlO
;
lO\
OlOOO\
lOOO
.
lOOllllll\
l
(
&
lO\
O\
l\
OOlll\
OO
)
;
Free
(
&
lOOl\
O\
OlllOO\

)
;
}
}
temp\
late
<
cla\
ss
Type
,
bool\

lOOOlllllOl
>
int
lOl\
Oll\
lOOO
<
Type\

,
lOOOlllllO\
l\

>
::
lOOlOOl\
OO\
l\
O
(
)
{
retur\
n\

lOOlOOlOl\
ll
.
lOOO\
ll\
lOOl
(
)
;
}
template
<
clas\
s
Type
,
bool
lOOOl\
lll\
lOl\

>
bo\
ol
lOlOlllO\
O\
O
<
Type
,
lO\
OOllll\
lOl
>
::
lO\
OlOO\
lOOll\

(
)
{
if\

(
lOOOllll\
lOl
)
return
true
;
re\
tu\
rn
!
lOOlOOlOll\
l
.
lOlOO\
OOlOO
(
)
.
AtEnd\

(
)
;
}
tem\
plate
<
class
Type
,
bo\
ol
lOOOlllllOl\

>
in\
t
lOlOlll\
OOO
<
Type
,
lOOO\
lll\
ll\
Ol\

>
::
lO\
OOlllO\
Ol\

(
)
{
retur\
n
lOlOOOlOOl
;
}
}
