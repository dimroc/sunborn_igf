//---------------------------------------------------------------------------------
// File Name: zcta013.inl
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

namespace
TA
{
__force\
inl\
in\
e\

Vec3\

TA_V\
EC3_\
CALL
operato\
r
*
(
const
Ve\
c\
3
&
lllllllll
,
con\
st
Vec3
&
lOOOOOO\
OOO
)
{
return
(
Vec\
3
&
)
_mm_mul\
_\
ps
(
(
__\
m1\
28
&
)
ll\
lll\
llll\

,
(
__\
m128\

&
)
lOOOOOOOOO\

)
;
}
__f\
orceinl\
ine\

Ve\
c\
3
TA_V\
EC3_CALL
oper\
a\
tor\

*
(
float
lllOll\
ll\
ll\

,
co\
nst
Vec3
&
lO\
OOOOO\
OOO
)
{
Ve\
c3
lO\
O\
OOll\
O\
lO\
l\

=
lO\
OOOOO\
OOO\

;
__m12\
8
lOl\
O\
Ol\
l\
lOlO\

=
_mm_s\
e\
t_ps1
(
lll\
Oll\
l\
ll\
l
)
;
(
__\
m12\
8
&
)
lOOOO\
ll\
O\
lOl\

=
_mm_mul_\
p\
s
(
(
__m128
&
)
lOO\
OOll\
OlO\
l\

,
lO\
l\
OOlllO\
lO\

)
;
retur\
n
lOOOO\
llOlOl
;
}
__f\
orceinline\

Ve\
c3
TA_\
VEC3\
_CALL
ope\
rat\
or\

*
(
const
Vec\
3\

&
lOOO\
OOOOOO
,
fl\
oat\

lllOlllll\
l
)
{
Vec3
lOO\
OO\
llO\
lOl\

=
lOOO\
OOOOOO
;
__m\
128
lO\
l\
OOl\
ll\
O\
lO\

=
_m\
m_set1_ps\

(
lllOllll\
ll
)
;
(
__m128\

&
)
lOOOOll\
O\
lO\
l
=
_mm_\
mul_ps
(
(
__\
m128
&
)
lO\
O\
O\
OllOlOl\

,
lOl\
OO\
lllOlO
)
;
retur\
n\

lOOOOl\
lOl\
Ol
;
}
template\

<
cl\
as\
s
lO\
lOO\
OOll\
lO
,
cla\
ss
lO\
lO\
OOOl\
lll
>
__for\
ceinli\
ne
float
TA_VEC3_CAL\
L\

operator
*
(
co\
nst
lOlOO\
OOOlOO\

::
lOl\
O\
OlO\
lOOO\

<
lO\
lO\
OOOlllO\

>
&
lOlOO\
lllOll
,
const
lOlOOOOOlOO\

::
lO\
lOOl\
O\
lOOO
<
lOlOO\
OOll\
ll
>
&
lO\
l\
O\
Ol\
lllO\
O\

)
{
retur\
n\

(
(
Vec\
3
&
)
lOlO\
Ol\
llOll\

.
lOlO\
OlOlOOl\

(
)
*
(
Vec\
3
&
)
lOlOOllll\
OO
.
lOl\
OOlO\
lOOl
(
)
)
.
x
;
}
te\
mpl\
a\
te
<
cl\
a\
ss\

Typ\
e
>
__f\
or\
cein\
line\

fl\
oat
TA_VEC3_CALL
operator\

*
(
flo\
at
lllO\
ll\
l\
ll\
l
,
cons\
t
lOlOOO\
OO\
lOO\

::
lOl\
OOlOlOOO
<
Type
>
&
lOlOOllllOO\

)
{
return\

lllOll\
ll\
ll\

*
lOlOOllllO\
O\

.
lOlOOlOl\
O\
lO
(
)
;
}
te\
mplate
<
class\

Type
>
__forcein\
li\
n\
e
flo\
at\

TA_VEC\
3_\
CALL\

operator\

*
(
cons\
t
lOl\
OOOOOlO\
O\

::
lOlOOlOlOO\
O\

<
Typ\
e
>
&
lOlO\
OllllOO
,
fl\
oat
lll\
Olllll\
l
)
{
return\

lOlO\
Ollll\
OO
.
lOl\
OOlO\
lOl\
O
(
)
*
ll\
lOll\
ll\
l\
l
;
}
temp\
l\
ate
<
cl\
ass
Typ\
e
>
__f\
or\
ce\
i\
nlin\
e
Vec3\

TA_VEC3\
_C\
ALL\

op\
erator
*
(
cons\
t
Vec\
3
&
lllllll\
ll
,
const
lOlO\
OO\
OO\
lOO\

::
lOl\
OOlOlOOO\

<
Type
>
&
lOlOOllll\
O\
O\

)
{
retu\
r\
n
ll\
llll\
l\
ll
*
(
Vec3
&
)
lOlOO\
llllOO
.
lOl\
OOlOlO\
O\
l
(
)
;
}
temp\
late\

<
cla\
ss
Type
>
__fo\
rceinline
Vec3
TA_\
V\
EC3_CALL
op\
erator
*
(
con\
st
lO\
lO\
OOO\
Ol\
OO
::
lOlO\
OlOlO\
OO\

<
Ty\
pe
>
&
lO\
l\
OO\
llllOO\

,
co\
nst\

Ve\
c\
3
&
lllllllll
)
{
ret\
ur\
n
(
Ve\
c\
3
&
)
lOl\
O\
Ol\
ll\
l\
OO
.
lO\
lOO\
lOlOOl
(
)
*
lllll\
lll\
l
;
}
__fo\
rceinline
Vec3
TA_\
VEC3_CAL\
L\

operator
/
(
con\
st
Vec3\

&
llll\
lll\
ll
,
co\
ns\
t
Vec3
&
lOO\
OOO\
OOO\
O
)
{
ret\
urn
(
Vec3
&
)
_mm_div_ps
(
(
__\
m128
&
)
ll\
lll\
ll\
l\
l
,
(
__m128
&
)
lOO\
OOOOOOO\

)
;
}
__forcei\
n\
line
Ve\
c3
TA_\
VEC3_\
CA\
L\
L
ope\
ra\
to\
r\

/
(
co\
nst
Vec3
&
lO\
OOOOOOOO\

,
float\

ll\
lOlll\
ll\
l
)
{
Ve\
c3
lOO\
O\
Oll\
O\
lOl\

=
lO\
OOOOOOOO
;
__\
m1\
28
lO\
lOOl\
ll\
Ol\
O
=
_m\
m_set\
_ps\
1\

(
lllOll\
llll
)
;
(
__m\
128
&
)
lOOOOl\
lOl\
Ol
=
_mm_div_ps
(
(
__m12\
8
&
)
lOO\
OO\
llOl\
Ol
,
lO\
lOOl\
llOlO
)
;
return
lO\
OOOllOl\
Ol
;
}
template
<
class
lO\
lOOOOll\
lO
,
cl\
ass
lOlO\
OOOllll
>
__forceinline
fl\
oat
TA_\
V\
EC3_CA\
LL
opera\
t\
or\

/
(
cons\
t\

lO\
lOOOO\
OlOO\

::
lO\
lOO\
lO\
lOOO
<
lO\
lOOOOlllO
>
&
lO\
l\
O\
Olll\
Oll\

,
const
lOlOOOO\
O\
lOO
::
lO\
lO\
Ol\
OlOOO
<
lO\
lOOOOl\
ll\
l
>
&
lOlOO\
llllOO\

)
{
return\

(
(
Ve\
c3
&
)
lO\
lO\
O\
lll\
Oll
.
lO\
l\
OOlOlOO\
l
(
)
/
(
Vec3
&
)
lOl\
OOll\
ll\
O\
O
.
lOlOOlOlOOl\

(
)
)
.
x
;
}
templ\
at\
e\

<
clas\
s
Type
>
__\
force\
in\
l\
in\
e
float\

TA_VE\
C\
3_CA\
LL
oper\
a\
tor
/
(
fl\
oa\
t
lll\
Olllll\
l
,
const\

lOlO\
O\
OOOl\
OO
::
lOlOOl\
OlO\
OO\

<
Ty\
pe
>
&
lOl\
OOl\
l\
llOO\

)
{
re\
turn
lllO\
l\
llll\
l\

/
lOlOOllllOO
.
lOl\
OOl\
OlO\
lO
(
)
;
}
templat\
e
<
cla\
ss\

Type
>
__for\
c\
e\
in\
line\

flo\
a\
t
TA_\
V\
EC3_CALL\

ope\
rator
/
(
con\
st
lOl\
OOOOOlOO\

::
lOlO\
O\
lOlOOO
<
Type\

>
&
lOlOO\
l\
lllOO
,
float
lllOl\
lllll
)
{
return\

ll\
lOlll\
l\
l\
l
/
lOlOOl\
l\
llOO
.
lOlO\
OlOlOlO
(
)
;
}
template
<
class\

Type
>
__\
forcein\
line
Vec\
3
TA_VEC3\
_CALL
oper\
ato\
r
/
(
co\
ns\
t\

Vec3\

&
lllllll\
l\
l\

,
co\
nst
lO\
l\
OOOOOl\
OO
::
lOl\
OOlOlO\
OO
<
Typ\
e
>
&
lO\
lOOl\
lllOO
)
{
return\

lll\
ll\
llll\

/
(
Ve\
c3\

&
)
lO\
l\
O\
O\
ll\
llOO\

.
lOlO\
OlOlOOl
(
)
;
}
te\
m\
plate\

<
clas\
s
Ty\
pe
>
__f\
orc\
einline\

Vec\
3\

TA_VEC3_CALL
operat\
or
/
(
cons\
t\

lOlOOOOOl\
O\
O
::
lOlOO\
lO\
lOOO
<
Type
>
&
lOlOOllll\
OO
,
const\

Vec3
&
lllllllll\

)
{
retur\
n
lll\
ll\
ll\
l\
l\

/
(
Ve\
c\
3
&
)
lOl\
O\
Oll\
llO\
O\

.
lOl\
OOlO\
lOO\
l
(
)
;
}
__fo\
r\
ceinl\
in\
e\

Vec3
TA_VEC3\
_\
CALL
oper\
ator
+
(
con\
s\
t\

Vec\
3\

&
lllllllll
,
con\
s\
t
Ve\
c3
&
lOOOO\
OO\
OOO\

)
{
Vec3
lOlOOllOOO\
O
;
(
__m12\
8
&
)
lOlOOl\
l\
OOOO\

=
_m\
m_add\
_\
ps
(
(
__m128
&
)
llllllll\
l
,
(
__m1\
28
&
)
lOOOOO\
OOO\
O
)
;
retur\
n
lOlOOll\
OOOO
;
}
__\
f\
o\
rcein\
l\
ine\

Vec3
TA_V\
E\
C\
3_\
CALL
op\
erator
-
(
const
Vec\
3
&
ll\
lllll\
ll
,
con\
st
Vec3
&
lOO\
O\
OOO\
OOO
)
{
Ve\
c3
lO\
lO\
Oll\
O\
OOO
;
(
__m128
&
)
lO\
lOOl\
l\
OOOO
=
_mm_su\
b_ps\

(
(
__\
m128
&
)
lllllllll\

,
(
__m128
&
)
lOOOO\
OO\
OO\
O
)
;
retur\
n
lO\
lOOllOO\
O\
O
;
}
__forc\
einl\
ine
Vec3\

&
TA_VEC3_CAL\
L\

operator
*=
(
Vec3\

&
ll\
ll\
lllll
,
float
lll\
l\
OOOO\
OO
)
{
__\
m128\

lOlO\
OlllOlO
=
_m\
m_\
set_ps\
1
(
llllO\
OOOOO\

)
;
lll\
llllll\

=
(
Ve\
c3
&
)
_m\
m\
_\
m\
ul_p\
s\

(
(
__m1\
28\

&
)
ll\
llll\
lll\

,
lOl\
OOl\
llOlO
)
;
ret\
ur\
n
ll\
lll\
l\
lll\

;
}
template\

<
cl\
ass\

Ty\
p\
e
>
__f\
orc\
ei\
nli\
n\
e
Ve\
c3
&
TA_VE\
C3_CALL
operator
*=
(
Vec3
&
lllll\
lll\
l
,
cons\
t
lOlOOO\
OOl\
OO
::
lOlOOlOlOOO
<
Type
>
&
lO\
lOOl\
lllOO
)
{
ll\
lllll\
ll
=
(
Ve\
c3
&
)
_mm_mul_ps
(
(
__m1\
28\

&
)
ll\
ll\
lllll
,
(
__m128
&
)
lOlOOlll\
lOO
.
lOlOOlOlOOl
(
)
)
;
re\
turn
lllll\
l\
lll\

;
}
__fo\
r\
cei\
n\
li\
ne
Ve\
c3
&
TA_VEC3\
_CALL\

operator
/=
(
Ve\
c3
&
ll\
l\
l\
lll\
l\
l
,
fl\
o\
a\
t\

ll\
l\
lO\
OO\
OOO
)
{
__m\
1\
28\

lOlOOl\
llO\
l\
O\

=
_mm\
_s\
e\
t_p\
s1
(
llll\
O\
O\
OOOO
)
;
ll\
lll\
l\
lll\

=
(
Ve\
c3
&
)
_mm_di\
v_p\
s\

(
(
__m128\

&
)
ll\
lll\
lll\
l
,
lOl\
OOll\
lOlO
)
;
re\
tur\
n\

lll\
ll\
llll
;
}
temp\
late
<
class
Type
>
__fo\
rceinl\
i\
ne
Vec\
3
&
TA_\
VEC3_\
CA\
L\
L\

operat\
or
/=
(
Ve\
c3
&
llllll\
l\
ll\

,
const
lOlOOO\
OOl\
OO
::
lOl\
OO\
l\
OlO\
OO
<
Type
>
&
lOlO\
OllllOO\

)
{
lll\
l\
l\
lll\
l
=
(
Vec\
3
&
)
_mm_\
div_ps\

(
(
__m1\
28\

&
)
llllllll\
l
,
(
__m128
&
)
lOlOO\
llllOO
.
lOlO\
OlO\
l\
OO\
l
(
)
)
;
re\
turn
lllllllll\

;
}
__forc\
einl\
ine
int
Ve\
c3\

::
GetGr\
eatest\
A\
xis
(
)
co\
nst
{
float
lOlOOOOO\
O\
OO
=
Fabs\

(
x
)
;
float\

lO\
lOO\
O\
OOOOl
=
Fa\
bs\

(
y
)
;
float\

lOlOOOOO\
OlO
=
Fabs
(
z
)
;
if
(
lOl\
OOOO\
OOOO\

>
lOlO\
OOOOO\
Ol
)
{
if
(
lOlO\
OOOOOOO
>
lO\
lO\
OOOOO\
lO
)
retu\
rn\

AXI\
S_X
;
else
return
AXI\
S\
_Z
;
}
else
{
if
(
lO\
lO\
O\
O\
O\
OOOl
>
lOlOOOOOOlO
)
re\
turn
AXI\
S_Y\

;
el\
se
retur\
n
AXI\
S\
_Z
;
}
}
__forceinl\
ine\

void\

Vec3
::
Ge\
t\
A\
xi\
sOr\
d\
er
(
int
lll\
lO\
OlOO\
l
[
3
]
)
const\

{
fl\
oa\
t
lOlOOOOOOOO\

=
Fa\
bs\

(
x
)
;
flo\
a\
t\

lOl\
OOOOO\
O\
O\
l
=
Fabs
(
y
)
;
flo\
at
lOlOO\
O\
OOOl\
O
=
Fabs
(
z
)
;
if
(
lO\
lOOOOOOOO
>
lO\
lOO\
OOOOO\
l
)
{
if\

(
lOlOO\
OOOOOO\

>
lO\
l\
O\
OOOOOlO\

)
{
llllO\
O\
lO\
Ol
[
0
]
=
AX\
IS_X
;
if
(
lOlOOOOOOOl\

>
lOl\
OOOO\
OOlO
)
{
llllOOlO\
O\
l\

[
1
]
=
AXIS_Y
;
ll\
ll\
OOl\
O\
Ol
[
2
]
=
AXIS_Z
;
}
else
{
llll\
OOl\
OOl
[
1
]
=
AX\
IS_\
Z
;
ll\
ll\
O\
O\
lO\
Ol
[
2
]
=
AXIS\
_Y\

;
}
}
else
{
ll\
llO\
O\
lOOl
[
0
]
=
AXIS_Z
;
ll\
l\
lO\
OlOOl
[
1
]
=
AXIS_\
X
;
lll\
lOOlOO\
l
[
2
]
=
AXI\
S_Y\

;
}
}
else
{
if
(
lO\
lOO\
O\
OO\
OO\
l
>
lOlOOO\
OOOlO\

)
{
llllO\
OlOOl\

[
0
]
=
AX\
I\
S_Y\

;
if
(
lOlOO\
O\
O\
OO\
OO
>
lOl\
OOO\
O\
O\
O\
lO\

)
{
lll\
l\
OOlOOl
[
1
]
=
AXIS_X
;
lll\
l\
OO\
lO\
Ol
[
2
]
=
AXIS\
_Z
;
}
el\
se
{
lll\
lOOlOOl
[
1
]
=
AXIS_Z
;
ll\
llOOlOO\
l
[
2
]
=
AXIS\
_\
X
;
}
}
else
{
llllOOl\
OOl\

[
0
]
=
AXIS\
_Z
;
ll\
ll\
O\
Ol\
OOl
[
1
]
=
AXIS_Y
;
lll\
lOOlOOl\

[
2
]
=
AXIS_X
;
}
}
TA_AS\
SE\
RT
(
Fab\
s
(
GetA\
xis\

(
llll\
O\
OlOOl\

[
0
]
)
)
>=
Fa\
bs
(
GetA\
xis
(
llllOOlO\
Ol
[
1
]
)
)
)
;
TA_ASS\
ERT
(
Fa\
b\
s
(
Ge\
tAxis
(
ll\
llOOlO\
Ol
[
1
]
)
)
>=
Fabs\

(
GetAxis
(
llll\
OO\
lOOl
[
2
]
)
)
)
;
}
__forc\
e\
inlin\
e
co\
ns\
t
Vec\
3
&
Vec3
::
Ge\
tUni\
tV\
ector\

(
in\
t
lO\
O\
OlOOlll\

)
{
switc\
h\

(
lOOOlOOlll\

)
{
case\

AXIS\
_X\

:
return\

k_v3Un\
it\
X
;
break\

;
case
AXIS\
_Y
:
retu\
rn\

k_v3UnitY
;
break\

;
cas\
e
AXI\
S\
_Z
:
retu\
r\
n\

k_\
v\
3\
Unit\
Z\

;
br\
eak
;
defau\
lt
:
ll\
lOO\
OlllO
;
retu\
r\
n\

k_v3\
Unit\
X
;
}
}
inline
bool\

Vec3
::
IsEqu\
alWithInErro\
r
(
co\
n\
st
Vec3
&
lll\
l\
OOOll\
l
,
flo\
at\

llOllOlllO
)
co\
n\
s\
t
{
Ve\
c3\

lOl\
O\
OO\
OOOll\

=
*
this\

-
llll\
O\
OOll\
l
;
return
Fab\
s\

(
lO\
lOOOOOOll
.
x
)
<=
ll\
OllO\
l\
llO\

&&
Fabs
(
lOl\
OO\
OOOO\
ll
.
y
)
<=
llOll\
Oll\
lO
&&
Fabs
(
lOlO\
OOOOOll
.
z
)
<=
ll\
Oll\
O\
lllO
;
}
}
