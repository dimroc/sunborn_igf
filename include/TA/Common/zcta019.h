//---------------------------------------------------------------------------------
// File Name: zcta019.h
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#ifndef lOOlllllllO
#define lOOlllllllO
#ifndef DOXYGEN
na\
mes\
pace
TA\

{
struct
Vec3
;
nam\
e\
spac\
e\

lOl\
OO\
O\
OO\
l\
OO
{
TA_ALI\
G\
N_16
struc\
t
lOlO\
OO\
O\
O\
lOl\

{
float
x
;
float
y
;
flo\
at
z
;
fl\
oat
w
;
__\
fo\
rcei\
nl\
i\
n\
e\

float
lOlOOOO\
OllO
(
)
con\
st
{
re\
tur\
n\

x
;
}
__f\
o\
rcein\
l\
i\
ne
flo\
at
lOlO\
OOO\
Olll
(
)
cons\
t
{
ret\
u\
rn
y
;
}
__forc\
einlin\
e
floa\
t
lOlOO\
O\
OlOOO
(
)
const
{
return
z
;
}
}
;
te\
mplate
<
clas\
s
Type
>
struct
lOlO\
OOO\
l\
OO\
l
:
publi\
c
Type\

,
public
lOl\
OOOO\
O\
lOl
{
}
;
templ\
ate
<
class\

Ty\
pe
>
st\
r\
uc\
t\

lOlOOO\
OlOl\
O
{
__\
forc\
ei\
nline
fl\
oat
lOlOO\
O\
OlOll\

(
)
const
{
return\

(
(
Typ\
e
&
)
(
*
this\

)
)
.
lOlOOOO\
OllO
(
)
;
}
__forcein\
l\
ine
floa\
t
lOl\
OOOO\
l\
lOO
(
)
const
{
retu\
rn
(
(
Ty\
p\
e
&
)
(
*
this
)
)
.
lOl\
O\
OOOOlll
(
)
;
}
__\
for\
ceinlin\
e
fl\
oat\

lO\
lOOO\
O\
ll\
Ol
(
)
const
{
return
(
(
Type
&
)
(
*
this
)
)
.
lOlOOO\
OlO\
OO
(
)
;
}
te\
mp\
la\
te
<
class\

lOlOOOOl\
l\
lO\

,
cla\
s\
s
lO\
l\
OOOO\
llll
>
stat\
ic
__\
force\
in\
line
fl\
oat\

Do\
t\

(
const\

lO\
lOOO\
Ol\
OlO\

<
lO\
l\
O\
O\
OO\
l\
ll\
O
>
&
ll\
l\
OOllOl\
O\

,
cons\
t
lO\
lOOO\
OlOlO
<
lOlOOOO\
l\
l\
ll
>
&
ll\
lOOllllO\

)
{
return\

ll\
lOOllOlO
.
lOl\
OOOO\
lOll
(
)
*
lll\
OO\
l\
ll\
lO
.
lO\
lOO\
OOlOll
(
)
+
lllOOllOlO
.
lOlOOOOl\
lOO\

(
)
*
ll\
lO\
O\
llllO
.
lOlO\
OO\
Oll\
OO
(
)
+
lll\
O\
OllOlO\

.
lOlOOOOl\
lOl\

(
)
*
lllOOl\
lllO
.
lO\
lOOOO\
ll\
Ol
(
)
;
}
templ\
at\
e
<
class
lOlOO\
OO\
lll\
O\

>
__fo\
r\
ceinline
float\

Dot\

(
const
lOlO\
O\
OOl\
OlO
<
lOl\
OO\
O\
Olll\
O
>
&
lOlO\
O\
OlO\
OOO\

)
const
{
re\
t\
u\
rn
Dot
(
*
this\

,
lOl\
O\
OO\
lO\
O\
O\
O
)
;
}
tem\
pl\
a\
te\

<
class
lOlO\
O\
OO\
l\
ll\
O
,
cla\
s\
s
lO\
lOO\
OOll\
ll
>
static
__\
for\
cei\
n\
line\

lOlOO\
OOlOOl
<
lOlOO\
OO\
lO\
lO
<
lOlO\
OO\
O\
O\
lOl
>
>
Cr\
o\
ss
(
const
lOl\
O\
O\
OOlOlO\

<
lO\
lOO\
OOl\
l\
lO
>
&
lll\
OOllO\
lO\

,
con\
st
lOlOOO\
OlOlO
<
lO\
lOO\
OOl\
lll
>
&
lllOO\
ll\
l\
l\
O
)
{
lO\
lOOOO\
O\
lOl\

ll\
lllllll
;
ll\
lllllll\

.
x
=
lll\
OOl\
lOl\
O
.
lOlOOOOlOll\

(
)
;
llll\
lllll
.
y
=
lll\
OO\
llOlO
.
lO\
l\
OOOO\
llO\
O\

(
)
;
lllllll\
ll
.
z
=
lllO\
O\
llOlO
.
lOlOO\
OOl\
l\
Ol
(
)
;
lOlO\
OOOOl\
Ol
lO\
O\
OOOOOOO\

;
lOOOOOOOOO
.
x
=
ll\
lOO\
ll\
llO
.
lOlOO\
OOlOll\

(
)
;
lO\
OOO\
O\
OO\
O\
O
.
y
=
lllO\
Ol\
lll\
O\

.
lOlOOOOl\
lOO
(
)
;
lOOO\
OOOO\
O\
O\

.
z
=
lllOOl\
ll\
lO
.
lOl\
OOOOl\
lOl
(
)
;
lO\
lOOO\
OlOOl
<
lO\
lOOOOlOlO
<
lO\
l\
OOOOOl\
Ol
>
>
lOOOOl\
lOlOl
;
lO\
O\
O\
OllOlOl
.
x
=
lll\
l\
ll\
ll\
l
.
y
*
lO\
OOOOOOOO\

.
z
-
ll\
lllll\
l\
l
.
z
*
lOO\
OOOOO\
OO
.
y
;
lOOOOllOl\
Ol\

.
y
=
lll\
llll\
ll\

.
z
*
lO\
OOOOOOOO
.
x
-
ll\
lllll\
l\
l
.
x
*
lO\
OOO\
OOOOO
.
z
;
lO\
O\
OOllOlOl\

.
z
=
ll\
ll\
l\
lll\
l
.
x
*
lOOOOOO\
OOO
.
y
-
lllll\
l\
lll
.
y
*
lOO\
OOOOOOO\

.
x
;
retu\
rn
lOOOO\
llO\
l\
Ol
;
}
template
<
class
lO\
lO\
OOOlllO
>
__forcei\
nli\
ne
lOl\
OOOO\
lOOl\

<
lOlOOOOlOlO
<
lOlOOOOOl\
Ol
>
>
Cross
(
const
lO\
lOOO\
OlOlO
<
lOlOOOOll\
l\
O
>
&
lllOO\
llllO
)
const
{
retur\
n
Cro\
ss\

(
*
th\
i\
s
,
lllOOl\
ll\
lO\

)
;
}
__f\
orc\
einl\
ine
floa\
t
GetM\
a\
g\
n\
itude
(
)
const
{
floa\
t
lOlO\
OOlOOO\
l
=
lO\
lOOOO\
l\
Ol\
l\

(
)
;
flo\
a\
t
lO\
lOOOlOOl\
O\

=
lOlO\
OO\
lOOO\
l\

*
lOl\
OOOlOOO\
l
;
float
lO\
lO\
OOlOOll
=
lO\
l\
OOOO\
llOO
(
)
;
lOlOOOl\
OOlO
+=
lOlOO\
Ol\
OOll
*
lOlOOOlOOll\

;
floa\
t
lOl\
OOOlOlOO
=
lOlOOO\
O\
ll\
Ol
(
)
;
lOlOO\
OlO\
OlO
+=
lOl\
OOOlOlOO
*
lO\
lOOOlOlOO
;
retur\
n
Sqrt
(
lOl\
OOOlOO\
lO
)
;
}
te\
mp\
la\
te
<
class\

lOlO\
OO\
Olll\
O
>
static\

inli\
n\
e
fl\
o\
at
TA_VE\
C\
3_CALL
Get\
Magnitude
(
cons\
t
lOlO\
O\
OOlO\
l\
O
<
lO\
lO\
OOOlllO
>
&
ll\
lO\
Oll\
O\
lO
)
{
return
lllO\
O\
llO\
lO
.
Get\
Magni\
tude
(
)
;
}
__forceinl\
ine
flo\
a\
t
GetMagnitud\
eS\
qr\
d\

(
)
const
{
float
lOlO\
O\
OlOOO\
l
=
lO\
lO\
OO\
OlOll
(
)
;
float
lOlOO\
OlOOlO
=
lOl\
OOO\
l\
OO\
O\
l
*
lO\
lOOOlOO\
Ol\

;
float\

lO\
lOO\
OlOOll
=
lO\
lOOOO\
llOO
(
)
;
lOlOOOl\
OO\
lO
+=
lO\
lO\
OOl\
OOll\

*
lOlOOOlOOl\
l\

;
float\

lOlO\
O\
OlOlOO\

=
lOlOOOOllOl\

(
)
;
lO\
lO\
OOl\
OO\
lO
+=
lOlOOOlOl\
OO
*
lOl\
OOOlOl\
OO\

;
re\
t\
u\
r\
n
lO\
lOOOlOOlO
;
}
templa\
te
<
class\

lOlOOOOll\
lO\

>
sta\
t\
i\
c
inline
float
TA_VEC3_CALL
GetMagnit\
u\
deSqrd
(
const
lOlOO\
O\
Ol\
OlO
<
lOlOOO\
Olll\
O
>
&
lllOOl\
l\
OlO
)
{
ret\
urn
lllO\
Oll\
OlO
.
GetM\
agni\
tu\
deSq\
rd
(
)
;
}
__forc\
einline
Vec3
GetNor\
ma\
l
(
)
const
;
template
<
cl\
as\
s
lOl\
O\
O\
OOl\
l\
l\
O\

>
stat\
ic
__for\
ceinli\
ne
lOl\
OO\
OOlOOl
<
lOlOOOOlOlO
<
lOlOOOOOlOl\

>
>
Get\
No\
rmal\

(
const\

lO\
lOOOO\
l\
O\
lO
<
lO\
l\
OOOO\
l\
llO\

>
&
ll\
lO\
OllllO\

)
{
re\
tur\
n
lllOOllll\
O
.
GetNormal
(
)
;
}
}
;
struct
lOlOlOOOO\
l
{
st\
ati\
c
__\
forc\
einline
float\

lOl\
O\
OO\
Ol\
Ol\
l
(
float
lll\
OOl\
l\
Ol\
O
,
float
lllO\
OllllO
)
{
re\
t\
u\
rn
lll\
O\
OllOlO
+
lll\
OO\
llllO
;
}
sta\
ti\
c\

__forc\
ein\
line
fl\
oat
lO\
lOOOOll\
O\
O
(
fl\
oat
lllOOllOlO
,
fl\
oat
lllOO\
llllO
)
{
return
lll\
OOll\
OlO
+
lllOOl\
ll\
lO
;
}
stat\
ic\

__for\
c\
einline
float
lO\
lOOOOllO\
l\

(
float\

lllO\
OllOl\
O\

,
fl\
o\
at
ll\
lO\
Ollll\
O
)
{
re\
tur\
n
lllO\
OllOl\
O\

+
lllOOllll\
O\

;
}
st\
ati\
c\

__forcein\
l\
i\
ne
fl\
oa\
t\

lOlOOO\
lOlO\
l
(
fl\
oat\

lllOO\
llOlO
,
fl\
oat
lllO\
OllllO\

)
{
retu\
rn
ll\
lOOllOlO
+
lllOOl\
l\
ll\
O
;
}
}
;
stru\
c\
t
lOlO\
O\
Ol\
Oll\
O
{
st\
at\
ic
__forcei\
nline\

flo\
at
lOlOOOOlOll
(
flo\
at
ll\
lO\
OllOlO
,
float\

lllOOl\
lll\
O
)
{
re\
turn
lllOO\
llOlO
-
ll\
lOOllllO\

;
}
stat\
ic
__\
fo\
rceinline\

floa\
t\

lOlOOO\
Ol\
lOO
(
float\

ll\
lOOllO\
lO
,
flo\
at
ll\
lO\
OllllO
)
{
re\
turn
lllOO\
llOl\
O
-
lllOOllllO
;
}
static
__fo\
rce\
inli\
ne
flo\
a\
t
lOl\
OOO\
O\
llOl
(
flo\
at\

ll\
lOOllOlO
,
float
lll\
O\
OllllO
)
{
return
lllOO\
llOlO\

-
lllOOll\
llO
;
}
sta\
tic
__fo\
rcein\
line\

fl\
oat
lO\
lOOO\
lOl\
Ol
(
flo\
at
lllO\
Oll\
OlO
,
flo\
at
ll\
lOO\
llll\
O
)
{
return
lllOOllOlO
-
ll\
lOOllllO\

;
}
}
;
stru\
ct
Mul
{
st\
atic\

__forceinline\

flo\
a\
t
lO\
lOOOOlOll
(
float
lllOOllOl\
O
,
flo\
at
ll\
lOOllllO
)
{
return
lllO\
O\
llOlO
*
lllOOllllO
;
}
stat\
i\
c
__f\
orceinl\
ine
floa\
t
lO\
lOOOOllO\
O
(
float
lllO\
OllO\
lO
,
flo\
a\
t
ll\
lOOl\
l\
l\
lO
)
{
ret\
urn
lll\
OOll\
OlO
*
ll\
lOOllllO
;
}
st\
a\
tic
__\
for\
cei\
nli\
n\
e
flo\
at
lOlO\
O\
OOll\
O\
l\

(
flo\
at
lllOOllO\
lO
,
flo\
at
lllOOll\
llO
)
{
retu\
rn
ll\
lOO\
ll\
OlO
*
lllO\
O\
ll\
llO\

;
}
sta\
t\
i\
c
__forc\
einl\
i\
ne
fl\
o\
a\
t
lOl\
OOOl\
Ol\
O\
l\

(
float
lllOOllOlO
,
float\

ll\
lO\
Ollll\
O
)
{
return
ll\
l\
OOllO\
lO
*
lll\
OO\
ll\
l\
lO
;
}
}
;
str\
uct
lOl\
OOOlOlll\

{
static
__forceinline
floa\
t
lOlOOO\
O\
l\
Oll
(
float
lllOO\
l\
lOl\
O
,
float
lllOOll\
llO
)
{
re\
t\
ur\
n
lllO\
O\
llO\
lO
/
lllO\
Olll\
l\
O\

;
}
stat\
i\
c
__forc\
ein\
line\

fl\
oat
lO\
lOOOOllOO\

(
float\

ll\
lOOll\
O\
lO
,
flo\
at
lllOOl\
lll\
O
)
{
re\
tur\
n
ll\
l\
OOllOlO
/
lllO\
O\
lll\
l\
O
;
}
st\
a\
tic
__forceinline
float
lO\
lO\
OO\
OllOl
(
fl\
oat
lllOO\
ll\
O\
lO
,
float
ll\
lO\
O\
llllO
)
{
return
lll\
OO\
ll\
OlO
/
lll\
OOl\
lllO
;
}
st\
atic\

__\
fo\
rceinl\
ine
flo\
at\

lOlO\
O\
O\
lOlOl
(
flo\
a\
t
ll\
l\
OOllO\
lO
,
fl\
oa\
t\

lllO\
O\
l\
l\
ll\
O
)
{
re\
turn
lllOO\
l\
lO\
lO
/
ll\
lOOlll\
lO
;
}
}
;
st\
ru\
ct
lOlOOOl\
lOOO
{
sta\
tic
__f\
o\
rce\
inli\
n\
e\

flo\
a\
t
lO\
lOOO\
OlOl\
l
(
fl\
o\
a\
t
lllOOllOl\
O
)
{
ret\
urn
lllOOl\
l\
O\
lO
;
}
sta\
tic
__fo\
rc\
einli\
ne\

float
lOlOOO\
O\
l\
lO\
O
(
fl\
o\
a\
t\

ll\
lOOllOl\
O
)
{
retur\
n
lll\
OO\
l\
l\
OlO
;
}
sta\
t\
i\
c
__f\
o\
r\
ceinl\
in\
e
fl\
o\
a\
t
lOl\
OOOOllO\
l
(
float
lllOO\
ll\
Ol\
O
)
{
re\
t\
urn
lll\
OOllO\
lO
;
}
static
__f\
orcei\
nl\
ine
flo\
at\

lOlOOOlOlOl
(
fl\
oat
ll\
lOO\
llOlO
)
{
return
lllOOll\
OlO
;
}
}
;
struct
lO\
lOOOllOOl
{
st\
at\
ic
__\
forc\
einl\
ine
fl\
oat
lOlOO\
OO\
l\
O\
l\
l
(
flo\
a\
t
ll\
lOO\
llO\
l\
O
)
{
re\
tu\
rn\

-
lll\
OOllO\
lO\

;
}
stat\
ic\

__for\
c\
einl\
ine
floa\
t
lOl\
O\
OO\
Ol\
lOO
(
flo\
at
lllOO\
llOlO
)
{
re\
turn
-
lll\
OOllO\
lO\

;
}
stati\
c
__f\
orceinline
fl\
oa\
t
lOlOO\
O\
Oll\
Ol
(
flo\
at\

lllOOllOl\
O\

)
{
return
-
lllO\
OllOlO
;
}
sta\
t\
ic
__for\
c\
einline\

floa\
t
lOlOOOlO\
l\
O\
l
(
fl\
oa\
t
lll\
OOll\
OlO
)
{
ret\
ur\
n\

-
lll\
OO\
l\
lOlO
;
}
}
;
templa\
te
<
class
lO\
l\
OOOO\
lllO
,
cl\
ass
lOlO\
OOOllll
,
cl\
ass
lOl\
OO\
OllOl\
O
>
st\
ru\
ct\

lO\
lOO\
Oll\
Ol\
l
:
publi\
c
lO\
l\
O\
OOOlOlO
<
lO\
lO\
OOllOll
>
{
const\

lOlO\
O\
OOll\
l\
O
&
lO\
lOOOlllOO
;
const
lOlOOOOllll
&
lOl\
OOOlll\
O\
l
;
__\
forceinli\
ne\

lOlOOOllOll
(
con\
s\
t
lOlOOOOll\
lO\

&
ll\
lOO\
ll\
OlO\

,
co\
ns\
t\

lOlOO\
OOl\
l\
l\
l
&
lllOO\
ll\
llO
)
:
lOl\
O\
OOlllOO
(
lll\
OO\
l\
lO\
lO\

)
,
lOlOOOl\
llOl
(
lllOOllllO
)
{
}
__force\
in\
li\
ne
flo\
a\
t
lOlOOO\
O\
O\
ll\
O
(
)
cons\
t
{
ret\
urn\

lO\
lOO\
OllOlO
::
lOlOOOOl\
Oll
(
lOl\
OOOlllOO
.
lOl\
OOOOl\
O\
ll
(
)
,
lO\
l\
OO\
O\
l\
ll\
O\
l
.
lOl\
OOOOlOll
(
)
)
;
}
__\
force\
inl\
i\
n\
e\

floa\
t
lOlOOOOOlll\

(
)
co\
ns\
t
{
return
lOl\
O\
OOllOlO
::
lO\
l\
OOO\
Ol\
l\
O\
O
(
lOlO\
OOlllO\
O
.
lO\
lOOO\
O\
l\
lOO\

(
)
,
lOlO\
OO\
lllOl
.
lOl\
OOOOll\
OO
(
)
)
;
}
__\
forcei\
nline\

fl\
oat
lOlOOOO\
lO\
OO
(
)
co\
n\
st\

{
re\
tur\
n
lOl\
OOOl\
lOlO\

::
lO\
lOOOOllO\
l\

(
lOlOO\
OlllOO
.
lOlO\
OOOllOl
(
)
,
lOlOOOll\
lOl
.
lOlOOOO\
llOl\

(
)
)
;
}
}
;
temp\
la\
te\

<
cl\
a\
ss
lOlOO\
OOlllO
,
clas\
s\

lOlOOOl\
lOl\
O
>
st\
ruct
lOlO\
OOllll\
O\

:
pu\
blic
lOlO\
OOOlO\
lO
<
lOl\
OOOl\
lllO
>
{
const\

lOlOOOO\
lllO
&
lOlOO\
Oll\
lOO
;
__\
for\
cei\
nli\
ne
lOlO\
OOll\
llO\

(
const
lOlO\
O\
OOlll\
O
&
lllOOll\
Ol\
O
)
:
lOl\
O\
O\
Olll\
OO\

(
lllO\
O\
ll\
OlO\

)
{
}
__\
f\
o\
r\
ce\
inl\
i\
n\
e
fl\
oa\
t
lOlOO\
OOOllO\

(
)
co\
n\
st
{
return
lOl\
OOOllO\
lO
::
lO\
lO\
O\
OOlOl\
l
(
lOl\
OOO\
lll\
O\
O
.
lOl\
O\
OOO\
lOll
(
)
)
;
}
__\
forc\
e\
inl\
ine
floa\
t\

lOl\
OOOO\
Oll\
l
(
)
co\
n\
st\

{
return
lOlOOOllOl\
O
::
lOl\
OOOOllOO
(
lO\
lOOOlllOO
.
lOlOOOOllOO\

(
)
)
;
}
__for\
cei\
nlin\
e
float
lO\
l\
OOOOl\
OO\
O\

(
)
co\
nst
{
ret\
u\
rn\

lO\
l\
OOOll\
O\
l\
O\

::
lOlO\
OOOll\
O\
l
(
lOlOOOlllO\
O
.
lOlOOO\
O\
l\
lOl
(
)
)
;
}
}
;
templa\
t\
e
<
class
lO\
lOO\
OOlll\
O
,
clas\
s\

lOlO\
OOl\
lO\
lO
>
struct
lO\
lOOOlllll
:
pub\
lic
lOl\
OO\
OOlOlO\

<
lOlO\
O\
Olllll
>
{
const
lOlOO\
OOl\
llO
&
lOlOOOll\
l\
OO
;
const
fl\
o\
at\

lOlOOOl\
llOl\

;
__f\
orceinl\
i\
ne
lOlO\
OO\
lllll\

(
co\
nst
lOlOO\
OOlllO\

&
lllOOllOlO
,
con\
s\
t
fl\
oat
lll\
OOlll\
lO\

)
:
lOl\
O\
OOl\
ll\
O\
O\

(
lll\
O\
OllOlO
)
,
lOlOOOlllOl
(
lllOOllllO
)
{
}
__force\
in\
li\
ne\

flo\
a\
t
lO\
l\
OOO\
OO\
llO
(
)
const
{
re\
tur\
n\

lOlO\
OOl\
lOlO
::
lOl\
OOOOlOll
(
lOlOOOlllOO
.
lOlO\
OOO\
lO\
l\
l
(
)
,
lOlOO\
OlllO\
l
)
;
}
__\
forceinl\
i\
ne
floa\
t
lOlOOOO\
Oll\
l\

(
)
con\
st
{
re\
t\
urn\

lOlO\
O\
OllOlO
::
lOlOOOOllOO
(
lO\
lO\
O\
O\
lllOO
.
lOlOO\
OO\
l\
lOO
(
)
,
lOl\
OO\
OlllOl
)
;
}
__\
forcei\
nl\
ine
fl\
oat
lOlOOOO\
l\
OOO
(
)
const
{
retu\
rn
lOlOOO\
llOl\
O
::
lOl\
OOOOllO\
l
(
lO\
lOO\
Olll\
OO\

.
lOlOOOO\
ll\
Ol
(
)
,
lOlOOOl\
ll\
Ol\

)
;
}
}
;
templ\
a\
t\
e
<
cla\
ss
lOlOOO\
O\
ll\
l\
l
,
class\

lOlOO\
O\
l\
lOlO
>
struct
lOlO\
OlOOOOO
:
pub\
lic
lOlOOOOlO\
lO
<
lOlOOl\
OOOO\
O
>
{
con\
st
flo\
at\

lOl\
OO\
OlllOO
;
const
lOlO\
OOOllll\

&
lO\
lOO\
Oll\
lOl
;
__\
forcein\
l\
ine
lOl\
O\
O\
lOOOOO\

(
co\
nst\

fl\
o\
at\

lllOOllOlO
,
con\
st\

lOlO\
OOOllll
&
lllOOllll\
O\

)
:
lOl\
OOO\
lll\
OO
(
lll\
OOllOlO
)
,
lOlO\
OO\
lll\
Ol
(
lllOO\
lll\
lO
)
{
}
__\
for\
ceinl\
ine
floa\
t
lOlOOOO\
OllO
(
)
const
{
re\
tu\
r\
n
lOl\
OOOllOlO\

::
lO\
l\
OOOOlOll
(
lO\
lOO\
O\
lll\
OO\

,
lOlO\
O\
OlllOl
.
lOlOOO\
O\
lOll
(
)
)
;
}
__fo\
rceinl\
ine
fl\
oat
lO\
lOOO\
OOll\
l
(
)
con\
st
{
return
lOlOOOllOl\
O\

::
lOlOOO\
Oll\
OO\

(
lOlOOO\
lllOO
,
lOlOOO\
lll\
Ol
.
lOlOOOOllOO\

(
)
)
;
}
__\
forcein\
line
float
lO\
lOO\
O\
OlOOO\

(
)
co\
nst
{
return
lOlOOOllO\
lO
::
lO\
l\
O\
OOOllOl
(
lOlOOOlllOO\

,
lOlOOO\
lllOl
.
lOl\
OOOO\
llO\
l
(
)
)
;
}
}
;
}
stru\
ct\

TACO\
MMON_CL\
A\
SS
Vec3\

:
publi\
c
lOl\
OOOOOlOO\

::
lOl\
OO\
OOO\
lOl
,
pu\
blic
lOlOOOOOlOO
::
lOlOO\
OOlOlO
<
Vec3
>
{
en\
um
Axis
{
AXIS_X\

=
0
,
AXI\
S_\
Y
,
AXIS_Z\

,
}
;
Vec3
(
)
{
}
;
Ve\
c3
(
co\
n\
s\
t\

Vec3
&
llllOOOlll\

)
{
x
=
ll\
llO\
OOll\
l
.
x
;
y
=
lll\
l\
O\
OOlll\

.
y
;
z
=
llllO\
OOlll
.
z
;
}
Vec3
(
fl\
oat
lOlOO\
Ol\
OOO\
l
,
float
lOl\
OOO\
lOOl\
l
,
flo\
at
lOl\
OOOl\
OlOO\

)
{
x
=
lOlOOOlOOO\
l
;
y
=
lOlOOOlOO\
ll
;
z
=
lOlOOOlOlOO
;
}
template
<
cla\
ss
Type
>
__force\
in\
lin\
e
Vec\
3
&
op\
erat\
o\
r
=
(
const
lOlOOOO\
O\
lO\
O
::
lO\
lOOOOl\
O\
lO\

<
Typ\
e
>
&
lOlOOOlOOO\
O
)
{
x
=
lOlO\
O\
OlOOOO
.
lOlO\
O\
O\
O\
lOl\
l
(
)
;
y
=
lO\
l\
O\
OO\
lOOO\
O
.
lOlOO\
O\
Ol\
lOO\

(
)
;
z
=
lOl\
OOO\
l\
OO\
OO
.
lOlOOOOllO\
l
(
)
;
re\
t\
urn\

*
this
;
}
template
<
cla\
s\
s\

Type
>
__fo\
rc\
ei\
nl\
ine\

Vec3
(
const
lOl\
OOOOOlOO
::
lO\
lO\
OOO\
lOlO
<
Type
>
&
lOlO\
OOlOO\
OO
)
{
x
=
lOl\
OOOl\
OO\
OO
.
lOl\
OOOOl\
O\
ll\

(
)
;
y
=
lOl\
O\
OO\
l\
OOO\
O
.
lOlOO\
OOl\
lO\
O
(
)
;
z
=
lOlOOO\
lOOO\
O
.
lOlOOOO\
ll\
Ol\

(
)
;
}
__force\
inline
vo\
i\
d
In\
itial\
ise
(
flo\
at
lOlOOOl\
OOOl
,
float
lOlOOO\
lO\
Ol\
l\

,
fl\
oat
lO\
l\
OOOl\
OlO\
O\

)
{
x
=
lOlOOO\
lOO\
Ol
;
y
=
lOl\
O\
OOlOOll\

;
z
=
lO\
l\
O\
O\
OlO\
l\
OO\

;
}
opera\
tor
float
*
(
)
{
retur\
n
(
float
*
)
&
x
;
}
op\
erator
co\
ns\
t
floa\
t
*
(
)
cons\
t
{
return\

(
float
*
)
&
x
;
}
float
&
op\
erator\

[
]
(
int
lO\
OO\
l\
O\
Ol\
l\
l
)
{
return
(
(
float
*
)
&
x
)
[
lO\
OOlOOl\
ll
]
;
}
const
float
&
operator
[
]
(
int
lOOOl\
OOlll
)
const
{
retur\
n\

(
(
float
*
)
&
x
)
[
lO\
OOlOOll\
l\

]
;
}
templ\
a\
te
<
cla\
s\
s\

Type
>
__for\
cei\
nl\
ine
Ve\
c3\

&
ope\
rator\

+=
(
const
lOlOOOOOlOO
::
lO\
lOO\
OO\
lO\
lO
<
Type\

>
&
lOl\
OOOl\
OO\
OO
)
{
x
+=
lOlOO\
Ol\
OO\
OO
.
lOl\
OOOO\
lO\
ll
(
)
;
y
+=
lOlOOOlOO\
O\
O\

.
lOlO\
OO\
Ol\
l\
OO
(
)
;
z
+=
lOlOO\
OlOOOO
.
lOlOO\
O\
O\
llOl
(
)
;
return
*
th\
i\
s
;
}
temp\
late
<
cla\
ss
Type
>
__forc\
einline\

Vec3
&
operator
-=
(
const\

lOlOOOO\
O\
l\
O\
O
::
lOl\
OOOOlOl\
O
<
Typ\
e
>
&
lO\
lOOOlO\
OOO
)
{
x
-=
lOlO\
OOlOOOO
.
lOlOOOOlOll
(
)
;
y
-=
lOl\
O\
OOlOOOO\

.
lO\
l\
OOOOllOO
(
)
;
z
-=
lOlOOOl\
OO\
OO
.
lOlOOOOll\
O\
l
(
)
;
retu\
rn
*
this
;
}
__for\
cei\
nline
Vec\
3\

&
ope\
r\
at\
or
*=
(
fl\
oa\
t
lOOOO\
OlllO\

)
{
x
*=
lOOOOO\
lll\
O
;
y
*=
lOOOOO\
lll\
O
;
z
*=
lOOOOO\
lllO
;
ret\
urn
*
this
;
}
__\
f\
orceinli\
ne
Vec3
&
operator
/=
(
float\

lOOOO\
Oll\
l\
O
)
{
float
lOlOOlOOOOl
=
1.0f
/
lOO\
O\
O\
Oll\
lO
;
x
*=
lO\
lOOlOOOOl
;
y
*=
lOlO\
OlOOOOl
;
z
*=
lOl\
O\
OlO\
OOOl
;
re\
turn\

*
thi\
s
;
}
sta\
t\
ic
inline\

Vec\
3
TA_V\
EC3_\
CALL
Cros\
sW\
ithUnitX
(
co\
ns\
t\

Vec3
&
llll\
OOO\
l\
ll
)
{
retu\
rn
Vec3
(
0.0f
,
llllOOOlll
.
z
,
-
lll\
l\
OO\
Ol\
l\
l\

.
y
)
;
}
in\
line
Vec3
Cro\
s\
sWit\
hUni\
tX
(
)
co\
nst
{
re\
turn\

CrossWithUni\
tX\

(
*
this
)
;
}
stati\
c
inli\
ne
Vec3
TA\
_VEC3\
_\
CAL\
L\

Cr\
os\
sWithUnitY\

(
const
Ve\
c3
&
llllOOOlll
)
{
return
Ve\
c3
(
-
llllO\
OOl\
ll\

.
z
,
0.0f
,
llllO\
OO\
l\
ll
.
x
)
;
}
inline
Vec3
Cro\
ss\
WithUn\
itY
(
)
con\
st
{
re\
turn\

Cro\
ssW\
ith\
Unit\
Y
(
*
thi\
s
)
;
}
st\
atic
inl\
i\
ne\

Vec3
TA_VEC\
3\
_CAL\
L
Cr\
ossWi\
thUnitZ
(
co\
nst
Vec\
3
&
lll\
l\
OOOlll
)
{
ret\
urn
Vec3
(
llllOOOl\
l\
l
.
y
,
-
llllO\
OOl\
ll
.
x
,
0.0f
)
;
}
in\
line
Vec3
CrossWithUnitZ
(
)
con\
s\
t
{
re\
t\
urn
Cros\
s\
WithUni\
tZ
(
*
this
)
;
}
st\
atic
inl\
in\
e
float
TA_VEC3_CALL
CrossX
(
const
Vec3
&
lllll\
l\
l\
ll\

,
cons\
t
Vec3
&
lOOOOOO\
OOO
)
{
retu\
rn
lllll\
llll
.
y
*
lO\
OOO\
O\
O\
O\
OO
.
z
-
ll\
lll\
llll
.
z
*
lOOOO\
O\
OOOO
.
y
;
}
in\
li\
ne\

float
Cros\
sX
(
const
Ve\
c3
&
ll\
llOOOlll\

)
const
{
return
Cr\
oss\
X
(
*
thi\
s
,
llll\
OOOlll
)
;
}
stat\
ic
inline
float\

TA_VE\
C3_CALL
Cr\
ossY
(
const
Vec\
3
&
lllllllll
,
const\

Vec3
&
lOO\
OOOOOOO
)
{
return
lllllllll
.
z
*
lOOOO\
OOOO\
O\

.
x
-
lllllllll
.
x
*
lOOO\
OOOOO\
O
.
z
;
}
inline
fl\
o\
at
CrossY
(
co\
nst
Vec3
&
lll\
lOO\
Olll
)
const
{
retu\
r\
n
Cr\
os\
sY\

(
*
th\
i\
s
,
ll\
llOOOll\
l
)
;
}
st\
ati\
c
inlin\
e
fl\
oat\

TA_\
VE\
C3_CALL
Cros\
s\
Z
(
co\
nst\

Vec3\

&
llllllll\
l
,
con\
s\
t\

Vec3
&
lOO\
OOOOOOO
)
{
re\
turn\

lll\
l\
lllll\

.
x
*
lOO\
OOO\
OOOO\

.
y
-
llllll\
l\
ll
.
y
*
lOOOO\
O\
O\
OOO\

.
x
;
}
in\
line
fl\
o\
at
Cross\
Z
(
co\
nst
Vec3\

&
llllOOOl\
ll\

)
const
{
re\
t\
u\
rn\

CrossZ
(
*
this
,
lll\
lOOOlll
)
;
}
static
inline
Vec3
TA\
_V\
EC3\
_C\
ALL
Mi\
n
(
con\
st\

Vec\
3
&
lllll\
l\
l\
ll
,
const\

Vec3
&
lOOOO\
O\
OOO\
O
)
{
Ve\
c\
3\

lOl\
OOlOOOlO
;
lOlO\
OlOOOlO
.
x
=
llllll\
lll
.
x
<
lOOO\
OO\
OOOO
.
x
?
lll\
lll\
ll\
l\

.
x
:
lOO\
O\
O\
OO\
OO\
O\

.
x
;
lOl\
OOlOOOlO\

.
y
=
ll\
ll\
ll\
lll\

.
y
<
lOOOOOO\
OO\
O
.
y
?
llll\
llll\
l\

.
y
:
lOOO\
OOOOOO
.
y
;
lOlOOlOOOl\
O
.
z
=
llllllll\
l\

.
z
<
lOOO\
OOOO\
O\
O
.
z
?
lllllllll
.
z
:
lOO\
OOOOOO\
O
.
z
;
re\
turn
lOlO\
OlOOO\
lO
;
}
static
inli\
ne
Vec3\

TA\
_VEC3_\
C\
A\
L\
L\

Max\

(
const
Vec\
3
&
llllll\
ll\
l
,
con\
st
Vec\
3\

&
lOOOOOOOO\
O\

)
{
Vec3
lOlOOlOOO\
lO\

;
lOlOOlOOO\
lO
.
x
=
lll\
lll\
ll\
l
.
x
>
lO\
O\
OOOOOOO\

.
x
?
lllllllll
.
x
:
lOO\
O\
OOOOOO
.
x
;
lOlOO\
lO\
OOlO
.
y
=
ll\
llll\
l\
l\
l\

.
y
>
lO\
OOOOOOOO
.
y
?
lllllll\
ll\

.
y
:
lO\
OOOOOOOO\

.
y
;
lOlOO\
lO\
OOlO
.
z
=
lll\
lll\
lll\

.
z
>
lO\
O\
OOOOO\
OO
.
z
?
lll\
llllll
.
z
:
lOO\
OO\
OOOOO
.
z
;
re\
turn
lOlOOlOOOlO
;
}
__forc\
einlin\
e
vo\
i\
d\

Normalis\
e
(
)
{
(
*
thi\
s
)
*=
Reciproc\
alSqr\
t
(
GetMagnit\
u\
deSqrd
(
)
)
;
}
__fo\
r\
ceinli\
n\
e
void\

Clear\

(
)
{
x
=
0.0f
;
y
=
0.0f
;
z
=
0.0f
;
}
__\
forceinlin\
e
bool\

IsNorm\
al\
ised
(
)
const
{
ret\
ur\
n
IsEq\
u\
al\
ToOneW\
ith\
InErr\
o\
r
(
Get\
Ma\
g\
nitu\
d\
eSqrd\

(
)
)
;
}
__\
for\
cein\
lin\
e
boo\
l
IsZero
(
)
const
{
retur\
n
GetM\
a\
gn\
itu\
de\
Sq\
r\
d\

(
)
==
0.0f
;
}
__\
fo\
rceinl\
ine
int
Ge\
tGr\
eatestAxis
(
)
const
;
__fo\
rc\
einl\
ine
float
Ge\
t\
Max
(
)
const
{
re\
t\
urn\

TA
::
Max\

(
TA
::
Max
(
x
,
y
)
,
z
)
;
}
__\
for\
cein\
line\

fl\
oat
GetMin
(
)
const\

{
retu\
rn
TA\

::
Mi\
n
(
TA\

::
Min
(
x
,
y
)
,
z
)
;
}
__f\
or\
ce\
inline
void
Ge\
tAxi\
sOrd\
er
(
int
ll\
ll\
OOl\
OOl
[
3
]
)
const
;
__f\
orc\
einline
fl\
oat
GetAxi\
s\

(
int\

lOOOlOOlll
)
cons\
t
{
retur\
n
(
*
this
)
[
lOOOlOO\
lll\

]
;
}
st\
atic
__\
f\
orceinline
cons\
t
Ve\
c3\

&
TA\
_V\
EC3_\
CAL\
L
Get\
UnitVe\
ctor
(
int
lOOO\
l\
OOll\
l\

)
;
}
;
const
Vec3
k_v3Ze\
r\
o\

(
0.0f
,
0.0f
,
0.0f
)
;
cons\
t
Vec\
3
k_v3\
Uni\
t\
X\

(
1.0f
,
0.0f
,
0.0f
)
;
cons\
t
Ve\
c3
k_v3U\
nitY
(
0.0f
,
1.0f
,
0.0f
)
;
const\

Vec3
k_v3Uni\
tZ\

(
0.0f
,
0.0f
,
1.0f
)
;
}
#include "../Common/zcta012.inl"
#endif //
#endif //
