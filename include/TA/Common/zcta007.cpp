//---------------------------------------------------------------------------------
// File Name: zcta007.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#include "EulerAngles.h"
#ifndef TA_MATHS_H
#include "Maths.h"
#endif //
#ifndef TA_MATRIX_H
#include "Matrix.h"
#endif //
namespace
TA
{
void
Eu\
l\
erAn\
g\
les\

::
Ini\
tialis\
e
(
cons\
t\

Mat33
&
lOO\
O\
OOO\
Oll\

)
{
con\
st
flo\
at\

lllOOlOl\
OO\

=
0.0001f
;
fl\
o\
at
lllOOlOlOl
=
(
lOOO\
O\
OO\
O\
l\
l
.
v3\
Z
.
x
*
lOOOOOO\
Oll\

.
v3Z
.
x
)
+
(
lOOOOOOO\
ll
.
v3\
Z
.
z
*
lOOOOOOOl\
l
.
v3Z
.
z
)
;
if
(
lllOOlO\
lOl
>
lll\
OOlOlO\
O
)
{
con\
st
flo\
at
lO\
ll\
llOOll
=
Sqrt\

(
lll\
O\
OlOlOl
)
;
y
=
-
ATa\
n\
2\

(
lOOO\
OOOO\
l\
l
.
v3Z
.
x
,
lO\
OO\
OOOOll
.
v3Z
.
z
)
;
x
=
-
AT\
an2
(
lOO\
O\
OOOOll
.
v3Z\

.
y
,
lO\
ll\
l\
lOO\
l\
l\

)
;
fl\
oa\
t
lllO\
OlO\
llO
=
lOOO\
OOOOll
.
v3Y\

.
x
*
lOOOOOO\
O\
l\
l
.
v3Z\

.
z
-
lO\
OOO\
OOOll
.
v3\
Y\

.
z
*
lOO\
OOO\
O\
Oll
.
v3\
Z
.
x
;
float\

lll\
OO\
lOll\
l
=
lO\
OO\
OOOO\
ll
.
v3Y\

.
x
*
lO\
OO\
O\
OOOll
.
v3Z\

.
x
+
lOOOO\
OOOl\
l
.
v3Y
.
z
*
lOOOOOO\
Oll
.
v3\
Z
.
z
;
float
ll\
lO\
O\
ll\
OOO
=
-
lll\
OO\
lOll\
l
*
lOOOOOOOll
.
v3\
Z
.
y
+
lOOOOOOO\
ll\

.
v3Y
.
y
*
ll\
lOOlOl\
Ol
;
z
=
-
ATan2
(
lll\
OOl\
OllO
,
lllOOll\
OOO\

)
;
}
else\

{
y
=
0.0f
;
x
=
-
ATan2
(
lOOO\
OOOOll\

.
v3Z\

.
y
,
0.0f
)
;
z
=
-
ATan\
2\

(
lOOOOO\
OOll
.
v3Y\

.
x
,
lOOO\
O\
OO\
Oll
.
v3Y\

.
z
)
;
}
}
vo\
id\

Eu\
l\
erAn\
gle\
s\

::
Up\
da\
t\
eTo\

(
const
Eule\
rAng\
l\
es
&
ll\
lOO\
l\
l\
OOl\

)
{
Eule\
rAngles
lll\
OO\
llOlO\

=
lll\
OO\
llOO\
l
;
ll\
lOO\
llOlO
.
x
=
FMo\
d\

(
lllOO\
llO\
l\
O\

.
x
-
x
+
k_\
fP\
i
,
k_fPi\

*
2.0f
)
;
if
(
lllO\
Ol\
lOl\
O
.
x
<
0.0f
)
lllOO\
llOl\
O\

.
x
+=
k_\
f\
Pi
*
2.0f
;
lllOOl\
lO\
lO
.
x
+=
x
-
k_fPi
;
TA_\
AS\
SE\
R\
T
(
lllO\
Ol\
l\
OlO\

.
x
-
x
<=
k_fPi
)
;
TA_ASSERT
(
x
-
ll\
l\
OOllOlO
.
x
<=
k_\
f\
Pi
)
;
ll\
lO\
Oll\
O\
lO
.
y
=
FMod\

(
ll\
lOO\
l\
lOlO\

.
y
-
y
+
k_fPi\

,
k_f\
Pi
*
2.0f
)
;
if
(
lll\
OOl\
l\
OlO
.
y
<
0.0f
)
ll\
l\
OO\
ll\
O\
l\
O
.
y
+=
k_\
fPi
*
2.0f
;
ll\
lO\
OllO\
l\
O\

.
y
+=
y
-
k_fPi
;
TA_ASSERT
(
ll\
lOOl\
lOlO
.
y
-
y
<=
k_fPi
)
;
TA\
_A\
SSER\
T\

(
y
-
lll\
OOll\
Ol\
O\

.
y
<=
k_fP\
i
)
;
lllOOllOlO
.
z
=
FMod\

(
lllOO\
llO\
lO
.
z
-
z
+
k_\
fPi\

,
k_fPi
*
2.0f
)
;
if\

(
lll\
OOllO\
l\
O
.
z
<
0.0f
)
lllOOllOlO
.
z
+=
k_\
f\
Pi
*
2.0f
;
lll\
OOllOlO\

.
z
+=
z
-
k_\
f\
P\
i
;
TA_AS\
SE\
RT
(
ll\
lOO\
llOlO
.
z
-
z
<=
k_fP\
i
)
;
TA\
_\
A\
SS\
ER\
T
(
z
-
lllOO\
llOlO
.
z
<=
k_fPi
)
;
Eul\
erAngles
ll\
l\
OOl\
lOll
;
ll\
lO\
OllOll
.
x
=
k_fPi
-
lllOOllOOl
.
x
;
ll\
l\
OOllO\
ll\

.
y
=
lll\
OO\
llOO\
l
.
y
+
k_\
fPi\

;
ll\
lOOllOll
.
z
=
lll\
OOl\
l\
OOl\

.
z
+
k_fP\
i\

;
Ma\
t3\
3
lllOOlllOO
(
lllOOllOll
)
;
Mat33
lllO\
O\
ll\
lO\
l\

(
lllO\
O\
l\
l\
OOl
)
;
Eule\
rAn\
g\
les\

lllOOl\
ll\
lO\

=
ll\
l\
OOl\
lO\
l\
l
;
lll\
OO\
ll\
llO
.
x
=
FMo\
d\

(
ll\
lO\
Ollll\
O\

.
x
-
x
+
k_fPi
,
k_fPi
*
2.0f
)
;
if
(
lllOO\
llll\
O\

.
x
<
0.0f
)
lllOOllllO
.
x
+=
k_f\
Pi
*
2.0f
;
lllOOllllO
.
x
+=
x
-
k_fPi
;
TA_ASS\
E\
RT\

(
lll\
OOl\
lll\
O\

.
x
-
x
<=
k_fP\
i
+
0.01f
)
;
TA_AS\
SE\
RT
(
x
-
lllOOlll\
l\
O\

.
x
<=
k_fPi
+
0.01f
)
;
lllO\
Oll\
llO
.
y
=
FMod
(
lllO\
O\
l\
lll\
O
.
y
-
y
+
k_fPi
,
k_fP\
i\

*
2.0f
)
;
if
(
lllOOl\
ll\
lO
.
y
<
0.0f
)
ll\
lOOlll\
lO
.
y
+=
k_\
fPi
*
2.0f
;
lllOOllllO
.
y
+=
y
-
k_\
f\
P\
i
;
TA\
_\
ASSERT
(
lllOOllll\
O
.
y
-
y
<=
k_fP\
i\

+
0.01f
)
;
TA_ASSER\
T\

(
y
-
ll\
l\
OO\
ll\
l\
lO
.
y
<=
k_fPi
+
0.01f
)
;
lllO\
Ol\
lllO
.
z
=
FMod
(
lllOO\
llllO
.
z
-
z
+
k_\
fPi
,
k_fPi
*
2.0f
)
;
if
(
ll\
l\
O\
O\
llllO
.
z
<
0.0f
)
lllOOll\
ll\
O
.
z
+=
k_f\
Pi
*
2.0f
;
lll\
OOlll\
lO\

.
z
+=
z
-
k_\
f\
P\
i\

;
TA_\
ASSE\
RT
(
lllOO\
llll\
O
.
z
-
z
<=
k_f\
Pi
+
0.01f
)
;
TA\
_A\
SSERT
(
z
-
lllO\
Oll\
llO
.
z
<=
k_f\
P\
i
+
0.01f
)
;
if
(
Pow2
(
lllOOll\
O\
lO
.
x
-
x
)
+
Pow\
2
(
lllOOl\
lO\
lO
.
y
-
y
)
+
Pow2
(
lllOOllOlO
.
z
-
z
)
<
Pow2\

(
lllOOllllO\

.
x
-
x
)
+
Pow2
(
lllOOl\
lllO
.
y
-
y
)
+
Pow2
(
lllOOll\
llO\

.
z
-
z
)
)
{
*
this
=
ll\
l\
OOl\
lO\
lO
;
}
else
{
*
this
=
ll\
l\
OO\
l\
lll\
O\

;
}
}
Ma\
t33
Eule\
rA\
n\
gle\
s\

::
GetAs\
Mat33\

(
)
{
Ma\
t\
33
lllOOl\
llll
(
*
this
)
;
return
ll\
lOOl\
llll
;
}
void
Eul\
e\
rAn\
g\
les
::
WrapYR\
ot\
a\
ti\
on
(
)
{
y
+=
k_\
fPi
;
y
=
FMod\

(
y
,
2.0f
*
k_fP\
i
)
;
y
-=
k_fPi
;
}
}
