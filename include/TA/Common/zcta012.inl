//---------------------------------------------------------------------------------
// File Name: zcta012.inl
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#ifndef TA_DEBUG_H
#include "Debug.h"
#endif //
na\
mespace\

TA
{
namespac\
e
lOlOOOOOlOO
{
template
<
class
Typ\
e
>
__\
fo\
rcei\
nline\

Vec\
3
lO\
lO\
OOOlOlO
<
Typ\
e
>
::
GetNormal
(
)
con\
st\

{
lOlO\
OOO\
Ol\
Ol
lO\
lOOlOO\
Oll
;
lOlO\
OlOOOll
.
x
=
lOlOO\
OOl\
Oll\

(
)
;
lOlOOlOOOl\
l
.
y
=
lOlOOOO\
llOO
(
)
;
lOlO\
O\
lO\
OOll
.
z
=
lOlOOO\
OllOl
(
)
;
fl\
oa\
t
lOl\
OOlO\
Ol\
OO
=
1.0f
/
Sq\
rt\

(
lOlO\
OlOOO\
l\
l
.
x
*
lOl\
OO\
l\
OOOl\
l
.
x
+
lO\
lOO\
lO\
O\
Oll
.
y
*
lO\
lO\
Ol\
OOO\
l\
l
.
y
+
lO\
lOOlO\
O\
Oll
.
z
*
lO\
lOOl\
OOO\
l\
l
.
z
)
;
Vec3
lOOO\
Ol\
l\
O\
l\
Ol
;
lOOOOl\
lOlO\
l
.
x
=
lOlOOlO\
O\
Oll
.
x
*
lOlO\
OlOO\
lOO
;
lOOOOll\
OlO\
l
.
y
=
lO\
l\
OO\
lOOOll
.
y
*
lO\
lO\
OlO\
OlOO
;
lOOOOl\
l\
OlOl
.
z
=
lOlOOlOO\
Oll\

.
z
*
lO\
lO\
O\
lO\
OlOO
;
ret\
urn
lOOOO\
llOlOl
;
}
temp\
l\
ate
<
cl\
ass
lOlOO\
OO\
lllO
,
clas\
s\

lOl\
OOOOl\
l\
l\
l
>
__\
for\
c\
einline\

lO\
lO\
OOllOll
<
lOlOOOOlOlO
<
lOlO\
OO\
OlllO
>
,
lOlOOO\
Ol\
OlO
<
lOlOOOO\
l\
ll\
l
>
,
lOlOlO\
O\
O\
Ol
>
oper\
a\
to\
r
+
(
con\
s\
t
lOl\
O\
OOOlOlO
<
lOl\
OOOOlll\
O
>
&
lllO\
Ol\
l\
O\
lO
,
cons\
t\

lOlOOOOlOlO
<
lOl\
O\
OO\
Ollll
>
&
lll\
OOllllO
)
{
retu\
rn
lOlO\
OOllO\
ll\

<
lOlOOOOlOlO
<
lOl\
OOO\
O\
ll\
l\
O
>
,
lO\
lOOO\
Ol\
OlO
<
lO\
lOOOOllll
>
,
lOl\
Ol\
OOOOl\

>
(
lll\
O\
OllOl\
O\

,
lllOO\
lll\
lO
)
;
}
templ\
a\
t\
e\

<
cl\
a\
s\
s\

lOl\
OO\
OO\
lllO
,
class\

lOlOOO\
Oll\
ll
>
__f\
o\
r\
ce\
inline
lOlO\
O\
OllOll
<
lOlOOOOlOlO
<
lOl\
OOOOlllO
>
,
lOlOO\
OO\
lOlO
<
lO\
lOOOOll\
ll
>
,
lO\
lOO\
O\
lO\
llO
>
operator\

-
(
co\
nst
lO\
lOOOOlOlO\

<
lOlO\
OOO\
lllO
>
&
lllOOl\
l\
OlO
,
con\
st
lOlOOOOlO\
lO
<
lOlO\
O\
OOlll\
l\

>
&
ll\
lOOllllO
)
{
re\
turn\

lO\
l\
OOOllOll
<
lO\
lOO\
OO\
lOlO
<
lO\
lOOOOll\
lO
>
,
lO\
lOOOOl\
Ol\
O\

<
lOl\
OOOOll\
ll
>
,
lOlO\
O\
OlOllO
>
(
lllOOll\
Ol\
O
,
lll\
OOlll\
lO\

)
;
}
te\
mplat\
e
<
cl\
ass
Type
>
__for\
ce\
inli\
ne
lOlOOO\
l\
ll\
ll
<
lOlOOOO\
lOl\
O
<
Type\

>
,
Mul
>
op\
era\
to\
r
*
(
con\
st
lOl\
O\
O\
OOlOlO
<
Type
>
&
lllOO\
l\
lOlO
,
floa\
t
lllOOl\
l\
l\
lO
)
{
re\
t\
urn
lO\
l\
OOOlll\
ll
<
lOlOOO\
OlOlO
<
Typ\
e
>
,
Mu\
l
>
(
lll\
O\
Oll\
OlO
,
ll\
l\
OO\
ll\
llO
)
;
}
tem\
p\
l\
a\
te
<
class
Typ\
e
>
__forcein\
lin\
e
lO\
lOOlOOOOO
<
lOl\
OO\
OOlOlO
<
Type
>
,
Mul\

>
opera\
tor
*
(
fl\
o\
at
lllOOllO\
lO\

,
const
lOl\
OOOOlOlO
<
Type
>
&
lllOOlll\
lO
)
{
return
lO\
l\
O\
OlO\
OOOO
<
lOlOOO\
OlOl\
O
<
Type
>
,
Mu\
l
>
(
lll\
OOllOlO\

,
lllOOllll\
O
)
;
}
tem\
plat\
e\

<
cla\
ss\

Type\

>
__\
force\
i\
nline
lOlOO\
Ol\
l\
lll\

<
lO\
lOO\
O\
O\
lOlO
<
Type
>
,
lOl\
OOOl\
Olll
>
operator
/
(
con\
st
lO\
l\
OO\
O\
OlOl\
O
<
Ty\
p\
e
>
&
lllOO\
l\
lOlO
,
fl\
o\
at\

lll\
OO\
llll\
O
)
{
re\
turn
lOl\
OOOlllll
<
lOlOOOOl\
O\
lO\

<
Typ\
e
>
,
lOlOO\
O\
lOlll
>
(
lll\
OOllOlO
,
lll\
OOl\
lllO\

)
;
}
temp\
l\
ate
<
class
Typ\
e\

>
__fo\
rce\
inline
lOlO\
O\
Ol\
lllO
<
lOlOOOO\
l\
OlO
<
Type
>
,
lOlOOOllOO\
O\

>
operat\
or
+
(
co\
nst\

lOlOOOOlOlO\

<
Type
>
&
lllOO\
llOlO\

)
{
re\
t\
urn
lOlOOOlll\
lO
<
lO\
l\
OOl\
OOlOl
<
Type\

>
,
lOlO\
OOllOOO
>
(
lllOOl\
lOlO
)
;
}
template
<
cla\
ss
Typ\
e\

>
__\
f\
orce\
inli\
ne
lOlO\
OOl\
lllO
<
lOl\
O\
OOOlOlO\

<
Typ\
e
>
,
lOlO\
OOllOOl
>
op\
e\
rator
-
(
cons\
t
lOlO\
OO\
OlOlO\

<
Type
>
&
ll\
lOO\
l\
l\
O\
l\
O
)
{
re\
tu\
rn\

lO\
lOOO\
llllO\

<
lOl\
O\
O\
OOl\
O\
l\
O
<
Type
>
,
lOlOOOl\
l\
OOl\

>
(
lllO\
O\
llO\
lO
)
;
}
templ\
at\
e
<
class
lOl\
OOOOl\
l\
l\
O
,
cl\
ass\

lOlOO\
OO\
llll
>
__force\
inline
boo\
l
opera\
t\
o\
r
==
(
con\
st
lO\
lOOOOlO\
lO
<
lOlO\
OOO\
lllO\

>
&
lll\
OOllO\
lO
,
co\
nst
lO\
lOO\
OOlO\
lO
<
lOlO\
O\
OOll\
ll
>
&
ll\
l\
OO\
l\
l\
llO
)
{
return
lll\
OOllOlO\

.
lOl\
OOOOlOll
(
)
==
lll\
OOllllO
.
lOlO\
O\
O\
OlOll\

(
)
&&
lllOOl\
lO\
l\
O
.
lOl\
OO\
O\
Ol\
l\
OO
(
)
==
lllO\
Ol\
ll\
lO
.
lOl\
OOOOllOO
(
)
&&
lllOO\
llOl\
O
.
lOlOOOO\
l\
l\
Ol
(
)
==
lll\
O\
O\
llllO
.
lO\
lOO\
OOllO\
l\

(
)
;
}
template
<
class
lOlOOOOlllO
,
cla\
ss
lOlOOOO\
l\
l\
ll
>
__\
for\
ceinlin\
e
bool
oper\
a\
t\
o\
r
!=
(
const\

lOlOOOOlOlO\

<
lOlOOO\
OlllO\

>
&
lllO\
O\
llO\
lO
,
cons\
t\

lO\
lOO\
OOlOlO
<
lO\
lOOOOl\
lll
>
&
lllOO\
ll\
llO
)
{
retur\
n\

lllOO\
llO\
lO
.
lOlO\
OOO\
lO\
ll
(
)
!=
lll\
OO\
llllO
.
lO\
lO\
OO\
OlOl\
l
(
)
||
lll\
OO\
llOlO
.
lOl\
OOO\
OllOO
(
)
!=
lllOOl\
lllO\

.
lOl\
OOOO\
ll\
OO
(
)
||
lll\
OOllOl\
O\

.
lOlO\
OOOll\
Ol
(
)
!=
lllOOl\
l\
llO
.
lO\
lOO\
OOllOl\

(
)
;
}
}
inl\
ine
int
Vec3
::
Ge\
tGr\
e\
a\
t\
es\
tAxi\
s
(
)
const
{
float
lO\
l\
OOOOOOOO
=
Fabs
(
x
)
;
fl\
oat
lO\
lOO\
OOOOOl
=
Fabs
(
y
)
;
float
lOlOOO\
O\
OOlO
=
Fabs
(
z
)
;
if
(
lO\
l\
OO\
OOOOO\
O
>
lO\
lOOOO\
OOOl\

)
{
if
(
lOl\
OOOOO\
OO\
O\

>
lO\
lOOOOOOlO
)
re\
tur\
n
AXIS_X
;
else\

retur\
n
AXIS_\
Z
;
}
el\
s\
e
{
if
(
lOlOO\
OOOOOl\

>
lOlOOO\
OO\
O\
lO\

)
retu\
rn
AX\
I\
S_\
Y
;
else
ret\
urn\

AXI\
S_\
Z
;
}
}
inlin\
e\

voi\
d\

Vec3
::
GetAxis\
Order
(
int\

lll\
lOO\
lO\
Ol
[
3
]
)
co\
nst
{
float
lOl\
OOOOOOOO\

=
Fabs
(
x
)
;
fl\
o\
at
lOlOOOOOOOl
=
Fa\
bs
(
y
)
;
float\

lOlOOOOOOlO
=
Fab\
s\

(
z
)
;
if\

(
lOl\
OOOO\
OOOO
>
lOlOOOOO\
OOl
)
{
if
(
lOl\
OO\
OOO\
O\
OO\

>
lOlO\
OOOOOlO
)
{
ll\
l\
lO\
O\
lO\
Ol
[
0
]
=
AXIS_X
;
if
(
lOlOOOOOO\
Ol
>
lOlOOOOOOlO\

)
{
llllOOlO\
Ol
[
1
]
=
AXIS_Y
;
llllOOlOOl\

[
2
]
=
AXI\
S_Z
;
}
el\
se
{
lll\
l\
OO\
lOOl
[
1
]
=
AXI\
S_Z\

;
llllOOlOO\
l
[
2
]
=
AX\
IS_Y
;
}
}
else
{
lll\
lOO\
lOOl
[
0
]
=
AXIS_Z\

;
lll\
lOOlO\
O\
l
[
1
]
=
AXI\
S_X\

;
ll\
llOOlO\
O\
l\

[
2
]
=
AXIS\
_Y
;
}
}
els\
e\

{
if
(
lOlOOOOOOOl\

>
lOlO\
OOOO\
O\
lO
)
{
llllO\
O\
lOOl\

[
0
]
=
AXIS_\
Y
;
if\

(
lOl\
OO\
OOOO\
O\
O
>
lOlOOOOO\
O\
lO
)
{
llllO\
O\
l\
O\
Ol
[
1
]
=
AXIS_\
X
;
lll\
lOOlOOl\

[
2
]
=
AX\
IS_Z\

;
}
else
{
llll\
O\
OlOO\
l
[
1
]
=
AXIS_Z\

;
ll\
llOO\
l\
OOl\

[
2
]
=
AX\
I\
S_X\

;
}
}
else
{
ll\
l\
lO\
O\
lOOl
[
0
]
=
AXIS\
_Z\

;
llllOOlO\
Ol\

[
1
]
=
AXIS_\
Y
;
llllOOlOO\
l
[
2
]
=
AXI\
S_\
X
;
}
}
TA_AS\
S\
E\
RT
(
Fabs\

(
Ge\
tA\
x\
is
(
llll\
OOlO\
Ol
[
0
]
)
)
>=
Fabs\

(
Ge\
tA\
x\
i\
s
(
llllO\
O\
l\
OO\
l
[
1
]
)
)
)
;
TA_\
ASSE\
RT\

(
Fabs\

(
Ge\
tA\
x\
is\

(
ll\
ll\
OO\
lO\
Ol
[
1
]
)
)
>=
Fabs\

(
Get\
A\
xis
(
llllOOl\
OOl
[
2
]
)
)
)
;
}
inl\
i\
ne
con\
st
Vec3
&
Vec3\

::
GetUn\
itVector
(
int
lOO\
OlOOlll
)
{
swit\
ch
(
lOOO\
l\
OOlll
)
{
case
AX\
I\
S\
_X\

:
return\

k_v\
3Unit\
X
;
brea\
k\

;
cas\
e
AXIS\
_Y
:
retu\
rn
k_\
v3\
U\
nitY
;
bre\
ak
;
case
AXIS_Z
:
return
k_v3Un\
itZ
;
break
;
de\
fau\
lt
:
lllOO\
O\
l\
llO
;
retur\
n
k_v3\
U\
nitX
;
}
}
}
