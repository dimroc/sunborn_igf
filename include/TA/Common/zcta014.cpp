//---------------------------------------------------------------------------------
// File Name: zcta014.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#include "MFrame.h"
na\
mesp\
ace
TA\

{
void\

MFra\
me\

::
Mirror
(
con\
st\

Ve\
c3
&
lO\
OO\
l\
lOl\
l\
l\
O
,
con\
st
Vec\
3
&
lOOO\
llOllll
)
{
lOOOOOO\
llO
(
lO\
OOll\
Ol\
llO
.
Is\
N\
or\
m\
alised
(
)
,
"MFrame::Mirror. v3DirectionToMirror isn't normalised.")
;
v3\
Tr\
an\
slati\
on
-=
2.0f
*
lOOOllOlllO
.
Dot
(
v3Transl\
ati\
o\
n\

-
lOO\
OllO\
llll\

)
*
lOOOllO\
l\
llO
;
lOOOOO\
O\
l\
lO\

(
m33Rot\
atio\
n\

.
Is\
Or\
thogona\
l
(
)
,
"MFrame::Mirror. Matrix isn't Orthogonal")
;
Mat33
lOOOlllOOOO
;
lO\
OO\
lllOOO\
O\

.
SetToLoo\
kDow\
nVecto\
r\

(
lOO\
O\
l\
lOlllO\

)
;
float
lO\
O\
Ol\
llOOOl
=
lOOOlllO\
OOO\

.
v3\
Y
.
Dot
(
m3\
3\
R\
otatio\
n\

.
v3X\

)
;
flo\
a\
t
lOOOlll\
OOlO
=
lOO\
Ol\
ll\
OOOO\

.
v3X\

.
Dot
(
m33\
Rot\
atio\
n
.
v3X
)
;
float\

lOOOlllOOll\

=
lOO\
Ol\
llOO\
OO\

.
v3X\

.
Dot
(
m33Rotat\
i\
o\
n
.
v3\
Y
)
;
float
lOOOll\
lOl\
OO
=
-
lO\
OO\
lllO\
OOO\

.
v3Y\

.
Do\
t
(
m3\
3Ro\
t\
atio\
n
.
v3Y
)
;
Ma\
t\
3\
3\

lOO\
OlllO\
lOl
;
if
(
lOOO\
ll\
lOOOl
*
lOOOlllOOOl
+
lOOOlllO\
O\
lO
*
lOO\
OlllO\
OlO
>
lOOO\
lllOO\
ll
*
lOOO\
lllOOll\

+
lOOOlllOlO\
O
*
lO\
OOlllO\
lOO
)
lOOOlllOlO\
l
.
Initialise
(
lOO\
OllOll\
l\
O\

,
AT\
an2\

(
lO\
OOlll\
OOOl
,
lOOOlllOOlO
)
)
;
else
lOOOlllO\
l\
Ol
.
Initi\
alise
(
lO\
OOllOl\
llO\

,
ATan\
2\

(
lOO\
Olll\
OOll
,
lOOOll\
lOl\
OO\

)
)
;
m3\
3R\
ot\
ation
*=
lOOO\
lll\
OlOl\

.
Get\
Tra\
nspo\
seA\
sIn\
verse
(
)
;
m3\
3\
Rot\
atio\
n
=
m3\
3Ro\
tat\
ion\

.
GetT\
ransposeA\
sI\
n\
vers\
e\

(
)
;
m33Rotatio\
n\

*=
lOOOlllO\
lO\
l\

;
lO\
O\
OO\
OOl\
lO\

(
m3\
3\
Rot\
a\
t\
io\
n\

.
IsOrt\
hogon\
al\

(
)
,
"MFrame::Mirror. Matrix isn't Orthogonal")
;
}
#define lOOOOlOllOO(lOOOllOOOl, lOOlOOlOlO) (((float*)lOOOOlOllOl)[((lOOOllOOOl) - 1) * 4 + ((lOOlOOlOlO) - 1)])
void
MF\
r\
ame
::
Ini\
ti\
al\
ise
(
D3D\
XM\
ATRIX
*
lOOO\
OlOl\
l\
O\
l
)
{
m3\
3R\
otation\

.
M11
(
)
=
lOOO\
OlO\
llOO\

(
1
,
1
)
;
m33Rotation\

.
M1\
2
(
)
=
lOOOOl\
Ol\
lOO
(
1
,
2
)
;
m3\
3Ro\
tati\
on\

.
M13\

(
)
=
lOO\
O\
O\
l\
O\
llOO
(
1
,
3
)
;
m33Rotatio\
n
.
M21
(
)
=
lOOOOl\
O\
llOO
(
2
,
1
)
;
m33\
Ro\
ta\
t\
io\
n
.
M22
(
)
=
lOO\
OOlOllOO
(
2
,
2
)
;
m33\
Ro\
ta\
ti\
on
.
M2\
3\

(
)
=
lOO\
OO\
lO\
llOO\

(
2
,
3
)
;
m3\
3\
Ro\
t\
at\
ion
.
M31
(
)
=
lOOOOlOl\
lOO
(
3
,
1
)
;
m3\
3Rot\
atio\
n
.
M32\

(
)
=
lOOOOlOl\
l\
OO
(
3
,
2
)
;
m33Rotati\
on
.
M33
(
)
=
lOOOOlOl\
lO\
O
(
3
,
3
)
;
v3Tr\
a\
nslatio\
n\

.
x
=
lOOO\
OlO\
llOO\

(
4
,
1
)
;
v3Translation
.
y
=
lOO\
OOl\
OllO\
O
(
4
,
2
)
;
v3Tr\
a\
nslati\
o\
n\

.
z
=
lO\
O\
OO\
lOll\
OO
(
4
,
3
)
;
}
voi\
d
MFrame
::
Ge\
tA\
s\
D3D\
Mat\
rix\

(
D3DXMAT\
R\
I\
X\

*
lOOOO\
l\
Ol\
lOl
)
const
{
lO\
OOO\
l\
O\
llO\
O
(
1
,
1
)
=
m33R\
otatio\
n\

.
M11\

(
)
;
lOOOOlOll\
OO
(
1
,
2
)
=
m3\
3Rotati\
on
.
M12
(
)
;
lOOO\
O\
lOl\
lOO
(
1
,
3
)
=
m33Rot\
a\
t\
ion
.
M13
(
)
;
lO\
OO\
OlO\
llOO
(
1
,
4
)
=
0.0f
;
lOOO\
OlO\
ll\
OO\

(
2
,
1
)
=
m33\
Rota\
tio\
n\

.
M2\
1
(
)
;
lOO\
OOlOl\
l\
OO
(
2
,
2
)
=
m33Ro\
tation
.
M22
(
)
;
lOOOO\
lOllOO
(
2
,
3
)
=
m33Rotation
.
M23
(
)
;
lOO\
OOl\
O\
llOO
(
2
,
4
)
=
0.0f
;
lOOOO\
lOll\
OO
(
3
,
1
)
=
m33Ro\
ta\
tion
.
M31
(
)
;
lOOOOlOll\
OO
(
3
,
2
)
=
m33R\
o\
tati\
on
.
M32
(
)
;
lOOOOlO\
ll\
OO\

(
3
,
3
)
=
m33\
Rotation
.
M33
(
)
;
lOOOOlO\
ll\
OO\

(
3
,
4
)
=
0.0f
;
lOO\
OOl\
Ol\
lO\
O
(
4
,
1
)
=
v3Tr\
an\
sla\
t\
i\
o\
n
.
x
;
lOOOOlOllO\
O\

(
4
,
2
)
=
v3Tr\
anslat\
i\
o\
n
.
y
;
lOOOO\
lO\
l\
l\
O\
O
(
4
,
3
)
=
v3T\
ranslation\

.
z
;
lO\
O\
OO\
l\
OllOO\

(
4
,
4
)
=
1.0f
;
}
#undef lOOOOlOllOO
#define lOOOlllOllO(lOOOllOOOl, lOOlOOlOlO) (((float*)lOOOlllOlll)[((lOOOllOOOl) - 1) * 4 + ((lOOlOOlOlO) - 1)])
void
MF\
rame
::
Init\
iali\
seF\
ro\
mO\
penGlMat\
r\
i\
x
(
con\
st\

float
*
lO\
OO\
l\
l\
lOll\
l\

)
{
m33\
Rota\
tion
.
M11
(
)
=
lO\
O\
Ol\
llOllO
(
1
,
1
)
;
m33Rota\
t\
ion\

.
M12
(
)
=
lOOOlllOllO
(
1
,
2
)
;
m33Ro\
tat\
ion
.
M13
(
)
=
lOOO\
lllO\
llO\

(
1
,
3
)
;
m33\
R\
o\
tatio\
n
.
M21
(
)
=
lO\
OOl\
l\
lOllO
(
2
,
1
)
;
m33Rota\
tion
.
M22
(
)
=
lOOOlllOl\
lO
(
2
,
2
)
;
m33R\
otat\
i\
on
.
M23\

(
)
=
lO\
OOl\
l\
lO\
l\
lO
(
2
,
3
)
;
m3\
3Ro\
tation\

.
M31\

(
)
=
lO\
OOl\
llOl\
lO
(
3
,
1
)
;
m33Rota\
t\
i\
on
.
M32\

(
)
=
lOOO\
lllOl\
lO
(
3
,
2
)
;
m33Rota\
tion
.
M33
(
)
=
lOOOlllOllO
(
3
,
3
)
;
v3\
Translation
.
x
=
lOOOll\
lOllO\

(
4
,
1
)
;
v3Translati\
on\

.
y
=
lO\
OO\
l\
l\
lOll\
O
(
4
,
2
)
;
v3Transla\
tion
.
z
=
lOOOl\
llO\
llO\

(
4
,
3
)
;
}
void\

MFrame
::
Get\
Op\
enGlMatrix
(
float\

*
lOOOll\
lOlll
)
con\
s\
t\

{
lO\
O\
OlllO\
l\
l\
O
(
1
,
1
)
=
m33\
R\
otati\
on
.
M11\

(
)
;
lOOOlllOl\
lO
(
1
,
2
)
=
m33Ro\
t\
at\
ion
.
M12
(
)
;
lO\
OO\
lllOllO\

(
1
,
3
)
=
m3\
3Ro\
tatio\
n
.
M1\
3
(
)
;
lOO\
Oll\
l\
O\
l\
lO\

(
1
,
4
)
=
0.0f
;
lOOOlll\
O\
l\
lO
(
2
,
1
)
=
m33Rotat\
ion
.
M21\

(
)
;
lOOOlllOllO
(
2
,
2
)
=
m33Rotation
.
M22
(
)
;
lOOO\
lllO\
llO\

(
2
,
3
)
=
m33Rot\
atio\
n\

.
M2\
3\

(
)
;
lO\
O\
Oll\
lOllO\

(
2
,
4
)
=
0.0f
;
lOOOl\
l\
l\
O\
llO
(
3
,
1
)
=
m3\
3Ro\
tation
.
M31
(
)
;
lOO\
OlllOll\
O
(
3
,
2
)
=
m33R\
otation
.
M32\

(
)
;
lO\
O\
OlllOll\
O
(
3
,
3
)
=
m33R\
otati\
o\
n\

.
M33\

(
)
;
lOO\
OlllOllO
(
3
,
4
)
=
0.0f
;
lO\
OO\
lllO\
l\
l\
O
(
4
,
1
)
=
v3Translati\
on
.
x
;
lOOOlll\
OllO
(
4
,
2
)
=
v3Trans\
lati\
o\
n\

.
y
;
lOOOl\
l\
lO\
l\
lO
(
4
,
3
)
=
v3\
T\
ran\
slation\

.
z
;
lO\
OOl\
llOll\
O
(
4
,
4
)
=
1.0f
;
}
#undef lOOOlllOllO
}
