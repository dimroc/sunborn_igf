//---------------------------------------------------------------------------------
// File Name: zcta020.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#ifndef _CRT_SECURE_NO_DEPRECATE
#define _CRT_SECURE_NO_DEPRECATE
#endif
#include "../Common/zcta015.h"
#ifndef lOOOOlOOll
#include "../Common/zcta012.h"
#endif //
#ifndef TA_ERROR_H
#include "Error.h"
#endif //
#ifndef TA_MEMORYMGR_H
#include "MemoryMgr.h"
#endif //
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
nam\
esp\
a\
ce
TA
{
Ch\
ar
lOOlllOOOl\
O\

[
4
]
=
{
0
,
0
,
0
,
0
}
;
#define lOOlllOOOll(lOOOlOllOlO, Type, lOOlllOllO)				\
{															\
	int lOOlllOOlOO = (lOOlllOllO);									\
	if (lOOlllOOlOO == 1)										\
	{														\
		lOOOlOllOlO = lOOlllOOOlO;									\
	}														\
	else													\
	{														\
		lOOOllllOO(lOOOlOllOlO, Type, lOOlllOOlOO)		\
	}														\
}
#define lOOlllOOlOl(lOOOlOllOlO, Type) { if (lOOOlOllOlO != lOOlllOOOlO) { lOlOOOlllO(lOOOlOllOlO, Type); } }
ll\
O\
lllllOO
::
llOl\
l\
ll\
l\
OO
(
)
{
lOlOOOlOO\
l
=
0
;
lOOlllOOOll
(
lO\
Oll\
lOOllO
,
Ch\
ar
,
lOlO\
OOlO\
Ol
+
1
)
;
lOO\
lllO\
O\
llO
[
0
]
=
0
;
}
llOlll\
llOO\

::
llOlllllO\
O
(
cons\
t
Char
*
lllO\
OOllOl
)
{
if
(
lllOO\
O\
llO\
l
)
{
lOlOOOlOOl
=
(
int\

)
str\
len
(
ll\
lO\
OOllOl
)
;
lOOll\
lOOOll
(
lO\
OlllOOllO
,
Char\

,
lOlOOOlOOl
+
1
)
;
memc\
py\

(
lOOlllOO\
llO
,
ll\
l\
OOOllOl
,
(
lOl\
OOOlOOl
+
1
)
*
siz\
eof
(
Char
)
)
;
}
el\
se\

{
Clear\

(
)
;
}
}
llOlllll\
OO
::
ll\
Ol\
l\
lllOO\

(
const
ll\
Olllll\
OO
&
lOOll\
l\
O\
Olll\

)
{
if
(
lOOlll\
OO\
ll\
l
.
lOl\
OOOl\
OOl
<
0
)
{
lOlOOOlOOl\

=
-
lOOlllOOll\
l
.
lOl\
O\
OOlO\
O\
l
;
lOO\
lll\
OOllO
=
lOOlll\
O\
Oll\
l
.
lOOlll\
OOllO
;
(
(
llOlll\
l\
lOO
&
)
lOOlllO\
Olll
)
.
lOlOOOlO\
Ol
=
0
;
(
(
llOlllllOO
&
)
lO\
O\
l\
l\
lOOlll
)
.
lOOlllOOl\
lO
=
0
;
}
else
{
lOlOOOl\
OOl
=
lOOlllOOll\
l
.
lOl\
O\
O\
OlOOl
;
lOO\
ll\
lOO\
Ol\
l
(
lO\
Oll\
lOO\
llO\

,
Cha\
r
,
lO\
lOOOlOO\
l
+
1
)
;
memcpy
(
lOOlllOOllO
,
lOOll\
l\
OO\
lll
.
lOOlllOOllO
,
(
lOlOOO\
lOO\
l
+
1
)
*
sizeof
(
Char
)
)
;
}
}
llOll\
lllOO
::
llOl\
l\
lllOO
(
const\

Cha\
r
*
ll\
lO\
OO\
l\
lOl
,
int
lO\
Ol\
l\
lOllO\

)
{
TA_ASSE\
RT
(
lO\
O\
lllO\
l\
lO\

>=
0
)
;
lOlOOOlOOl
=
lOOlll\
OllO
;
lOOll\
lOOOll\

(
lO\
OlllO\
Ol\
lO
,
Cha\
r
,
lOlOOO\
lO\
O\
l
+
1
)
;
in\
t
lOOOl\
l\
O\
OO\
l
=
0
;
if
(
lll\
OOOl\
lOl\

)
{
fo\
r
(
;
lll\
OOOl\
lOl
[
lO\
OOllOO\
Ol
]
&&
lOO\
Oll\
OO\
Ol\

<
lO\
O\
lll\
OllO
;
lOOO\
llOOOl
++
)
lOOlllO\
O\
llO\

[
lOO\
OllOOOl
]
=
lllOO\
Ol\
lOl
[
lOOO\
llO\
OOl
]
;
}
lO\
Ol\
llO\
Oll\
O
[
lO\
O\
Ol\
lOOOl
]
=
0
;
}
llOlllll\
O\
O\

::
llOll\
lllOO
(
in\
t
lOOl\
lO\
OlllO\

)
{
cha\
r\

lllOOOllOl\

[
128
]
;
sprintf
(
lll\
O\
OOll\
Ol
,
"%d",
lOOl\
lOO\
ll\
lO
)
;
new
(
thi\
s
)
llO\
lllllOO
(
lllOOOllOl
)
;
}
llOlllllOO\

::
llO\
ll\
l\
llOO\

(
fl\
oat
lOOO\
OOll\
l\
O
)
{
char
ll\
lO\
OOllO\
l
[
64
]
;
sprint\
f
(
lllOO\
O\
llO\
l
,
"%f",
lOOOOO\
l\
l\
lO
)
;
new
(
thi\
s
)
llOllll\
lO\
O
(
lllOOOll\
Ol
)
;
}
llOl\
ll\
l\
lO\
O\

::
~
llO\
l\
llllOO
(
)
{
if
(
lO\
Oll\
lOOllO
)
{
lO\
Olll\
OOl\
Ol\

(
lOOlll\
OOllO
,
Char
)
;
lOOlllOOl\
lO
=
0
;
}
}
void
ll\
Ol\
ll\
llOO\

::
Se\
r\
ia\
li\
se
(
Serialiser\

&
lOOOlOllOl
)
{
if\

(
lOOOlOllO\
l
.
lllOlOOl\
Ol
(
)
)
{
in\
t
lO\
Ol\
ll\
Oll\
O\

=
lO\
OOl\
llOO\
l
(
)
;
lOOOlO\
l\
lOl\

.
Se\
ria\
li\
se
(
lOO\
lllOllO
)
;
fo\
r
(
int\

lO\
O\
Ol\
lOOO\
l
=
0
;
lOOO\
l\
lOOOl
<
lOO\
ll\
lOllO
;
lO\
OOll\
OO\
Ol
++
)
{
char
lllOlOOl\
lO\

=
lOO\
lllOOll\
O
[
lOOOll\
OOO\
l\

]
;
lOOO\
lOl\
lOl
.
Se\
rialise
(
lllO\
lOOllO\

)
;
}
}
els\
e
{
int
lOO\
l\
ll\
OllO
=
0
;
lOOO\
lO\
llO\
l
.
Serial\
ise
(
lO\
Ol\
ll\
OllO
)
;
lOOl\
l\
lOlO\
OO
(
lOO\
lll\
Oll\
O
)
;
in\
t
lOOOllOOOl
=
0
;
for
(
;
lOOO\
llOOOl\

<
lO\
O\
ll\
l\
O\
llO
;
lOOOllO\
O\
Ol\

++
)
{
char\

lllOl\
OO\
llO\

;
lOOOl\
OllOl
.
Seri\
alis\
e
(
lllOlOOllO
)
;
lOOlllOOl\
lO
[
lOOOllOOOl\

]
=
lllOlOOl\
lO
;
}
lOOlllO\
Ol\
lO
[
lOOOll\
OOOl
]
=
0
;
}
}
void\

ll\
Olllll\
OO\

::
lOOl\
llOlOO\
l\

(
Serialiser
&
lOOOl\
OllOl
)
{
if
(
lOOOlO\
llOl
.
lllOlOO\
l\
Ol
(
)
)
{
int
lOOll\
l\
OllO
=
lOOOlll\
OOl
(
)
;
lOOO\
l\
O\
llOl
.
Ser\
ial\
ise
(
lO\
Olll\
OllO
)
;
int
lO\
O\
Oll\
OOO\
l
;
for
(
lOOO\
llO\
OOl\

=
0
;
lO\
O\
OllO\
OOl
<
lOOlllO\
ll\
O\

;
lOOO\
llOOO\
l\

++
)
{
char\

ll\
lO\
l\
OOl\
l\
O
=
lOOlllO\
Oll\
O
[
lOOOllOOO\
l
]
;
lOO\
OlO\
ll\
Ol
.
Serialise\

(
lllO\
lO\
Ol\
lO
)
;
}
int
lll\
OlO\
Olll
=
0
;
if
(
(
-
lOO\
OllOO\
O\
l\

)
&
4
)
lO\
OOl\
OllOl
.
lllOlO\
lOO\
O
(
&
lll\
Ol\
OOlll\

,
(
-
lO\
OOllOOOl
)
&
4
)
;
}
el\
se
{
int\

lOOlll\
Ol\
lO
=
0
;
lOOO\
lO\
l\
l\
Ol
.
Se\
rialise
(
lOO\
lllOl\
lO
)
;
lOOlll\
OlOOO
(
lOOlllOll\
O
)
;
in\
t
lOOO\
l\
lO\
OOl
;
for
(
lOOO\
ll\
O\
O\
O\
l
=
0
;
lOOOllOOOl
<
lOO\
lllOll\
O\

;
lOO\
OllO\
O\
Ol\

++
)
{
cha\
r
lllOlO\
Oll\
O
;
lOO\
OlO\
l\
l\
Ol\

.
Seria\
lis\
e
(
lllO\
lOOll\
O
)
;
lO\
O\
lll\
OO\
llO
[
lOOO\
llOOOl
]
=
lllOlO\
OllO
;
}
lO\
Ol\
llO\
OllO
[
lO\
O\
O\
llOOO\
l
]
=
0
;
in\
t
lll\
OlOOl\
l\
l
=
0
;
if
(
(
-
lOO\
OllOOOl\

)
&
4
)
lOO\
OlOl\
lO\
l
.
lll\
Ol\
OlO\
OO
(
&
lllOlOO\
ll\
l
,
(
-
lOOOllOOOl
)
&
4
)
;
}
}
bool
ll\
OlllllOO
::
operator
==
(
const
llOllll\
lO\
O
&
lOOlllOO\
lll
)
{
return
(
strcm\
p
(
lOOlll\
OOllO
,
lO\
O\
l\
llOOlll
.
lOO\
lllO\
OllO\

)
==
0
)
;
}
bool\

llO\
ll\
lllOO
::
ope\
rator\

==
(
co\
ns\
t
Char
*
ll\
lO\
OOllOl
)
{
re\
t\
ur\
n
(
str\
cmp
(
lOO\
lllO\
OllO
,
lll\
OOOllOl
)
==
0
)
;
}
bo\
o\
l
llOll\
lllOO
::
operator
!=
(
const
llOlllllOO
&
lOOl\
llOOll\
l
)
{
return
(
str\
cmp
(
lO\
OlllOO\
llO
,
lOOl\
ll\
OOll\
l\

.
lOO\
lllOOllO
)
!=
0
)
;
}
bool
llOll\
ll\
lOO
::
opera\
tor
!=
(
const
Cha\
r
*
lllOOOll\
Ol
)
{
return
(
strcmp
(
lOOl\
ll\
O\
Ol\
lO
,
lllO\
O\
O\
l\
l\
Ol\

)
!=
0
)
;
}
llOlllll\
O\
O\

&
llOlllllO\
O\

::
operator
=
(
cons\
t\

llOlllllOO
&
lO\
OlllOOll\
l
)
{
lOOlllOlO\
OO
(
lOO\
lllO\
O\
l\
ll
.
lO\
O\
Olll\
OOl
(
)
)
;
strc\
p\
y
(
lOO\
lllOOllO
,
lOOl\
l\
lO\
Olll
.
lOOl\
l\
l\
OOllO
)
;
re\
turn
*
thi\
s
;
}
llOlllllO\
O
&
ll\
Ol\
l\
lllOO
::
opera\
tor
=
(
co\
ns\
t
Cha\
r
*
lll\
O\
O\
OllOl\

)
{
if
(
lllOOOll\
Ol
==
0
)
{
Cl\
e\
a\
r
(
)
;
}
else
{
lO\
Oll\
lO\
lO\
OO\

(
(
in\
t
)
strl\
en
(
lllOOOl\
lOl\

)
)
;
str\
cp\
y\

(
lOO\
lllOOllO
,
lll\
OO\
O\
llOl
)
;
}
return\

*
this\

;
}
llO\
lllllOO
&
llO\
lllll\
OO
::
opera\
tor\

+=
(
const
llOllll\
lOO
&
lOOlllOOl\
ll\

)
{
int
lOOOl\
lOOOl
=
lOlO\
OOlOOl
;
lO\
OlllO\
lO\
OO
(
lOl\
OOOlO\
O\
l\

+
lOOl\
llOOl\
l\
l
.
lOlOOOl\
OOl
)
;
for
(
int
lOO\
l\
O\
OlO\
lO
=
0
;
lO\
O\
OllOOOl\

<
lOlOOOl\
OOl\

+
1
;
lO\
O\
OllOOOl\

++
,
lOOlOOl\
OlO\

++
)
lOOl\
l\
lO\
Ol\
l\
O
[
lO\
O\
OllOOOl
]
=
lOOll\
lOOl\
l\
l
.
lOOll\
lOOllO
[
lOO\
lO\
OlOlO
]
;
return
*
this
;
}
llOlllllOO\

&
llO\
lllllOO\

::
operat\
o\
r\

+=
(
const
Char
*
lllOOOllO\
l
)
{
int
lO\
O\
O\
llOOOl
=
lOlO\
OOl\
OO\
l
;
lOOl\
l\
l\
OlOO\
O
(
lOl\
OOOlOOl
+
(
int
)
strl\
en
(
lllOOOl\
lOl\

)
)
;
fo\
r
(
in\
t
lO\
O\
lO\
OlOl\
O
=
0
;
lOO\
Oll\
OOOl\

<
lOlOO\
OlOOl
+
1
;
lOOOllOO\
O\
l
++
,
lOO\
lO\
OlOlO
++
)
lO\
O\
lllOOll\
O
[
lO\
OOllOOOl
]
=
lllOOOllO\
l
[
lO\
OlOOl\
Ol\
O\

]
;
return
*
thi\
s\

;
}
ll\
Ol\
l\
ll\
lOO\

&
llOlllllOO
::
ope\
r\
a\
t\
or
+=
(
int
lOOllOOlllO
)
{
char
lll\
OOOl\
lOl
[
128
]
;
sp\
rint\
f
(
ll\
lOO\
OllO\
l
,
"%d",
lOOll\
OO\
lllO
)
;
*
this
+=
lllOOOll\
Ol
;
ret\
ur\
n
*
this\

;
}
llOlllllOO
&
ll\
Olll\
llOO
::
operato\
r\

+=
(
float
lO\
OOOOlll\
O
)
{
char
lllOOO\
llO\
l
[
64
]
;
spri\
n\
tf
(
lllO\
OOllOl
,
"%f",
lOOO\
OOl\
ll\
O
)
;
*
this
+=
ll\
lO\
OOl\
l\
Ol
;
return
*
th\
i\
s
;
}
llOlll\
ll\
OO
llOll\
l\
ll\
OO
::
oper\
a\
tor
+
(
cons\
t
llOllll\
l\
O\
O
&
lOOl\
ll\
O\
Olll
)
const
{
llOllll\
lOO
lO\
Ol\
llOlO\
lO
(
*
this
)
;
lOOlllOl\
OlO\

+=
lO\
Ol\
ll\
OO\
ll\
l
;
lOOlllOlOl\
O
.
lO\
lOOOlOOl\

=
-
lO\
Olll\
OlOlO
.
lOlO\
OOlOO\
l\

;
ret\
u\
rn
lOO\
l\
l\
lOlOl\
O
;
}
llOll\
lllOO\

llO\
llll\
lOO
::
opera\
to\
r
+
(
co\
ns\
t
Char\

*
lllOOO\
llOl
)
co\
n\
st
{
llO\
lllllO\
O
lOOlllOlOlO\

(
*
this
)
;
lOOlllOlOlO\

+=
lllOO\
Ol\
lOl
;
lOOl\
llO\
lOl\
O
.
lO\
l\
O\
OOlOO\
l
=
-
lOO\
lll\
Ol\
O\
lO
.
lOlO\
OOl\
OOl
;
retur\
n
lOOll\
l\
OlOlO
;
}
llOl\
llllO\
O\

TAC_CA\
L\
L
oper\
ator
+
(
const\

Char\

*
lllOOllO\
l\
O
,
cons\
t\

llO\
ll\
lllOO
&
ll\
lOOll\
ll\
O
)
{
llOlllllOO
lOO\
lllOlOlO
(
lllOOllOlO
)
;
lOOlllOlOlO
+=
ll\
lOOl\
lllO
;
lOOll\
lO\
lOl\
O
.
lOlO\
OOlOOl
=
-
lOOl\
llOl\
Ol\
O\

.
lOlOOOlOO\
l
;
return
lOOlllOl\
O\
lO
;
}
ll\
Ol\
l\
lll\
OO\

llOlllllOO
::
oper\
ator
+
(
in\
t\

lOOl\
lOOlll\
O
)
const
{
llOlllll\
O\
O
lOOll\
lOl\
O\
lO
(
*
th\
i\
s
)
;
lOOll\
lO\
lOlO
+=
lO\
OllOO\
lllO
;
lO\
Olll\
OlOl\
O\

.
lO\
lO\
OO\
lO\
Ol\

=
-
lOOl\
ll\
OlOl\
O\

.
lOl\
OOO\
lOO\
l
;
ret\
ur\
n\

lOOlllOlOlO\

;
}
llOlllllOO
llO\
lllllO\
O
::
operat\
or
+
(
flo\
at
lO\
OOO\
O\
lllO\

)
co\
ns\
t
{
llOlllll\
OO
lOOlll\
OlOlO\

(
*
th\
is
)
;
lOOlll\
OlOl\
O\

+=
lOOOOO\
lllO
;
lOO\
lllOlOlO
.
lOlOOOlOOl
=
-
lOO\
lll\
OlO\
lO
.
lOlOO\
OlO\
Ol
;
re\
tur\
n
lOO\
ll\
lOl\
Ol\
O
;
}
void
llOl\
llllO\
O
::
Clea\
r
(
)
{
lO\
OlllOlOOO
(
0
)
;
lO\
Olll\
OO\
l\
lO
[
0
]
=
0
;
}
voi\
d
llOl\
l\
lll\
OO
::
lOOll\
lO\
lO\
l\
l
(
)
{
for\

(
int
lOOOl\
lOOOl
=
0
;
lO\
OOll\
OOOl
<
lOl\
OO\
OlO\
Ol
;
lOOOl\
lOOOl
++
)
{
if
(
lO\
Ol\
llOO\
llO
[
lOOOllOOOl
]
>=
'A'&&
lOOll\
lOOll\
O\

[
lOOOll\
O\
OOl
]
<=
'Z')
lOO\
l\
llOOllO
[
lOOOllO\
OOl
]
+=
'a'-
'A';
}
}
vo\
id
llOlllllOO\

::
lOOlllO\
llOO
(
)
{
for\

(
int
lO\
O\
OllOOOl\

=
0
;
lO\
OO\
llOOOl\

<
lOlOOOlOOl
;
lOOOllOO\
Ol
++
)
{
if\

(
lOO\
l\
ll\
OOllO
[
lOOOl\
lOOOl
]
>=
'a'&&
lOOll\
l\
OOllO
[
lOOOllOO\
Ol
]
<=
'z')
lOO\
ll\
l\
O\
OllO
[
lO\
O\
Ol\
l\
O\
OOl
]
+=
'A'-
'a';
}
}
void\

ll\
Ol\
ll\
llOO
::
lO\
OlllOl\
OOO
(
int
lOOlllOll\
O
)
{
if
(
lOO\
lll\
OllO\

!=
lOlOOOl\
OOl\

)
{
Char
*
lO\
Olll\
Oll\
O\
l\

;
lO\
Oll\
lO\
O\
Oll\

(
lOOlllOllO\
l
,
Char\

,
lO\
O\
lll\
O\
llO
+
1
)
;
fo\
r
(
int\

lOOOllOOOl\

=
0
;
lOOOllO\
OOl\

<
lOlOO\
O\
l\
OOl
&&
lOOOll\
OOOl\

<
lOOl\
ll\
Ol\
lO\

;
lO\
OOl\
l\
OOOl
++
)
lOOlllO\
l\
lO\
l
[
lOOO\
l\
lOOOl
]
=
lOOlllO\
OllO\

[
lO\
OOl\
lOOO\
l\

]
;
lOOll\
lO\
Ol\
Ol
(
lOOlll\
OO\
llO
,
Char
)
;
lO\
lOOOlOO\
l\

=
lOOlllOl\
lO
;
lO\
Ol\
llOOllO
=
lOO\
l\
l\
l\
O\
llO\
l
;
}
}
}
