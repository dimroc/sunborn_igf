//---------------------------------------------------------------------------------
// File Name: zcta010.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#ifndef _CRT_SECURE_NO_DEPRECATE
#define _CRT_SECURE_NO_DEPRECATE
#endif
#include "../Common/zcta007.h"
#ifndef TA_DEBUG_H
#include "Debug.h"
#endif //
#include <stdio.h>
#include <memory.h>
#ifndef lOlOlOOllO
#include <io.h>
#endif
names\
pace
TA\

{
static\

inlin\
e
FIL\
E
*
ll\
llllllOO
(
uSiz\
e\

ll\
lllll\
lOl\

)
{
retur\
n\

(
FILE
*
)
ll\
llllllOl\

;
}
stati\
c
inline\

uSi\
ze\

ll\
lll\
llll\
O
(
FIL\
E
*
lllOOOlOlO
)
{
re\
turn
(
uSiz\
e
)
lll\
O\
OOlOl\
O\

;
}
ll\
l\
l\
llllll
::
lll\
lll\
l\
lll
(
)
{
lOOOO\
OOO\
OOO
=
0
;
}
llllllllll
::
~
llll\
ll\
llll
(
)
{
Fi\
n\
al\
ise
(
)
;
}
bool
lll\
lll\
lll\
l
::
Initialis\
e
(
const
Char\

*
ll\
lOOO\
l\
OO\
l
)
{
if\

(
lO\
O\
OOOOOOOO
!=
0
)
{
TA_A\
SSE\
RT
(
0
)
;
Finalise
(
)
;
}
FILE
*
lllOOOlO\
l\
O
=
fopen
(
lllOOO\
l\
OOl\

,
"wb")
;
if
(
!
lllOOO\
lOlO\

)
{
TA_\
AS\
SER\
T
(
0
)
;
return
fals\
e\

;
}
lOOOOOOOO\
OO
=
llllll\
l\
l\
lO
(
lllOO\
O\
lOlO
)
;
lO\
OO\
OO\
OOOOl
=
lllOOO\
l\
O\
O\
l
;
return\

true
;
}
void
lll\
llllll\
l
::
Fi\
nalise
(
)
{
TA_ASSERT
(
lOOOOOOOOOO
)
;
FI\
L\
E\

*
ll\
lOOOl\
Ol\
O
=
ll\
ll\
ll\
llOO
(
lOOOOOO\
O\
O\
OO
)
;
if
(
!
lllOOO\
l\
Ol\
O
)
re\
turn
;
fclo\
se
(
ll\
lOOO\
lO\
l\
O\

)
;
lOO\
O\
OOOOOOl
.
Cl\
e\
a\
r
(
)
;
}
voi\
d
lllllll\
lll
::
lOlO\
Ol\
lOl\
O
(
void\

*
lOO\
lllOOOO
,
int
lOOl\
ll\
OllO
)
{
TA_ASS\
E\
RT
(
lO\
O\
OO\
O\
OO\
OOO
)
;
FILE
*
lllOOOlOlO
=
llll\
ll\
llOO
(
lOO\
OOOOOOOO\

)
;
size_t
lOO\
OOOOOOl\
O\

=
fwrit\
e
(
lOOl\
llOOOO
,
lOOl\
llOl\
l\
O
,
1
,
ll\
lOOOlOlO
)
;
TA_\
AS\
SERT
(
lOOOOO\
OOO\
lO
==
1
)
;
}
lO\
OOOOOOOll
::
lOOO\
OOOOOll
(
)
{
lO\
O\
OOOOO\
l\
OO
=
0
;
lOO\
O\
OOO\
O\
l\
Ol
=
0
;
lOlOOOlOOl
=
0
;
}
lOO\
OOO\
OOOll
::
~
lOOOOOOOOll
(
)
{
Fi\
na\
lise
(
)
;
}
vo\
i\
d
lOOOO\
OOOOll
::
Init\
ial\
ise
(
void\

*
lO\
OlllOOO\
O
,
int
lOO\
lllOll\
O
)
{
TA\
_\
AS\
SE\
RT\

(
lOO\
ll\
lOOOO\

)
;
TA_AS\
SERT
(
lOOll\
lOllO\

)
;
lOOO\
OOOOlOO
=
(
u8
*
)
lOO\
l\
l\
l\
O\
OO\
O\

;
lOOOOOOOlOl
=
0
;
lOlOOO\
lOOl\

=
lOOlllO\
llO
;
}
void
lOOOO\
OOOOll\

::
Finalis\
e
(
)
{
lOOO\
OOOOl\
OO
=
0
;
lOOOO\
O\
O\
OlOl
=
0
;
lOl\
O\
OOlO\
Ol\

=
0
;
}
void
lOOOOOOOO\
ll
::
lOl\
O\
Oll\
OlO
(
void
*
lOOlll\
OO\
OO\

,
in\
t\

lO\
O\
ll\
lO\
llO\

)
{
if
(
lOOOO\
OOOlOl\

+
lOOll\
lOllO
<=
lOlOOOlOOl\

)
memc\
py
(
&
lOOO\
OOOO\
lOO
[
lOOOOOOO\
lO\
l
]
,
lOO\
lllO\
OOO
,
lOOlll\
OllO
)
;
lOO\
OOO\
OOlOl\

+=
lO\
Oll\
lOllO
;
}
lOOOOOOOl\
lO
::
lOO\
O\
OOOOllO
(
)
{
lOOO\
O\
OOOOOO
=
0
;
}
lOOOOOOOllO
::
~
lOOOOOOOl\
lO\

(
)
{
Finalise
(
)
;
}
bool
lOOO\
OOOOllO\

::
Initial\
is\
e
(
cons\
t
Char\

*
lllO\
OOl\
OOl
)
{
if
(
lO\
O\
O\
OOO\
O\
OOO
!=
0
)
{
TA_A\
SS\
ERT\

(
0
)
;
Finalise
(
)
;
}
FILE
*
ll\
l\
OOOlOlO
=
fopen
(
lllOOOlO\
O\
l
,
"rb")
;
if
(
!
lll\
OOOl\
Ol\
O\

)
{
return\

fals\
e
;
}
lO\
OOOOOOO\
OO\

=
llll\
l\
l\
lllO
(
lllO\
O\
O\
l\
OlO
)
;
lOO\
OO\
OO\
OO\
Ol\

=
ll\
lOOOlO\
Ol
;
retur\
n
tru\
e
;
}
vo\
id\

lO\
OOOOOOllO\

::
Finalise
(
)
{
if
(
lO\
O\
O\
OO\
OOOOO
)
{
FILE
*
lll\
OOOl\
Ol\
O\

=
lllll\
lllOO
(
lOOOOO\
O\
OO\
OO\

)
;
if
(
!
lllOOOlO\
lO\

)
re\
turn
;
fclos\
e
(
lllOOO\
lOlO
)
;
}
lOOO\
OOO\
OOOl
.
Cle\
ar
(
)
;
}
void\

lOOOOO\
OOl\
l\
O
::
lOlOOllOlO
(
void
*
lO\
Ol\
l\
lO\
O\
OO\

,
int
lOO\
lllO\
l\
lO
)
{
TA\
_ASSERT
(
lOOOOO\
OOOOO\

)
;
FI\
LE
*
lllOOO\
lOlO
=
lll\
l\
llllOO
(
lOOOOO\
O\
O\
OOO
)
;
siz\
e_t
lOOOOOOOOlO
=
fread
(
lOOlllOO\
O\
O
,
lOO\
lll\
O\
ll\
O
,
1
,
lllOO\
OlOlO
)
;
TA_ASS\
ER\
T
(
lOOOOOOOO\
lO
==
1
)
;
}
int
lO\
O\
O\
O\
OOOllO
::
lOlO\
O\
ll\
OOl
(
)
{
FILE\

*
lllOOOlOlO\

=
lllll\
lllOO\

(
lOOO\
OO\
OOO\
O\
O\

)
;
ret\
urn\

ftel\
l
(
lllOOOlOlO
)
;
}
int
lOOOOOOOllO
::
lOOO\
lllOO\
l
(
)
{
#ifdef lOlOlOOllO
lOO\
O\
OOOllO
(
0
,
"Error, IOStreamInputFile::GetSize() un-implemented in linux")
;
retu\
rn
0
;
#else
FIL\
E
*
ll\
lOOOlO\
lO
=
lllll\
ll\
lOO
(
lO\
OOO\
OOOOOO
)
;
retur\
n\

_f\
il\
ele\
n\
gt\
h
(
_fi\
leno
(
lllOO\
OlOl\
O
)
)
;
#endif
}
lOOO\
OOOO\
l\
ll
::
lOOOOO\
OOll\
l
(
)
{
lO\
OO\
O\
OOOlOO
=
0
;
lOO\
O\
O\
OO\
O\
lOl
=
0
;
lO\
lOO\
OlOO\
l
=
0
;
}
lOOO\
OOOOlll
::
~
lO\
O\
OOOOOlll
(
)
{
Fin\
alise\

(
)
;
}
void
lOOOOOOO\
ll\
l
::
In\
itial\
ise
(
vo\
id
*
lO\
Ol\
llOOOO
,
int\

lOO\
ll\
lO\
llO
)
{
TA\
_AS\
S\
E\
RT
(
lOOll\
lOO\
O\
O\

)
;
TA_\
A\
S\
SERT\

(
lOOlllOl\
lO
)
;
lO\
OOOOO\
OlOO\

=
(
u8\

*
)
lO\
OlllOOOO\

;
lOOOOOO\
OlOl
=
0
;
lOlOOO\
l\
OOl
=
lOO\
lllO\
llO
;
}
vo\
i\
d
lOO\
OOOO\
Oll\
l\

::
Finali\
se
(
)
{
lOO\
OOOO\
Ol\
O\
O
=
0
;
lOO\
OO\
O\
OOlO\
l\

=
0
;
lOl\
O\
OO\
lOOl
=
0
;
}
void
lOO\
OO\
OOO\
l\
ll
::
lO\
lOOllOlO
(
void
*
lO\
OlllO\
OO\
O
,
int
lOO\
l\
l\
l\
Ol\
lO
)
{
if
(
lOOOOOOOlOl\

+
lOOl\
ll\
O\
ll\
O
<=
lOlOOOlOO\
l\

)
memcpy
(
lOOlllO\
OO\
O
,
&
lOOO\
O\
OOO\
lOO
[
lOOO\
OOO\
OlOl\

]
,
lOOlll\
O\
l\
l\
O
)
;
lOOOOOOOl\
Ol
+=
lOOl\
ll\
Ol\
lO
;
}
lOOOO\
OOlO\
OO
::
lOO\
O\
O\
OO\
lOOO
(
)
{
lOlOO\
O\
lOO\
l
=
0
;
}
lO\
OOOOOl\
OOO
::
~
lOO\
OOOOl\
OOO
(
)
{
lO\
OOOOOl\
OOO
::
Fi\
nalise
(
)
;
}
vo\
id
lOOOOOOl\
O\
O\
O
::
In\
it\
ialise
(
)
{
lO\
l\
OO\
Ol\
OO\
l
=
0
;
}
void\

lOOOOOOlOOO
::
Finalise
(
)
{
lOlOO\
O\
lOO\
l
=
0
;
}
void
lO\
O\
O\
OO\
O\
lO\
OO
::
lO\
lOOl\
lOl\
O
(
void
*
lO\
O\
lll\
OOOO
,
int
lOO\
ll\
l\
OllO\

)
{
lO\
l\
O\
O\
Ol\
OO\
l
+=
lOOlllOllO
;
}
}
