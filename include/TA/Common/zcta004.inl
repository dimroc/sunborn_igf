//---------------------------------------------------------------------------------
// File Name: zcta004.inl
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#ifndef TA_DEBUG_H
#include "Debug.h"
#endif //
#ifndef TA_MATHS_H
#include "Maths.h"
#endif //
#ifdef TA_SSE2
#include <xmmintrin.h>
#include <emmintrin.h>
#endif //
na\
mespac\
e
TA\

{
#define lOOOOllOllO(lllOOllOlO, lOOOOllOlll, lllOOllllO)											\
do																					\
{																					\
	(lllOOllOlO).M11() lOOOOllOlll (lllOOllllO).M11(); (lllOOllOlO).M12() lOOOOllOlll (lllOOllllO).M12(); (lllOOllOlO).M13() lOOOOllOlll (lllOOllllO).M13();			\
	(lllOOllOlO).M21() lOOOOllOlll (lllOOllllO).M21(); (lllOOllOlO).M22() lOOOOllOlll (lllOOllllO).M22(); (lllOOllOlO).M23() lOOOOllOlll (lllOOllllO).M23();			\
	(lllOOllOlO).M31() lOOOOllOlll (lllOOllllO).M31(); (lllOOllOlO).M32() lOOOOllOlll (lllOOllllO).M32(); (lllOOllOlO).M33() lOOOOllOlll (lllOOllllO).M33();			\
} while (0)
#define lOOOOlllOOO(lllOOllOlO, lOOOOllOlll, lllOOllllO)									\
do																					\
{																					\
	(lllOOllOlO).M11() lOOOOllOlll lllOOllllO; (lllOOllOlO).M12() lOOOOllOlll lllOOllllO; (lllOOllOlO).M13() lOOOOllOlll lllOOllllO;									\
	(lllOOllOlO).M21() lOOOOllOlll lllOOllllO; (lllOOllOlO).M22() lOOOOllOlll lllOOllllO; (lllOOllOlO).M23() lOOOOllOlll lllOOllllO;									\
	(lllOOllOlO).M31() lOOOOllOlll lllOOllllO; (lllOOllOlO).M32() lOOOOllOlll lllOOllllO; (lllOOllOlO).M33() lOOOOllOlll lllOOllllO;									\
} while (0)
inline
Mat3\
3
::
Mat\
33\

(
)
{
}
in\
li\
ne\

Mat\
33
::
Ma\
t\
33
(
cons\
t
Ma\
t3\
3
&
lOOOOlllO\
Ol
)
{
lO\
OOO\
l\
lOllO
(
*
this
,
=
,
lO\
OO\
OlllOOl\

)
;
}
in\
l\
ine
Ma\
t\
3\
3
::
Ma\
t33\

(
flo\
at\

lOOOOl\
llOlO
,
flo\
a\
t
lOO\
OO\
lllO\
ll
,
float
lOOO\
Oll\
llOO
,
float
lO\
OOOllll\
Ol\

,
flo\
at
lO\
OO\
OlllllO
,
float
lOO\
OOlll\
lll
,
float\

lOOO\
l\
OO\
OOOO
,
flo\
at
lO\
OOlOO\
OOOl
,
fl\
oa\
t
lOOOl\
OOO\
Ol\
O\

)
{
M1\
1\

(
)
=
lOOOO\
lllOlO\

;
M12
(
)
=
lOOO\
Ol\
llOll
;
M13
(
)
=
lOOOOllllO\
O
;
M2\
1
(
)
=
lOOOOllll\
O\
l\

;
M22
(
)
=
lOOOOlllllO
;
M23
(
)
=
lOOOOl\
l\
llll
;
M31
(
)
=
lOOO\
lOOOOOO
;
M32\

(
)
=
lOOOlOOOO\
Ol
;
M33
(
)
=
lOO\
OlOOOOlO
;
}
inlin\
e
void\

Mat\
33\

::
In\
itia\
l\
ise\

(
Rotat\
i\
o\
n\
Axis
lOOO\
Oll\
OOOO
,
float
lO\
OOOO\
llllO\

)
{
switc\
h\

(
lO\
O\
O\
Oll\
OOOO\

)
{
cas\
e
ROTATIO\
N\
_\
AXIS\
_X
:
Sin\
AndCos
(
lOOO\
OOll\
llO\

,
M2\
3
(
)
,
M2\
2
(
)
)
;
M11
(
)
=
1.0f
;
M12
(
)
=
0.0f
;
M13\

(
)
=
0.0f
;
M2\
1
(
)
=
0.0f
;
M31\

(
)
=
0.0f
;
M32\

(
)
=
-
M23
(
)
;
M33
(
)
=
M2\
2
(
)
;
br\
ea\
k\

;
case\

ROTATION_\
AXIS\
_Y
:
SinAn\
dCos
(
lOOOO\
Ollll\
O
,
M13
(
)
,
M11
(
)
)
;
M12\

(
)
=
0.0f
;
M21
(
)
=
0.0f
;
M22
(
)
=
1.0f
;
M23
(
)
=
0.0f
;
M3\
1
(
)
=
-
M13
(
)
;
M32
(
)
=
0.0f
;
M33\

(
)
=
M11
(
)
;
br\
eak\

;
case
ROTA\
T\
IO\
N\
_AX\
IS_Z\

:
SinA\
ndCos
(
lOO\
OOOll\
l\
lO
,
M12\

(
)
,
M1\
1
(
)
)
;
M1\
3
(
)
=
0.0f
;
M21
(
)
=
-
M12
(
)
;
M22
(
)
=
M11
(
)
;
M2\
3
(
)
=
0.0f
;
M31
(
)
=
0.0f
;
M32\

(
)
=
0.0f
;
M33
(
)
=
1.0f
;
break
;
de\
fa\
ult
:
ll\
lOOOl\
l\
lO
;
}
}
in\
line
voi\
d
Mat33
::
SetToL\
oo\
k\
DownV\
ect\
or\

(
const\

Ve\
c\
3
&
lO\
O\
OlOOOO\
ll\

)
{
lOOO\
OO\
OllO\

(
lOOOlO\
O\
OO\
ll\

.
IsNo\
rmalised
(
)
,
"Mat33::SetToLookDownVector. v3Vector isn't normalised.")
;
v3Z
=
lOO\
O\
lO\
OOOll
;
int
lOOOl\
OOOlO\
O
[
3
]
;
lOO\
OlOOOOll\

.
GetA\
xisO\
rder\

(
lOOOl\
OOOlOO\

)
;
Vec3
lOOOlOOOlOl\

=
Vec3
::
Ge\
tUni\
tVe\
ctor
(
lOOOlO\
OO\
l\
O\
O
[
2
]
)
;
v3X\

=
lO\
O\
O\
lOOOOll\

.
Cr\
oss
(
lOOO\
lO\
OO\
lO\
l\

)
;
v3X
.
Nor\
malise
(
)
;
v3\
Y
=
v3\
Z
.
Cross
(
v3\
X
)
;
}
in\
line
vo\
i\
d
Mat\
33\

::
SetTo\
Loo\
kAt\

(
co\
n\
st\

Vec3
&
lOO\
O\
lOOOO\
ll
,
const
Vec3\

&
lOOO\
lO\
OOll\
O
)
{
lOOOOOO\
llO
(
lOOOlOOOOll\

.
IsNor\
ma\
l\
ised
(
)
,
"Mat33::SetToLookAt. v3Vector isn't normalised.")
;
lOOO\
OOOllO\

(
lO\
OO\
l\
OOOll\
O
.
IsN\
ormali\
sed
(
)
,
"Mat33::SetToLookAt. v3UpVector isn't normalised.")
;
v3Z
=
lOO\
Ol\
OOO\
Oll
;
v3X
=
lO\
OOlO\
O\
O\
llO
.
Cros\
s
(
lOOOlOOO\
O\
ll
)
;
flo\
at
lOllllOOll
=
v3X
.
Ge\
t\
Magni\
tude
(
)
;
if
(
lOl\
lllOO\
ll\

<
0.000001f
)
{
lOO\
O\
O\
OO\
llO
(
0
,
"Mat33::SetToLookAt. v3Vector and v3UpVector are parallel")
;
Se\
t\
T\
o\
I\
dentity
(
)
;
}
el\
se
{
v3X
/=
lOllllOOll
;
v3Y
=
v3Z
.
Cr\
o\
ss
(
v3\
X
)
;
}
}
inline\

float
&
Mat33
::
op\
erator
(
)
(
in\
t\

lOOOl\
OOOlll
,
int\

lOOOl\
OO\
l\
OOO
)
{
ret\
u\
r\
n\

(
&
v3X
)
[
lOOOlOOOlll
]
[
lOO\
OlOOl\
O\
O\
O\

]
;
}
inline
float
Mat\
3\
3
::
ope\
rator
(
)
(
int\

lOOO\
lOOOl\
ll
,
in\
t\

lO\
OOlOOl\
OOO\

)
const
{
re\
turn
(
&
v3\
X\

)
[
lOO\
OlOO\
Oll\
l\

]
[
lOOOlO\
O\
l\
OO\
O
]
;
}
inli\
ne
Vec3
&
Mat33\

::
ope\
rat\
or\

[
]
(
int
lO\
OOl\
OO\
Olll
)
{
retu\
r\
n
(
&
v3X
)
[
lOO\
OlOOOlll
]
;
}
in\
line
co\
n\
s\
t\

Ve\
c\
3\

&
Mat33
::
operator
[
]
(
in\
t
lOOO\
lOOOlll
)
const
{
re\
t\
urn
(
&
v3\
X
)
[
lOO\
OlOOO\
lll
]
;
}
inline
Mat\
33
&
Mat33
::
ope\
r\
ator
*=
(
const
Mat\
33
&
lO\
OO\
OlllOOl
)
{
MulInPl\
ac\
e
(
*
th\
is
,
lO\
OO\
Ol\
ll\
O\
O\
l
)
;
retu\
rn
*
thi\
s
;
}
inli\
ne
Ma\
t33
&
Ma\
t33
::
operator\

/=
(
co\
ns\
t
Mat\
33
&
lOOOOl\
l\
lOOl\

)
{
Mu\
lB\
y\
T\
ranspo\
seIn\
Place
(
*
this\

,
lOOOO\
lllO\
Ol\

)
;
return
*
th\
is
;
}
inli\
ne
Mat33
&
Mat\
33\

::
operator\

+=
(
con\
st
Mat33\

&
lO\
O\
OO\
ll\
lOOl
)
{
lO\
OO\
O\
llOllO
(
*
thi\
s
,
+=
,
lOOOOlllOOl\

)
;
re\
tur\
n
*
this\

;
}
in\
li\
ne\

Mat33\

&
Mat3\
3
::
operator
-=
(
co\
n\
st
Mat33\

&
lOOOOll\
lOOl
)
{
lOOOOllOll\
O\

(
*
th\
i\
s\

,
-=
,
lOO\
O\
Ol\
l\
lOO\
l
)
;
ret\
ur\
n
*
thi\
s\

;
}
inline
Ma\
t33
&
Mat33
::
ope\
ra\
tor
*=
(
float
lO\
O\
OO\
O\
lll\
O
)
{
lOOOOl\
llO\
OO
(
*
this\

,
*=
,
lO\
OOOOl\
l\
lO
)
;
return\

*
th\
i\
s
;
}
in\
li\
ne\

Mat33
&
Mat33
::
op\
era\
tor\

/=
(
fl\
oat
lOOOOO\
lllO\

)
{
lOOOO\
OlllO
=
1.0f
/
lO\
OOO\
O\
l\
l\
lO\

;
lOO\
OOll\
lOOO
(
*
th\
is
,
*=
,
lO\
OOOOll\
lO
)
;
ret\
urn
*
thi\
s
;
}
inline
con\
st
Mat33\

&
Mat\
33
::
opera\
tor\

+
(
)
co\
nst\

{
retu\
r\
n\

*
this
;
}
inline\

Mat33
Mat\
33
::
op\
er\
ator
-
(
)
co\
n\
st
{
Mat\
33
lllOOl\
llll\

;
lO\
OOO\
llOllO\

(
lllOOlllll\

,
=
,
-
*
thi\
s
)
;
ret\
u\
rn
lllOOl\
llll
;
}
inline
Mat33
Mat33
::
op\
erator
*
(
const
Mat3\
3\

&
lO\
O\
O\
Ol\
ll\
OOl
)
cons\
t
{
Mat33
ll\
lOO\
ll\
lll
;
Mu\
l
(
*
this
,
lOO\
OO\
l\
ll\
OO\
l
,
ll\
l\
OOlllll
)
;
return
lllOOl\
l\
ll\
l\

;
}
inline
Ma\
t\
3\
3
Mat33
::
ope\
rator\

/
(
const
Mat33
&
lOOOOll\
lOOl\

)
const
{
Mat\
33
lll\
OO\
llll\
l\

;
MulByTranspose
(
*
thi\
s
,
lOO\
OOll\
lOOl\

,
lllOOlll\
l\
l\

)
;
retu\
rn
lllOOlll\
ll\

;
}
inline
Mat\
3\
3
Mat33
::
operator
+
(
co\
nst
Ma\
t3\
3
&
lOO\
O\
OlllOO\
l\

)
const
{
Ma\
t33
lllOOllll\
l
;
lOOOOllO\
ll\
O
(
ll\
lOOll\
l\
ll
,
=
,
*
thi\
s
)
;
lOO\
OOllOllO
(
lllO\
Olllll
,
+=
,
lO\
OOOlll\
OOl
)
;
re\
turn
lllOO\
ll\
l\
l\
l\

;
}
in\
l\
in\
e
Mat\
33
Mat\
33
::
oper\
at\
o\
r
-
(
const
Mat\
33
&
lOO\
OOl\
l\
lOO\
l
)
con\
st\

{
Ma\
t33
ll\
lOOlllll
;
lOOO\
O\
llOll\
O\

(
ll\
lOOl\
l\
l\
ll
,
=
,
*
this\

)
;
lOOOO\
llOll\
O
(
lllO\
O\
ll\
lll
,
-=
,
lO\
OOOlll\
OOl\

)
;
return\

lllO\
O\
lll\
l\
l\

;
}
in\
lin\
e
Mat33
Mat33
::
operato\
r
*
(
float\

lO\
O\
OOO\
ll\
lO
)
const
{
Mat33
lllO\
Ol\
ll\
ll
;
lO\
O\
OOllOl\
lO
(
ll\
lOO\
l\
ll\
ll
,
=
,
*
thi\
s
)
;
lOOO\
O\
lllO\
O\
O\

(
ll\
lOOlllll\

,
*=
,
lOO\
OOOll\
lO
)
;
re\
turn
ll\
lO\
Olll\
ll
;
}
inlin\
e
Mat33
Ma\
t\
3\
3
::
opera\
to\
r\

/
(
float\

lO\
OOOOlllO
)
cons\
t
{
Mat33
lllOO\
lllll
;
lO\
OOOll\
Oll\
O
(
lllOOl\
lll\
l
,
=
,
*
thi\
s
)
;
lO\
O\
OOO\
lll\
O\

=
1.0f
/
lOOOOOl\
llO
;
lOOO\
O\
l\
llOO\
O\

(
ll\
lOOllll\
l\

,
/=
,
lO\
OOOOll\
l\
O
)
;
re\
turn
lll\
OOll\
lll
;
}
inlin\
e
Ma\
t33
ope\
ra\
tor
*
(
float
lOOOOO\
lllO\

,
cons\
t
Ma\
t33
&
lOOO\
OlllOOl
)
{
Mat3\
3
lllOOlllll
;
lOOOOllOll\
O
(
lll\
OOl\
ll\
ll\

,
=
,
lO\
OOOlllOOl\

)
;
lOOOOlllOOO
(
lllO\
O\
l\
l\
lll
,
*=
,
lOOO\
OOlllO
)
;
ret\
u\
r\
n
ll\
lOO\
lll\
l\
l
;
}
inli\
ne
Vec3
TA_F\
AST_CAL\
L
operato\
r
*
(
const
Ve\
c\
3
&
lllllll\
ll
,
cons\
t
Mat\
3\
3\

&
lllOOlll\
Ol
)
;
#ifdef TA_SSE2
lOlOlOl\
OOO\

inl\
i\
ne
vo\
i\
d
TA_\
FAS\
T\
_CALL
lO\
OOlOOlOO\
l\

(
Vec3\

*
lOl\
O\
lO\
Oll\
l\

lOOOl\
OOlOlO
,
con\
st
Vec\
3
*
lOl\
OlOOll\
l
lOO\
Ol\
OO\
lOll\

,
co\
n\
st
Mat3\
3
*
lO\
lOlOOlll\

lO\
OOlOO\
llOO
)
{
lllOO\
O\
lll\
l
(
(
voi\
d\

*
)
lOOOlOOlOlO\

!=
(
voi\
d\

*
)
lOO\
OlO\
Ol\
O\
ll
)
;
lllOOOll\
ll\

(
(
voi\
d
*
)
lOO\
O\
lOOl\
OlO
!=
(
void
*
)
lO\
OOlO\
O\
llO\
O\

)
;
lllOO\
O\
llll
(
(
void
*
)
lOOOlOOlOll
!=
(
void
*
)
lOO\
OlOO\
l\
lOO
)
;
__m\
128
lO\
OOlOOllOl
;
__\
m128
lOOOlOO\
lll\
O
;
__m\
1\
2\
8
lOO\
O\
l\
OOl\
l\
ll
;
__\
m128
lO\
OOlOlO\
OOO
;
co\
nst\

__\
m\
1\
28
lOO\
OlOlOO\
Ol\

=
*
(
const
__\
m\
128
*
lOlOlOO\
ll\
l
)
lOOO\
lO\
Ol\
Ol\
l\

;
co\
nst
__m1\
28\

lOOOlOlOOlO
=
*
(
co\
nst
__\
m\
128\

*
)
&
lOO\
O\
lOOl\
lOO
->
v3X
;
const
__m1\
2\
8
lOOOlOl\
OOl\
l\

=
*
(
const
__m12\
8
*
)
&
lOOO\
lOOllOO\

->
v3\
Y
;
con\
st\

__m\
1\
28
lOOOlO\
lO\
lOO\

=
*
(
const
__m1\
28
*
)
&
lOO\
OlOO\
llOO
->
v3\
Z
;
lOOOlO\
OllO\
l
=
(
__m12\
8
&
)
_mm_shuffle_epi32\

(
(
co\
nst
__\
m128i\

&
)
lOOOl\
Ol\
O\
O\
Ol\

,
_MM_S\
HUF\
FL\
E
(
0
,
0
,
0
,
0
)
)
;
lOOOlO\
Oll\
lO\

=
(
__m128
&
)
_mm\
_shuff\
l\
e_\
epi32
(
(
const\

__m\
12\
8i\

&
)
lO\
O\
Ol\
OlO\
OOl\

,
_MM\
_\
SHUFFLE
(
1
,
1
,
1
,
1
)
)
;
lO\
OOl\
OOllll
=
(
__m\
12\
8
&
)
_mm_\
shuffl\
e_\
epi\
3\
2
(
(
const
__m\
1\
28i
&
)
lO\
OOlOl\
OOOl
,
_MM\
_S\
H\
UFF\
LE
(
2
,
2
,
2
,
2
)
)
;
lO\
OO\
lOlO\
OOO\

=
_mm\
_\
mul\
_\
p\
s\

(
lO\
OOlOOllOl\

,
lOOOlO\
lO\
OlO
)
;
lOOOlOOlll\
O
=
_mm\
_mul_p\
s
(
lOO\
O\
lOOlllO
,
lOOOlOlOOll
)
;
lOOOlOOllll
=
_mm_\
mul\
_p\
s
(
lO\
O\
Ol\
OO\
l\
lll
,
lOOOl\
O\
lOl\
OO\

)
;
lOO\
Ol\
O\
lOOO\
O
=
_m\
m_add\
_ps
(
lO\
OO\
l\
OlOOOO
,
lOO\
OlO\
Olll\
O
)
;
lOOOlOlOOOO
=
_mm_add\
_ps
(
lOO\
OlOl\
OOOO
,
lOOOlO\
Ollll
)
;
*
(
__m128\

*
)
lOOOlO\
OlOlO
=
lO\
OOl\
OlOO\
OO
;
}
#endif
#ifdef TA_SSE2
lOlOlO\
lOO\
l
Vec3\

TA_\
FAS\
T_CA\
LL
operator
*
(
co\
n\
s\
t
Vec\
3
&
lllllllll
,
co\
nst\

Mat33
&
ll\
lOOl\
llOl
)
{
Vec3\

lOO\
O\
lOlOlOl
;
lOOOlO\
OlOOl
(
&
lOO\
OlOl\
OlOl
,
&
lllllllll\

,
&
lllOOlllOl
)
;
return\

lOOOlOlOlOl
;
}
#else
inline
Vec\
3\

TA_FA\
ST_\
C\
ALL\

opera\
tor
*
(
co\
nst\

Vec3
&
llllllll\
l
,
cons\
t
Mat33
&
lllOOlllOl
)
{
Vec3
lOOO\
l\
OlO\
l\
O\
l
;
lO\
OOlOl\
O\
lOl
.
x
=
llll\
lllll\

.
x
*
lll\
O\
OlllOl
.
M11
(
)
+
llllllll\
l
.
y
*
ll\
l\
O\
Ol\
llOl
.
M21
(
)
+
lllllllll
.
z
*
lllOOlllO\
l\

.
M31
(
)
;
lOOOl\
Ol\
OlOl\

.
y
=
lllllll\
ll
.
x
*
lllOO\
ll\
lOl
.
M12
(
)
+
lllllll\
ll\

.
y
*
lllOOlllO\
l\

.
M22
(
)
+
ll\
l\
l\
lll\
ll
.
z
*
ll\
l\
OOll\
lO\
l
.
M3\
2
(
)
;
lO\
OOlOlOlO\
l\

.
z
=
lll\
llllll\

.
x
*
lllOOlllOl
.
M13\

(
)
+
lllllllll
.
y
*
lllOOl\
llO\
l
.
M23
(
)
+
ll\
l\
ll\
l\
lll
.
z
*
lllOOl\
l\
lOl
.
M33
(
)
;
retur\
n
lOOOlOlOlOl
;
}
#endif
in\
l\
ine\

Ve\
c3
oper\
a\
t\
or
/
(
con\
st\

Vec\
3
&
lllllllll
,
cons\
t
Mat\
33
&
lll\
OO\
lllOl
)
{
Vec3
lOOOl\
O\
lOlOl
;
lOO\
OOOOllO
(
lllO\
O\
lllOl
.
IsOrth\
o\
gon\
al
(
)
,
"Vec3 operator / (const Vec3& v3A, const Mat33& m33B). The matrix is not orthogonal.\n""(operator / assumes orthogonal for speed)")
;
Ma\
t3\
3\

::
MulB\
y\
T\
r\
a\
n\
spos\
e
(
lllllll\
ll
,
lllOOl\
llOl\

,
lOOOlOlO\
l\
Ol
)
;
return\

lOOOlO\
l\
Ol\
Ol\

;
}
in\
line
Ve\
c3
&
op\
erat\
or
*=
(
Vec\
3
&
llllll\
l\
l\
l
,
const
Mat\
33\

&
lllOOlllO\
l
)
{
ll\
ll\
lllll
=
llllll\
ll\
l
*
ll\
l\
O\
Ol\
ll\
Ol
;
return
lllllllll
;
}
in\
line\

Vec3
&
operat\
or
/=
(
Ve\
c3
&
lll\
lllll\
l
,
cons\
t
Mat33
&
lll\
OOlllOl\

)
{
lll\
llll\
l\
l
=
ll\
l\
llllll
/
lllOOll\
lO\
l
;
return
llllll\
lll
;
}
inline\

bool
Ma\
t33\

::
operat\
o\
r
==
(
const
Mat\
3\
3\

&
lOOOOll\
lO\
Ol
)
cons\
t
{
return\

v3\
X
==
lOOOOlllOOl
.
v3X
&&
v3Y\

==
lO\
OO\
O\
lllOOl
.
v3Y\

&&
v3Z
==
lOOOOlll\
OOl
.
v3\
Z
;
}
inl\
ine\

bool\

Mat33
::
oper\
a\
tor\

!=
(
co\
nst\

Mat33
&
lO\
OOOll\
lOOl
)
cons\
t
{
re\
turn\

v3\
X
!=
lOOOO\
lllOOl
.
v3\
X
||
v3Y
!=
lOOO\
O\
lllO\
Ol
.
v3\
Y\

||
v3Z
!=
lOOOOll\
l\
OOl
.
v3Z
;
}
inline
flo\
at\

Mat33
::
Get\
De\
te\
rm\
inan\
t
(
)
co\
nst
{
lOlOOlO\
OOl
(
"Mat33::GetDeterminant. Not implemented.")
;
retur\
n
1.0f
;
}
inli\
ne
flo\
at
Ma\
t\
33
::
GetD\
eterminant\

(
co\
ns\
t
Ma\
t33\

&
lO\
OOOlllOOl
)
{
retu\
rn
lOO\
O\
OlllOOl
.
GetDete\
r\
min\
a\
nt
(
)
;
}
inli\
ne
voi\
d
Mat3\
3\

::
Inver\
t
(
)
{
*
this
=
GetIn\
v\
er\
s\
e
(
)
;
}
inline
Ma\
t\
33
Mat3\
3
::
Ge\
tIn\
verse\

(
cons\
t
Mat3\
3
&
lOOO\
Olll\
OOl
)
{
re\
tur\
n\

lO\
OOOlllOOl\

.
Ge\
tIn\
ve\
rs\
e
(
)
;
}
inline
Ma\
t3\
3
Mat\
3\
3
::
Get\
Inverse
(
)
cons\
t\

{
Mat\
33
lOOOlO\
l\
OllO\

;
lOO\
OlO\
l\
O\
llO
.
M11
(
)
=
(
M2\
2
(
)
*
M33
(
)
-
M32
(
)
*
M23
(
)
)
;
lOOOlO\
lOllO\

.
M2\
1
(
)
=
-
(
M21
(
)
*
M3\
3
(
)
-
M31
(
)
*
M23
(
)
)
;
lOO\
OlOlO\
llO
.
M3\
1\

(
)
=
(
M21
(
)
*
M3\
2\

(
)
-
M31\

(
)
*
M22
(
)
)
;
fl\
o\
at
lOO\
O\
l\
OlOll\
l\

=
M11
(
)
*
lO\
OOlO\
l\
Ol\
lO\

.
M11\

(
)
+
M12
(
)
*
lOOOl\
Ol\
Ol\
lO
.
M21
(
)
+
M13
(
)
*
lOO\
O\
lOlOllO
.
M3\
1\

(
)
;
lOOOO\
OOllO\

(
lO\
OOlO\
l\
Olll
!=
0.0f
,
"Mat33::GetInverse. The matrix is singular.")
;
lOOO\
l\
OlOllO\

.
M12\

(
)
=
-
(
M12
(
)
*
M33\

(
)
-
M3\
2
(
)
*
M13
(
)
)
;
lO\
O\
O\
lO\
lOllO
.
M22\

(
)
=
(
M11\

(
)
*
M33
(
)
-
M31
(
)
*
M13
(
)
)
;
lOOOl\
O\
lOl\
lO
.
M32
(
)
=
-
(
M11\

(
)
*
M32
(
)
-
M3\
1
(
)
*
M12
(
)
)
;
lOOOlOlOl\
lO
.
M13
(
)
=
(
M12
(
)
*
M23
(
)
-
M22
(
)
*
M13
(
)
)
;
lOOOlOlO\
ll\
O\

.
M2\
3
(
)
=
-
(
M11
(
)
*
M23
(
)
-
M21
(
)
*
M13\

(
)
)
;
lOOOlOlOllO
.
M33
(
)
=
(
M1\
1\

(
)
*
M22
(
)
-
M21
(
)
*
M1\
2
(
)
)
;
float\

lOOOl\
Ol\
lOOO\

=
1.0f
/
lOO\
OlO\
lO\
l\
ll
;
lOOOlOlOllO
*=
lOOO\
lOllOOO
;
ret\
urn\

lO\
OOl\
OlOll\
O
;
}
inline
voi\
d
Mat33
::
Or\
thogonalise\

(
)
{
lOOOOOOllO
(
!
v3X
.
IsZero
(
)
,
"Mat33::Orthogonalise. Orthogonalise Failed")
;
v3\
X
.
Nor\
ma\
lis\
e
(
)
;
v3Y
=
v3X
.
Cross
(
v3\
Y
)
.
Cr\
oss\

(
v3X\

)
;
lO\
OOOOOll\
O
(
!
v3Y
.
IsZ\
ero\

(
)
,
"Mat33::Orthogonalise. Orthogonalise Failed")
;
v3Y\

.
Normali\
se
(
)
;
v3\
Z\

=
v3\
X
.
Cro\
ss
(
v3Y
)
;
}
inli\
ne
boo\
l\

Mat3\
3
::
IsOrtho\
gona\
l
(
)
const
{
co\
nst
fl\
oat
lOOO\
l\
Ol\
lO\
O\
l\

=
0.005f
;
flo\
at\

lO\
O\
OOOl\
l\
l\
O
=
Vec3
::
Dot
(
Ve\
c3
::
Cross\

(
v3X
,
v3Y\

)
,
v3Z
)
;
float
llOllO\
l\
ll\
O
=
Fa\
bs
(
lO\
OOOOll\
l\
O\

-
1.0f
)
;
re\
turn
llO\
ll\
Oll\
lO
<
lO\
OOlO\
l\
l\
OO\
l\

;
}
inl\
i\
ne\

void
Ma\
t3\
3
::
Set\
ToIden\
tit\
y\

(
)
{
M11\

(
)
=
1.0f
;
M12
(
)
=
0.0f
;
M13
(
)
=
0.0f
;
M2\
1
(
)
=
0.0f
;
M22
(
)
=
1.0f
;
M23
(
)
=
0.0f
;
M31
(
)
=
0.0f
;
M32\

(
)
=
0.0f
;
M33
(
)
=
1.0f
;
}
inl\
ine\

Mat3\
3\

Mat\
3\
3
::
Get\
Id\
en\
t\
i\
t\
y
(
)
{
Mat33
lllOOl\
llll
;
lllOO\
llll\
l
.
SetToI\
d\
entity
(
)
;
retu\
rn\

lllO\
O\
llll\
l\

;
}
inline\

void
Mat\
33\

::
Tran\
spose\

(
)
{
*
this
=
GetTra\
nspo\
s\
e
(
)
;
}
inline
Mat3\
3\

Mat33
::
Get\
Tra\
nspos\
e
(
const
Mat3\
3\

&
lOOOO\
lllO\
Ol
)
{
retu\
rn\

lOOOOlllO\
Ol\

.
Ge\
tTrans\
pos\
e
(
)
;
}
inli\
ne
Ma\
t33
Ma\
t33
::
GetTransp\
ose
(
)
const
{
Mat33
lllOOl\
llll
;
lllOOlllll
.
M11
(
)
=
M11
(
)
;
lllOOl\
llll
.
M12
(
)
=
M2\
1
(
)
;
ll\
lOOll\
l\
ll\

.
M13
(
)
=
M31
(
)
;
ll\
l\
O\
Ol\
l\
lll\

.
M21\

(
)
=
M12\

(
)
;
ll\
lOOlllll\

.
M22
(
)
=
M22
(
)
;
lllOOll\
ll\
l
.
M2\
3\

(
)
=
M32\

(
)
;
ll\
lOOll\
ll\
l
.
M31\

(
)
=
M13
(
)
;
lllO\
O\
l\
l\
l\
l\
l
.
M3\
2\

(
)
=
M23\

(
)
;
lll\
O\
O\
l\
llll
.
M3\
3
(
)
=
M33
(
)
;
return
lllOOlll\
ll
;
}
inl\
i\
ne
vo\
i\
d
Mat3\
3
::
Tr\
ans\
poseAsIn\
ver\
t
(
)
{
*
this
=
Ge\
t\
Tran\
s\
poseA\
s\
Inverse
(
)
;
}
inlin\
e
Mat3\
3\

Mat33
::
GetTr\
ans\
poseAsInvers\
e\

(
con\
s\
t\

Mat33\

&
lO\
OOO\
l\
l\
lO\
Ol
)
{
return\

lO\
OOO\
l\
ll\
OOl
.
Ge\
tTra\
ns\
poseAsI\
nver\
se
(
)
;
}
inl\
i\
n\
e\

Mat33\

Ma\
t3\
3\

::
GetTransposeA\
sInve\
rse
(
)
cons\
t
{
lO\
OO\
OOOl\
lO\

(
IsO\
rt\
hog\
onal\

(
)
,
"Mat33::GetTransposeAsInverse. The matrix is not orthogonal.")
;
return
GetTr\
an\
spose\

(
)
;
}
}
