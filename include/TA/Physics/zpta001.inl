//---------------------------------------------------------------------------------
// File Name: zpta001.inl
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

nam\
espace
TA
{
in\
li\
n\
e
Collisio\
n
::
Co\
l\
lis\
ion
(
)
{
Cl\
e\
ar
(
)
;
}
inl\
ine\

con\
st
Vec3
&
Coll\
i\
sio\
n
::
Ge\
tP\
osi\
tion
(
)
co\
ns\
t
{
ret\
u\
rn\

lOOOOll\
ll\
l\

;
}
in\
l\
in\
e
void
Col\
lision
::
SetPosi\
ti\
o\
n
(
cons\
t
Vec3\

&
lOOOOl\
ll\
ll
)
{
this
->
lO\
OOOlllll
=
lO\
O\
O\
Oll\
lll
;
}
inl\
ine\

const
Ve\
c3
&
Col\
l\
ision
::
GetN\
orm\
al
(
)
const\

{
return\

lOOOlOO\
O\
O\
O\

;
}
in\
li\
ne\

vo\
i\
d\

Co\
ll\
ision\

::
Se\
tNormal
(
const
Vec\
3
&
lO\
OOlOO\
OOO
)
{
thi\
s
->
lO\
OOlOOOOO
=
lOOOlOO\
OOO
;
}
inli\
ne
DynamicOb\
je\
ct
*
Coll\
isio\
n\

::
Ge\
tObje\
c\
tA
(
)
con\
st\

{
re\
t\
urn\

lOllOOO\
l\
Oll\

;
}
inlin\
e\

Dynami\
cO\
bject
*
Co\
l\
lisi\
on
::
GetO\
b\
jec\
tB
(
)
const
{
retu\
rn
lOllOOOllOO
;
}
inl\
ine
void\

Co\
llision
::
SetObjec\
tA\

(
Dyna\
micObject
*
lOlllOOO\
llO
)
{
lOllOO\
OlO\
ll
=
lOlll\
O\
O\
O\
ll\
O\

;
}
inline\

voi\
d\

Colli\
sio\
n\

::
SetObj\
ectB\

(
Dy\
na\
mic\
Obj\
ect
*
lOl\
ll\
O\
OOllO
)
{
lOllOOOllOO
=
lOlllOOOllO\

;
}
inli\
n\
e
Co\
l\
lis\
ionObj\
ect
*
Collision
::
Ge\
t\
Co\
lli\
s\
ion\
ObjectA
(
)
{
if
(
lOlOl\
l\
OOOl
&
(
Col\
l\
ision
::
FLAG_\
J\
OIN\
T
|
FLAG\
_JOIN\
T_LIM\
I\
T
)
)
retur\
n
0
;
return
lOllOOOll\
Ol
;
}
inline\

Co\
llisionO\
bject\

*
Col\
lisi\
on
::
GetCo\
lli\
si\
o\
nOb\
jectB
(
)
{
if\

(
lO\
l\
Ol\
lOOOl
&
(
Co\
lli\
s\
ion\

::
FLAG_\
J\
OINT\

|
FLAG_JOINT_LIMIT
)
)
ret\
urn
0
;
retur\
n
lOllOOOlll\
O
;
}
inlin\
e\

const
Co\
lli\
s\
io\
nOb\
jec\
t
*
Co\
llis\
io\
n
::
Get\
Collision\
O\
bj\
ectA
(
)
co\
nst
{
return
lOllOllOOl\
l
(
)
->
GetCo\
llis\
io\
nOb\
ject\
A
(
)
;
}
inl\
i\
n\
e\

con\
s\
t
Collisio\
nO\
bject
*
Coll\
isi\
o\
n
::
Ge\
t\
Co\
ll\
isio\
nObjectB
(
)
const
{
return
lOllO\
llOOll
(
)
->
GetC\
o\
ll\
i\
si\
o\
nOb\
j\
ec\
tB
(
)
;
}
inline
vo\
i\
d
Col\
lision\

::
Se\
t\
Collisi\
o\
n\
Object\
A
(
Co\
llis\
ion\
Obj\
ect
*
lOllOOO\
l\
lOl
)
{
TA_AS\
SE\
RT\

(
(
lO\
lO\
llOOOl
&
(
Co\
lli\
sion
::
FLA\
G\
_JOIN\
T
|
FLA\
G_JO\
INT_L\
I\
MIT
)
)
==
0
)
;
thi\
s
->
lO\
llOOOllO\
l
=
lOl\
l\
OOOllOl
;
}
inlin\
e
void
Co\
llisio\
n\

::
SetCo\
lli\
si\
onO\
bjectB
(
Collis\
io\
nObject\

*
lOll\
OO\
OlllO\

)
{
TA_ASSERT
(
(
lOl\
OllOO\
Ol
&
(
Collision
::
FLA\
G_JOINT\

|
FL\
AG_JOINT_LIMIT
)
)
==
0
)
;
this\

->
lOl\
lOO\
O\
lll\
O
=
lO\
ll\
OO\
OlllO
;
}
inline
in\
t
Col\
li\
sion
::
Ge\
tF\
lag\
s\

(
)
cons\
t
{
retu\
r\
n
lO\
l\
OllOO\
Ol
;
}
inlin\
e
void
Collis\
ion\

::
SetF\
lags
(
u32
lOlOl\
l\
OOOl
)
{
this
->
lOlOllOO\
Ol
=
lOlOllO\
O\
Ol\

;
}
inline
u32
&
Colli\
s\
ion\

::
Flags
(
)
{
re\
turn\

lOlOl\
lOOOl\

;
}
in\
l\
ine\

float
Collision\

::
GetRest\
itution
(
)
co\
nst\

{
re\
tu\
rn\

lO\
l\
lOO\
lOO\
ll
;
}
inl\
in\
e
void
Colli\
sion
::
Se\
tRest\
itut\
ion
(
float\

lOl\
lOOlOOl\
l
)
{
th\
is
->
lO\
ll\
OO\
lOO\
l\
l
=
lOl\
l\
OOlOOll
;
}
in\
line
fl\
oat\

Collision
::
GetImpulse\

(
)
const
{
ret\
urn
lOllOOl\
OOlO
;
}
inli\
ne
vo\
id\

Coll\
ision
::
SetIm\
pulse
(
float
lOl\
l\
OOlO\
OlO
)
{
this
->
lO\
llOO\
lO\
Ol\
O\

=
lOll\
OOlOOlO
;
}
inl\
ine
floa\
t
Coll\
is\
io\
n
::
GetF\
ri\
ct\
i\
onCoe\
ffi\
cien\
t
(
)
con\
st
{
return\

lO\
llO\
O\
lOlO\
O
;
}
in\
l\
in\
e\

voi\
d
Co\
llisi\
on
::
SetF\
ri\
cti\
o\
nCoe\
ffic\
ient
(
flo\
a\
t
lOllOOl\
OlOO
)
{
this\

->
lOl\
lOO\
lOlOO\

=
lOllOOl\
Ol\
OO
;
}
in\
line
float
Colli\
sion
::
GetT\
ime\

(
)
cons\
t\

{
ret\
urn\

ll\
lOllllOO
;
}
inline\

void
Coll\
ision
::
SetTi\
me
(
fl\
oat
lllO\
lll\
l\
OO
)
{
thi\
s
->
ll\
lOl\
lll\
OO
=
lllOllllO\
O\

;
}
inl\
i\
ne
float\

Col\
lisi\
o\
n
::
Ge\
tInters\
e\
c\
tin\
gDe\
pth
(
)
co\
nst
{
re\
turn
lOllOOl\
OOO\
l
;
}
inline
vo\
id
Collision
::
SetIntersectin\
gD\
e\
pth
(
fl\
oat\

lOllOOlOOO\
l
)
{
this
->
lOllOO\
lOOOl
=
lOllOOl\
O\
OOl
;
}
inline
u3\
2
Colli\
sion
::
GetColli\
sionIdA
(
)
const
{
return
lOl\
lOl\
l\
OOOl
;
}
inlin\
e
void
Collision
::
Se\
tCollis\
io\
nIdA
(
u32
lOl\
lOllOO\
O\
l
)
{
this
->
lOll\
OllOOOl
=
lOllOllOOOl
;
}
inline
u32
Collisi\
on
::
Ge\
tC\
o\
l\
l\
isi\
onId\
B\

(
)
con\
st
{
ret\
ur\
n
lOll\
O\
llO\
OlO
;
}
inlin\
e\

voi\
d\

Coll\
ision
::
SetC\
ollis\
io\
nIdB
(
u32
lOl\
lO\
ll\
O\
OlO
)
{
this
->
lO\
llOl\
lOOlO
=
lOllOl\
lOOlO
;
}
inline
u32
Collisio\
n
::
GetA\
tt\
ri\
bute\
A\

(
)
cons\
t\

{
retur\
n\

lOllOOOllll
;
}
inli\
ne
voi\
d
Coll\
isio\
n
::
SetA\
t\
trib\
uteA
(
u32\

lOllO\
O\
O\
lll\
l
)
{
this\

->
lO\
l\
lOOOll\
ll\

=
lOl\
lOOOll\
ll\

;
}
in\
line
u32\

Col\
lis\
ion
::
Get\
Att\
ri\
but\
eB
(
)
cons\
t\

{
return
lO\
llOOlOOO\
O
;
}
inli\
n\
e
vo\
id\

Co\
l\
l\
i\
s\
i\
o\
n
::
Se\
t\
Attri\
but\
eB
(
u32
lO\
ll\
OOlOOOO
)
{
thi\
s\

->
lOllOOlO\
OOO
=
lOll\
O\
OlOOOO
;
}
inline
PhysicsJoint
*
Colli\
sion\

::
GetJoin\
t
(
)
{
if
(
(
lOlOllOOOl
&
(
Co\
llisi\
on\

::
FLAG_JOIN\
T\

|
FLAG_J\
O\
IN\
T_LIMIT
)
)
==
0
)
re\
tur\
n
0
;
return
(
Physics\
Join\
t
*
)
lOl\
l\
O\
OOll\
Ol\

;
}
inl\
ine
co\
nst
PhysicsJoi\
nt
*
Co\
l\
lision
::
GetJo\
in\
t\

(
)
cons\
t
{
lOllO\
llOOll
(
)
->
GetJoint
(
)
;
}
inli\
n\
e
boo\
l
Co\
ll\
isi\
on
::
Co\
ll\
ision\
O\
ccu\
rred
(
)
co\
nst
{
return
(
lOlOllO\
OOl\

&
FLA\
G_C\
OLL\
IS\
I\
ON_OCCURR\
E\
D
)
!=
0
;
}
inli\
ne
Collision\

*
Collision
::
GetNe\
xt
(
)
{
return
lOOOO\
OOll\
l\
l\

;
}
in\
line\

voi\
d
Collisio\
n\

::
Ini\
tia\
lise
(
Type
lOlllOOOl\
ll
,
floa\
t
lOllOOll\
Ol\
O
,
fl\
oat\

lO\
llOO\
llO\
l\
l\

,
const\

Vec3
&
lOll\
O\
OlllOO
,
cons\
t
Vec3\

&
lO\
llO\
Oll\
lOl
,
Physics\
Joi\
nt
*
lOlll\
OOlOO\
O
)
{
if
(
lOlllOOlOO\
O
==
0
)
{
TA\
_A\
S\
S\
E\
RT
(
lO\
lll\
O\
OOll\
l
!=
lOllOOll\
l\
l\
l
)
;
TA_ASSE\
R\
T\

(
lO\
lllOO\
Olll
!=
lOl\
lO\
lO\
OOOO
)
;
TA_AS\
SE\
RT
(
lOll\
lOO\
Olll
!=
TYP\
E\
_\
ROTA\
T\
ION\
_\
CON\
STRAI\
NT\

)
;
TA\
_AS\
S\
ER\
T
(
lOlllOOOll\
l
!=
lOll\
OlOOOOl
)
;
lOl\
l\
OO\
O\
llOl
=
0
;
}
else
{
TA_ASSERT\

(
lOl\
l\
lO\
OOlll\

==
lO\
llOO\
lllll
||
lOl\
llO\
O\
Ol\
ll
==
lOl\
l\
O\
l\
OOOOO
||
lOl\
ll\
O\
OO\
lll
==
TYPE_\
ROTAT\
IO\
N_\
CONSTRAI\
NT
||
lOlll\
OOO\
ll\
l
==
lOl\
lOlOOOOl
)
;
lOl\
l\
OOO\
llOl\

=
(
Collisi\
onObje\
ct
*
)
lOlll\
OOlO\
OO
;
}
lOl\
lOOO\
lllO
=
0
;
lllOll\
ll\
OO
=
lOllOOllOlO
;
lOllOO\
lOO\
Ol\

=
lOllOO\
l\
lO\
ll\

;
lO\
OOOlll\
ll
=
lOllO\
O\
l\
llOO
;
lO\
OOlOO\
OO\
O
=
lOl\
lOOlll\
Ol
;
lOl\
lO\
OOllll
=
0
;
lOllOO\
lOOO\
O
=
0
;
lOOOOOO\
ll\
ll
=
0
;
lOlOllOO\
Ol
=
lO\
lllOOOlll\

;
lO\
llOOl\
O\
l\
lO
.
Cle\
ar\

(
)
;
lOll\
O\
Ol\
Ol\
l\
l
.
Cl\
ear
(
)
;
}
in\
lin\
e
const
Dy\
na\
m\
icObject
*
PreColli\
s\
ion\

::
Get\
Obj\
ectA
(
)
const
{
ret\
u\
rn
lOlllO\
OOlO\
l
.
GetObjectA
(
)
;
}
in\
line\

co\
nst
DynamicObj\
ect
*
PreColl\
ision
::
Get\
O\
b\
j\
ectB
(
)
const
{
retu\
rn
lOl\
llOOOl\
Ol
.
GetObject\
B
(
)
;
}
inl\
ine
con\
st
Collision\
Obj\
ect
*
PreCollisi\
on\

::
Get\
C\
oll\
isionObj\
ect\
A\

(
)
const
{
re\
turn\

lO\
lll\
OOOlOl
.
Get\
Coll\
isionOb\
j\
ectA
(
)
;
}
inline
const\

Coll\
isionObj\
ect
*
PreC\
ol\
l\
isio\
n
::
GetColli\
s\
i\
on\
O\
bje\
c\
tB
(
)
const
{
retu\
rn
lO\
lllOOOlOl\

.
Get\
C\
ol\
lisionObje\
ct\
B
(
)
;
}
in\
li\
ne
cons\
t\

Physic\
sJoint
*
Pre\
Colli\
sion\

::
GetJoi\
nt
(
)
co\
ns\
t
{
lOlllOO\
O\
lOl
.
Ge\
tJoint\

(
)
;
}
inlin\
e
PreCollisio\
n
*
Pr\
e\
Collisi\
on
::
GetN\
ext
(
)
{
ret\
urn
(
Pr\
eCollis\
io\
n
*
)
lOl\
llOOOl\
Ol
.
GetNex\
t
(
)
;
}
in\
l\
i\
ne
const
Vec\
3
&
PreC\
o\
l\
li\
sion\

::
GetPo\
siti\
o\
n
(
)
con\
st
{
retu\
rn
lOlll\
O\
OO\
lOl\

.
lO\
OOOl\
llll
;
}
inl\
ine
voi\
d
PreC\
ol\
lision
::
SetPosit\
i\
on\

(
cons\
t\

Ve\
c3
&
lOOOOl\
ll\
ll
)
{
lO\
lllOOOlOl
.
lOOOOl\
llll\

=
lOOOOl\
l\
lll\

;
}
inl\
in\
e
cons\
t\

Vec3
&
PreCollision\

::
GetNor\
ma\
l
(
)
cons\
t\

{
re\
t\
u\
rn\

lO\
lllOO\
OlOl
.
lOOOl\
OOOOO
;
}
inl\
ine\

void
Pr\
e\
Col\
lisio\
n
::
SetNorma\
l
(
const
Vec3\

&
lOOO\
l\
O\
O\
OOO
)
{
lOl\
llOO\
OlOl
.
lOO\
O\
lOO\
OOO
=
lOOO\
lOOO\
OO
;
}
inline
u3\
2
PreC\
o\
lli\
sion
::
GetFlags\

(
)
cons\
t
{
retur\
n
lO\
lllOOOlOl
.
lOlOll\
OOOl
;
}
inli\
n\
e
void
Pr\
eCollision
::
SetFl\
ags
(
u32\

lO\
lO\
l\
l\
OO\
Ol\

)
{
lO\
lll\
OO\
OlOl\

.
lOlOl\
lOO\
Ol
=
lOlO\
l\
lOO\
O\
l
;
}
inlin\
e
flo\
a\
t
PreCol\
lisi\
on\

::
Get\
Rest\
itution
(
)
con\
s\
t\

{
re\
tu\
rn
lO\
l\
l\
lOOO\
lOl
.
lOllOOlOOl\
l\

;
}
inl\
ine\

voi\
d\

PreC\
ollisi\
o\
n
::
Set\
Restit\
uti\
on
(
fl\
oat
lOl\
lOOl\
OO\
l\
l
)
{
lO\
l\
llOOOl\
Ol
.
lOl\
lOOlO\
O\
l\
l
=
lOll\
OOl\
OOl\
l\

;
}
inl\
ine
flo\
at
Pre\
Collision\

::
GetF\
r\
iction\
Co\
effici\
e\
nt
(
)
cons\
t
{
ret\
urn
lO\
lllO\
OO\
lO\
l
.
lOl\
l\
OOl\
OlOO
;
}
inl\
i\
ne\

voi\
d
Pre\
Co\
lli\
si\
on\

::
SetFri\
ctionC\
oe\
ffi\
cient
(
flo\
at\

lO\
llOOlOlOO\

)
{
lO\
ll\
lO\
OO\
lOl
.
lOll\
OOlOl\
O\
O
=
lOllOOlOlOO
;
}
in\
lin\
e
flo\
at
PreCollisi\
on
::
Ge\
tTime
(
)
cons\
t
{
ret\
urn
lO\
l\
llOOO\
lO\
l
.
lllO\
llllOO
;
}
inline
void
PreCollision
::
Se\
t\
Time
(
fl\
oat
lllOllll\
OO
)
{
lOll\
lOOOlO\
l
.
lllO\
llllO\
O
=
lllOl\
lllO\
O
;
}
inline
float
Pre\
Co\
l\
li\
sion
::
GetIn\
tersect\
ingDepth
(
)
co\
nst
{
return
lOlll\
OOO\
l\
Ol
.
lOllO\
OlOO\
Ol
;
}
inlin\
e
void
PreCol\
l\
ision
::
SetIntersectingDe\
pth
(
flo\
at\

lOllO\
OlO\
O\
Ol
)
{
lOlllOO\
OlO\
l
.
lO\
llOOlOOOl
=
lOll\
OOlOOOl
;
}
inli\
n\
e
u3\
2\

Pr\
eCo\
lli\
si\
on
::
Get\
At\
tribute\
A
(
)
const
{
return\

lOlllO\
OOlOl
.
lO\
ll\
OOOllll
;
}
inline
u32
PreCo\
ll\
i\
sion
::
GetAttrib\
uteB
(
)
co\
ns\
t\

{
return\

lOlll\
OOOlOl
.
lOllO\
Ol\
OOO\
O
;
}
inl\
ine
u32
Pr\
eC\
ollision\

::
GetC\
o\
llisi\
onId\
A
(
)
cons\
t
{
return
lO\
lll\
O\
O\
O\
lO\
l
.
lOllO\
ll\
OOOl
;
}
inline
u32
PreColli\
s\
i\
on
::
Get\
Colli\
si\
onIdB
(
)
con\
s\
t\

{
return\

lOlllO\
OOlO\
l
.
lOllOl\
lOO\
l\
O
;
}
in\
l\
in\
e
DynamicObje\
ct
*
Po\
st\
Col\
lision\

::
Get\
O\
bject\
A\

(
)
{
retu\
rn\

lOlllOOOlO\
l
.
Get\
ObjectA\

(
)
;
}
inli\
ne
Dynam\
icOb\
ject\

*
PostCollision\

::
GetO\
bj\
e\
ctB
(
)
{
re\
tur\
n
lOl\
llOOOlOl
.
Get\
Obje\
ct\
B
(
)
;
}
in\
line
Colli\
si\
onOb\
ject
*
Post\
Co\
llisio\
n
::
Get\
Co\
l\
li\
sio\
nObject\
A
(
)
{
re\
t\
urn
lOlllOO\
O\
lOl
.
Ge\
t\
Co\
ll\
isi\
onObjectA
(
)
;
}
inline
Col\
lisio\
nObject
*
Po\
s\
tCo\
ll\
ision\

::
Ge\
t\
C\
o\
llision\
Obje\
c\
tB
(
)
{
return
lO\
lllO\
OOlOl
.
Ge\
tCollisio\
n\
O\
bje\
ct\
B
(
)
;
}
in\
li\
ne
Physi\
csJoint
*
PostCol\
lisio\
n
::
GetJoint
(
)
{
lOlllOOOlOl\

.
Ge\
t\
Joint
(
)
;
}
inline
PostCo\
llis\
ion
*
PostC\
oll\
isi\
on
::
GetN\
ext
(
)
{
re\
turn\

(
Post\
Col\
lisio\
n
*
)
lOlllO\
OOlOl
.
Get\
Next\

(
)
;
}
in\
line
co\
nst
Vec3
&
Pos\
tCollisi\
on\

::
GetP\
osition
(
)
co\
n\
st
{
retu\
rn\

lO\
ll\
lOOOl\
Ol\

.
lO\
OO\
Ol\
llll\

;
}
inli\
ne
co\
nst\

Vec3
&
Po\
stC\
o\
llisio\
n\

::
GetN\
or\
m\
al
(
)
co\
nst\

{
re\
tu\
r\
n\

lOlllOOO\
lOl
.
lOOOl\
OO\
OOO
;
}
inlin\
e\

u32
PostCollision
::
GetFlags
(
)
co\
n\
st
{
ret\
u\
r\
n\

lO\
lll\
OOO\
lO\
l
.
lOlO\
ll\
OOO\
l
;
}
inli\
ne
flo\
at\

PostColl\
ision\

::
GetIm\
pu\
lse
(
)
cons\
t
{
re\
turn\

lOlllOOOlOl\

.
lOllOO\
lOOlO
;
}
in\
l\
in\
e
float
PostCollisio\
n\

::
GetTim\
e
(
)
const\

{
return\

lO\
l\
l\
lOO\
OlOl
.
lllO\
l\
lllO\
O
;
}
in\
l\
ine
fl\
oat\

PostC\
olli\
sion
::
Get\
Int\
ersect\
ing\
De\
pth
(
)
const
{
retur\
n
lOlll\
OOOlO\
l
.
lOllO\
O\
l\
OOOl\

;
}
inl\
i\
n\
e
u3\
2
Po\
s\
tCol\
lisio\
n\

::
GetAtt\
ribu\
teA
(
)
con\
s\
t
{
re\
tu\
r\
n\

lOlllOOOlOl
.
lO\
l\
lOO\
Olll\
l
;
}
inlin\
e
u32
PostCol\
lision\

::
GetA\
t\
t\
ri\
but\
eB
(
)
co\
ns\
t
{
retur\
n
lOl\
l\
lO\
O\
Ol\
Ol
.
lOllO\
O\
lO\
OOO
;
}
inl\
in\
e
u32
Po\
st\
C\
ollision\

::
GetCollis\
i\
o\
nIdA
(
)
con\
st
{
retur\
n
lOll\
l\
OO\
OlOl
.
lOllOllOOO\
l
;
}
in\
line
u32
PostColli\
s\
i\
on\

::
GetC\
ollisio\
nIdB\

(
)
const\

{
ret\
u\
rn
lOlll\
OO\
O\
lOl
.
lOl\
l\
Oll\
O\
O\
l\
O\

;
}
}
