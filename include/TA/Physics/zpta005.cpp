//---------------------------------------------------------------------------------
// File Name: zpta005.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#define llOllOlOOOl
#define lOllOllOOOO
#include "CollisionObjectAABBMesh.h"
#ifndef lOOllOllll
#include "../Common/zcta001.h"
#endif //
#ifndef lOlOOlllOO
#include "../Common/zcta003.h"
#endif //
#ifndef TA_MFRAME_H
#include "../Common/MFrame.h"
#endif //
#ifndef TA_ERROR_H
#include "../Common/Error.h"
#endif //
#ifndef llOllOOOllO
#include "../Physics/zpta013.h"
#endif //
#ifndef TA_COLLISION_H
#include "Collision.h"
#endif //
#ifndef TA_COLLISIONOBJECTCACHEDPOLYDATA_H
#include "CollisionObjectCachedPolyData.h"
#endif //
#ifndef llOllOlOOlO
#include "../Physics/zpta003.h"
#endif //
#ifndef TA_PHYSICSRENDER_H
#include "PhysicsRender.h"
#endif //
namespace
TA
{
sta\
ti\
c
const
int
llO\
ll\
OlOOl\
l
=
6
;
struct
ll\
OllOlOl\
OO\

{
Ve\
c3
lO\
O\
l\
O\
lOlll
;
Vec\
3
lOO\
O\
lOO\
OOO\

;
floa\
t
lOOl\
OllO\
OO
;
Col\
lisio\
n\

*
llO\
llOlOl\
O\
l\

;
const
Colli\
sionOb\
je\
ct\
A\
A\
BB\
Me\
sh
*
llOllOl\
Oll\
O
;
bo\
ol
lOll\
ll\
OOllO
;
}
;
struct\

llOllOlOlll\

{
Collis\
ionO\
b\
j\
e\
ct\
Ca\
chedPol\
yData
*
llOll\
Oll\
OOO
;
co\
nst
Colli\
sio\
nObjectAABBM\
e\
s\
h
::
Data
*
llOllOllO\
Ol\

;
bool
llOll\
OllO\
l\
O
;
}
;
#ifndef DOXYGEN
enum\

llOl\
lO\
llOll\

{
llOllO\
l\
ll\
O\
O
=
0xF0000000
,
llOllOl\
llOl
=
0x80000000
,
}
;
#endif //
vo\
id\

Co\
ll\
is\
ionObjectAABBMesh
::
Initia\
l\
is\
e
(
int
lO\
llOllOll
,
int
ll\
Ol\
llOO\
OO
,
int
llOl\
lOll\
l\
l\
O
)
{
if
(
lOlO\
OlOllO
)
{
lOO\
OO\
OOll\
O\

(
0
,
"CollisionObjectAABBMesh::Initialise. Already initialised.")
;
Fin\
alise\

(
)
;
}
lOOOOOl\
lOOO
(
lOlOOlOllO
,
Data\

)
;
lOl\
O\
OlOllO
->
llOllOllll\
l
.
Ini\
t\
i\
alis\
e
(
0
,
lOl\
lOl\
lOl\
l
)
;
int
llOll\
lO\
OOO\
O
=
llOlllOOOO\

*
llOllOl\
O\
Oll
+
ll\
Ol\
lOllllO\

;
lOlOOl\
OllO
->
lOll\
OOllO\
O
.
In\
itialis\
e
(
0
,
llO\
lllOOOO\
O\

)
;
lOlOOlOllO
->
llOlllO\
O\
OOl\

=
0
;
lOl\
OOlOl\
lO
->
llOlll\
OOOlO
.
Ini\
tia\
li\
se
(
ll\
O\
l\
ll\
OO\
O\
O
)
;
}
void
Coll\
is\
ionObjectAAB\
BMesh
::
Finali\
se
(
)
{
if
(
lOlOOl\
OllO\

)
{
lOOlO\
OOOOO
(
lOlOOlOllO
,
Data
)
;
lO\
lOOlOll\
O
=
0
;
}
}
void
CollisionObjec\
t\
AABBMe\
sh
::
Seri\
alise
(
Se\
ri\
a\
l\
i\
ser
&
lOOO\
l\
OllOl\

,
cons\
t\

Ve\
rs\
i\
o\
n
&
lllOl\
O\
OOlO
)
{
lOOOO\
O\
Ol\
lO\

(
ll\
lO\
lOO\
OlO
<=
ll\
Oll\
OOlOlO\

,
"CollisionObjectAABBMesh::Serialise. The version number is too new.")
;
if\

(
lOOOlOl\
lOl
.
lllO\
lO\
O\
lO\
l
(
)
)
{
if\

(
!
lO\
lOOlOllO
)
{
lO\
O\
Olll\
O\
lO\

(
0
,
"CollisionObjectAABBMesh::Serialise. Object not initialised, save failed.")
;
retu\
rn
;
}
}
else\

{
if\

(
lOlOOlOl\
l\
O
)
{
lOOOOOOll\
O\

(
0
,
"CollisionObjectAABBMesh::Initialise. Already initialised.")
;
Finalise\

(
)
;
}
lOOOOOllO\
OO\

(
lOlOOlOllO
,
Data
)
;
}
lOO\
OlOllOl\

.
lO\
OO\
lOllll
(
lOlOOl\
OllO
->
lOllOOllO\
O
)
;
lO\
OOl\
O\
ll\
Ol
.
lOO\
OlO\
l\
lll
(
lOlOOlOllO
->
llOllO\
llll\
l
)
;
if
(
lllO\
l\
OOOlO\

>=
Version
(
1012
,
0
)
)
{
lOlOOlOllO
->
llOl\
llOOOlO\

.
Se\
ri\
a\
lis\
e
(
lOO\
OlO\
llO\
l
,
&
lO\
lO\
Ol\
Ol\
l\
O
->
lOl\
lOO\
ll\
OO\

[
0
]
)
;
}
else
{
TA_A\
SS\
E\
RT
(
lOO\
Ol\
O\
llOl
.
lO\
O\
O\
llOOOO\

(
)
)
;
lOOOl\
l\
lOlO
(
0
,
"CollisionObjectAABBMesh::Initialise. Old file format is being loaded, this may be slow.")
;
lOlOOlO\
llO\

->
llOll\
lOOOl\
O
.
lOOOllOOll
(
lOOOlOl\
lOl
,
&
lOl\
OOlOllO\

->
lO\
llOO\
l\
lOO\

[
0
]
)
;
}
}
vo\
i\
d
Coll\
is\
ionObje\
ctAABBMe\
sh\

::
Re\
nde\
r\

(
)
{
lOlOO\
ll\
l\
O\
l
llOl\
llOOOl\
l
;
ll\
Olll\
OO\
Oll
.
Initia\
lise
(
&
lOlO\
OlOl\
lO
->
lOll\
O\
Ol\
lOO
[
0
]
,
lOlOOlOl\
lO\

->
lOl\
l\
OOl\
lO\
O
.
lOOOlll\
OO\
l
(
)
*
size\
of
(
in\
t
)
)
;
for
(
;
;
)
{
Polygon
*
llOlllOOlOO
=
(
Polygon
*
)
llO\
lll\
OOOll
.
lO\
lOlOOl\
O\
l
(
)
;
TA_ASSE\
RT
(
llOlll\
OOlOO
->
lO\
l\
lOl\
lOl\
l\

<
lOl\
l\
lOOl\
OOl
)
;
for
(
int
lO\
O\
OllOO\
Ol
=
0
;
lOOOllO\
OOl
<
llOll\
l\
OO\
lOO
->
lOl\
lOllOll\

;
lOOO\
l\
lOOO\
l
++
)
{
Vec\
3
&
lll\
lO\
OO\
OOl
=
lO\
lOOlOllO\

->
llOllOlllll
[
llOlllO\
O\
lO\
O\

->
llOllll\
OOO
[
lOO\
Ol\
lO\
OOl
]
]
;
Vec3
&
llllOOOOlO
=
lOlOOlO\
llO
->
llOllO\
ll\
lll\

[
llO\
l\
llOO\
l\
OO\

->
llOlll\
lOOO
[
lOOOllOOOl\

+
1
<
llOlllOOlO\
O
->
lOllO\
llOll
?
lOOOllOO\
Ol
+
1
:
0
]
]
;
Physi\
csR\
en\
der
::
RenderLin\
e\

(
ll\
ll\
O\
OOO\
O\
l
,
ll\
llOOOO\
lO\

,
0xffff0000
)
;
}
llOl\
l\
lO\
OOll
.
lO\
lOl\
OOlOO
(
sizeof\

(
float
)
*
4
)
;
ll\
OlllOO\
Oll\

.
lOlO\
l\
O\
O\
O\
lO\

(
)
;
llOlllO\
O\
Oll\

.
lO\
l\
OlOOOlO
(
)
;
ll\
OlllOO\
Oll
.
lOlOlOOlOO
(
llOlllO\
OlO\
O
->
lOll\
OllO\
ll\

*
sizeo\
f
(
int\

)
)
;
if
(
ll\
OlllOO\
Ol\
l
.
AtEnd
(
)
)
brea\
k\

;
}
}
voi\
d
Collis\
ion\
Obje\
ctAA\
BBMes\
h
::
Ad\
dVe\
rtex
(
const\

Vec3
&
llOOllll\
O\
O\

)
{
lO\
lOOl\
O\
llO
->
llOllOlll\
l\
l
.
lOOOlllOOO
(
llOO\
lll\
lOO
)
;
}
void\

Colli\
si\
on\
O\
bjectAABB\
Me\
sh
::
AddPo\
l\
y\
go\
n\

(
int
lOllOllOll\

,
const
int
*
llOl\
llO\
OlOl
,
u32
llOl\
llOOllO
)
{
if
(
lOllOl\
lOll
<
3
)
{
lOOO\
OOOllO
(
0
,
"CollisionObjectAABBMesh::AddPolygon. nNumVertices is < 3.")
;
return\

;
}
con\
st\

int
llO\
lll\
OOlll
=
lOlOOlOll\
O
->
lOl\
lO\
OllO\
O
.
lOOO\
l\
llOOl
(
)
;
lOl\
OOlOllO
->
lO\
llO\
Ol\
l\
OO
.
lOOlllll\
Ol\

(
ll\
OllOlO\
Ol\
l
+
lO\
llO\
llOll
)
;
Po\
ly\
go\
n
*
llOll\
l\
OOl\
OO\

=
(
Po\
lyg\
o\
n
*
)
&
lOlO\
Ol\
OllO
->
lOllO\
Ol\
lO\
O
[
llOl\
llOO\
lll
]
;
llOll\
lOO\
l\
O\
O\

->
llOlllO\
O\
llO
=
llOl\
llOO\
l\
l\
O
&
0xFFFFFFF
;
llOll\
lOOlOO
->
lOl\
lO\
l\
lOl\
l
=
lOl\
lO\
llOll
;
if\

(
ll\
O\
ll\
l\
O\
OlOO
->
lOll\
Oll\
O\
ll
>
lOll\
lOOl\
OOl
)
{
lO\
OOO\
OOll\
O
(
0
,
"CollisionObjectAABBMesh::AddPolygon. nNumVertices is > k_nMaxNumVerticesInPolygon.")
;
llOlll\
O\
OlO\
O\

->
lOl\
lOll\
Oll
=
lOlllOOlO\
Ol
;
}
int
lOl\
llO\
Olll
;
for
(
lOl\
llOOlll
=
0
;
lOl\
llOOlll
<
llOl\
ll\
OOlO\
O
->
lOl\
lO\
ll\
Oll
;
lO\
lllOOl\
ll
++
)
{
lOOOOOOll\
O
(
llOll\
lOOl\
Ol\

[
lO\
ll\
lOOl\
l\
l
]
>=
0
,
"CollisionObjectAABBMesh::AddPolygon. Vertex index is invalid.")
;
lOOOOOOllO
(
llOl\
llOOlOl
[
lOl\
llOOlll
]
<
lOlOO\
l\
O\
llO
->
llOl\
lOlll\
ll
.
lOOOl\
l\
lOOl
(
)
,
"CollisionObjectAABBMesh::AddPolygon. Vertex index is invalid.\n Make sure add the vertices a polygon needs before the polygon")
;
llOlllOOlOO
->
llO\
llllOO\
O
[
lOlllOOlll
]
=
ll\
Oll\
l\
O\
OlOl
[
lOlllOOl\
l\
l\

]
;
}
{
Vec3
lOOOlOO\
OO\
O
;
lOOO\
lOOOO\
O
.
Clear
(
)
;
float\

lOlll\
l\
OO\
ll
=
0.0f
;
for\

(
lOl\
ll\
OOll\
l
=
0
;
lOlll\
OOll\
l
<
lO\
llO\
l\
lO\
ll\

-
2
;
lOlllOOlll
++
)
{
Vec3
llll\
lll\
l\
l
=
lOlO\
O\
lOllO
->
llO\
llO\
lllll
[
llO\
l\
l\
lO\
O\
lOO
->
llO\
ll\
llO\
OO
[
2
+
lO\
l\
l\
lOOlll\

]
]
-
lOl\
O\
Ol\
O\
llO\

->
ll\
Oll\
Olllll
[
llO\
lll\
OOl\
O\
O\

->
llOllllOO\
O
[
0
]
]
;
Vec3
lOOOOOOOOO
=
lOlOOl\
OllO
->
ll\
OllOlllll
[
llOl\
ll\
OO\
lOO
->
llOllllO\
OO
[
1
+
lOlllOOlll
]
]
-
lOlOOl\
O\
llO\

->
ll\
OllOllll\
l\

[
llO\
lllO\
OlOO\

->
llOl\
l\
llOOO
[
0
]
]
;
lO\
OOlOOOOO
+=
Vec\
3
::
Cross\

(
llll\
llll\
l\

,
lOO\
OOOOOOO
)
;
flo\
a\
t\

llO\
ll\
l\
OlOOO
=
lll\
lllll\
l
.
GetMa\
g\
nitude\

(
)
;
if\

(
lOl\
lllOOl\
l\

<
ll\
OlllOlOO\
O
)
lOllllOO\
l\
l
=
llO\
lllOlO\
O\
O\

;
}
if
(
lO\
O\
O\
l\
OOOOO\

.
GetMagnitude
(
)
<=
lO\
llllOOll\

*
0.0001f
||
lOl\
ll\
lOOll\

==
0.0f
)
{
lO\
OOl\
l\
lOlO
(
0
,
"CollisionObjectAABBMesh::AddPolygon. Zero area polygon found. Ignoring.")
;
ll\
Oll\
lOOlOO
->
llOlllOOll\
O\

|=
ll\
OllOl\
ll\
Ol\

;
lO\
OOlO\
OO\
OO\

.
Clear
(
)
;
}
el\
se\

{
lO\
OO\
lOOOOO
.
Norm\
al\
ise\

(
)
;
}
llOlllO\
O\
lO\
O
->
llOlllOlO\
O\
l\

=
lOOOlO\
OO\
OO\

.
x
;
llOl\
ll\
OOlOO
->
ll\
O\
l\
ll\
OlOlO
=
lOOOlOOOOO
.
y
;
llOlllOO\
lO\
O\

->
ll\
OlllOl\
Oll
=
lO\
OOlOOOO\
O\

.
z
;
llOlllO\
OlOO
->
llOll\
l\
Oll\
OO\

=
lOlO\
Ol\
OllO
->
llOll\
l\
OO\
OOl
++
;
}
}
vo\
i\
d
Coll\
i\
si\
o\
nOb\
ject\
AA\
BBM\
esh
::
Finishe\
dAddingGeometry
(
)
{
lOOOOOO\
llO
(
lO\
lO\
Ol\
Oll\
O
->
llOl\
l\
Oll\
lll
.
lOOOlllO\
Ol
(
)
==
lOl\
OOlOl\
lO
->
llOl\
lOlll\
l\
l\

.
lOOll\
l\
lOll
(
)
,
"CollisionObjectAABBMesh::FinishedAddingGeometry. The number of vertices added does not match the vertices specified in the call to CollisionObjectAABBMesh::Initialise.")
;
lO\
OOOO\
OllO
(
lO\
lOOlO\
l\
lO\

->
lOllO\
OllOO
.
lOOOlll\
OOl
(
)
==
lOlO\
OlOll\
O
->
lOllOOllOO
.
lOOll\
llO\
ll
(
)
,
"CollisionObjectAABBMesh::FinishedAddingGeometry. The added polygon data size does not match the expected size calculated from the parameters provided in CollisionObjectAABBMesh::Initialise.")
;
fo\
r
(
int
llOlllOOll\
l\

=
0
;
ll\
OlllOO\
lll
<
lOlOO\
lO\
llO
->
lOllOOllOO
.
lOOO\
lllOOl
(
)
;
)
{
Polygon\

*
llOOOl\
O\
O\
l\
O
=
(
Po\
lygon
*
)
&
lOlOOlOllO
->
lOl\
l\
OOllOO
[
llOll\
l\
OOl\
l\
l
]
;
llOlllOO\
lll\

+=
llOllOlOO\
ll
+
llOOOlOOlO
->
lO\
ll\
OllO\
ll\

;
if
(
(
llOOOl\
O\
OlO
->
ll\
OlllOOl\
l\
O
&
llOllOlllO\
l\

)
==
0
)
llOlllOllOl
(
ll\
OOOlOOlO
)
;
}
lO\
lOO\
lOll\
O\

->
llOlll\
O\
OOl\
O
.
lOOOl\
l\
Ol\
Ol\

(
)
;
}
#ifndef DOXYGEN
voi\
d
TA\
C_CA\
LL
llO\
ll\
lOll\
lO
(
lO\
OOOllOll
::
lOO\
ll\
OOOOO\

*
lO\
OlllOOOl
,
vo\
id
*
lOOl\
llOOOO
)
{
TA_A\
S\
S\
ER\
T
(
lOOlllOOOO\

)
;
llOl\
lOlOlOO
&
llOlllOllll\

=
*
(
llOllOlOlOO
*
)
lOOlllO\
OOO\

;
con\
st
Co\
ll\
is\
i\
onObjectA\
ABBMe\
sh
::
Pol\
y\
go\
n
*
ll\
OO\
Ol\
OOlO
=
(
Co\
l\
l\
isio\
nO\
bjec\
t\
A\
ABBM\
e\
sh
::
Poly\
gon
*
)
lOOl\
l\
lOOOl
->
Ge\
tData
(
)
;
cons\
t\

Colli\
sionO\
bjectA\
ABBMesh\

::
Dat\
a
*
llOll\
O\
llOO\
l\

=
llOlllOllll
.
ll\
OllO\
lOll\
O
->
Get\
Data
(
)
;
Vec\
3
llO\
llllO\
O\
O\
O\

;
llOl\
l\
llOOOO\

.
x
=
llOO\
O\
lOOl\
O
->
llO\
lllOlO\
Ol
;
llOllllOOOO\

.
y
=
llOOOlO\
O\
lO
->
ll\
O\
l\
llOlOl\
O
;
llOll\
ll\
O\
OO\
O
.
z
=
llOO\
OlOOlO
->
llOl\
l\
lOl\
Oll\

;
flo\
at
ll\
Oll\
llOOOl
=
ll\
Ol\
ll\
lOOOO
.
Dot\

(
llOllOllO\
O\
l
->
llOllOll\
ll\
l
[
llO\
OOl\
OOlO
->
llO\
l\
lll\
O\
OO\

[
0
]
]
)
;
float
llO\
ll\
llOO\
lO
=
llO\
l\
lll\
O\
OOO
.
Do\
t
(
llOlllOlll\
l
.
lOO\
lOlO\
lll
)
-
llOll\
llOOOl
;
fl\
oat
llOl\
ll\
lOOl\
l\

=
ll\
Ol\
lllO\
O\
lO\

+
llOlll\
lOO\
OO\

.
Do\
t
(
ll\
Olll\
Ollll\

.
lO\
OOlO\
O\
OOO
)
*
ll\
OlllO\
lll\
l
.
lOOlOl\
l\
OO\
O
;
if
(
llO\
llllO\
Ol\
O\

<=
0.0f
||
llOll\
llOOll
>=
0.0f
)
return
;
fl\
oat
lll\
Oll\
ll\
OO
=
llOllllO\
Ol\
O\

/
(
llO\
llllO\
OlO
-
ll\
Olll\
lOOll\

)
;
if
(
llOlllO\
ll\
l\
l\

.
llOl\
lOlOlO\
l
->
lllO\
ll\
ll\
OO
<
lllOllllOO
)
retu\
rn
;
Vec\
3\

lO\
lllOllOlO\

=
llO\
ll\
lOllll
.
lOOlO\
lO\
lll\

+
(
llOll\
lO\
ll\
ll
.
lOOOlO\
O\
OOO\

)
*
(
lll\
OllllO\
O
*
llO\
l\
llOl\
l\
l\
l
.
lOO\
lOl\
l\
OO\
O
)
;
fo\
r
(
int
llOl\
OlOlOO
=
0
;
ll\
O\
lOl\
O\
lOO
<
llO\
OOl\
O\
OlO\

->
lOllOllOll
;
llOlOlO\
lO\
O
++
)
{
cons\
t\

Ve\
c3
&
lll\
llllll
=
llOllOl\
lO\
Ol
->
llOllOlllll
[
ll\
OOOlOOl\
O
->
llOl\
ll\
lOOO\

[
ll\
OlOlOlOO
]
]
;
const
Vec\
3
&
lOOOO\
OO\
OOO\

=
llOlOlO\
lOO
+
1
<
llOOOl\
OOlO
->
lOllOl\
l\
O\
ll
?
llOl\
lO\
llOOl
->
ll\
Oll\
Ol\
l\
lll
[
llOOOlO\
O\
lO
->
llO\
l\
lll\
OOO
[
llOlOlOlO\
O
+
1
]
]
:
llOllOl\
lOOl
->
llOllOlllll
[
llOO\
O\
lOOlO
->
ll\
Ol\
l\
llOOO\

[
0
]
]
;
Vec3\

ll\
Oll\
llOl\
OO\

=
llOl\
l\
l\
lO\
O\
OO\

.
Cro\
ss
(
lOOO\
OOO\
OOO
-
lll\
l\
ll\
l\
l\
l
)
;
if\

(
ll\
Olll\
lOlOO
.
Dot
(
lO\
l\
llOllOlO
-
ll\
lllllll
)
>
0.005f
)
ret\
u\
r\
n
;
}
llOl\
llOllll
.
llO\
llOlO\
lOl\

->
lO\
lOllOOOl\

|=
Co\
llis\
ion\

::
FLAG_\
COLL\
ISION_\
OCCURRE\
D
|
Coll\
is\
i\
on
::
FLAG_NEW_COLLISION
;
ll\
OlllOl\
ll\
l
.
llOll\
OlOl\
Ol
->
ll\
lO\
l\
lll\
OO\

=
lllO\
llllO\
O
;
ll\
OlllOllll
.
llOllOlO\
lOl
->
lO\
ll\
OOlOOOl
=
lll\
OllllOO
*
llOlllO\
llll
.
lOO\
lO\
ll\
OOO
;
llO\
ll\
l\
Ollll
.
llO\
llO\
lOlO\
l
->
lOllO\
OlO\
OOO\

=
ll\
OOOlO\
O\
lO
->
ll\
OlllO\
O\
llO
;
ll\
Ol\
l\
lOllll\

.
llO\
llOl\
OlO\
l
->
lOOO\
Olllll
=
lOll\
lO\
llOlO\

;
llOl\
llOl\
ll\
l
.
llO\
llOlO\
lOl
->
lOO\
OlOOOOO
=
llOl\
l\
llOO\
OO\

;
llOlllOllll
.
llO\
ll\
OlO\
lOl
->
SetCo\
llis\
i\
on\
Obj\
ec\
tA
(
con\
st\
_c\
ast
<
Colli\
s\
ionO\
bjectAABB\
Mesh
*
>
(
llOl\
llOllll\

.
llOllOlOll\
O\

)
)
;
llOll\
lOllll
.
ll\
Oll\
OlOlOl\

->
lOl\
lOll\
O\
OOl\

=
llOOOlO\
O\
l\
O\

->
ll\
O\
lllOl\
lO\
O
;
llOlllO\
lll\
l
.
lOllllOO\
ll\
O\

=
tr\
ue
;
}
#endif //
bo\
ol
Collisio\
nObjectA\
ABB\
Me\
sh
::
Tes\
tLin\
eFo\
rCollisio\
n
(
cons\
t
Vec3
&
lOOlOl\
Ol\
ll
,
con\
st
Vec3
&
lOOOl\
OO\
OO\
O
,
floa\
t
lOOl\
OllOO\
O\

,
Collis\
io\
n
&
llOllllOlOl
)
const
{
ll\
Ol\
lOlOlOO\

llO\
lll\
O\
lll\
l
;
llOlllO\
llll
.
lOOlOlO\
l\
ll
=
lO\
O\
lOlOlll\

;
llOlllOl\
lll\

.
lOOOlOOO\
O\
O
=
lOOOlOOOOO
;
ll\
Oll\
lO\
lll\
l\

.
lOO\
lOll\
OOO\

=
lOOlOl\
lOOO
;
ll\
O\
lllOl\
lll
.
llOllOlOl\
Ol
=
&
llOlll\
lO\
lOl
;
llOlllOllll
.
llOllO\
l\
OllO
=
thi\
s
;
llOlllOl\
l\
ll
.
lOllll\
OOllO
=
fals\
e\

;
lO\
lOOlOllO
->
llOll\
lOO\
OlO
.
lOOlOlOOlO\

(
lOOlOlOlll
,
lOOOlO\
OOOO
,
lO\
Ol\
OllOO\
O
,
ll\
Ol\
ll\
O\
lllO
,
&
ll\
Olll\
Oll\
ll\

)
;
return
ll\
Ol\
llOl\
ll\
l
.
lOllllOOllO
;
}
#ifndef DOXYGEN
void
TAC_CA\
LL
llOll\
llO\
l\
lO
(
lO\
OOOllOll
::
lOO\
l\
l\
OO\
OOO
*
lOOlll\
OOO\
l
,
vo\
i\
d
*
lOO\
ll\
lOOOO
)
{
llOllO\
lOll\
l
*
lOOOO\
ll\
llO
=
(
llOl\
lO\
lOlll
*
)
lOOll\
lOOOO
;
Co\
llisio\
n\
Obj\
ectC\
a\
c\
he\
dPoly\
Da\
ta
&
ll\
OllllOlll
=
*
lO\
OO\
O\
l\
lllO
->
llOllOllOOO
;
stat\
ic
Vec3
ll\
O\
lllllOOO
[
lO\
l\
llOOlO\
Ol\

]
;
Co\
ll\
ision\
Obj\
ect\
A\
AB\
BMesh
::
Po\
lygo\
n
*
llOl\
llll\
OO\
l\

=
(
Colli\
si\
onObj\
ectAABBMesh
::
Pol\
ygo\
n
*
)
lOOlllOOOl
->
GetD\
ata\

(
)
;
TA_ASSERT
(
llOll\
lll\
O\
Ol
->
lOll\
OllO\
ll
>=
3
)
;
Colli\
s\
io\
nObj\
ectCa\
ched\
Po\
lyData
::
Po\
l\
ygo\
n
*
llOllll\
lOlO
=
llOll\
llOlll
.
Ge\
tN\
ew\
P\
olygon
(
ll\
OlllllO\
Ol
->
lOllOllOll
)
;
if\

(
!
llOlllll\
O\
lO
)
{
if
(
!
lO\
OO\
Ol\
lllO
->
llOl\
lOllO\
lO
)
{
lOOOOll\
l\
lO
->
llOllO\
llOlO
=
true
;
}
retur\
n\

;
}
ll\
Ollll\
lOlO
->
llO\
lll\
OOl\
lO
=
llOlll\
llOOl
->
llOlllO\
Oll\
O
;
llO\
lllllOlO
->
ll\
O\
lllOll\
OO
=
llOlllllOOl\

->
ll\
OlllOllOO
;
llOl\
ll\
llOlO
->
lOllOllOll
=
llOl\
l\
lllOOl
->
lOl\
lOllOll
;
TA\
_A\
SSERT
(
llOlllll\
OlO
->
lOl\
lOl\
l\
O\
ll
>=
0
)
;
TA_A\
SS\
ERT
(
llOlll\
llOlO\

->
lO\
llOllOl\
l
<
lOl\
llOOlOOl
)
;
const
Vec3
llOll\
ll\
lOll
(
llOllll\
l\
OOl
->
llOlllOlOOl
,
ll\
Olllll\
OOl\

->
llOlll\
OlOlO\

,
llOl\
llllOOl
->
llO\
lll\
Ol\
Oll
)
;
llO\
ll\
ll\
lOlO\

->
lO\
OO\
lOO\
OOO
=
llOllll\
lOl\
l\

;
TA_AS\
SERT
(
ll\
Oll\
ll\
l\
OlO
->
lOllOllO\
l\
l
<=
lO\
lll\
O\
OlOO\
l
)
;
for\

(
in\
t\

lOO\
Oll\
O\
O\
Ol
=
0
;
lO\
OOllOOOl\

<
ll\
Ol\
ll\
llOl\
O
->
lO\
ll\
OllO\
ll
;
lOOOll\
OOOl
++
)
{
co\
ns\
t
Ve\
c3\

&
llllO\
OO\
O\
Ol
=
lOOO\
O\
llll\
O
->
llOl\
lO\
llOOl
->
llOllOllll\
l
[
llOllll\
lOOl
->
llO\
ll\
ll\
OOO
[
lOO\
O\
llOOOl\

]
]
;
cons\
t
Vec3
&
ll\
llOOOOlO
=
lOOO\
Olll\
lO
->
llOll\
Ol\
lOO\
l
->
llOllOlll\
l\
l\

[
llO\
lll\
ll\
OOl
->
llO\
ll\
ll\
O\
OO
[
lOOOl\
lO\
OOl
<
llOl\
llllOl\
O
->
lOllOllOl\
l
-
1
?
lOO\
OllO\
O\
Ol
+
1
:
0
]
]
;
llO\
ll\
l\
l\
lOl\
O
->
ll\
O\
llllOOO
[
lOOOl\
l\
OO\
O\
l\

]
.
lOOO\
O\
ll\
lll
=
ll\
l\
lOOOOOl
;
Vec3
lOlll\
O\
lO\
lOl
=
llOlllllOll
.
Cross
(
lll\
lO\
OO\
OOl
-
llllOO\
OOl\
O
)
;
TA\
_AS\
S\
ERT\

(
lOl\
l\
lO\
lO\
lOl\

.
GetMag\
n\
itude
(
)
>
0.0f
)
;
lOl\
l\
l\
Ol\
OlOl\

.
Normali\
se\

(
)
;
llOllll\
l\
OlO
->
llOllllOOO\

[
lO\
OOllOOO\
l
]
.
lOlllO\
lO\
lOl
=
lOlllOlOlO\
l\

;
}
}
#endif //
void\

Co\
ll\
is\
ionObjec\
tAABB\
Mes\
h
::
Ca\
che\
d\
Lo\
ca\
l\
Pol\
ygons
(
CollisionO\
bjectC\
achedPolyDa\
ta
&
llOll\
llOl\
l\
l
,
const
AAB\
B
&
lOOOOOOl\
ll
,
void
*
llOl\
l\
l\
lll\
OO
)
con\
st
{
TA\
_\
ASS\
ERT\

(
lOlOOl\
Oll\
O\

)
;
llOllOlOlll
llOllllllOl
;
llOll\
l\
lllOl\

.
llOllOllOOO
=
&
llO\
llll\
Olll\

;
llOllllll\
O\
l
.
llO\
llOll\
OOl
=
GetData
(
)
;
llOlll\
ll\
lOl
.
llOllOllOlO
=
false
;
lOlOOlO\
ll\
O\

->
llOlll\
OOOl\
O
.
lOOlOl\
OOlO
(
lOOOO\
OO\
l\
ll
,
llOllllO\
l\
l\
O
,
&
llOll\
llllOl
)
;
}
const\

AAB\
B
&
Co\
lli\
s\
ionO\
bj\
ectAABBMesh
::
GetAA\
BB
(
)
con\
s\
t
{
TA_ASSERT\

(
lOl\
OO\
lOllO\

)
;
retur\
n\

lO\
lOOlOl\
lO
->
llOlll\
OOOlO
.
GetAAB\
B
(
)
;
}
Co\
l\
li\
si\
o\
nO\
bje\
ctA\
ABB\
Mesh
*
TAC_C\
ALL
Collisi\
onObje\
c\
tAA\
BBM\
esh
::
Create\
Ne\
w\

(
)
{
Coll\
isi\
onO\
bjectA\
AB\
BMesh
*
lO\
lOllOOlll
;
lO\
O\
O\
OOllOOO
(
lOl\
O\
l\
lO\
Ol\
ll
,
Collisio\
nO\
b\
j\
ec\
tA\
A\
BBMe\
s\
h
)
;
re\
t\
urn
lOlOl\
lO\
Olll\

;
}
void
Co\
llis\
ion\
Obj\
e\
ctA\
A\
BB\
Mesh
::
llOll\
lOllOl
(
Po\
lygon
*
llOO\
OlO\
Ol\
O
)
{
lO\
OOOOOllO
(
llOOOlOO\
lO
->
lOll\
OllOl\
l
>
2
,
"CollisionObjectAABBMesh::AddPolygonToAABBTree. pPolygon->nNumVertices is less than 3")
;
AAB\
B
lOOOOO\
Olll
;
lOOOOO\
Olll
.
Initial\
is\
e
(
lOlOOlOllO\

->
llOll\
Olllll
[
llOO\
O\
lOO\
l\
O
->
llOllllOO\
O
[
0
]
]
,
k_v3Zer\
o
)
;
for
(
int
lOlll\
OOll\
l
=
1
;
lOl\
ll\
O\
Olll\

<
llO\
OOlOOl\
O
->
lOllOllO\
ll
;
lOlllOOll\
l
++
)
lO\
OOOOOlll\

.
Exp\
andToFi\
t
(
lOlO\
OlOllO
->
llOl\
l\
Olllll
[
llOOOl\
O\
OlO
->
llOl\
lllOOO
[
lOlll\
OOlll
]
]
)
;
floa\
t
lO\
OO\
O\
Ol\
OOO
=
lOO\
O\
OOOlll
.
v3\
Extent
[
lO\
O\
OOOOlll
.
v3E\
x\
te\
nt
.
Get\
Great\
es\
t\
A\
xis
(
)
]
;
lOOOOOOlll
.
v3Ext\
e\
nt
.
x
+=
lOOOO\
O\
l\
O\
OO
*
0.001f
;
lO\
O\
OOOOlll
.
v3Ex\
te\
nt
.
y
+=
lOOOOOlOO\
O
*
0.001f
;
lOOOO\
OOl\
ll
.
v3E\
xte\
nt\

.
z
+=
lOO\
OOOl\
O\
OO
*
0.001f
;
lOlOOlO\
ll\
O
->
ll\
Oll\
lOOOlO\

.
lOOOll\
O\
l\
lO
(
ll\
OO\
O\
lO\
OlO
,
lO\
OOO\
OO\
l\
l\
l
)
;
}
Col\
li\
si\
onObjectAA\
BB\
M\
esh\

::
Coll\
isi\
on\
O\
bj\
ectA\
AB\
BMes\
h
(
)
:
Coll\
is\
i\
on\
Obj\
e\
c\
t\
C\
ompl\
e\
x
(
)
{
lO\
lOOlOll\
O
=
0
;
}
CollisionO\
bject\
A\
A\
BB\
Mes\
h
::
~
CollisionObjec\
tAA\
BBMesh\

(
)
{
Finali\
se
(
)
;
}
}
