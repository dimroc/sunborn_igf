//---------------------------------------------------------------------------------
// File Name: zpta016.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#include "../Physics/zpta005.h"
#ifndef TA_MFRAME_H
#include "../Common/MFrame.h"
#endif //
#ifndef TA_PHYSICSRENDER_H
#include "PhysicsRender.h"
#endif //
#include <memory.h>
nam\
espace\

TA
{
con\
st
floa\
t
lOOOlOOO\
l\
l\

=
0.001f
;
static
int
lOOOllllllOO
=
0
;
#ifdef _DEBUG
#define lOOOllllllOl(llOOOOOOlll)											\
if (lOOlOOOllO)																				\
{																								\
	TA_ASSERT(lOOOlllllllO.lOlOOOOllO((u32*)(llOOOOOOlll)));										\
	TA_ASSERT((u32*)(llOOOOOOlll)- &lOOOlllllllO[0] < lOOOllllllll);									\
}
#define lOOlOOOOOOOO(llOOOOOOlll)											\
if (lOOlOOOllO)																				\
{																								\
	TA_ASSERT(lOOOlllllllO.lOlOOOOllO((u32*)(llOOOOOOlll)));										\
	TA_ASSERT((u32*)(llOOOOOOlll) - &lOOOlllllllO[0] >= lOOOlllllllO.lOOOlllOOl() - lOOlOOOOOOOl);		\
}
#define lOOlOOOOOOlO(llOOOOOOlll) lOOlOOOOOOll(llOOOOOOlll, true)
#define lOOlOOOOOlOO(llOOOOOOlll) lOOlOOOOOOll(llOOOOOOlll, false)
#define lOOlOOOOOlOl(llOOOOOOlll) lOOlOOOOOllO(llOOOOOOlll)
#define lOOlOOOOOlll(llOOOOOOlll, lOOlOOOOlOOO) TA_ASSERT(lOOlOOOOlOOl(llOOOOOOlll, lOOlOOOOlOOO))
#define lOOlOOOOlOlO(llOOOOOOlll, lOOlOOOOlOOO) lOOlOOOOlOll(llOOOOOOlll, lOOlOOOOlOOO)
#else
#define lOOlOOOOOOlO(llOOOOOOlll)
#define lOOlOOOOOlOO(llOOOOOOlll)
#define lOOOllllllOl(llOOOOOOlll)
#define lOOlOOOOOOOO(llOOOOOOlll)
#define lOOlOOOOOlOl(llOOOOOOlll)
#define lOOlOOOOOlll(llOOOOOOlll, lOOlOOOOlOOO)
#define lOOlOOOOlOlO(llOOOOOOlll, lOOlOOOOlOOO)
#endif
#define lOOlOOOOllOO()						\
lOOlOOOOllOl(lOOlOOOOlllO, lOOlOOOOllll, lOOlOOOlOOOO, -, -, -)		\
lOOlOOOOllOl(lOOlOOOOlllO, lOOlOOOOllll, lOOlOOOlOOOl, -, -, +)		\
lOOlOOOOllOl(lOOlOOOOlllO, lOOlOOOlOOlO, lOOlOOOlOOOO, -, +, -)		\
lOOlOOOOllOl(lOOlOOOOlllO, lOOlOOOlOOlO, lOOlOOOlOOOl, -, +, +)		\
lOOlOOOOllOl(lOOlOOOlOOll, lOOlOOOOllll, lOOlOOOlOOOO, +, -, -)		\
lOOlOOOOllOl(lOOlOOOlOOll, lOOlOOOOllll, lOOlOOOlOOOl, +, -, +)		\
lOOlOOOOllOl(lOOlOOOlOOll, lOOlOOOlOOlO, lOOlOOOlOOOO, +, +, -)		\
lOOlOOOOllOl(lOOlOOOlOOll, lOOlOOOlOOlO, lOOlOOOlOOOl, +, +, +)
lO\
OlO\
O\
Ol\
OlOO
::
llO\
OO\
OOOllO
::
ll\
OO\
O\
O\
OOllO
(
)
{
ll\
O\
OOOlOlO\
O\

=
0
;
llOOOO\
OlOll
=
0
;
llO\
OO\
OlOOlO
=
0
;
lOl\
OllO\
O\
Ol
=
0
;
ll\
OOOOlOOOl\

[
0
]
=
0
;
ll\
O\
OOO\
lO\
O\
O\
l
[
1
]
=
0
;
ll\
OO\
O\
OlOO\
Ol
[
2
]
=
0
;
ll\
OOOOl\
OO\
O\
l
[
3
]
=
0
;
llO\
O\
OOlOOO\
l\

[
4
]
=
0
;
llO\
O\
OOlO\
O\
Ol
[
5
]
=
0
;
llOOOOl\
OO\
Ol\

[
6
]
=
0
;
llOOOOlOO\
Ol
[
7
]
=
0
;
}
lOOlOOOlOlOO
::
lOOl\
OO\
OlOlOl\

::
lOO\
lOOOl\
Ol\
Ol
(
)
{
llOOOO\
l\
OlOO
=
0
;
ll\
OO\
OOOl\
Oll
=
0
;
ll\
OO\
OOlOO\
lO
=
0
;
lO\
lOl\
lOO\
Ol
=
0
;
llO\
OOOO\
l\
l\
OO\

=
0
;
}
lO\
OlOO\
Ol\
O\
lOO
::
lO\
O\
lOO\
O\
lO\
lOO
(
)
{
llllOlOO\
OOO\

.
Clear
(
)
;
lO\
OlOOOlOllO
=
0
;
lOOlO\
OOl\
O\
ll\
l
=
0
;
}
lOOlOOOlOlOO
::
~
lOOlOOOlOl\
OO
(
)
{
lOOlOO\
OlO\
lOO
::
Fin\
al\
i\
s\
e
(
)
;
}
voi\
d
lOOl\
OOOlO\
lO\
O
::
Initia\
li\
s\
e\

(
fl\
oat\

llOlOlO\
lOOl
,
in\
t
llOlOl\
OlOlO
,
co\
nst
AABB\

&
lOOOOOOlll
)
{
int
lOOOll\
OOOl
;
flo\
at
llOlOl\
l\
OO\
OO
=
lOOO\
O\
O\
Olll
.
v3Exten\
t\

[
lOOOOOOlll
.
v3\
E\
x\
te\
nt
.
GetG\
r\
eate\
st\
Axis
(
)
]
*
2.0f
;
in\
t
lOOlOO\
O\
llOOO
=
16
;
fl\
o\
a\
t
llOl\
O\
lO\
l\
llO
=
(
ll\
O\
lOl\
lOO\
OO
/
llOlOl\
OlOOl
+
1.0f
)
;
if
(
llOlOlOlllO
>
(
fl\
oat\

)
(
1
<<
lOOlOOOllOOO
)
)
ll\
Ol\
OlOlll\
O
=
(
fl\
oat
)
(
1
<<
lOOlOOO\
ll\
O\
OO
)
;
int
lOOl\
OOOl\
lOOl
=
(
int
)
llOl\
OlOll\
l\
O
;
if
(
lO\
Ol\
O\
O\
O\
llOOl
<
1
)
lOOlOOOl\
lOO\
l\

=
1
;
fo\
r\

(
lOOOll\
OOO\
l
=
0
;
lOOO\
llOOOl
<
32
;
lO\
O\
O\
l\
l\
OOOl
++
)
{
if\

(
lOOlO\
OO\
llOO\
l
&
(
1
<<
lOO\
OllOO\
Ol\

)
)
lO\
OlOOOlOllO
=
lOOO\
l\
l\
O\
OO\
l
;
}
lOOl\
O\
O\
OlOllO\

++
;
llllOlOO\
OOO
.
v3\
Cente\
r\

=
lOOOOOOlll
.
v3C\
enter
;
lll\
lOl\
O\
O\
OOO
.
v3Exte\
nt
.
x
=
llOl\
OlOlO\
O\
l\

*
lOO\
lOOOlOll\
O
;
if
(
lll\
l\
OlOOOO\
O\

.
v3Ext\
ent\

.
x
<
ll\
OlOll\
OOOO\

)
llllOlOO\
O\
OO\

.
v3Extent\

.
x
=
llOlOllOOO\
O
;
llllOlOO\
O\
O\
O
.
v3Extent
.
x
*=
0.5f
;
llllOlOOOOO
.
v3\
Extent
.
y
=
llllOlO\
O\
OO\
O
.
v3E\
xte\
nt
.
x
;
llllOlO\
O\
OOO\

.
v3\
Ext\
e\
n\
t
.
z
=
ll\
llOlOOOOO
.
v3\
E\
xtent
.
x
;
const
in\
t
lO\
OlOO\
OllO\
lO\

=
si\
zeof
(
llOO\
OOOO\
llO\

)
;
if\

(
llOlOlOlOl\
O
<
lOOlOOOl\
lOlO\

)
{
lOO\
Ol\
llO\
l\
O
(
0
,
"CollisionOctree::Initialise. Minimum octree memory clamped to 1k")
;
llO\
lOlOlOlO
=
lOOlO\
O\
OllOlO
;
}
llOl\
O\
lOlOl\
O
/=
4
;
lO\
O\
OlllllllO
.
Ini\
t\
ia\
lise
(
llOlOlO\
lOlO
,
llOl\
OlOlOlO\

)
;
lOOOll\
lllllO\

.
lO\
Olll\
lOlO\

(
)
;
in\
t
lOOlOOlOOO
=
0
;
int
lO\
OlO\
OlOOl
=
llO\
lOl\
OlOlO
;
lO\
OllOllOl\
l
=
0
;
lOOl\
O\
O\
OllOl\
l
=
0
;
lO\
OlOOOlOll\
l
=
0
;
for
(
;
;
)
{
if\

(
lOO\
lO\
OlO\
OO
+
(
int
)
(
sizeof
(
ll\
OOOOO\
O\
ll\
O
)
/
4
)
>=
lOOl\
OOlOO\
l\

)
brea\
k
;
llOOOOOOllO
*
ll\
OOO\
OOOlll
=
(
llO\
OOOOOll\
O
*
)
&
lOO\
O\
lllllllO
[
lOOlO\
OlOO\
O\

]
;
lO\
O\
lO\
OlOOO
+=
(
int
)
(
sizeo\
f
(
llOOOOOOll\
O
)
/
4
)
;
lOOOll\
llll\
ll
=
lOOl\
OOl\
O\
OO
;
lOOO\
l\
ll\
lllOl\

(
llOOOOOOl\
ll
)
;
if
(
!
lOOlO\
OOlOl\
ll
)
{
lO\
O\
l\
OO\
O\
lOl\
ll
=
llOOOOOOl\
ll
;
lOOlOOO\
lOlll
->
lOlO\
llOOOl
|=
lOOlOOO\
lll\
O\
O\

;
}
else\

{
ll\
OOOOO\
OOl\
O\

(
llOOOOO\
Olll
)
;
}
if
(
lOOlOO\
lOOO
>=
lO\
Ol\
O\
OlOOl
-
(
int\

)
(
si\
z\
e\
o\
f\

(
lOOlOOOlO\
lOl
)
/
4
)
)
bre\
ak\

;
lO\
OlOOlO\
O\
l
-=
(
in\
t\

)
(
sizeo\
f
(
lOO\
lO\
OOlOlO\
l
)
/
4
)
;
lOOl\
OOOlOlOl\

*
lOOlO\
OOll\
l\
O\
l
=
(
lOOlOO\
Ol\
OlOl
*
)
&
lOOOll\
lllllO\

[
lOOlOO\
lO\
Ol
]
;
lOO\
lOOOOOO\
O\
l\

=
llOlOlOlOlO
-
lOOlO\
O\
lOOl
;
lOOlOOOOOO\
OO
(
lO\
OlO\
OO\
l\
llOl\

)
;
lOOlO\
OOllll\
O
(
lOOlOO\
Oll\
lO\
l
)
;
}
lOOO\
llllllll\

=
lOO\
l\
OO\
l\
OOO
;
lO\
OlO\
OOO\
OO\
Ol
=
llOlO\
lO\
lOlO
-
lOO\
lOOlOO\
l
;
}
void
lO\
OlOO\
O\
lOlOO
::
Finalise
(
)
{
lOOlOOOlOlll
=
0
;
llllOlOO\
OO\
O
.
Cl\
ear
(
)
;
lOOl\
OO\
OlOllO
=
0
;
lOOOll\
ll\
ll\
lO
.
Finali\
se\

(
)
;
}
vo\
i\
d\

lOO\
lOOOl\
OlO\
O
::
lOl\
O\
lO\
OO\
O\
l
(
Sp\
aceDi\
visionO\
bject
&
lO\
lllllll\
lO
)
{
lO\
O\
O\
OOO\
llO
(
lOOO\
lll\
l\
ll\
OO\

==
0
,
"CollisionOctree::Add, Error: Called during CollisionOctree::ForAllIntersectionsWithLineSegment")
;
if
(
lOllllllllO
.
ll\
O\
OOOlOlOl\

)
lOO\
ll\
l\
llll
(
lOllllll\
llO\

)
;
llOOOOOO\
ll\
O
*
llOO\
OOOOl\
l\
l
;
const
AABB
&
lOOlOO\
Oll\
l\
ll\

=
lOllllllll\
O\

.
Get\
Col\
li\
s\
ionGridWorl\
d\
AA\
B\
B
(
)
;
fl\
oat
lOOlOO\
l\
OOOOO
=
lOOlO\
OO\
lll\
l\
l
.
v3Ext\
e\
n\
t
[
lOOlOO\
O\
lllll
.
v3Ex\
tent
.
GetGrea\
testA\
xis
(
)
]
;
flo\
at
lOOlO\
OlO\
OO\
Ol
=
llllOlOOOOO
.
v3Ex\
t\
ent
.
x
;
int
lOOlO\
O\
lOO\
O\
lO\

=
(
1
<<
lOOlOOO\
l\
OllO\

)
;
float
llOllO\
llll
=
(
floa\
t
)
lOOlO\
OlO\
OO\
lO
/
(
lO\
OlOOlOO\
OOl
*
2.0f
)
;
fl\
oat
llOlO\
O\
llO\
lO
=
(
flo\
at
)
lOOlOO\
l\
OO\
OlO
*
0.5f
;
int\

ll\
OOOOO\
OOl
=
FastF\
loatToIn\
t
(
(
lOO\
lOOO\
l\
llll\

.
v3C\
enter
.
x
-
llll\
OlOOOOO
.
v3Cente\
r
.
x
)
*
ll\
Oll\
Ol\
l\
ll\

+
llOlO\
OllO\
l\
O
)
;
Cl\
a\
mp
(
llOO\
O\
OOOO\
l
,
0
,
lOO\
l\
O\
OlOOOlO
-
1
)
;
int
llOOOOOOl\
O
=
FastFloa\
tToInt\

(
(
lOOlOOO\
l\
l\
l\
ll
.
v3\
Cen\
ter
.
y
-
llll\
O\
lO\
OOO\
O\

.
v3C\
en\
ter
.
y
)
*
ll\
OllOllll
+
llO\
lOOl\
lOl\
O
)
;
Cl\
amp
(
ll\
OOOOO\
OlO
,
0
,
lOOl\
OOlOO\
OlO\

-
1
)
;
int\

llOOO\
OOOl\
l
=
Fa\
stFloa\
tTo\
In\
t
(
(
lOOl\
OO\
O\
llll\
l
.
v3Center\

.
z
-
llll\
OlO\
OOOO\

.
v3C\
en\
t\
e\
r
.
z
)
*
llOllOll\
ll
+
llO\
lOOllOlO
)
;
Clamp\

(
llOOOOO\
Ol\
l
,
0
,
lOOlOOlOOOl\
O
-
1
)
;
TA_\
AS\
SERT
(
lO\
OlOOO\
lO\
lll
)
;
ll\
OO\
OO\
OOlll
=
lOOlO\
OOlOll\
l
;
int\

lOOlO\
Ol\
OOOll
=
lOOlOOOlOll\
O
;
do
{
lOOlOOlOOOll
--
;
if
(
lOOlOOl\
OOOl\
l
<
0
)
break
;
lOOlOO\
lOOOOl\

*=
0.5f
;
int
lOOOlOOll\
l\

=
(
(
(
llOOOOOOOl\

<<
2
)
>>
lO\
OlOOlOOOl\
l\

)
&
4
)
+
(
(
(
llOO\
OO\
OOlO
<<
1
)
>>
lOOlOOl\
OO\
O\
l\
l\

)
&
2
)
+
(
(
llOOOO\
OOll\

>>
(
lOO\
lOOl\
OOOll\

-
0
)
)
&
1
)
;
TA_\
A\
SS\
ERT
(
lO\
OOlOOll\
l
>=
0
&&
lOOOlOO\
lll\

<
8
)
;
lOOlOO\
O\
OOOl\
O
(
llOO\
OOOO\
lll
)
;
if
(
llO\
OOOOOl\
ll
->
lO\
l\
O\
l\
lOOOl
&
lO\
O\
l\
OOOl\
ll\
O\
O\

)
{
TA_ASSER\
T
(
llOO\
O\
OOOlll
->
llO\
ll\
OOlOl
>
1
||
llOOOOOO\
lll\

==
lO\
OlOOOlOlll
)
;
if
(
!
ll\
OOOOOOlll
->
llO\
OOO\
lOO\
O\
l
[
lO\
OO\
lOO\
l\
l\
l\

]
)
{
llOOOOO\
O\
lll
->
llOOOOlO\
OOl
[
lO\
OOlOOl\
l\
l
]
=
(
llOO\
OO\
OOl\
lO\

*
)
lOO\
lOOlOO\
lOO
(
&
llOOO\
OOOll\
l
)
;
if
(
llOOO\
OO\
Ol\
ll
->
ll\
OO\
OOlO\
OOl
[
lOOOl\
OOlll
]
==
0
)
brea\
k
;
ll\
OOO\
OOOlll
->
llOOOOlOOOl
[
lOOO\
lOO\
l\
ll
]
->
llO\
OO\
OOlO\
ll\

=
llO\
O\
OOOO\
l\
ll
;
ll\
OO\
OOOOlll
->
ll\
O\
OO\
O\
lOO\
Ol\

[
lOOOlOOl\
ll
]
->
llO\
OOO\
lO\
OlO
=
lOO\
Ol\
OOl\
ll
;
llOOOO\
OO\
lll
->
llO\
OOO\
l\
OO\
Ol
[
lOOOlOOlll
]
->
llO\
llOOlOl
=
0
;
llOOOOO\
O\
l\
l\
l
->
llOO\
OOlOO\
O\
l\

[
lOOO\
lOOl\
ll
]
->
lOl\
Oll\
O\
O\
Ol
=
0
;
llOO\
OOOOlll\

->
llOllOOlOl
++
;
}
lOOlOOOO\
OOlO
(
llOOO\
OOO\
lll
)
;
ll\
O\
O\
OOOOlll\

=
llO\
OO\
O\
OOlll
->
ll\
O\
OOO\
lOO\
Ol
[
lOOOlOOlll
]
;
lO\
OlOOOOO\
OlO
(
llOOO\
OO\
O\
lll\

)
;
}
el\
se
{
lOOlOOO\
lOlOl\

*
lOOlOOOll\
lOl\

=
(
lO\
OlO\
O\
OlOlOl
*
)
ll\
OOOOOOll\
l
;
if\

(
lOOlOO\
O\
lll\
Ol\

->
ll\
OOOOOll\
O\
O\

)
{
if
(
lO\
O\
lOO\
OlllOl
->
llOO\
O\
OlOO\
OO\

==
lOOOlO\
Ol\
ll\

)
{
llOOOOOO\
ll\
l\

=
lOOlO\
O\
O\
ll\
lOl
->
llOOOOO\
llO\
O\

;
lO\
OlOOOOOOlO
(
ll\
OOOOOOlll\

)
;
}
el\
s\
e
{
llOOOOO\
O\
lll\

=
llOOO\
O\
OlllO\

(
(
ll\
OO\
OOOOllO\

*
*
)
&
lO\
Ol\
O\
OOl\
ll\
Ol
)
;
if\

(
llO\
OOOOOlll
==
0
)
{
llO\
OOOOOll\
l\

=
(
ll\
OO\
OO\
OO\
llO
*
)
lOO\
l\
OOOlll\
Ol
;
break\

;
}
if\

(
lOOlOOOlllOl
->
llO\
O\
O\
OOlOl\
l
->
lOlO\
ll\
O\
OOl\

&
lO\
O\
l\
OOOll\
lOO
)
lOOlOOOlll\
Ol
->
llO\
O\
OO\
OlOl\
l
->
ll\
O\
OOOl\
OOOl
[
lO\
OlO\
OOlllO\
l
->
llO\
OOOlOO\
lO
]
=
llOOO\
OO\
O\
lll
;
else
(
(
lO\
OlO\
O\
OlOl\
O\
l
*
)
lOOlOOOlllOl
->
llOOO\
OOlOl\
l
)
->
llOOO\
OOl\
l\
OO\

=
llOO\
OO\
OO\
l\
ll
;
ll\
OO\
OOO\
Olll
->
llO\
OOOOl\
Oll\

=
lO\
OlOO\
Oll\
lOl
->
llO\
OO\
OOlOll
;
lOOl\
OOOl\
ll\
Ol
->
ll\
OOO\
OOllOO
->
llOOO\
OOlOll\

=
llOOO\
O\
O\
Oll\
l
;
llOOOOOO\
ll\
l\

->
llOllOOl\
O\
l
=
1
;
ll\
OOO\
OO\
Olll
->
llO\
O\
OOlOOlO
=
lOOl\
O\
O\
Ol\
l\
lOl
->
llOOOOl\
OOl\
O\

;
llOOO\
OOOlll
->
lO\
lOl\
lOO\
O\
l
=
0
;
llOO\
OOOOlll
->
llOOOO\
lO\
OOO
=
0
;
TA\
_ASSER\
T\

(
llO\
OOOO\
Olll
->
llOOO\
OlO\
O\
O\
l
[
0
]
==
0
)
;
TA\
_ASS\
E\
R\
T
(
llO\
O\
OOOOl\
ll
->
ll\
OO\
O\
OlOOO\
l
[
1
]
==
0
)
;
TA_A\
SSERT
(
llOOOOO\
O\
l\
ll\

->
ll\
O\
OOOlOOOl
[
2
]
==
0
)
;
TA\
_A\
SSERT
(
llOOOOOOlll\

->
llOOOOlO\
O\
O\
l
[
3
]
==
0
)
;
TA\
_ASS\
ER\
T
(
llO\
OOOOOlll\

->
llOOOOlO\
OOl
[
4
]
==
0
)
;
TA_\
AS\
S\
E\
RT
(
llOOO\
OO\
Olll
->
llO\
OOOlOOO\
l
[
5
]
==
0
)
;
TA_ASSERT
(
llOO\
OOOO\
lll\

->
ll\
O\
OOO\
lOOOl\

[
7
]
==
0
)
;
llO\
O\
OOOOlll
->
llO\
OOOlOOOl
[
lO\
OlOO\
OlllOl
->
ll\
OOO\
O\
lOOOO
]
=
lOOl\
OOOlllOl\

->
llOOOOOllOO
;
llOOOOOO\
lll
->
llOOOOlOl\
O\
O
=
lOOl\
OOOl\
llOl
->
llOOO\
OlO\
lOO\

;
if\

(
llOOOOOOlll
->
ll\
OOOOlOlOO\

)
ll\
OO\
OOOOlll
->
llOOOOlO\
l\
O\
O
->
llOOOO\
lOl\
Ol
=
&
ll\
OOO\
OOOl\
ll
->
ll\
OOOOlOl\
O\
O
;
ll\
OOOOOOlll
->
lOl\
Ol\
lO\
O\
Ol
=
lOO\
lO\
O\
Olll\
OO
;
lOOlOOOll\
l\
lO
(
lOO\
lOOO\
l\
llOl
)
;
TA_A\
S\
SE\
RT\

(
llOOOO\
OOl\
l\
l
->
llOO\
OOlO\
OOl
[
lO\
OOlOOll\
l
]
==
0
)
;
llOOO\
OOOl\
ll
->
llOO\
O\
OlOOOl
[
lOOOlOO\
lll
]
=
(
ll\
OOOOOOllO\

*
)
lOOlOOlOOlOO
(
&
llOOOOOOl\
ll
)
;
if
(
llOOO\
OOOlll
->
llOOOO\
lOOOl\

[
lOO\
OlOOl\
l\
l
]
==
0
)
break
;
llO\
OOOOOlll
->
llO\
OOO\
l\
OOOl
[
lOOOl\
O\
Oll\
l
]
->
llOO\
OO\
OlOll
=
llOO\
OOOO\
lll\

;
llO\
OO\
OOO\
lll
->
llOO\
OO\
lOOOl\

[
lOOOlOOlll\

]
->
ll\
OO\
OO\
lOO\
l\
O\

=
lO\
OOlO\
Ol\
ll
;
llOOOO\
O\
O\
lll\

->
ll\
OllOOlOl\

++
;
TA_\
AS\
S\
ERT
(
llOOO\
O\
O\
Olll
->
llOllO\
OlOl
==
2
)
;
lOOlOOOOO\
O\
lO
(
llOOO\
OOOl\
ll\

)
;
llOOO\
OO\
Olll
=
llOOOOOOlll
->
llOOOOlOOOl
[
lOO\
OlOOlll
]
;
lOO\
lOO\
OOOOlO\

(
llOOOO\
OO\
lll
)
;
}
}
else
{
TA_ASSERT\

(
lO\
Ol\
OOOlllOl
->
llOOOOOllOO
==
0
)
;
lOOl\
OOOll\
l\
O\
l\

->
ll\
OOO\
OOl\
lOO
=
(
llOOOOOOl\
lO
*
)
lO\
OlOOl\
OO\
lOO\

(
(
ll\
OOO\
O\
O\
Ol\
l\
O
*
*
)
&
lO\
OlOOO\
l\
llO\
l\

)
;
if
(
lOOl\
OOOl\
llOl
->
llOO\
OOO\
llOO\

==
0
)
bre\
ak
;
lO\
Ol\
OOOl\
llOl
->
llOOOOl\
OOOO
=
lO\
OOlOO\
l\
ll
;
lOO\
lOO\
Olll\
O\
l
->
ll\
Ol\
lOOl\
Ol
++
;
lOOlOOOlllO\
l
->
llOOO\
OO\
ll\
OO
->
ll\
OOOOlOOlO
=
lOOOlO\
Olll
;
lO\
O\
lOOOl\
l\
lOl
->
ll\
OO\
O\
OO\
l\
lO\
O
->
llOOOOlO\
OO\
O
=
0
;
lO\
Ol\
OOOlllOl
->
llOOOOOll\
OO
->
lO\
l\
OllOOOl
=
0
;
lOOlO\
O\
Olll\
Ol
->
llOO\
OO\
OllOO
->
llOO\
OOOlO\
l\
l
=
llO\
O\
O\
OOO\
lll
;
TA_\
ASSER\
T
(
lOOl\
OO\
OlllOl
->
llOl\
lOOlOl\

==
1
)
;
lOOlOOOOOOlO\

(
llOOO\
OO\
Ol\
l\
l
)
;
ll\
OOOOOOlll
=
lO\
Ol\
OOO\
lllO\
l
->
ll\
OOO\
OOllOO
;
lO\
O\
lOOO\
OOOl\
O
(
ll\
OOO\
OOOlll\

)
;
}
}
}
while\

(
lO\
OlOOlOOOOl
>
lOOlOOlOOOOO\

)
;
lOOl\
OOO\
OOOlO
(
llO\
OOOOOlll
)
;
Space\
D\
i\
visi\
onO\
b\
j\
ec\
t\

*
*
llOl\
Ol\
l\
OO\
O\
l
=
&
llOO\
OO\
OOlll\

->
llO\
OOOlOlO\
O
;
lOlllllll\
lO
.
ll\
OOOOlllll
=
*
llO\
lOl\
lOOOl\

;
if
(
lOl\
l\
ll\
lll\
lO
.
llOOOOlllll
)
lOlllll\
ll\
lO
.
llOOOOlll\
l\
l
->
ll\
OOO\
Ol\
Ol\
Ol
=
&
lOllll\
llll\
O
.
llOOOOll\
l\
l\
l
;
*
ll\
O\
l\
Ol\
l\
OOO\
l
=
&
lOlllll\
ll\
lO
;
lOllllllllO
.
llO\
O\
O\
OlOlOl
=
ll\
O\
lOllOOOl
;
lOOlOOO\
OOOlO\

(
ll\
OOOOOOlll
)
;
lOOlOOOOOlOl
(
lOOlOOOlOll\
l
)
;
}
vo\
id\

lO\
OlOOOl\
Ol\
O\
O
::
lOOlllll\
ll
(
Space\
Divisio\
nObject\

&
lOl\
l\
lllll\
l\
O
)
{
lO\
OOOOOll\
O
(
lOOOl\
lllllOO
==
0
,
"CollisionOctree::Remove, Error: Called during CollisionOctree::ForAllIntersectionsWithLineSegment")
;
if
(
!
lO\
l\
ll\
lllllO\

.
llOOOOlOlO\
l
)
{
TA_\
ASSERT
(
lO\
l\
lllllll\
O
.
llOOOO\
l\
llll
==
0
)
;
return\

;
}
TA\
_ASSE\
R\
T
(
lOlllll\
lll\
O
.
llOO\
OOlOlOl
)
;
TA_ASSE\
RT
(
*
lOl\
lllll\
l\
lO\

.
llOOOOlOlOl
==
&
lOl\
llllll\
lO\

)
;
if\

(
lOllllllllO\

.
llOO\
OOll\
ll\
l
)
{
TA_\
ASSERT\

(
lOlll\
lllllO
.
ll\
OOOOll\
lll\

->
llOOOOlOlO\
l
==
&
lOl\
llllll\
lO
.
ll\
OOO\
O\
l\
l\
lll
)
;
lO\
llllllll\
O
.
llOOO\
Ollll\
l
->
llOOOO\
lOlO\
l
=
lOllllllllO\

.
ll\
OO\
OOl\
OlOl
;
*
lOllll\
llllO
.
ll\
OOOOlO\
lOl
=
lOllll\
llllO
.
llOO\
OOlllll
;
}
els\
e\

{
*
lOl\
lllll\
ll\
O
.
llOOOO\
lOlOl
=
lOll\
llllll\
O\

.
ll\
OOO\
O\
lllll
;
llOO\
OOOO\
llO\

*
llOO\
OOOOl\
ll
=
re\
in\
t\
er\
p\
re\
t_c\
ast\

<
ll\
OOO\
OOO\
l\
l\
O
*
>
(
lO\
ll\
l\
lll\
llO
.
llOOOOlOlOl
)
;
if
(
lO\
OO\
lllllllO
.
lOl\
OOOOll\
O
(
(
u32
*
)
llOOOOO\
Olll\

)
)
{
lOOl\
OOOOOOlO
(
llOOO\
OOOll\
l
)
;
whi\
le
(
llOO\
OO\
O\
Olll
->
ll\
OOOOOlO\
l\
l
)
{
TA\
_\
A\
SSERT
(
ll\
OO\
OO\
OOl\
l\
l
!=
lOOlOO\
OlOlll\

)
;
lO\
OlOO\
OOOlOO
(
ll\
OOO\
OO\
O\
l\
l\
l
)
;
if
(
llOO\
O\
OOO\
lll\

->
lOlO\
llOOOl
&
lOOlOOO\
lllOO
)
{
TA_\
AS\
SE\
R\
T
(
llOOOOOOll\
l
->
llOl\
l\
OOlOl
>
0
)
;
if
(
ll\
OOOOOOlll
->
llO\
l\
lOOlOl
==
1
)
{
int\

ll\
OOOO\
lOOOO
;
fo\
r
(
llOOOOl\
O\
O\
O\
O
=
0
;
llOOO\
OlOOOO
<
8
;
llO\
OOOlOOOO
++
)
if
(
llO\
OO\
O\
OOlll
->
llO\
O\
O\
Ol\
OOOl\

[
llOOOOlO\
OOO
]
)
br\
e\
a\
k
;
TA\
_A\
S\
S\
ERT
(
ll\
OOOOlOOOO
!=
8
)
;
llO\
OOO\
OOl\
lO
*
llOOO\
O\
Ol\
l\
OO
=
ll\
O\
O\
OOO\
Olll
->
llOOO\
O\
lOOOl
[
llOOOO\
lOOOO
]
;
SpaceDivi\
sion\
Object
*
llO\
OOOlOlOO
=
ll\
OOOOOO\
ll\
l\

->
ll\
OO\
OO\
l\
OlO\
O
;
int
llOOO\
O\
lOOlO
=
llOOOOO\
Ol\
l\
l\

->
llOOOOl\
OOl\
O\

;
llO\
OOOOOllO
*
ll\
OOO\
OOlOll
=
ll\
OOO\
OOOl\
l\
l
->
ll\
OOOOOl\
Oll\

;
llOOO\
OOOOl\
O\

(
ll\
O\
OOOOO\
lll
)
;
lO\
OlOO\
O\
lOlOl
*
lO\
OlOOOll\
lOl
=
lOO\
lO\
OlOOlOO
(
&
llOOOOOlOll\

)
;
lOOl\
OO\
O\
lllO\
l\

->
llOOOOOlO\
l\
l\

=
llOOOOOlO\
l\
l
;
lOOlOOOlllOl\

->
ll\
OllOOl\
Ol
=
1
;
lOOl\
OOOlllO\
l
->
llOOOOlO\
O\
O\
O
=
llOOOOlOOOO
;
lOO\
l\
OO\
OlllOl
->
llOOOOlOOlO
=
llOOO\
O\
lOOlO
;
lO\
O\
lOO\
Olll\
O\
l
->
lOlOllOO\
Ol
=
0
;
lOO\
l\
OOOlll\
Ol
->
ll\
O\
OO\
OO\
l\
lO\
O
=
llOOOOOl\
l\
OO
;
lOOl\
OOO\
lllOl\

->
llOOOO\
OllO\
O
->
llO\
OOO\
OlOl\
l
=
(
ll\
OOOOOOll\
O
*
)
lOOl\
OOOlllO\
l
;
lOO\
lOOOlll\
Ol
->
llOOOOl\
OlOO
=
llOOO\
OlOlO\
O\

;
if
(
lO\
Ol\
OOO\
lllOl\

->
llOOOO\
lO\
lOO
)
lOOlOO\
OlllOl
->
llOOOOlOlOO
->
llO\
OOOlO\
l\
Ol
=
&
lO\
O\
lOOOll\
lOl
->
llO\
OOOlOl\
O\
O\

;
if
(
llO\
OO\
OO\
lO\
ll\

->
lOlOl\
l\
OOOl
&
lOOlOOOlllOO
)
llOO\
OOO\
lOll
->
ll\
OOO\
O\
lO\
OOl
[
lOO\
lO\
OOll\
lOl
->
llOOOOlO\
O\
lO
]
=
(
llOO\
OO\
OO\
llO
*
)
lO\
OlOOOlll\
Ol
;
else
(
(
lO\
Ol\
OOO\
l\
OlOl
*
)
llOOOOOlOll
)
->
llO\
OOOOllOO\

=
(
llO\
OOOOO\
l\
lO
*
)
lOOlOOOlll\
Ol
;
lOOl\
OO\
OOO\
Ol\
O
(
(
llOOOOOOll\
O
*
)
lOOlO\
OO\
lllO\
l
)
;
}
bre\
ak
;
}
els\
e
{
lOOl\
O\
OOlOlOl\

*
lO\
OlOOO\
lllOl
=
(
lOOl\
OOOlOlOl\

*
)
ll\
OOO\
OOOlll\

;
if\

(
lOOlOO\
O\
lllO\
l
->
llOOOO\
lOlO\
O\

==
0
&&
lOO\
lOOOlll\
Ol\

->
llO\
OOOO\
l\
lOO
==
0
)
{
int
llOOOOl\
OOlO
=
lO\
OlOOOlllOl
->
llO\
OO\
OlOOlO
;
TA\
_ASS\
ERT
(
llOO\
OOlOOl\
O
>=
0
)
;
TA_\
ASSERT\

(
llOOOOlO\
OlO\

<
8
)
;
llOO\
OOOO\
ll\
l\

=
lOOl\
OOOll\
l\
Ol
->
llO\
OO\
O\
O\
l\
Oll
;
if
(
llOO\
OO\
OOll\
l
->
lOl\
OllOOOl\

&
lO\
OlOOOlllOO
)
{
lOOOll\
llll\
Ol
(
llO\
OOO\
OOlll
)
;
TA_AS\
SER\
T
(
llOO\
O\
OOOll\
l
->
llOOO\
OlOOOl
[
llOOO\
Ol\
OO\
lO
]
==
(
llOOOOOOl\
l\
O\

*
)
lO\
O\
lOOO\
lllOl
)
;
lOO\
lOO\
OOO\
OO\
O
(
lOOlO\
OOlllOl\

)
;
lOO\
lOOOl\
l\
llO
(
lOO\
lO\
OOll\
lOl
)
;
llOOO\
OO\
Olll
->
llOOOOlOOOl
[
llO\
O\
OO\
l\
OOlO
]
=
0
;
llOOO\
OOOlll\

->
llOllOO\
lOl\

--
;
lOO\
lOO\
OO\
O\
lOO
(
ll\
O\
O\
O\
OO\
Olll
)
;
}
else\

{
lOOl\
O\
OO\
lOlOl\

*
lOO\
lOO\
l\
O\
O\
lOl
=
(
lO\
OlOOOl\
OlOl
*
)
ll\
OOO\
O\
OO\
ll\
l
;
lOOlOOOOOOOO
(
lO\
Ol\
OOl\
OO\
lOl\

)
;
TA\
_A\
SSERT
(
lOO\
l\
OO\
l\
OO\
l\
O\
l
->
ll\
O\
OOOOllO\
O
==
(
llOO\
OO\
OOllO
*
)
lO\
OlOO\
O\
l\
llO\
l
)
;
lOOlOOO\
OOOO\
O\

(
lOO\
l\
OOOl\
llO\
l
)
;
lOO\
lOO\
OllllO
(
lO\
O\
l\
OOO\
lllOl\

)
;
lO\
Ol\
OOl\
OOlOl\

->
llOO\
OO\
OllOO\

=
0
;
lOO\
lOOlO\
Ol\
Ol
->
llOO\
OO\
l\
OOOO
=
0
;
lOOl\
OOlOOlO\
l
->
llO\
ll\
OO\
lOl
--
;
TA_AS\
SERT
(
lOOlOOlOOl\
Ol
->
llOllOO\
lO\
l\

==
0
)
;
lO\
OlOO\
OOOOlO
(
ll\
OOOOO\
Ol\
ll\

)
;
}
}
el\
se
{
brea\
k
;
}
}
}
}
}
lOllll\
llllO
.
llOOOOl\
O\
lOl
=
0
;
lOl\
lllllllO\

.
llOOOOll\
lll
=
0
;
}
void
lO\
OlO\
OO\
lOl\
O\
O
::
llOOO\
l\
OOlO\
O
(
const
AA\
BB
&
lOOOOOOlll
,
void
(
TAC_\
CALL
*
llO\
OlOllOOO
)
(
Sp\
ace\
D\
iv\
i\
si\
o\
nObject\

&
lOllllll\
l\
lO
,
vo\
id
*
lOOl\
l\
lOO\
OO
)
,
void
*
lOO\
O\
Oll\
ll\
O
)
{
lOOOll\
llllO\
O
++
;
lOOl\
OOlO\
Ol\
lO\

lOOlOOlO\
Oll\
l
;
lO\
Ol\
OOl\
OO\
ll\
l\

.
lOOOOOOll\
l
=
lO\
OOOO\
Oll\
l\

;
lO\
OlOOlOO\
l\
ll
.
llOOlOllOO\
O
=
llOOlOllOOO\

;
lOO\
lOOlOOll\
l
.
lOO\
OOl\
l\
llO
=
lOOOOllllO
;
float
lO\
O\
lOO\
lOO\
OO\
l
=
ll\
l\
lOlOOOOO\

.
v3Extent
.
x
;
int
lOOlO\
OlOOOlO
=
(
1
<<
lOOl\
OOOlOl\
lO\

)
;
float
llOl\
lOllll\

=
(
float
)
lOOlOOlOOOl\
O\

/
(
lOO\
lOOl\
OOOOl\

*
2.0f
)
;
fl\
oat
llOlOOll\
OlO
=
(
fl\
oat
)
lO\
O\
l\
OOlOOOlO
*
0.5f
;
lOOl\
OOlO\
O\
lll
.
llOO\
OO\
OOOl
=
Fas\
tFl\
oatT\
oI\
n\
t\

(
(
lOOOO\
OO\
l\
l\
l\

.
v3\
C\
e\
n\
te\
r
.
x
-
llll\
Ol\
OO\
OOO
.
v3Center
.
x
)
*
llOllOlll\
l
+
ll\
O\
l\
OOllOlO
)
;
Clamp
(
lOOlOO\
lO\
Olll\

.
llO\
OOOOO\
Ol
,
0
,
lOOlOOlO\
O\
OlO
-
1
)
;
lOOl\
OOlOOlll
.
llOOOO\
O\
OlO\

=
Fas\
tFloatT\
oI\
nt
(
(
lOO\
OOOOlll
.
v3Ce\
n\
ter
.
y
-
llllO\
lOOOO\
O
.
v3Ce\
n\
ter
.
y
)
*
llOllO\
lll\
l
+
ll\
OlOOll\
OlO
)
;
Cla\
mp\

(
lOO\
lO\
Ol\
O\
Oll\
l
.
llOOOOOOlO
,
0
,
lOO\
lOOlOOOlO
-
1
)
;
lOOl\
OOl\
O\
Oll\
l
.
ll\
OOOOOOll\

=
Fast\
F\
loatT\
oIn\
t
(
(
lOO\
OOO\
Olll
.
v3Cent\
er
.
z
-
llllOlOOOOO
.
v3\
Cen\
ter
.
z
)
*
llOll\
Ol\
lll
+
llOlOO\
llOlO
)
;
Cl\
a\
m\
p\

(
lOOlO\
OlOOlll
.
llO\
O\
OOO\
O\
ll
,
0
,
lOOl\
OOlOOOlO
-
1
)
;
lOOlOOlOOl\
ll
.
llOOO\
lOlOOO
=
Fas\
tF\
loatTo\
Int\

(
lO\
O\
O\
O\
OO\
lll
.
v3E\
xte\
nt
.
x
*
llO\
llOll\
ll
+
0.99f
)
;
lOOlO\
OlOO\
ll\
l
.
llOO\
OlO\
lOOl
=
Fas\
tFl\
oatTo\
Int
(
lOOOO\
OO\
lll
.
v3Exte\
n\
t
.
y
*
ll\
Oll\
Ollll
+
0.99f
)
;
lOOlOOl\
OOll\
l
.
ll\
OOOlOl\
O\
lO
=
FastFloat\
ToInt
(
lOOOOOOl\
ll
.
v3\
Ext\
en\
t
.
z
*
llOllOllll
+
0.99f
)
;
llO\
O\
OlOl\
Ol\
l
(
lO\
Ol\
OOOlO\
lll
,
lOOlOOO\
l\
OllO
,
0
,
0
,
0
,
&
lO\
Ol\
OOlOOlll
)
;
lOO\
Olll\
l\
llO\
O
--
;
}
void
lOOlOOOl\
OlOO
::
ll\
OOOlOl\
l\
OO
(
const
Vec\
3
&
lOOlOlOl\
ll
,
const
Vec3\

&
lOO\
l\
OllOOl
,
void\

(
TAC_CAL\
L
*
llOOlOllOOO
)
(
Spa\
ceDiv\
ision\
O\
bj\
ect
&
lOllll\
llllO
,
vo\
id
*
lOOlllOO\
OO
)
,
vo\
id
*
lO\
OOO\
ll\
llO
)
{
lOO\
l\
O\
OlOlO\
OO\

lOOlO\
O\
l\
OOl\
l\
l
;
lOO\
lO\
OlO\
Ol\
l\
l
.
lOl\
lOlO\
lll\
l
=
this\

;
lOOlO\
O\
lO\
Olll
.
llOOlO\
llO\
OO
=
ll\
OO\
lO\
ll\
OOO
;
lOOlOO\
lOO\
lll\

.
lOOOOll\
llO\

=
lOO\
O\
O\
ll\
ll\
O
;
lOOlOOl\
OOlll\

.
lOO\
lOlO\
lll
=
lO\
OlOl\
Olll\

;
lOOlOOlO\
O\
lll
.
lO\
OlO\
llOOl\

=
lO\
OlOllOOl
;
Vec3
lOOOlOOO\
OO
=
lO\
O\
lO\
llOOl
-
lOOlOlO\
ll\
l\

;
lOOl\
O\
Ol\
OO\
lll
.
lOO\
lOll\
OOO
=
lOOOlOO\
OOO
.
GetMagnit\
u\
de\

(
)
;
lOO\
lOOlO\
O\
ll\
l
.
lOOOOOll\
Ol
[
0
]
.
ll\
O\
OOl\
lOOOO
=
lOO\
lOlO\
lll
.
x
;
lOO\
lOOlOOlll
.
lOO\
OOO\
llOl
[
1
]
.
llO\
OOl\
lO\
OOO
=
lOOlOl\
Ol\
ll
.
y
;
lOO\
lOO\
l\
OO\
lll
.
lOO\
OOOl\
l\
Ol\

[
2
]
.
llOO\
Ol\
l\
O\
OOO
=
lOO\
lOlOlll
.
z
;
lOO\
lOO\
lOO\
l\
ll
.
lOO\
OO\
OllOl
[
0
]
.
llOOO\
l\
l\
OOO\
l\

=
lOO\
OlOOOOO
.
x
;
lOOlOOlO\
Oll\
l
.
lO\
O\
O\
OOllOl
[
1
]
.
llO\
OO\
llO\
OOl
=
lOO\
OlOOO\
OO
.
y
;
lOOlOOlOOll\
l
.
lOOOOOl\
l\
Ol
[
2
]
.
llOOOllOO\
Ol
=
lOOOlOOO\
OO
.
z
;
if
(
Fabs\

(
lOO\
OlOO\
OOO\

.
x
)
>
lO\
OO\
lOOO\
ll
)
{
lOO\
l\
OOlO\
O\
ll\
l\

.
lOOOOOllO\
l
[
0
]
.
llOOOl\
lO\
OlO
=
1.0f
/
lOOOlOOOOO
.
x
;
lOOl\
OOlOOll\
l\

.
lOOOOOl\
lO\
l\

[
0
]
.
llOO\
OllO\
Ol\
l
=
1
;
}
els\
e\

{
lOO\
lOOlOOlll
.
lOOOO\
OllOl
[
0
]
.
ll\
OOO\
l\
l\
OO\
l\
l
=
0
;
lOOlOOlOOl\
ll
.
lO\
O\
OOOllOl
[
0
]
.
llOOOllO\
lO\
O
=
(
lO\
OlO\
lOl\
ll
.
x
+
lO\
OlOll\
OOl\

.
x
)
*
0.5f
;
lOOlOOl\
OO\
ll\
l
.
lO\
OOOO\
ll\
Ol\

[
0
]
.
llOOOll\
Ol\
Ol
=
Fab\
s
(
lOOlOl\
Oll\
l\

.
x
-
lOOlOllO\
Ol
.
x
)
*
0.5f
;
}
if
(
Fabs
(
lOOO\
lOOO\
OO
.
y
)
>
lOOOlOO\
O\
ll\

)
{
lOOlOOlO\
Oll\
l
.
lOOOOOllO\
l
[
1
]
.
llOOO\
l\
lOO\
l\
O
=
1.0f
/
lOOO\
lOO\
OOO
.
y
;
lO\
OlOOlOOl\
ll
.
lOO\
OOOl\
lO\
l
[
1
]
.
llOOO\
l\
l\
OOll\

=
1
;
}
els\
e
{
lO\
O\
lOOlOOl\
ll
.
lOO\
OO\
Ol\
lOl
[
1
]
.
llOOO\
llO\
Oll
=
0
;
lOO\
lOO\
lO\
Olll
.
lOOOOO\
llOl
[
1
]
.
llO\
OOll\
O\
lO\
O\

=
(
lOOlOl\
Ol\
ll
.
y
+
lO\
O\
l\
O\
llOOl
.
y
)
*
0.5f
;
lOOlOOlOOlll
.
lOOOOOl\
lOl\

[
1
]
.
llO\
O\
Oll\
OlOl
=
Fabs
(
lOO\
lOl\
Olll
.
y
-
lOO\
lOllOO\
l
.
y
)
*
0.5f
;
}
if
(
Fa\
bs
(
lOOOl\
OO\
O\
OO\

.
z
)
>
lOOOlOOO\
ll\

)
{
lOOl\
O\
Ol\
OO\
lll
.
lOOOO\
OllO\
l
[
2
]
.
llO\
OOll\
OOl\
O
=
1.0f
/
lOO\
OlOOOOO\

.
z
;
lO\
OlOO\
lO\
Olll\

.
lOOO\
O\
Oll\
Ol
[
2
]
.
llO\
OOllOOll\

=
1
;
}
el\
se
{
lO\
Ol\
OO\
l\
OO\
ll\
l
.
lOO\
OOOl\
l\
Ol
[
2
]
.
llOO\
Oll\
OOl\
l
=
0
;
lO\
OlO\
OlOOl\
l\
l
.
lOOOO\
Ol\
lO\
l
[
2
]
.
llOOOll\
OlO\
O
=
(
lOOlOl\
Olll
.
z
+
lOOl\
O\
l\
l\
O\
O\
l
.
z
)
*
0.5f
;
lO\
OlOOlOOl\
ll
.
lO\
OOOOllOl\

[
2
]
.
llOOOll\
O\
lOl\

=
Fabs\

(
lOOlOlOlll
.
z
-
lO\
OlOl\
lOOl
.
z
)
*
0.5f
;
}
llOOOll\
O\
llO
(
lOOlOOOl\
Oll\
l
,
llll\
OlOOOOO
.
v3E\
xte\
nt
.
x
,
ll\
l\
lOlOO\
OO\
O\

.
v3C\
ent\
er\

,
&
lOOl\
OO\
l\
OOlll
)
;
}
lOOl\
O\
O\
OlO\
lOO\

::
llOOOO\
OOll\
O\

*
lOOlO\
OOlOl\
OO
::
llOOOOO\
lllO
(
llOOO\
OOOll\
O
*
*
lOOlOOlOlOOl
)
{
llOO\
OOOOll\
O
*
ll\
OO\
OOO\
llOl
=
lOOll\
OllOll\

;
if
(
lO\
OllOllOll
)
{
lOOl\
lOl\
lO\
l\
l
=
lOOl\
lOl\
l\
Ol\
l
->
lOO\
OOOO\
llll
(
)
;
if\

(
lOOllOllOll
)
{
TA_A\
SS\
E\
R\
T
(
lOOl\
l\
Oll\
Oll
->
lOlOl\
l\
OOOl
&
lOOlOOlOl\
Ol\
O
)
;
lO\
OllOl\
lO\
l\
l
->
lOOlOOO\
OOOO\

(
)
=
&
lOOll\
OllOll
;
}
TA_A\
SSERT
(
ll\
OOOOOll\
Ol
->
lOlOllOOO\
l
&
lOOlOOlOlO\
lO\

)
;
memset
(
llOOOOOllOl
,
0
,
si\
zeof
(
llOOOO\
OOl\
lO
)
)
;
lOOO\
l\
lll\
ll\
Ol
(
llOO\
OOOll\
Ol
)
;
}
else
{
if
(
lO\
O\
lO\
OOOOOOl
<=
0
)
re\
turn
0
;
co\
n\
st
int
lO\
OlOOlO\
l\
Oll
=
lO\
OOl\
l\
llll\
l\
l
;
int
lOOl\
OOlOllOO
=
lOOOlllllllO\

.
lOOO\
l\
llOOl
(
)
-
lOOlOOOOOOOl\

;
const
in\
t
lOOlOOlOllOl
=
lO\
O\
lOOlOllOO
-
lO\
OlO\
OlO\
lOll
;
int
lOO\
lOOl\
O\
lllO
=
(
in\
t
)
(
si\
zeof
(
llOOOOOO\
llO
)
/
4
)
-
lO\
OlOOl\
O\
llOl
;
wh\
ile
(
lOOlOOlOlll\
O
>
0
)
{
if
(
!
lOOlOOO\
llOll
)
retu\
rn
0
;
lOOlOOlOl\
lll
(
lOOlOOlOll\
O\
O
,
lO\
OlOOlOlOOl
)
;
lO\
OlOOl\
Ol\
l\
OO
+=
(
int
)
(
si\
zeof\

(
lOOlOOO\
l\
O\
lOl
)
/
4
)
;
lO\
OlOOlOl\
llO
-=
(
int
)
(
siz\
eof
(
lOOlOOOlOlOl
)
/
4
)
;
lOOlOOOOOO\
Ol
=
lOOOl\
lll\
lllO
.
lOOO\
l\
l\
l\
OOl
(
)
-
lOOlOOlOllOO
;
}
ll\
OO\
OOOllOl
=
(
llO\
OOOOOl\
lO\

*
)
&
lOOO\
lllllll\
O
[
lOO\
l\
O\
Ol\
O\
lOll
]
;
mems\
et
(
llOO\
OOOl\
lO\
l
,
0
,
si\
z\
eof
(
ll\
OOOO\
OOllO
)
)
;
lOO\
Ol\
lllll\
ll\

+=
(
int\

)
(
sizeof
(
llO\
OOO\
OOl\
lO
)
/
4
)
;
TA_ASSERT\

(
lOOO\
ll\
l\
llll\
l
+
lOOlOOOO\
OOOl
<=
lOO\
Olll\
l\
lll\
O\

.
lOO\
O\
lllOO\
l
(
)
)
;
lOOOllll\
ll\
O\
l
(
llO\
O\
OOOllOl
)
;
}
return
llO\
OO\
O\
O\
l\
lOl\

;
}
void
lOOlOOOlOl\
O\
O
::
llOOOOO\
OO\
lO\

(
llOOOO\
OO\
llO
*
llOO\
OOO\
Olll
)
{
TA_\
AS\
SER\
T
(
(
ll\
OO\
OOOOlll\

->
lOlOl\
l\
O\
OOl\

&
lOOlOOlOlOlO\

)
==
0
)
;
lO\
O\
Oll\
l\
ll\
l\
Ol\

(
ll\
OOOOOOlll
)
;
TA\
_A\
SSE\
R\
T
(
!
lOOl\
lO\
llOll\

||
lOO\
l\
l\
O\
llO\
ll
->
lOO\
lOOOOO\
OO\

(
)
==
&
lO\
O\
l\
lOl\
l\
Oll
)
;
llOOOOOO\
lll
->
lOOO\
OO\
O\
ll\
l\
l
(
)
=
lOOl\
l\
OllOll
;
if\

(
lOOll\
O\
llOll
)
lOO\
l\
lOllOll
->
lOOlOOOO\
OOO
(
)
=
&
llOOO\
OO\
O\
lll
->
lOOO\
O\
OO\
llll
(
)
;
lOO\
llO\
llOl\
l
=
llOOOOO\
O\
lll
;
llOOOO\
OOl\
ll\

->
lOOlO\
OOOO\
O\
O
(
)
=
&
lOOllO\
llOll
;
llOOOO\
OOll\
l
->
lOlOll\
OOOl
=
lOOlOOl\
OlOlO\

;
}
lOO\
l\
OOOlOl\
OO\

::
lO\
Ol\
OOOlO\
lO\
l
*
lO\
O\
lOOOlOl\
OO
::
lO\
Ol\
OO\
l\
OOlO\
O
(
llOOOOOO\
llO
*
*
lOOlO\
OlO\
l\
O\
Ol\

)
{
lO\
OlOO\
OlO\
lOl
*
ll\
OOOOOllO\
l
=
lOOlO\
OOllOll
;
if
(
lOOl\
OOO\
ll\
Oll\

)
{
TA_AS\
SERT
(
llOOOO\
OllOl
->
lOlOllOOOl
&
lO\
OlO\
OlOl\
O\
lO
)
;
lOOlOOO\
ll\
O\
l\
l
=
lOOl\
OOOllOll\

->
lOO\
OO\
O\
Ol\
lll
(
)
;
if
(
lOOlO\
O\
OllO\
ll
)
{
TA_\
ASSER\
T
(
lOOlOO\
OllOll
->
lOlOl\
lOOO\
l\

&
lOOlOOl\
OlO\
lO\

)
;
lO\
Ol\
OOOllOll
->
lO\
Ol\
O\
O\
O\
OO\
OO\

(
)
=
&
lOOlO\
OOll\
Oll
;
}
TA_ASSERT
(
ll\
O\
O\
OO\
OllOl\

->
lO\
lOllOOOl\

&
lOOlO\
O\
lOl\
O\
lO\

)
;
mems\
et
(
llO\
OOOO\
llOl\

,
0
,
si\
ze\
of
(
lOO\
lOO\
OlO\
l\
Ol
)
)
;
lOOl\
OOOOO\
OOO
(
llOOOOOl\
l\
Ol
)
;
}
els\
e
{
if\

(
lOO\
Olll\
lllll
<=
size\
of
(
llOO\
OOO\
Ol\
lO\

)
||
!
lOOll\
OllO\
l\
l
)
re\
turn
0
;
int\

lOOlO\
Ol\
O\
l\
Ol\
l
=
lOOOlllll\
lll\

;
in\
t\

lO\
O\
l\
OOlOllOO\

=
lO\
O\
Olllllll\
O
.
lO\
O\
O\
lllOOl
(
)
-
lOOlO\
OOOOOOl
;
cons\
t\

int
lOOl\
OOlO\
l\
l\
Ol
=
lOO\
lO\
OlOllO\
O\

-
lO\
OlOOlO\
l\
Oll\

;
int
lOO\
lO\
OlOll\
lO\

=
(
(
(
int
)
si\
zeo\
f
(
lO\
OlOOO\
lOlOl\

)
/
4
)
-
lO\
OlOOlO\
llOl
)
;
if
(
lOOlOOlOl\
l\
lO
>
0
)
{
TA_ASS\
ER\
T\

(
lOOlO\
O\
l\
Ol\
llO
-
(
int\

)
(
sizeof
(
llOO\
OOOOllO
)
/
4
)
<=
0
)
;
lOOlOOl\
O\
l\
O\
ll
-=
(
in\
t\

)
(
sizeof
(
llOO\
OOOOllO
)
/
4
)
;
lO\
OlO\
O\
l\
lO\
OO\
O
(
lOOl\
O\
OlOlOll\

,
lOOlO\
Ol\
OlOO\
l
)
;
}
lOOOllllllll
=
lOO\
lOOlOlOll
;
lOOlOO\
l\
OllOO
-=
(
(
int\

)
size\
of
(
lO\
Ol\
OO\
OlO\
lOl\

)
/
4
)
;
ll\
OOO\
OOll\
Ol
=
(
lOOlOO\
O\
lO\
lOl\

*
)
&
lOOOlllllllO\

[
lOOlOOl\
OllO\
O
]
;
memse\
t\

(
llO\
OO\
OOll\
O\
l
,
0
,
size\
of
(
lOOlOOOl\
Ol\
Ol\

)
)
;
lOOl\
OOOOOOOl
=
lOOOl\
l\
lllll\
O
.
lOOOlllOOl\

(
)
-
lOOlOOlOllOO
;
TA_ASSE\
RT
(
lOOOl\
l\
llll\
ll\

+
lOO\
lO\
OOO\
OO\
Ol
<=
lO\
OO\
llllll\
lO
.
lOOOlllO\
Ol\

(
)
)
;
lOO\
lOOOO\
OO\
O\
O
(
llOOOOOllO\
l\

)
;
}
ret\
urn
llOOOOO\
ll\
Ol
;
}
void
lO\
OlOOOlO\
l\
O\
O\

::
lOOlOOO\
llllO
(
lO\
OlOOO\
lOlOl\

*
ll\
OOOOO\
Ol\
ll
)
{
TA_ASS\
ERT
(
(
llOOOO\
O\
Oll\
l
->
lO\
lOl\
l\
O\
OO\
l
&
lOO\
l\
OOlO\
l\
OlO
)
==
0
)
;
lOOlOOOOOOO\
O
(
llOO\
OOOOl\
ll
)
;
TA_ASSER\
T\

(
!
lOOlOO\
OllO\
ll
||
lOOlO\
O\
OllOll\

->
lOO\
lOOOOOOO\

(
)
==
&
lOOlOOO\
l\
lOll
)
;
llOOOOOOlll
->
lOOOO\
OOllll\

(
)
=
lOOlO\
OOllOll
;
if\

(
lO\
OlOO\
OllOll
)
lO\
OlOOOllOl\
l
->
lOOlOO\
OOOO\
O
(
)
=
&
llO\
O\
OOO\
Olll\

->
lO\
OOOO\
O\
llll\

(
)
;
lOO\
lO\
OOl\
lOll
=
llO\
OOOO\
Ol\
l\
l
;
llO\
OOO\
OOlll
->
lOOl\
O\
OO\
O\
OOO
(
)
=
&
lOO\
lO\
OO\
llOll
;
llOOO\
OOOlll
->
lO\
lO\
llOOOl\

=
lO\
OlOOl\
OlO\
lO
;
}
void\

lOO\
lOOO\
lOlOO\

::
lOOl\
OOllOOOO\

(
int
lOOl\
O\
O\
llOOOl
,
llO\
OO\
OOOllO
*
*
lOOl\
OO\
lO\
lOOl\

)
{
lOOl\
OOO\
OO\
lOl
(
lO\
OlO\
O\
OlOlll
)
;
llOOOOO\
Ol\
l\
O
*
llOOOOOOll\
l
=
(
llOOO\
OOOll\
O
*
)
&
lO\
OOl\
llllllO\

[
lOOl\
OO\
ll\
OOOl
]
;
if
(
llOO\
O\
OOOl\
ll\

->
lO\
l\
O\
llO\
OOl\

&
lOO\
l\
OOlO\
lOlO\

)
{
lOO\
O\
l\
lllllOl\

(
ll\
OOO\
O\
O\
O\
l\
ll\

)
;
lO\
Ol\
OOOO\
lOl\
O
(
(
llOOO\
OOOll\
O\

*
)
lOOll\
Oll\
Ol\
l\

,
(
ll\
OO\
OOO\
OllO
*
)
llOO\
OOO\
O\
lll
)
;
TA_A\
S\
SER\
T
(
&
lOOOlllllllO\

[
lOO\
lOOllO\
O\
Ol\

]
!=
(
u32
*
)
lOO\
l\
O\
O\
OlOlll
)
;
TA\
_ASSERT\

(
!
llO\
OO\
OO\
Ol\
ll
->
lO\
OO\
OOOlll\
l
(
)
||
llOOOOOOll\
l
->
lOOOOO\
Olll\
l\

(
)
->
lOOlOO\
OOOO\
O
(
)
==
&
llOO\
OOOO\
ll\
l\

->
lOO\
OOO\
O\
lll\
l\

(
)
)
;
TA_AS\
SER\
T
(
ll\
O\
OO\
OOOl\
ll
->
lOOlOOO\
OO\
OO
(
)
)
;
TA\
_AS\
S\
ERT
(
*
ll\
O\
OOOOOll\
l
->
lOO\
l\
OOOOO\
O\
O
(
)
==
llOO\
OOOO\
lll
)
;
*
llOOOO\
O\
Olll
->
lO\
OlOOOO\
OOO
(
)
=
llOOOOO\
Olll
->
lOOOOOOl\
ll\
l
(
)
;
if
(
llOOO\
O\
O\
Ol\
ll\

->
lOOOOOOlll\
l\

(
)
)
ll\
O\
OO\
OOOl\
ll
->
lOO\
OOOO\
llll
(
)
->
lOOl\
OO\
OOOOO
(
)
=
ll\
O\
OO\
OOOl\
ll\

->
lO\
OlO\
OOOOOO
(
)
;
}
else\

{
TA_ASS\
E\
RT
(
&
lOO\
Olll\
llllO\

[
lO\
Ol\
O\
O\
ll\
OOOl
]
!=
(
u32
*
)
lOOl\
OO\
OlOl\
l\
l
)
;
lO\
OlOOOOOOlO
(
llO\
OOOO\
Ol\
ll
)
;
ll\
O\
OO\
OO\
Oll\
O
*
llOOOOOl\
lOl
=
lOOll\
OllO\
ll
;
TA_\
ASSERT
(
llOOOO\
Oll\
Ol\

)
;
lOOllOllOll
=
lOOllOl\
l\
Oll
->
lOOOO\
O\
Ollll\

(
)
;
if
(
lO\
Oll\
OllOl\
l
)
lOO\
llO\
llOll
->
lOOlOO\
OOOO\
O
(
)
=
&
lOOllOl\
lO\
ll
;
lOOOlll\
lllOl
(
llO\
OO\
OOl\
lOl
)
;
me\
mcpy
(
ll\
OO\
O\
O\
Ol\
lOl
,
llOOOOO\
O\
l\
l\
l\

,
sizeof
(
ll\
OOOOOOll\
O
)
)
;
fo\
r\

(
int
lOO\
OllOOOl\

=
0
;
lOO\
OllOO\
Ol
<
8
;
lO\
OOllOO\
O\
l
++
)
{
if
(
ll\
O\
O\
OOOllOl
->
ll\
OO\
OO\
l\
OOOl
[
lO\
O\
Oll\
O\
OOl
]
)
llOOOOOllOl
->
llOOOO\
lOOOl
[
lOO\
Ol\
lOOO\
l
]
->
llOOOOOlOll\

=
llOO\
OOOllOl
;
}
if
(
llOOOO\
OllO\
l\

->
ll\
OOOOOlOl\
l\

->
lOlOll\
OOOl
&
lOOl\
OOO\
l\
ll\
OO
)
ll\
OOOOOllOl
->
llOO\
O\
OOlOll
->
ll\
OO\
OOlOOOl
[
llOOOOOllOl
->
llO\
OO\
Ol\
OOlO\

]
=
llOO\
OOO\
llOl
;
els\
e
(
(
lOOlO\
OOlO\
lOl
*
)
ll\
OOO\
OOl\
lOl
->
llOOOOO\
lOll
)
->
llOOOOOllOO
=
ll\
OOOOOl\
lOl
;
if\

(
llOOOOOllO\
l\

->
llOOOOlOl\
OO\

)
ll\
OOO\
OO\
llO\
l\

->
llOOOOl\
Ol\
O\
O
->
llOOO\
OlOlOl\

=
&
llO\
O\
OOOllO\
l
->
llOOOOl\
OlOO\

;
lOOlOOOOOOlO
(
llO\
O\
O\
OOllOl
)
;
lOOlO\
O\
OOO\
OlO
(
llO\
OO\
OO\
ll\
O\
l\

->
llO\
OOOOlO\
ll
)
;
if\

(
*
lOOlOOlOlOOl
==
llOOOOO\
Olll
)
*
lOOlO\
Ol\
OlOOl\

=
llOO\
OO\
Oll\
Ol
;
lO\
OlOOOOOO\
lO
(
*
lOOlOOlOl\
OO\
l\

)
;
}
lOOlOOOOO\
lOl\

(
lOOlOOO\
lOlll\

)
;
}
void
lOOlOOO\
lOlOO
::
lOO\
lO\
OlOll\
ll
(
int
lO\
O\
lOOll\
OOOl
,
llO\
OOOOOl\
lO
*
*
lOOlOOlOlOOl
)
{
lO\
Ol\
OO\
OOOlOl\

(
lOOlOOOl\
Olll
)
;
lOOlOOOlO\
lOl\

*
llOOOOO\
Ol\
ll
=
(
lO\
Ol\
OO\
OlOlO\
l
*
)
&
lOOO\
l\
ll\
lll\
lO
[
lOOlO\
OllOOOl
]
;
if\

(
llO\
OOO\
O\
Olll
->
lOlOllO\
OOl
&
lOO\
lOO\
lO\
lOlO\

)
{
lOOl\
OOOOO\
OOO
(
llOOO\
OOOlll\

)
;
lOO\
lOO\
OOlOlO
(
(
llO\
OOOO\
OllO
*
)
lOOlOO\
Oll\
Oll
,
(
ll\
OOO\
O\
OOll\
O\

*
)
llO\
OO\
OOO\
l\
ll\

)
;
TA_ASS\
ERT\

(
!
ll\
OOOO\
O\
Olll\

->
lOOOOOOllll\

(
)
||
*
ll\
O\
O\
OO\
OO\
lll
->
lO\
OOO\
OOl\
lll
(
)
->
lOOlO\
O\
OOOOO
(
)
==
llO\
O\
O\
OOO\
ll\
l
->
lOOOOOO\
l\
lll
(
)
)
;
TA_ASSERT
(
!
llO\
OOOO\
O\
l\
ll\

->
lOOOOO\
O\
llll
(
)
||
ll\
OOOOOOlll\

->
lOOOOO\
Oll\
ll
(
)
->
lOOl\
OOO\
OO\
OO\

(
)
==
&
llOOOOOO\
lll\

->
lO\
OO\
OO\
Ol\
lll\

(
)
)
;
TA_ASSE\
RT\

(
llOOOOOO\
lll\

->
lOOlOOO\
OOO\
O\

(
)
)
;
TA_ASSERT
(
*
llOOOOOO\
ll\
l
->
lOOlO\
OOOOOO
(
)
==
llO\
O\
OOO\
O\
lll
)
;
*
llO\
OOO\
OO\
lll
->
lOOlO\
OO\
OOOO
(
)
=
llOO\
OOOOl\
ll
->
lOO\
O\
OOOllll
(
)
;
if
(
llOOOO\
OOl\
ll
->
lOOOOOO\
ll\
ll
(
)
)
llO\
OOOOOl\
ll
->
lO\
OOOOOllll\

(
)
->
lOOlO\
OOOOO\
O
(
)
=
llO\
OOOOOll\
l
->
lOO\
lOOOOO\
OO\

(
)
;
}
el\
se\

{
lOO\
l\
O\
OO\
OOlll
(
lOO\
l\
OOOl\
Olll
,
(
llOOOO\
OOllO
*
)
llOO\
OO\
OOlll
)
;
lOOl\
OOOO\
O\
OlO
(
(
llO\
OOOOOl\
lO
*
)
llO\
OOO\
OOll\
l
)
;
lOOl\
OOOlOl\
Ol
*
llOOOOOl\
l\
O\
l
=
lOO\
lO\
OOl\
lOll\

;
TA_A\
S\
S\
ERT
(
llOOOOOl\
lOl
)
;
lOOlO\
OOl\
lOll
=
lOOlOOOllOl\
l
->
lOOOOOO\
llll
(
)
;
if
(
lOOlOOOll\
Oll
)
lO\
OlOO\
O\
llOll
->
lOOlO\
O\
OO\
OOO
(
)
=
&
lO\
OlO\
O\
O\
llO\
ll
;
lOOlOO\
O\
OOOOO
(
ll\
OOOOOll\
O\
l\

)
;
memcpy
(
llOO\
O\
OOllOl
,
llOO\
OO\
OOl\
ll\

,
size\
of
(
lOO\
lOOO\
lOlOl
)
)
;
if\

(
ll\
O\
O\
OO\
OllOl
->
llOOOOOl\
l\
O\
O\

)
llO\
OOOOl\
lOl
->
llOOOOOllOO\

->
llO\
OO\
O\
O\
lOll
=
(
llOO\
OOOOl\
l\
O
*
)
llOO\
OOO\
l\
lOl
;
TA\
_ASSERT
(
llOO\
OOOl\
lOl
->
llO\
O\
O\
OOl\
O\
ll
)
;
if
(
llO\
OOOOl\
lOl
->
llOOO\
O\
OlOl\
l\

->
lOlOllOOO\
l
&
lOOlOOOlllO\
O
)
llOOOOOllOl
->
llOO\
OO\
OlOll\

->
ll\
OOOOl\
OOO\
l
[
llO\
O\
OOOllOl
->
ll\
OOO\
OlOOl\
O\

]
=
(
llOOOOOOllO\

*
)
llO\
OOO\
Oll\
Ol
;
else\

(
(
lOOlOOOl\
O\
lOl
*
)
llOOOOOllOl
->
llOO\
O\
OOl\
Oll\

)
->
ll\
OOOOOll\
O\
O\

=
(
llOOOOOO\
l\
l\
O
*
)
llOOOO\
O\
l\
lOl
;
if\

(
llOOOO\
O\
llOl
->
llOO\
O\
Ol\
OlOO
)
llOOO\
O\
OllOl
->
ll\
OO\
OOl\
OlO\
O
->
llOOOOlOlOl
=
&
llO\
OOOOllOl
->
llOOO\
OlOlOO
;
lO\
OlOOO\
OO\
O\
l\
O\

(
(
llOOO\
O\
OOl\
lO
*
)
llOOOOOllOl
)
;
lOO\
lOOOO\
OO\
lO
(
llOO\
OO\
Oll\
O\
l\

->
llOOOO\
O\
lOll
)
;
if
(
*
lOO\
l\
OOlOl\
OOl
==
(
llO\
OO\
OOOl\
lO
*
)
llOOOO\
O\
O\
lll
)
*
lOOlOOlOl\
OOl\

=
(
llOO\
O\
O\
OOl\
lO
*
)
llOOOO\
O\
l\
lOl
;
lOOlOOO\
OOO\
l\
O\

(
*
lO\
OlOOl\
OlO\
Ol\

)
;
}
lOOlO\
OOOOl\
Ol
(
lOO\
lOOOl\
Olll\

)
;
}
void
lOOlO\
O\
OlOlOO
::
lOOl\
O\
OOOOO\
l\
l\

(
llOO\
OOOOllO\

*
llO\
OOOOOlll
,
bool
lOOl\
OO\
l\
lO\
Ol\
O\

)
{
#ifdef _DEBUG
if
(
!
lO\
O\
lOOO\
l\
lO
)
retu\
rn\

;
TA_AS\
SERT
(
ll\
O\
O\
OOOO\
lll
)
;
TA\
_ASSERT
(
(
llO\
OO\
O\
OOl\
ll\

->
lO\
lOll\
O\
OOl\

&
lO\
OlOOlOlO\
lO
)
==
0
)
;
if\

(
llOO\
OOOOlll
->
llOOO\
Ol\
OlOO
)
{
TA_ASSERT
(
llO\
OO\
OOOlll\

->
ll\
OO\
OOlOlOO
->
llOOO\
OlO\
lOl
==
&
llOOO\
OO\
O\
lll
->
llOOOO\
lOl\
OO\

)
;
}
if
(
llOOO\
OOOll\
l
->
lOlOllOOOl
&
lOOlOOO\
lll\
OO
)
{
if
(
ll\
OOOOOOlll
!=
lOOlOOO\
lOlll
)
{
lOO\
Olll\
lll\
Ol\

(
ll\
OOO\
OO\
O\
l\
ll
)
;
if
(
lOO\
l\
O\
Oll\
OOl\
O
)
{
TA_\
ASSER\
T
(
llOOOO\
OOl\
ll\

->
llO\
llOOlOl\

>
1
)
;
}
TA\
_\
ASS\
ERT\

(
llOOOOOOlll
->
llO\
llOO\
lO\
l
>
0
)
;
TA\
_ASSERT
(
llO\
OOOOOlll\

->
llOOOOOlOll
)
;
}
TA_\
A\
SSER\
T
(
ll\
OOO\
OOOll\
l
->
ll\
OllOO\
l\
Ol\

<=
8
)
;
TA_AS\
S\
ERT
(
ll\
OO\
O\
OOOll\
l
->
llO\
O\
OO\
lO\
O\
OO
==
0
)
;
int\

llOll\
OOlO\
l\

=
0
;
fo\
r
(
int
lOOOllOOOl\

=
0
;
lOOOllOOOl
<
8
;
lOO\
Oll\
O\
O\
Ol
++
)
{
if\

(
llOO\
OOOOll\
l
->
ll\
OOO\
O\
l\
OOOl
[
lOOOllOOO\
l
]
)
{
TA_AS\
SE\
RT\

(
llO\
OO\
OOOlll
->
llOOOOlO\
OOl
[
lOOO\
llO\
OO\
l
]
->
llO\
OO\
O\
Ol\
Ol\
l\

==
llOOOOOOll\
l\

)
;
TA\
_ASSERT
(
llOOOOO\
Olll
->
llO\
O\
O\
OlO\
O\
Ol
[
lOOOl\
l\
OOO\
l
]
->
llO\
OO\
OlOOlO\

==
lO\
O\
OllOOOl
)
;
llOllOOlO\
l
++
;
}
}
TA\
_ASSER\
T
(
llO\
llOOlOl
==
llO\
OOO\
OO\
lll
->
ll\
OllO\
OlOl
)
;
}
else
{
TA_AS\
SER\
T
(
llO\
OO\
O\
OOlll\

!=
lOOl\
OOOlOll\
l
)
;
lO\
Ol\
OOOl\
Ol\
Ol
*
lOOl\
O\
OO\
lllOl
=
(
lOOlOOO\
lO\
lOl
*
)
ll\
OOOOOO\
ll\
l\

;
lO\
O\
lOOO\
OOOOO
(
lOOlOOOlll\
O\
l\

)
;
TA_\
AS\
SERT\

(
lO\
Ol\
O\
OO\
lll\
Ol
->
llOl\
l\
O\
OlOl
<=
1
)
;
TA_ASSE\
RT\

(
lOOlOOOlll\
O\
l
->
llOO\
O\
OOl\
O\
ll
)
;
if
(
lOOl\
OO\
Olll\
O\
l
->
ll\
OOOO\
O\
llOO\

)
{
TA\
_AS\
SERT
(
lOOlOO\
O\
lll\
Ol\

->
llOl\
lOOlOl
==
1
)
;
TA_\
AS\
SER\
T
(
lOOlOOOl\
l\
lO\
l
->
llOO\
OO\
lOOO\
O
==
lOOlOOOlllOl
->
llOO\
O\
OOllO\
O
->
llOOO\
OlOO\
lO
)
;
TA_ASS\
E\
R\
T
(
ll\
O\
OOO\
OOlll
==
lOOlOOOlllO\
l\

->
ll\
OOOOO\
llOO
->
llOOOOO\
l\
O\
ll
)
;
}
el\
s\
e\

{
TA_ASSE\
RT
(
lO\
O\
lOO\
O\
l\
llOl\

->
ll\
Ol\
lOOlO\
l
==
0
)
;
}
}
if
(
llOOO\
OO\
Ol\
ll\

->
llO\
OOOOlOll\

)
{
if
(
llO\
O\
OO\
OOl\
ll
->
llOO\
OOOlO\
l\
l
->
lOlOllO\
O\
Ol
&
lOOlOOOlllO\
O\

)
{
TA_A\
SSE\
RT
(
llOOO\
O\
OOll\
l
->
llO\
OOOOlOl\
l
->
llOOO\
OlO\
OOl
[
llOOOOOOlll
->
llO\
OOOl\
OOl\
O
]
==
ll\
OOOOO\
Ol\
ll
)
;
}
else
{
TA_ASSER\
T
(
(
(
lOOlOO\
OlOlOl\

*
)
llOOO\
OOOll\
l
->
llOOO\
OOl\
Oll
)
->
llOO\
OOOllO\
O
==
llO\
OOO\
OO\
lll
)
;
TA_ASSERT
(
(
(
lOOlOOOlOlO\
l\

*
)
ll\
O\
OOOOOl\
ll\

->
ll\
O\
OOOOlO\
ll
)
->
ll\
OOO\
O\
lOOOO
==
llOO\
OOOOll\
l
->
llO\
OO\
Ol\
OOlO
)
;
}
}
#endif //
}
vo\
i\
d
lOOl\
OO\
OlOlOO
::
llOOOl\
Ol\
Oll\

(
llO\
O\
OO\
OOll\
O
*
llOO\
OOO\
Oll\
l
,
in\
t\

lOO\
lO\
OlOO\
Oll
,
in\
t
llO\
OOO\
OOOl
,
int
ll\
OO\
OO\
OOlO
,
int
ll\
O\
OOOO\
Oll\

,
lOOl\
OOlOO\
llO\

*
lOO\
l\
OOl\
lO\
O\
ll
)
{
lOOlO\
O\
Ol\
Ol\
OO\

::
llOOOO\
OOllO\

lOOlO\
Ol\
lOlOO\

;
TA\
_ASSE\
RT
(
lOOlOOlOOOll
>=
0
)
;
TA_AS\
SER\
T
(
llOOOOOOll\
l
)
;
lO\
OlOO\
OOOOlO\

(
llOOO\
OOOl\
ll
)
;
for
(
Spac\
e\
Divisi\
on\
Ob\
ject
*
ll\
OO\
OOlOllO
=
llOO\
OOOO\
ll\
l\

->
ll\
OO\
OOlOl\
OO
;
llOO\
O\
OlO\
llO
;
llOOOOlOllO
=
llOOOOlOll\
O
->
llOOOOl\
llll
)
{
lO\
OlO\
Ol\
lOOl\
l
->
llOOlOllO\
OO
(
*
ll\
OO\
O\
O\
l\
O\
llO
,
lOOlOOllOO\
ll
->
lO\
OOOl\
lllO\

)
;
}
lOOlOO\
l\
O\
OOll
--
;
llOOOOO\
OOl
<<=
1
;
llOOOOOO\
lO
<<=
1
;
llOOO\
OOO\
ll
<<=
1
;
int
lOlOO\
O\
llOl\

=
0
;
if\

(
ll\
O\
OOOOOl\
ll
->
lOlOllOOOl
&
lOO\
lOOOl\
l\
l\
OO
)
{
#define lOOlOOllOlOl(llOOOOOOOl, llOOOlOlOOO, lOOlOOllOllO, lOOlOOllOlll)									\
		const int llOOOlOlOOO = (lOOlOOllOOll->llOOOlOlOOO >> (lOOlOOlOOOll)) + 1;					\
		if (Abs(llOOOOOOOl + 0 - (lOOlOOllOOll->llOOOOOOOl >> lOOlOOlOOOll)) <= llOOOlOlOOO)						\
		{																					\
			const int lOOlOOllOllO = 0;															\
			lOOlOOllOlll																			\
		}																					\
		if (Abs(llOOOOOOOl + 1 - (lOOlOOllOOll->llOOOOOOOl >> lOOlOOlOOOll)) <= llOOOlOlOOO)						\
		{																					\
			const int lOOlOOllOllO = 1;															\
			lOOlOOllOlll																			\
		}
lOOlOOll\
OlO\
l\

(
ll\
OOO\
OOOOl
,
llOOOlOlOOO
,
lOOlOOllOllO
,
lOOlOOl\
lOlOl
(
ll\
OOOOOOlO
,
llOO\
Ol\
OlOOl
,
lOOlOOl\
l\
lO\
O\
O
,
lO\
OlOOllOlOl
(
llO\
OOO\
OOll
,
llOOOlOlO\
lO
,
lOOlOOlll\
O\
Ol\

,
{
const
in\
t\

llOOO\
OlO\
Oll
=
(
lO\
OlOOll\
OllO
<<
2
)
+
(
lOO\
lOO\
lllOOO
<<
1
)
+
lOOlOOll\
l\
OO\
l
;
TA\
_\
ASSERT\

(
ll\
O\
OOOlOO\
l\
l
>=
0
&&
ll\
OO\
OO\
lOOll
<
8
)
;
if
(
llO\
OO\
OOOlll\

->
ll\
O\
O\
OOlOO\
Ol
[
ll\
OOOOlOOll
]
)
{
llOO\
OlO\
lO\
ll
(
llOOO\
O\
OOlll
->
llOOO\
OlOOOl
[
ll\
OOOOlO\
Ol\
l\

]
,
lOOlOOlOOOll
,
llOOO\
O\
OOO\
l\

+
lOOlOOllOllO\

,
ll\
O\
OOOO\
Ol\
O
+
lOO\
lOOlll\
O\
OO
,
llO\
OOOOOll
+
lOOlO\
OlllO\
Ol
,
lO\
OlOOllO\
Oll
)
;
}
}
)
)
)
#undef lOOlOOllOlOl
}
el\
se
{
lOOlO\
OO\
lOlOl
*
lOO\
lO\
OOlllOl
=
(
lOOlO\
OOlOlOl\

*
)
ll\
OOOOO\
Olll
;
if
(
lOO\
l\
OOOl\
l\
lOl
->
llOOOOOll\
O\
O
)
{
const
int\

llOOO\
lOlO\
O\
O
=
(
lOOl\
OO\
ll\
O\
Ol\
l
->
llOOOlOlOOO\

>>
(
lO\
OlOO\
lO\
OOl\
l
)
)
+
1
;
con\
st
int
lOO\
lOOllOllO
=
(
(
lOOl\
O\
OOlllO\
l
->
llOOOOlO\
OOO
>>
2
)
&
1
)
;
if
(
Abs
(
ll\
OOOOOOOl
+
lOOlOOl\
lOllO
-
(
lOOlOOllOOl\
l\

->
llOOOO\
OOOl\

>>
lOOlOOlO\
OO\
ll\

)
)
<=
llOO\
OlOlOOO
)
{
co\
ns\
t\

int
llOOOlOlOOl
=
(
lOOlOOl\
l\
OOll
->
llOOOlO\
lOOl
>>
(
lOO\
lOOlO\
O\
Oll
)
)
+
1
;
co\
n\
st\

int
lO\
O\
lOOll\
l\
O\
OO
=
(
(
lOOlOOOlllOl
->
ll\
O\
OOOlO\
OOO
>>
1
)
&
1
)
;
if
(
Ab\
s\

(
ll\
O\
OO\
O\
OOlO
+
lOO\
lOOlllOOO
-
(
lOOlOOllOO\
ll\

->
ll\
OOOOO\
OlO
>>
lOOlO\
OlO\
OOll
)
)
<=
llOO\
OlO\
lOO\
l\

)
{
const
int
llO\
O\
OlO\
lOlO\

=
(
lOOlOO\
llOO\
ll
->
ll\
OOO\
l\
OlOl\
O\

>>
(
lOO\
l\
O\
O\
lOOO\
ll\

)
)
+
1
;
con\
st\

in\
t\

lOOlOOl\
llOOl
=
(
lOOlOOO\
l\
llOl
->
llOOO\
OlO\
OOO\

&
1
)
;
if
(
Abs
(
ll\
OOO\
O\
OO\
ll\

+
lOOl\
OO\
lll\
OO\
l\

-
(
lOO\
lO\
O\
ll\
OO\
ll\

->
llOOO\
O\
OOll
>>
lOOlOOl\
OO\
Ol\
l
)
)
<=
ll\
OOOlO\
l\
OlO
)
{
llO\
OOl\
Ol\
O\
ll
(
lO\
OlOOOl\
llOl
->
llOOOOO\
llOO\

,
lOOl\
O\
O\
lOO\
Oll\

,
llO\
OOOO\
OO\
l
+
lOOlOOllOllO
,
llO\
OOOOO\
lO\

+
lO\
OlOOl\
llOOO\

,
ll\
OOO\
OOOll
+
lOOlO\
OlllOOl
,
lO\
Ol\
OO\
llO\
O\
ll
)
;
}
}
}
}
}
}
void
lOO\
lOO\
O\
lOlOO
::
llOOOllOll\
O
(
llOOOO\
OOllO\

*
llOOOOOOl\
ll
,
float
llOll\
Oll\
l\
l
,
Vec3\

&
v3Ce\
nter
,
lOOlOO\
lOlO\
O\
O\

*
lOOlOOl\
lO\
Ol\
l
)
{
float
lOOO\
OOllll
;
float
lOOllOOO\
O\
l
=
0.0f
;
flo\
at
lOOl\
lO\
OOlO
=
lO\
OlO\
OllO\
Oll
->
lOOlO\
llOOO
;
for
(
int
lO\
OOll\
llOl
=
0
;
lOOOl\
ll\
l\
Ol
<
3
;
lOOO\
llll\
Ol
++
)
{
float\

llOOOllOlOl
=
llOllOll\
ll\

*
3.0f
;
lOOlO\
OlO\
l\
OOO\

::
Axis\

&
lOOOO\
Oll\
Ol
=
lOOl\
OO\
llO\
Ol\
l\

->
lO\
OOOOllOl
[
lO\
OOll\
llOl
]
;
float
ll\
O\
OOll\
OlO\
O
=
v3\
C\
en\
ter\

[
lOO\
OllllOl\

]
;
lOOOOOl\
l\
l\
l\

=
Sign
(
lOO\
OOOllOl
.
llO\
OO\
ll\
O\
O\
lO
)
;
if
(
lOOOOOl\
lOl\

.
ll\
OOO\
l\
lO\
O\
ll
)
{
ll\
OO\
OllOlO\
l
*=
lOO\
OO\
Ollll
;
float\

lO\
lOllO\
l\
ll
=
llOOO\
llOlOO\

-
lOO\
OOOllO\
l
.
llOOOllOOOO
;
floa\
t
lOO\
l\
l\
O\
OllO
=
(
lOlO\
l\
lOlll\

-
llOO\
O\
l\
lOlOl\

)
*
lOOOOOllOl
.
ll\
OOOll\
OOlO
;
if
(
lOOllO\
OOlO
<
lOOllO\
OllO
)
retur\
n
;
float
lOOllOO\
l\
l\
l\

=
(
lOlOll\
Ol\
l\
l\

+
llOOOll\
Ol\
Ol
)
*
lO\
OO\
OO\
ll\
O\
l\

.
llO\
OOl\
l\
O\
Ol\
O
;
if\

(
lO\
Ol\
lOOOOl
>
lOO\
llO\
Ol\
ll
)
return
;
Cla\
mpIf\
L\
essTh\
en
(
lOOllOOOOl
,
lOOllOOl\
l\
O
)
;
Cl\
ampI\
fGr\
e\
ate\
r\
T\
h\
en
(
lOOllOOOl\
O
,
lOO\
l\
lOOlll
)
;
}
else
{
if
(
Fabs
(
lO\
O\
O\
OOllOl
.
llOOOl\
lO\
lO\
O
-
llOOO\
l\
lO\
l\
OO\

)
>
lOOOOOll\
Ol
.
llOOOllOlOl\

+
llOOOl\
lOl\
Ol
)
return
;
}
}
TA\
_ASSERT
(
ll\
OOOOOOlll
)
;
for
(
SpaceDivis\
ionObj\
ec\
t
*
llO\
OO\
OlO\
ll\
O
=
llOO\
OOOOll\
l
->
llOOOOlOlOO\

;
llOOOO\
l\
Oll\
O
;
llOO\
OOl\
O\
llO
=
llO\
OOOlOllO\

->
llOOOOl\
llll
)
{
lOO\
lO\
Ol\
lOO\
l\
l
->
llOOlO\
llOO\
O
(
*
llOOO\
O\
lOllO
,
lO\
OlOOllOO\
ll
->
lOOOOllll\
O
)
;
}
llOllO\
l\
ll\
l
*=
0.5f
;
if
(
llOOOOOOl\
ll
->
lOl\
OllOOOl
&
lO\
Ol\
OOO\
l\
ll\
OO
)
{
fo\
r\

(
int\

llOO\
OO\
l\
OO\
l\
l
=
0
;
ll\
OOOO\
lOOl\
l\

<
8
;
llOOOOlOOl\
l
++
)
{
if\

(
ll\
OOOOOOl\
ll
->
ll\
OOOO\
l\
O\
OOl
[
llO\
O\
O\
OlOO\
ll
]
)
{
Ve\
c\
3
lOO\
OOOOl\
OO
=
v3Ce\
nt\
er\

;
lOOOOOOlO\
O
.
x
+=
llO\
llOl\
ll\
l\

*
(
float
)
(
(
(
llOOOOlOOl\
l
&
0x4
)
>>
1
)
-
1
)
;
lOOO\
OOO\
lOO
.
y
+=
ll\
OllO\
lll\
l
*
(
fl\
oa\
t
)
(
(
ll\
O\
OO\
OlOOll\

&
0x2
)
-
1
)
;
lOOOOO\
OlOO
.
z
+=
ll\
Oll\
Ollll
*
(
float
)
(
(
(
llO\
OOOlOOll
&
0x1
)
<<
1
)
-
1
)
;
llO\
OOllOllO
(
ll\
O\
O\
OOOOlll
->
llOOOOlOOOl
[
ll\
OO\
OOlOOll
]
,
llOll\
Ollll
,
lOOOOO\
OlOO
,
lO\
OlOOll\
OO\
ll
)
;
}
}
}
else
{
lOOlOO\
OlOl\
O\
l
*
lOOlOOOlllOl\

=
(
lOOlO\
O\
OlO\
lOl
*
)
llO\
O\
OOOO\
l\
ll
;
if
(
lOOlOOOl\
l\
l\
Ol\

->
llO\
O\
O\
OOll\
OO
)
{
int\

llOO\
O\
Ol\
OOl\
l
=
lOOl\
O\
OOlll\
Ol
->
ll\
OO\
OOlOOOO
;
Vec3\

lOOOOOOlOO
=
v3\
Center\

;
lO\
OOOOO\
l\
OO
.
x
+=
llOllO\
llll\

*
(
float
)
(
(
(
llO\
OOOlO\
Oll\

&
0x4
)
>>
1
)
-
1
)
;
lOOO\
OOOlOO
.
y
+=
ll\
O\
ll\
Ol\
l\
l\
l\

*
(
floa\
t
)
(
(
llOOO\
Ol\
OOll
&
0x2
)
-
1
)
;
lOO\
OOOOlOO
.
z
+=
ll\
Oll\
Ollll
*
(
float
)
(
(
(
llOOO\
OlO\
Oll
&
0x1
)
<<
1
)
-
1
)
;
ll\
OOOllO\
ll\
O\

(
lO\
Ol\
OOOlllOl\

->
llOOO\
OOll\
OO\

,
ll\
OllOl\
ll\
l
,
lO\
O\
OOOOl\
OO\

,
lOOl\
OOllOO\
ll
)
;
}
}
}
vo\
id
lOOlOOOl\
O\
l\
O\
O
::
lO\
Ol\
OOOOO\
llO
(
llOOO\
O\
OOll\
O\

*
llOOOOOOlll
)
{
#ifdef _DEBUG	
if
(
!
lO\
Ol\
OOOllO
)
return
;
lOO\
lOOOOO\
Ol\
O
(
llO\
OOOOO\
l\
ll
)
;
TA\
_ASSER\
T\

(
llOOOOOOl\
ll
)
;
if\

(
llOO\
O\
OOOlll
->
lOlO\
llOO\
Ol
&
lOOlO\
OOl\
ll\
OO\

)
{
for
(
in\
t
ll\
O\
OOOlOOll\

=
0
;
llOOOOlOO\
ll
<
8
;
ll\
O\
OO\
OlOOll\

++
)
{
if
(
llOOOOO\
O\
ll\
l
->
llOOO\
Ol\
OOOl\

[
ll\
OOO\
OlO\
O\
ll
]
)
lOO\
lOO\
O\
OO\
llO
(
llOOOOO\
Olll\

->
llOOO\
OlOOOl
[
ll\
OOOOl\
OOll
]
)
;
}
}
else\

{
lOOlO\
OOl\
OlOl
*
lOOlOO\
Olll\
Ol
=
(
lOOlOOO\
l\
OlO\
l
*
)
ll\
OOO\
OOOlll
;
if
(
lO\
OlO\
OOll\
lOl
->
ll\
OOOOOl\
lOO
)
lOOlOOO\
OOllO
(
lOOl\
OOO\
l\
llOl\

->
llOOOOOllOO
)
;
}
#endif //
}
bo\
ol\

lOOlOO\
O\
lOlOO
::
lOOlO\
OOO\
lOOl
(
llO\
OOOOOllO\

*
ll\
O\
O\
OOOOlll
,
llOOOOO\
O\
llO
*
lOOlOOOOl\
OOO
)
{
#ifdef _DEBUG	
if
(
!
lOOl\
OOOl\
lO
)
re\
tu\
rn\

true\

;
lOOlOOOOOOlO\

(
llOOOOOOlll
)
;
TA\
_ASSER\
T
(
llOOOOOOl\
l\
l
)
;
if
(
ll\
OOO\
OOOl\
ll\

==
lOO\
lO\
O\
OOl\
OO\
O
)
re\
tu\
rn
tru\
e
;
if
(
ll\
OOO\
OOOl\
ll\

->
lOlO\
ll\
OO\
Ol
&
lOOlOO\
Oll\
l\
OO\

)
{
fo\
r
(
in\
t\

ll\
OOOOl\
OOl\
l
=
0
;
ll\
O\
OOOlOOll
<
8
;
llOOOO\
lOOll
++
)
{
if\

(
llO\
OOOOO\
l\
l\
l
->
ll\
OOOO\
lOOOl
[
ll\
O\
OOO\
lOOl\
l\

]
)
{
if
(
lOOl\
OO\
O\
OlOO\
l
(
ll\
OOOOOOll\
l
->
llO\
OOO\
lOO\
Ol
[
llOOOOl\
O\
Oll\

]
,
lOO\
lOOO\
Ol\
OO\
O\

)
)
return
tr\
u\
e\

;
}
}
}
else\

{
lO\
O\
lOO\
OlO\
lOl
*
lO\
Ol\
OO\
Ol\
llOl\

=
(
lOOlOOOl\
OlOl\

*
)
ll\
OO\
OOOO\
lll
;
if
(
lO\
Ol\
OOOlll\
Ol
->
llOO\
O\
OOl\
lOO
)
{
if
(
lOOlO\
O\
OOlOO\
l
(
lOOlOO\
Oll\
lO\
l
->
llOOOOOllOO\

,
lOOlOOO\
OlOOO
)
)
return
tr\
u\
e
;
}
}
return
false
;
#else
retu\
rn
tru\
e
;
#endif //
}
void
lOOlOO\
OlOlOO\

::
lO\
OlOO\
OOl\
O\
ll
(
llOOO\
OO\
OllO
*
llOOO\
OOO\
lll
,
llO\
O\
OO\
OOllO
*
lOOlOOO\
OlOOO
)
{
fo\
r
(
;
llOO\
OOOOl\
ll
;
llO\
OOOO\
Olll
=
llO\
OOOOOl\
ll
->
lOOOO\
OOllll
(
)
)
if
(
llOOOOOO\
ll\
l
==
lOOl\
OOOO\
lOOO\

)
return
;
TA_ASSERT
(
0
)
;
}
}
