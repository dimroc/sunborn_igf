//---------------------------------------------------------------------------------
// File Name: zpta007.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#define lOllOllOOOO
#include "CollisionObjectCachedPolyData.h"
#ifndef lllOOOlOllO
#include "../Physics/zpta007.h"
#endif //
namesp\
ac\
e
TA
{
struct\

lllOOOlOl\
l\
l\

{
enum
{
lll\
O\
OOllO\
OO
=
0x1
,
ll\
l\
O\
OOllOOl
=
0x2
,
}
;
flo\
a\
t
lOl\
lOOlO\
OOl\

;
flo\
a\
t
lllO\
llllOO\

;
in\
t
llOl\
l\
lOOllO
;
u32
lO\
lO\
llOOO\
l
;
Vec\
3
lllOOOllOlO
;
Vec3
lOO\
O\
Olll\
l\
l
;
Vec3
lOOO\
lOOOOO
;
Ve\
c3
lll\
OOOllOll
;
}
;
stru\
ct\

lllOOOlllOO
{
Vec3
lOOOOlllll
;
Ve\
c3
ll\
lOOOll\
lOl
;
}
;
struc\
t\

lllOOOll\
l\
l\
O
{
fl\
o\
at
lOll\
OO\
lOOO\
l
;
float
lllOll\
llOO
;
u32
ll\
Olll\
OOllO
;
int
lO\
l\
lOlO\
lOOO
;
Vec\
3
lOllllO\
O\
lO\
O
;
Vec\
3
lOlll\
O\
ll\
OOO
;
Vec3\

lOOOO\
lllll
;
Ve\
c3
lOO\
OlOOO\
OO
;
}
;
st\
at\
i\
c
int
lllOOOl\
ll\
l\
l
=
0
;
st\
ati\
c
const
int\

lllOO\
l\
OOOOO\

=
32
;
sta\
tic
lll\
OOOlOll\
l
lllO\
O\
lOO\
O\
Ol
[
lll\
OOlOOOO\
O
]
;
st\
ati\
c
int
lllOOlOOOlO
[
2
]
=
{
0
,
0
}
;
st\
at\
ic\

const
int
lllOOlOOO\
l\
l
=
32
;
stati\
c\

Vec\
3\

ll\
lO\
Ol\
OO\
lOO
[
lllOO\
lOO\
O\
l\
l
]
[
2
]
;
sta\
tic
int\

ll\
lO\
OlO\
OlOl
=
0
;
st\
a\
ti\
c\

lllOOOll\
lOO
ll\
l\
O\
O\
lOOl\
lO
[
lllOOlO\
OOll\

]
;
st\
at\
ic
int
lllOOlO\
O\
lll\

=
0
;
static
cons\
t
in\
t
ll\
l\
OOlO\
l\
OO\
O
=
32
;
st\
atic\

lllOOOllllO\

lllOOl\
OlOOl
[
lll\
O\
O\
lO\
l\
OOO
]
;
stat\
ic
in\
t
lllOOl\
OlOlO
[
3
]
=
{
0
,
0
,
0
}
;
sta\
t\
ic
const
int
lll\
OOlOlOll
=
32
;
st\
a\
tic
Vec3
lll\
OO\
lOllOO
[
3
]
[
lllOO\
lOlOll
]
[
2
]
;
voi\
d
Co\
llisio\
n\
O\
bjectCac\
hedPolyDat\
a
::
Po\
lygon
::
Gene\
rateEd\
g\
eNor\
ma\
l\
s
(
)
{
for
(
int
lOOO\
llOOOl
=
0
;
lOOOllOO\
Ol
<
lO\
llOllOll
;
lO\
OOllOO\
Ol\

++
)
{
con\
st\

Vec3
&
llllOO\
OOOl
=
llOllllOOO\

[
lO\
OOllOOO\
l
]
.
lO\
O\
OOl\
ll\
l\
l\

;
co\
ns\
t
Vec3
&
lll\
lO\
OOOl\
O
=
llO\
lll\
lOOO
[
lOOOl\
l\
OOOl
<
lOllOll\
O\
ll
-
1
?
lO\
O\
OllOO\
Ol
+
1
:
0
]
.
lOOO\
Ol\
llll
;
Vec3
lOlllOlO\
lOl
=
lOO\
OlOOOOO
.
Cross
(
llllOOOOOl
-
llllOOO\
O\
lO
)
;
TA_ASSERT
(
lO\
lllO\
lO\
lOl
.
GetMagnit\
ude
(
)
>
0.0f
)
;
lO\
lllOl\
O\
lOl
.
No\
rmalis\
e
(
)
;
llOlll\
l\
OO\
O
[
lOO\
Ol\
l\
O\
O\
Ol
]
.
lOlll\
OlOlOl
=
lO\
lll\
OlOlOl
;
}
}
void
Co\
l\
lisionObj\
ectC\
ac\
hedPol\
yD\
ata
::
Initial\
ise
(
)
{
lO\
OOllOOOlO
.
Initia\
l\
i\
se
(
0
,
8
*
1024
)
;
lllOOlO\
ll\
Ol
=
0
;
}
vo\
i\
d
CollisionObj\
ec\
tCach\
edPolyDat\
a\

::
Fi\
na\
lis\
e
(
)
{
lOOOllOO\
OlO
.
Finalise\

(
)
;
lllO\
Ol\
OllOl
=
0
;
}
CollisionObje\
ctCachedPolyD\
ata
::
Po\
ly\
gon\

*
Coll\
i\
sio\
n\
ObjectCa\
c\
h\
ed\
Po\
lyData
::
GetNewPo\
lyg\
o\
n
(
in\
t
lOll\
OllOll
)
{
TA\
_ASSERT
(
lOOOllOOO\
lO
.
lOOllllO\
ll
(
)
>
0
)
;
con\
st\

int
lllOOlOll\
l\
O\

=
lllOOlOllll
(
lOll\
Oll\
Ol\
l
)
;
if\

(
lOOOll\
OOO\
lO\

.
lO\
O\
O\
ll\
lOOl
(
)
+
ll\
l\
O\
Ol\
Oll\
lO
>
lO\
OOllOO\
Ol\
O
.
lO\
O\
lll\
lOll
(
)
)
ret\
ur\
n
0
;
const
int
llOlllOOlll
=
lOOOl\
lOOOl\
O
.
lO\
O\
Oll\
lO\
O\
l
(
)
;
lOOO\
l\
l\
OOOlO\

.
lO\
OlllllOl\

(
lllOOlOlllO
)
;
Po\
l\
yg\
on\

*
llOlllll\
OlO\

=
(
Poly\
go\
n\

*
)
&
lOOO\
ll\
OOOl\
O
[
llOlll\
O\
Ol\
l\
l
]
;
retur\
n
llO\
lllllOlO
;
}
Collis\
i\
onObje\
c\
t\
C\
ac\
he\
dPolyData\

*
TAC_CA\
LL
Co\
l\
lisionOb\
je\
c\
tCached\
PolyDat\
a\

::
Create\
New
(
)
{
Colli\
sion\
O\
bjectCac\
h\
edP\
olyData
*
lO\
l\
Ol\
lOOlll
;
lOO\
OOOll\
OOO
(
lOlOllOOll\
l
,
Collision\
ObjectC\
ac\
hed\
Po\
l\
yDa\
t\
a
)
;
ret\
urn\

lOlO\
l\
l\
OOlll
;
}
Col\
lisionObj\
e\
ctC\
achedPol\
yD\
at\
a
::
Col\
l\
isi\
o\
nO\
b\
jec\
tCachedPoly\
Data
(
)
:
Coll\
is\
i\
onO\
bjec\
t
(
TY\
PE_CA\
CH\
E\
D_POLY\
_D\
ATA\

)
{
}
Collision\
Obj\
e\
c\
tC\
a\
ch\
e\
dPolyDa\
ta\

::
~
Col\
lision\
Obj\
ectCachedPo\
l\
yData
(
)
{
Fi\
nalise
(
)
;
}
#ifndef DOXYGEN
voi\
d
TAC_CALL
lllO\
O\
ll\
OOOO
(
)
{
lllOO\
O\
ll\
lll
=
0
;
lll\
O\
Ol\
OOOlO\

[
0
]
=
0
;
ll\
lOOlOO\
OlO
[
1
]
=
0
;
ll\
lOOlOOll\
l
=
0
;
lllOO\
lOl\
O\
lO
[
0
]
=
0
;
lllOO\
l\
OlO\
lO
[
1
]
=
0
;
lllO\
OlO\
lOlO
[
2
]
=
0
;
lll\
OOl\
OO\
lOl
=
0
;
}
voi\
d
TAC_\
C\
ALL
ll\
lO\
OllO\
OO\
l\

(
lOllOllOl\
lO
*
lO\
l\
l\
lOO\
OOOl
)
{
for\

(
int\

lllOOllOOlO
=
0
;
ll\
l\
OO\
llO\
O\
lO
<
ll\
lOO\
O\
ll\
l\
l\
l
;
lll\
OO\
l\
lOO\
l\
O
++
)
{
con\
st
lllOOOlOl\
ll
&
lllOOll\
OOll
=
lllOOlOOOOl
[
lllOOllO\
OlO\

]
;
if\

(
(
lllOOllOOl\
l\

.
lO\
lOll\
OO\
Ol
&
ll\
lOO\
Ol\
O\
l\
l\
l
::
lllOOOllOOl
)
==
0
)
{
const
floa\
t
lOllOlO\
lOl
=
0.0001f
;
bool
lll\
OOllO\
l\
O\
O
=
fa\
l\
se\

;
fo\
r\

(
int
lOll\
O\
lOl\
OOO
=
0
;
lOll\
OlOl\
OOO\

<
2
;
lOl\
lOlOlO\
OO
++
)
{
int
lOOO\
llOOOl\

;
for\

(
lOO\
O\
llOO\
Ol
=
0
;
lOOO\
ll\
OO\
Ol
<
lll\
OOl\
O\
OO\
l\
O
[
lOllO\
lOlOO\
O
]
;
lOO\
OllO\
OO\
l
++
)
{
if
(
(
lllOOl\
OOl\
OO\

[
lO\
OOll\
OO\
Ol\

]
[
lOllO\
l\
OlO\
OO
]
-
lllOO\
llOOll
.
lllOOOllO\
lO\

)
.
GetMa\
gnitu\
deSqrd
(
)
<
lOl\
lOl\
OlOl
*
lO\
l\
l\
Ol\
OlOl
)
br\
eak
;
}
if
(
lOOO\
llO\
OO\
l
!=
lllOO\
l\
OOOlO
[
lOllO\
lOlOOO
]
)
{
ll\
l\
OOllO\
lO\
O\

=
true\

;
br\
ea\
k
;
}
if\

(
lllOOllO\
O\
ll\

.
lOl\
OllOO\
Ol\

&
ll\
lO\
OOlO\
lll\

::
ll\
lO\
OO\
llOOO
)
{
fo\
r
(
lOOOl\
l\
OOOl
=
0
;
lOO\
Oll\
OOOl
<
lllOOlOOlO\
l
;
lO\
O\
OllOOOl
++
)
{
if\

(
(
ll\
lOOl\
O\
OllO
[
lOOOllOO\
O\
l
]
.
lOOOOl\
l\
lll
-
lllO\
OllOOl\
l\

.
lllOOOll\
OlO
)
.
Get\
Ma\
g\
n\
itudeSqrd
(
)
<
lOllO\
lOl\
Ol
*
lOllOlO\
lOl
&&
(
lll\
O\
O\
lOOl\
l\
O\

[
lOOO\
l\
lOO\
Ol\

]
.
lll\
OOO\
lllOl
-
lllOOll\
OOll\

.
lllO\
O\
Ol\
lOll
)
.
Ge\
t\
Ma\
gnitudeSq\
rd\

(
)
<
lOllOlOl\
Ol
*
lOll\
OlOlOl
)
break
;
}
if
(
lOOOl\
lOOOl
!=
lll\
O\
OlOO\
lO\
l
)
lllO\
OllOlOO
=
true
;
break
;
}
}
if
(
lll\
O\
O\
llOlOO
)
co\
n\
t\
in\
ue\

;
}
Collis\
ion\

llOll\
l\
lOlOl
;
ll\
OllllOlOl\

.
In\
itia\
li\
se
(
Collisi\
on
::
lO\
llOOllllO\

,
lll\
O\
Ol\
lOOl\
l\

.
lll\
Ol\
l\
ll\
OO
,
lllOOl\
lOOl\
l
.
lO\
llOO\
l\
O\
OOl
,
lll\
OOll\
OOll
.
lOOOO\
lllll
,
lll\
OO\
ll\
O\
Oll
.
lO\
OOlOOOO\
O\

)
;
llOl\
l\
llOlOl\

.
lOllOOlOOOO\

=
ll\
l\
OOllOOll
.
llOlllO\
O\
l\
lO\

;
lllOOllOl\
Ol
(
llOllllOl\
Ol
,
lO\
lllO\
OOOOl\

)
;
}
for
(
int\

lllOOllOllO
=
0
;
lll\
OOll\
OllO
<
lllO\
Ol\
OOlll
;
lll\
OOl\
lOllO
++
)
{
co\
nst
lllO\
OO\
llllO\

&
lll\
OOllOlll
=
lllOOlO\
lOOl\

[
ll\
lOOllOl\
lO
]
;
con\
st
int\

lOl\
lOlO\
lOOO\

=
ll\
lO\
OllOll\
l\

.
lOll\
OlOl\
OO\
O
;
int
lOO\
OllOOOl
;
for
(
lOOOllOOO\
l
=
0
;
lOOOllOO\
Ol
<
lllOOlOl\
OlO
[
lOll\
O\
lOlOOO
]
;
lO\
O\
O\
llO\
O\
Ol
++
)
{
co\
n\
s\
t
float
lOllOl\
Ol\
Ol\

=
0.0001f
;
if
(
(
(
lllO\
OlOl\
lOO\

[
lOllO\
lO\
lOOO
]
[
lO\
O\
O\
ll\
OOOl
]
[
0
]
-
lllOO\
llOlll
.
lO\
ll\
llOO\
lO\
O
)
.
GetMagnitud\
e\
Sq\
r\
d
(
)
<
lOl\
lOlO\
lOl\

*
lO\
ll\
Ol\
Ol\
Ol
)
&&
(
(
lllOOlOll\
OO
[
lOl\
l\
OlOlO\
OO
]
[
lOO\
OllOOOl
]
[
1
]
-
lllO\
O\
llO\
l\
ll\

.
lOlllOl\
lOO\
O
)
.
GetMa\
gnitu\
d\
eSq\
r\
d
(
)
<
lOllOlO\
lOl
*
lOllOlOl\
Ol
)
)
br\
eak
;
}
if
(
lOOOllO\
OOl\

!=
ll\
lOOl\
Ol\
Ol\
O\

[
lOll\
Ol\
OlOOO
]
)
co\
ntinue\

;
Co\
llision
lO\
ll\
O\
llOlOl
;
lO\
llOllOl\
Ol\

.
Initialise\

(
Collis\
io\
n
::
lOl\
lOOl\
lllO
,
ll\
lOOl\
lOlll
.
lll\
Oll\
llOO
,
lll\
OOl\
l\
O\
ll\
l
.
lOllO\
O\
l\
OOOl
,
ll\
lO\
OllO\
lll
.
lOO\
OOlllll
,
ll\
l\
O\
Ol\
lOlll\

.
lOOO\
lOOOOO
)
;
lOllOllOlOl
.
lO\
l\
lOO\
l\
O\
OOO
=
lllOO\
llOlll
.
llOlllOOllO
;
lllOO\
llOlOl
(
lOl\
lOll\
OlOl
,
lO\
lllO\
OO\
OO\
l\

)
;
}
}
voi\
d
TAC_CA\
L\
L
ll\
l\
OO\
lllOOO
(
float
lllOl\
lll\
OO
,
float\

lO\
llOO\
l\
OOOl\

,
const
Col\
li\
sionObj\
e\
ctCache\
dPoly\
Data\

::
Pol\
ygo\
n\

*
llOO\
OlO\
O\
lO\

,
in\
t
lOlllOO\
lll
,
bool\

lllOO\
lllOOl
,
cons\
t
Vec3
&
lllOOOll\
Ol\
O
,
con\
s\
t
Ve\
c\
3\

&
lllO\
O\
l\
ll\
O\
lO
,
cons\
t
Vec\
3
&
lOO\
OlO\
O\
O\
O\
O
)
{
TA_A\
SSER\
T\

(
lllOO\
Oll\
lll
<
lllOOlOO\
O\
OO
)
;
if
(
lllOOOlllll\

>=
lllOOl\
OOOOO
)
retu\
r\
n
;
TA_ASSERT
(
ll\
lOl\
ll\
l\
OO
>=
0.0f
)
;
TA_\
ASSERT
(
lll\
Oll\
llOO
<=
1.0f
)
;
TA_AS\
S\
E\
RT
(
lO\
lllOOlll
>=
0.0f
)
;
TA_ASSER\
T
(
lOlllO\
Oll\
l
<
llO\
OOl\
OO\
lO
->
lOl\
lOl\
lOll
)
;
ll\
lOOOlOlll
&
ll\
lOOllOOll
=
lllOOlOOO\
Ol
[
lllO\
O\
Ollll\
l
++
]
;
lll\
O\
O\
ll\
O\
Oll
.
lOll\
O\
OlOOOl
=
lOllOOlOOOl\

;
ll\
lO\
OllO\
Oll\

.
lllOllllO\
O
=
lllOll\
llOO
;
lll\
O\
OllOO\
ll
.
lllOOOl\
lO\
lO
=
lllOOO\
llOlO\

;
lll\
OO\
llOOll
.
lOO\
OO\
lll\
ll\

=
lll\
OO\
l\
llO\
lO\

;
lll\
OOllO\
O\
ll
.
lOlO\
ll\
OO\
O\
l
=
0
;
lll\
OO\
ll\
O\
Oll
.
lOOOlOOO\
OO
=
lOO\
O\
lOOOOO\

;
lll\
OOllOOl\
l
.
lllOOO\
llO\
ll
.
Cle\
ar
(
)
;
ll\
l\
OOllOOll
.
llOlll\
OOllO
=
ll\
O\
OO\
l\
O\
OlO
->
ll\
OlllOOl\
lO
;
if
(
lllOOlll\
OOl
)
{
co\
nst
fl\
oat
lOllOlOl\
O\
l
=
0.0001f
;
con\
st
int\

lOlllO\
lO\
l\
lO
=
lOlllO\
Olll
+
1
<
llOOO\
lOOlO\

->
lOl\
lOllOl\
l
?
lOl\
llOOll\
l\

+
1
:
0
;
const\

int
lOlllOlllOO\

=
lOl\
ll\
OOlll
-
1
>=
0
?
lOlllOOll\
l
-
1
:
ll\
OOOl\
O\
O\
lO
->
lOll\
O\
llOll
-
1
;
const
Vec3
&
lOll\
l\
lOOlO\
O\

=
llOOOlO\
OlO
->
llOlll\
l\
OOO
[
lOlllO\
Ol\
ll
]
.
lOO\
OOl\
ll\
ll
;
const
Ve\
c3
&
lOlllOllO\
OO\

=
llOOO\
l\
OOl\
O
->
ll\
Ol\
lllOOO
[
lOl\
l\
l\
OlOllO
]
.
lOOOO\
lllll
;
cons\
t
Vec\
3
&
lllOOl\
l\
lO\
l\
l
=
ll\
O\
OOlOOlO
->
llOllll\
O\
OO
[
lOl\
l\
l\
Oll\
lOO
]
.
lOOOOllll\
l\

;
TA\
_A\
SSE\
RT
(
(
lllOO\
O\
llO\
lO\

-
lOll\
ll\
OOlOO
)
.
IsZer\
o\

(
)
)
;
flo\
at
lll\
OOllllO\
O
=
ll\
OO\
O\
lOOlO
->
llOllllOOO
[
lOl\
llOOlll\

]
.
lOll\
l\
OlO\
lOl\

.
Do\
t\

(
lOOOl\
OOO\
OO
)
;
float
lll\
OOllll\
Ol
=
llOOOlOOl\
O
->
llOl\
ll\
l\
OOO\

[
lOlll\
OlllOO
]
.
lOl\
llO\
lOlOl
.
Dot
(
lOOOlO\
OOOO
)
;
if\

(
ll\
l\
OOl\
lllOO\

>=
0.0f
&&
lllOOl\
ll\
lOl
>=
0.0f
)
{
lllOO\
llOOll
.
lOOOlOOO\
OO\

=
llOOOlOOlO
->
lOOOlO\
OO\
OO
;
lll\
O\
OllOO\
ll
.
lOlOllOOOl\

|=
ll\
lOOOlOl\
ll\

::
lllOO\
Ol\
lOOl
;
ll\
lOO\
lll\
ll\
O\

(
lllO\
OOll\
O\
lO
,
ll\
l\
OOlll\
lll\

)
;
}
else
{
bool
lll\
O\
lOOO\
OOO
=
tr\
ue
;
{
Ve\
c3
lllO\
OOlllOl
=
lO\
lllOll\
OOO\

-
lOllllOOlOO
;
if
(
(
lllOOOl\
llO\
l
)
.
Dot\

(
lOOOlOOOO\
O
)
>
0.0f
)
{
if
(
lllOOllllOO
<
0.0f
)
{
Ve\
c\
3
lllOlOOOOO\
l
=
lllOOOlllOl
.
Cross\

(
lOOOlO\
O\
OOO
.
Cro\
s\
s
(
lllO\
O\
OlllOl
)
)
;
fl\
o\
a\
t
lOllllOOll
=
ll\
lOlOOO\
OOl
.
Ge\
t\
M\
agnitude\

(
)
;
if
(
lO\
l\
ll\
lO\
Oll\

>
lO\
ll\
OlOlOl
*
lOllOl\
O\
lOl
)
lll\
OlOO\
OOOl
/=
lO\
llllOOll
;
el\
s\
e
lll\
O\
l\
OOOOOl
=
llOOOlOOlO
->
lOOO\
l\
O\
O\
OOO
;
lllOOl\
lOO\
l\
l
.
lOOO\
lOOOOO
=
lllO\
l\
OOOO\
Ol\

;
lllO\
O\
llOOl\
l
.
lOlOllO\
OO\
l
|=
lllOOOlOl\
ll
::
lll\
OOOl\
lO\
OO
;
ll\
lOOllO\
Oll
.
lllOOO\
llOll
=
lllO\
OOlllOl
;
lll\
OlO\
OOOOO
=
false
;
lllOO\
ll\
l\
l\
lO
(
lll\
OOOllOlO
,
lllOlOOOOlO\

)
;
}
els\
e\

{
lll\
OO\
lll\
llO\

(
lllOOOll\
OlO
,
lllO\
OOlll\
Ol
)
;
}
}
}
{
Vec3
ll\
lOOOll\
lOl
=
lllOO\
ll\
lO\
ll
-
lO\
llllOOlOO
;
if
(
ll\
lOOOlllO\
l
.
Dot
(
lOOOl\
OOOOO
)
>
0.0f
)
{
if
(
lllOOll\
llOl
<
0.0f
)
{
Vec3
lllOlOOOOOl
=
lllO\
OO\
lllOl\

.
Cro\
ss
(
lOOOl\
OOOOO
.
Cross
(
lll\
OOO\
l\
llOl\

)
)
;
float\

lOllllOOll
=
lllOlOOOOOl
.
Ge\
tMagnit\
u\
d\
e
(
)
;
if\

(
lOl\
lll\
OOl\
l
>
lO\
llOlOl\
O\
l
*
lOllOl\
OlO\
l
)
lllOl\
O\
O\
OOO\
l
/=
lOll\
llOOll
;
els\
e
ll\
lOl\
OOOO\
Ol
=
llOOOlOOlO
->
lOO\
O\
lOO\
OOO
;
lllO\
OllO\
O\
l\
l
.
lOOO\
lOOOOO
=
lllOlOO\
OOOl\

;
lllOOllOOll
.
lOlOllOOOl
|=
lllO\
OO\
lOlll
::
lll\
OOOl\
lOOO
;
lllOOllO\
Oll\

.
lll\
OOOllOll
=
lllOOOl\
llOl
;
lllOl\
OOOOO\
O
=
false\

;
lllOOlll\
llO
(
lllOO\
O\
ll\
OlO
,
lllO\
lOO\
OOlO\

)
;
}
else
{
lllO\
O\
lllllO
(
lllOOOllOlO\

,
lllOOOll\
lOl
)
;
}
}
}
}
}
TA_\
ASS\
ERT
(
ll\
lOOl\
lO\
O\
l\
l\

.
lOOOl\
O\
O\
OOO
.
IsNormalised
(
)
)
;
}
vo\
i\
d
TAC_C\
AL\
L
lllOOll\
lllO
(
co\
nst
Vec\
3
&
ll\
lOlO\
OO\
Oll\

,
int
lOllO\
lOlOO\
O\

)
{
TA_\
A\
SSERT
(
lllOOlOO\
OlO
[
lOl\
lOlO\
lO\
OO
]
<=
lllOOl\
OO\
O\
l\
l\

)
;
TA_ASSERT\

(
lOll\
O\
lOlO\
OO\

>=
0
)
;
TA\
_A\
S\
SE\
RT\

(
lO\
l\
lOlOlO\
OO\

<=
1
)
;
if\

(
ll\
lOO\
l\
OOOlO
[
lO\
llOl\
OlOOO\

]
>=
lllOO\
l\
OOOll
)
ret\
urn
;
lllOOlOOlOO
[
lllOOl\
OOOlO
[
lOllOlO\
lOOO
]
++
]
[
lOllO\
lOl\
OO\
O
]
=
lllO\
lOOO\
Oll
;
}
void
TA\
C\
_C\
ALL
lll\
OO\
ll\
ll\
l\
O
(
con\
s\
t\

Vec\
3
&
ll\
lOlOOO\
Oll
,
const
Vec3\

&
ll\
l\
OOOll\
lOl\

)
{
TA_\
AS\
S\
ERT
(
ll\
l\
OOl\
O\
OlOl\

<=
ll\
lO\
OlOO\
Oll\

)
;
if
(
lll\
OO\
lOOlOl\

>=
lllO\
OlO\
OOll
)
re\
turn\

;
lllO\
O\
lO\
OllO
[
lllOO\
lOOlOl
]
.
lOOO\
O\
l\
ll\
ll
=
ll\
l\
OlO\
OOO\
ll\

;
lllO\
O\
lOOllO
[
ll\
lOOlO\
OlOl
]
.
ll\
l\
OOOlll\
Ol\

=
lll\
O\
OOlllOl\

;
lllO\
Ol\
OOlOl
++
;
}
void
TAC_\
C\
AL\
L\

lllOl\
O\
OOlO\
O
(
float
lllOllllOO
,
float\

lOll\
OO\
lOOOl
,
u32
llOlll\
OOll\
O
,
con\
st\

Ve\
c3
&
lOl\
ll\
lO\
OlO\
O
,
co\
ns\
t
Ve\
c\
3
&
lOlllOllOOO
,
const\

Vec\
3
&
lllO\
Ol\
llOlO
,
co\
nst\

Vec3\

&
lOOOlOOOOO
,
in\
t\

lOllOlOl\
OOO\

)
{
TA_\
ASSERT\

(
lllOOl\
OO\
lll
<
lllOOl\
Ol\
O\
O\
O
)
;
if
(
lllOO\
lOOlll
>=
lllO\
OlO\
l\
OOO
)
return
;
TA\
_ASS\
ERT
(
lllOlll\
lOO\

>=
0.0f
)
;
TA_A\
S\
SERT
(
ll\
lOl\
lllOO
<=
1.0f
)
;
lllOO\
Ol\
lllO
&
lllOOllO\
l\
ll\

=
lll\
OOl\
OlOOl
[
lllO\
OlOOl\
l\
l
++
]
;
lllO\
OllOlll
.
lOl\
lOOlOO\
O\
l\

=
lOll\
OOlOOOl
;
ll\
lOOll\
Ol\
ll
.
lllOl\
lllOO
=
lllO\
l\
l\
llO\
O
;
ll\
l\
OOll\
Ol\
ll
.
llOlllOOl\
l\
O\

=
llOlll\
O\
Ol\
lO
;
Ve\
c\
3
lllllOOll\
O\

=
lOlllOllOOO\

-
lO\
llllO\
O\
lO\
O
;
in\
t
lO\
OOl\
ll\
lOl\

=
lll\
llO\
O\
l\
l\
O
.
Ge\
tG\
reates\
tAxis\

(
)
;
if
(
ll\
lll\
OOll\
O
[
lOOOllllO\
l
]
>
0.0f
)
{
lllOOllOl\
ll
.
lOllllO\
OlOO\

=
lOlll\
l\
OOlO\
O\

;
lll\
OOllOl\
ll
.
lOlllO\
l\
lO\
OO
=
lOll\
lOllO\
OO
;
}
el\
se
{
lllO\
Ol\
lOlll\

.
lOll\
llOOlO\
O\

=
lOlllO\
l\
lOO\
O
;
lllOOl\
lO\
lll
.
lOlllOllOOO
=
lO\
l\
lll\
OOlOO
;
}
lllO\
Ol\
l\
Oll\
l
.
lOOOOlllll
=
lllOOl\
llO\
lO
;
lllOO\
llOlll
.
lOOOlO\
O\
OOO\

=
lO\
O\
O\
lOOOO\
O\

;
lllOOllOlll
.
lOllOlOlOOO\

=
lO\
ll\
Ol\
OlOOO
;
}
void
TAC_C\
ALL
lllOlOOOlO\
l
(
const
Ve\
c\
3
&
lOllllOO\
lOO
,
co\
ns\
t
Vec3\

&
lOl\
llOllOO\
O
,
in\
t
lOllOlOlOOO\

)
{
TA_A\
SSERT\

(
lO\
l\
lOlOlOO\
O
>=
0
&&
lOllOl\
OlOOO
<
3
)
;
if
(
lllOOlO\
l\
OlO
[
lOl\
lOl\
OlOO\
O\

]
>=
lllOOl\
OlO\
ll
)
re\
tu\
rn
;
Vec\
3\

llll\
l\
O\
Oll\
O
=
lOlllOllOOO\

-
lOl\
l\
llOOlOO
;
int\

lOOO\
l\
lllOl
=
lllllO\
O\
l\
lO
.
Get\
Gr\
e\
atest\
Ax\
is\

(
)
;
if
(
lll\
llOOl\
lO\

[
lOOOlll\
l\
Ol
]
>
0.0f
)
{
ll\
lOOlO\
l\
lOO
[
lOll\
Ol\
O\
lOO\
O
]
[
lll\
OOlOlOl\
O\

[
lOllO\
lOlOOO\

]
]
[
0
]
=
lOllllOOlOO
;
lll\
OOlOl\
lO\
O
[
lOl\
l\
O\
lO\
l\
O\
O\
O\

]
[
lllOOlOlOlO\

[
lOll\
OlOlOOO
]
]
[
1
]
=
lO\
l\
l\
l\
Ol\
lO\
O\
O
;
}
else
{
lll\
O\
OlO\
l\
lOO\

[
lOllOlOlOO\
O
]
[
lllO\
OlOlO\
lO\

[
lOll\
OlO\
lOOO
]
]
[
0
]
=
lOll\
l\
O\
l\
lOOO
;
lllOOl\
OllOO
[
lOllO\
lOlOOO
]
[
ll\
lOOlO\
l\
OlO
[
lOllO\
lOl\
O\
OO
]
]
[
1
]
=
lO\
llllO\
OlO\
O\

;
}
ll\
lOO\
l\
OlOlO\

[
lOll\
OlOl\
OOO
]
++
;
}
#endif //
}
