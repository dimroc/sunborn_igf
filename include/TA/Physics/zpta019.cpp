//---------------------------------------------------------------------------------
// File Name: zpta019.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#include "DynamicObjectCar.h"
#ifndef TA_GEOMETRY_H
#include "../Common/Geometry.h"
#endif //
#ifndef lOOlOOlllOl
#include "../Common/zcta010.h"
#endif //
#ifndef TA_CARTEMPLATE_H
#include "CarTemplate.h"
#endif //
#ifndef TA_PHYSICS_H
#include "Physics.h"
#endif //
#ifndef llllOOOOlOl
#include "../Physics/zpta010.h"
#endif //
#ifndef TA_PHYSICSRENDER_H
#include "PhysicsRender.h"
#endif //
cons\
t
fl\
oa\
t
lO\
lOlOO\
Ol\
llO\

=
0.1f
;
const
flo\
at\

lOlOlOOO\
llll\

=
10000.0f
;
const
fl\
o\
at
lOlOlO\
OlOOO\
O
=
0.12f
;
namespa\
ce
TA
{
vo\
i\
d
Dy\
nami\
cO\
bject\
Ca\
r
::
In\
itialise\

(
const
Char
*
lllOOOlOO\
l
)
{
lO\
O\
OO\
OOl\
lO\

(
0
,
"DynamicObjectCar::Initialise(const Char* szFileName) is not supported")
;
Dy\
namicO\
bje\
ct
::
In\
it\
iali\
seF\
r\
o\
mFile
(
lll\
OO\
OlOOl
)
;
lOl\
OlOOlO\
OOl
.
Initialise
(
4
,
4
)
;
In\
i\
tia\
lise\
Common
(
)
;
}
voi\
d
Dy\
namicObje\
c\
tCar
::
Initial\
ise
(
Ca\
rTemplate
*
lOlOlO\
O\
lOOlO
)
{
TA_A\
SSE\
RT
(
lOl\
OlOOlO\
OlO
)
;
Dynam\
i\
c\
O\
bje\
c\
t
::
Ini\
tia\
lis\
e
(
lOl\
OlOOlOO\
lO
->
lO\
lO\
lO\
l\
O\
OO\
O\

)
;
SetOri\
enta\
tion
(
lOl\
OlO\
OlOO\
lO
->
GetForwar\
d\

(
)
,
lOlOlO\
OlOO\
lO
->
GetUp
(
)
)
;
int\

lOlO\
l\
OllOll\

=
lOl\
O\
lO\
OlO\
O\
l\
O
->
lOlO\
l\
Olll\
OO
.
lOOO\
lllO\
Ol
(
)
;
if\

(
lOlOlOllOll
>
0
)
{
lO\
lOlO\
Ol\
OOOl
.
In\
itialise
(
lOlO\
lOllOll
,
lO\
lOl\
OllOl\
l
)
;
SetMass
(
lOlOlOOlOOlO
->
GetMas\
s
(
)
)
;
Li\
s\
t
<
Ca\
rTem\
pla\
te\

::
Wh\
eel
>
::
lOOO\
OOlOO\
Ol
lOlOOl\
OOlO
=
lOlOlOO\
lO\
OlO
->
lOl\
OlOlll\
OO
.
lOOOO\
Ol\
OllO\

(
)
;
for
(
int
lOlOlOll\
l\
Ol\

=
0
;
!
lOlOOlO\
OlO
.
AtEnd
(
)
;
++
lOlOOl\
O\
OlO
,
++
lOl\
OlO\
l\
l\
l\
Ol
)
{
const
CarTemp\
late\

::
Whee\
l
&
lOl\
Ol\
OOlOOll
=
*
lOl\
OOlO\
OlO
;
Wheel\

&
lOl\
O\
lOllllO\

=
lOlOlOO\
lOO\
Ol
[
lOlO\
lOlll\
Ol\

]
;
lOlOlOlll\
lO
.
lllO\
lOlllO
=
0
;
if
(
lOl\
O\
lO\
O\
lOO\
ll
.
GetSteeri\
n\
gFl\
ag
(
)
)
lOl\
OlOllll\
O
.
lllOlOlllO
|=
lOlOlO\
OlOlOO
;
if\

(
lO\
lOlOOl\
OOll
.
GetD\
r\
ivingFlag
(
)
)
lO\
lOlOl\
lllO
.
lllOlOll\
lO
|=
lOlO\
lOO\
lOlOl
;
if
(
lO\
l\
O\
lOOlO\
Oll
.
Ge\
t\
HandB\
rakeFla\
g
(
)
)
lOlOlOlll\
lO
.
ll\
lOl\
OlllO\

|=
lOlO\
lOOl\
O\
llO\

;
lOl\
OlOlll\
l\
O
.
lO\
lOl\
O\
OlOlll
.
Clear
(
)
;
lO\
lOlOl\
lllO
.
lOlOlO\
Oll\
O\
OO
.
SetTo\
Identity
(
)
;
lO\
lO\
l\
O\
ll\
l\
lO
.
lOlOlOO\
l\
l\
O\
Ol
.
SetT\
oI\
d\
enti\
t\
y\

(
)
;
lOlOlOllllO
.
lOlOl\
OOlO\
OO
=
lO\
l\
O\
lOOlO\
Ol\
l\

.
Get\
Radius\

(
)
;
lOlO\
l\
Oll\
l\
lO
.
lOlOlOOll\
Ol\
O
=
1.0f
/
lOlOlOllllO
.
lOlOlO\
O\
l\
O\
OO
;
lOlO\
l\
Ol\
l\
llO
.
lOlOl\
OOllOll
=
0.0f
;
lOlOlOllllO
.
lOlOl\
O\
Ol\
l\
l\
OO
=
0.0f
;
lOlOlO\
lll\
l\
O
.
lOl\
OlOOlllOl\

=
0.0f
;
lOlOl\
Olll\
lO\

.
lOlOl\
OOll\
llO
=
0.0f
;
lOlOlOl\
l\
ll\
O
.
lOlO\
lO\
OlOll
=
lOlO\
lOOlOOl\
l
.
GetRollResistan\
ce
(
)
;
lO\
lOlOll\
llO
.
lOlOlO\
O\
lO\
lO\

=
lOlOlOOl\
OOl\
l
.
GetBrake\
Torq\
ue\

(
)
;
if
(
lOlOlOO\
lO\
Oll
.
GetIn\
er\
ti\
a
(
)
>
0.0f
)
lO\
lOlOllllO
.
lOlOlOO\
ll\
lll\

=
1.0f
/
lOl\
OlOOlOO\
ll\

.
Ge\
tI\
ner\
tia
(
)
;
else
lOlOlOlll\
lO\

.
lO\
lOlO\
O\
ll\
l\
l\
l\

=
1.0f
;
lO\
lOlOllll\
O
.
lOlOlOO\
l\
lOO\

=
lOlOl\
OOl\
OOll\

.
Ge\
t\
Sus\
pens\
ionSprin\
gC\
o\
ns\
ta\
nt\

(
)
;
lOlOlOllllO
.
lOlOlOOllO\
l
=
lOlOlOO\
lOOll
.
Ge\
t\
Su\
spens\
i\
onDamping\
Co\
nst\
ant
(
)
;
lOlOlO\
llllO
.
lOlOl\
OOlllO
=
lO\
l\
Ol\
O\
O\
l\
OOll
.
Ge\
tS\
l\
i\
pRatioT\
o\
Nor\
mal\
i\
sed\
Tract\
ionCa\
ll\
Back\

(
)
;
TA_ASS\
ERT
(
lO\
lO\
l\
Ollll\
O\

.
lOlOl\
OO\
lllO
)
;
lO\
lOlOl\
lllO
.
lOlOlOOllll
=
lO\
l\
Ol\
O\
Ol\
OOll
.
Ge\
tSli\
pAn\
gle\
ToLateralForc\
e\
Cal\
lBack
(
)
;
TA_A\
S\
SERT
(
lOlO\
lOllll\
O\

.
lO\
l\
OlOOllll
)
;
lOlOlOlOOOOO\

(
lOl\
O\
lOllllO
)
;
lO\
lOl\
OllllO
.
lOlOlOOlOll\
l
.
v3\
T\
ranslat\
i\
on
=
lO\
l\
OlOOl\
OOll\

.
Ge\
t\
Sus\
p\
e\
nsionBottom
(
)
;
lOlOl\
Olll\
l\
O\

.
lOlOlO\
OlO\
ll\
l\

.
v3T\
r\
an\
sla\
tion
+=
lOlOlOll\
ll\
O
.
lO\
l\
OlOOlO\
OO
*
lO\
lOlO\
lll\
l\
O
.
lO\
lOlOOllOOl\

.
v3Y
;
lO\
lO\
l\
Ol\
l\
llO
.
lOlOlOO\
lOl\
ll
.
m33Ro\
t\
a\
tion\

=
lOl\
Ol\
OllllO
.
lOlOlOOllOOl
;
lOlOlOllllO
.
lOlOl\
OOlO\
lll
=
MFram\
e
(
Mat33\

(
Mat33
::
ROTATION\
_AX\
IS_X
,
lO\
lOlO\
ll\
l\
lO\

.
lOlOlO\
Oll\
l\
OO
)
)
*
lOlOl\
Ol\
l\
llO
.
lOlOl\
OOlO\
ll\
l
;
}
}
SetM\
ass
(
lOlOl\
OOlOOlO
->
GetM\
ass
(
)
)
;
int
lO\
lOll\
OOllO
=
lO\
lOlO\
Ol\
OOl\
O
->
lOl\
OlOlO\
llO
.
lOOO\
lll\
O\
Ol
(
)
;
if
(
lOlOl\
lO\
Oll\
O\

<
2
)
{
lOO\
OO\
OOllO
(
0
,
"DynamicObjectCar::Initialise. Num Gears is less than 2, ignoring.")
;
lO\
lOlO\
lO\
OOOl\

.
In\
itia\
lis\
e
(
2
,
2
)
;
lOlOlO\
lOO\
OOl
[
0
]
=
-
2.9f
;
lO\
l\
OlOlOOOOl\

[
1
]
=
2.6f
;
}
else
{
lOl\
O\
lOlO\
OOOl
.
Initialise
(
lOlOl\
lOOllO
,
lO\
lOllOOllO
)
;
fo\
r
(
int
lO\
lOlOl\
OOOlO
=
0
;
lO\
lOlOlOOOlO\

<
lOlOllOOllO
;
lOlOlOlOO\
OlO
++
)
lOlO\
l\
OlO\
OO\
Ol
[
lOl\
OlOlOO\
Ol\
O
]
=
lOl\
OlOO\
lOOlO
->
lO\
lOlOlO\
llO
[
lOlOlOlOOOlO
]
;
}
lO\
lOlOlOlll
=
lOlO\
lOO\
l\
OOlO\

->
GetD\
ifferent\
ia\
l\
R\
at\
io\

(
)
;
lOlO\
lOlOlOl
=
lO\
lOl\
OOlO\
OlO
->
GetTransm\
issi\
onE\
fficiency\

(
)
;
lOlOlOlOOl\
l\

=
lOlOl\
O\
O\
lOO\
lO
->
GetTorq\
ueMultip\
lier
(
)
;
lOlOlOlO\
lO\
O
=
lOlOlOOlO\
OlO
->
lOlOlO\
l\
OlOO\

;
TA_A\
SSER\
T
(
lO\
lOlO\
lO\
l\
O\
O\

)
;
lO\
lOlOllOOO
=
lO\
lOl\
O\
Ol\
OO\
l\
O
->
Get\
A\
irResi\
s\
ta\
n\
ce\

(
)
;
lO\
lOlO\
llOOl
=
lOlOlOOl\
OOlO\

->
Get\
DownForc\
e
(
)
;
lOlO\
lOl\
lOlO
=
lO\
lOlOOl\
OO\
lO
->
GetAntiRollF\
udge\

(
)
;
In\
itia\
lise\
Co\
mm\
o\
n
(
)
;
Cle\
ar\
Contr\
ols\

(
)
;
}
void
Dyn\
am\
icOb\
jectCar
::
Fin\
a\
l\
ise
(
)
{
Dy\
namicO\
b\
je\
ct
::
Fi\
n\
ali\
se
(
)
;
ClearControls\

(
)
;
lO\
lO\
lOlO\
OOll
=
0.0f
;
lO\
lOlOlO\
OlO\
O
=
0.0f
;
}
void
Dy\
nami\
c\
Objec\
t\
Car\

::
SetO\
rien\
tation
(
co\
n\
st
Ve\
c3
&
lOlOll\
OO\
O\
lO
,
const\

Ve\
c\
3\

&
lOlO\
l\
l\
OOOll
)
{
lO\
OOOOOllO
(
lOlOllOOOlO
.
Is\
Normalis\
ed\

(
)
,
"DynamicObjectCar::SetOrientation. v3Forward must be normalised.")
;
lOOOOOOllO\

(
lOlOl\
l\
OOOl\
l
.
IsNormalised\

(
)
,
"DynamicObjectCar::SetOrientation. v3Up must be normalised")
;
lOOOOOOllO
(
lOl\
O\
llO\
OOlO\

.
Cross
(
lOl\
OllOOOll\

)
.
IsNormalis\
e\
d
(
)
,
" CarTemplate::Wheel::SetOrientation. v3Forward and v3Up must be orthogonal.")
;
lOlOll\
OOlO\
O\

=
lOl\
O\
llOOO\
l\
O
;
lOl\
OllOOl\
Ol
=
lOlOllO\
OO\
l\
l\

;
for\

(
int
lOlOlO\
lllOl
=
0
;
lOl\
O\
lO\
lllO\
l
<
lOlOlOOlOOOl
.
lOOO\
lll\
OOl
(
)
;
lOl\
OlOlllOl
++
)
{
Wh\
eel
&
lOlOlOl\
ll\
lO
=
lO\
lOlOOl\
O\
O\
O\
l
[
lO\
lOlOl\
l\
l\
Ol
]
;
lOlOlOl\
OO\
O\
OO\

(
lO\
lOlOllllO\

)
;
}
}
void
DynamicOb\
j\
ec\
t\
Car\

::
Update
(
float
lOOlllO\
OllOl
)
{
lOOOOO\
OllO
(
GetP\
hy\
sics
(
)
,
"DynamicObjectCar::Update: Error, not added to physics")
;
Physic\
s
&
lO\
lOlO\
l\
O\
O\
lOl
=
*
GetPh\
ysics
(
)
;
Cl\
earForc\
eA\
ndTo\
rq\
ue
(
)
;
fl\
oat\

lOlOlOlOOllO
=
0.0f
;
{
Vec\
3\

lO\
lOlOlO\
O\
l\
ll
=
GetV\
elo\
cityAtWorl\
d\
Pos\
itio\
n
(
lOl\
O\
llOOlOO\

*
2.0f
*
Get\
F\
rame\

(
)
)
;
lOlOl\
Ol\
O\
O\
lll
*=
GetFrame
(
)
.
m3\
3Rota\
tion
.
GetT\
ranspos\
eAs\
Inv\
erse
(
)
;
flo\
at
lOlOlOlOlOOO\

=
lOlOl\
OlOOl\
ll
.
Dot
(
lO\
lOllOOlOO
)
;
fl\
oat\

lOlOlOlO\
lOOl
=
lOl\
OlOlOOl\
ll
.
Dot\

(
lOlOllOO\
lOl
.
Cross
(
lOlOll\
OOlOO
)
)
;
if
(
lOlOlO\
lOl\
OOO
<
0.0f
)
{
lOlOlOlOlOOO
=
-
lOlOlOlOlO\
O\
O
;
lOlOlOl\
O\
lOOl
=
-
lOlOl\
OlOlO\
Ol
;
}
float
lO\
lOl\
Ol\
OlOl\
O\

=
ATan\
2
(
lOlOlOlOlO\
Ol\

,
lOl\
O\
lO\
lOlO\
OO
)
;
cons\
t
fl\
oat
lOlOl\
O\
lO\
l\
Oll
=
0.22f
;
if
(
Fa\
bs
(
lOlO\
lOl\
O\
l\
O\
OO
)
<
1.0f
||
lOl\
O\
l\
OlOllOO\

.
lOlOlO\
lO\
llO\
l\

<
0.5f
)
{
lOl\
OlO\
lOOllO
=
lOlO\
lOlO\
llOO
.
lOlOlOlOlllO\

;
}
else\

{
if
(
lOlOlO\
lO\
ll\
OO
.
lO\
lO\
l\
OlOlll\
O
>
0.0f
)
{
if
(
lO\
lOlO\
lOlO\
lO
+
lO\
lOlOlO\
lOl\
l
<
0.0f
)
lOl\
OlOl\
OOll\
O\

=
0.0f
;
else
lOlOlOlOOll\
O
=
(
lOlOlOl\
Ol\
OlO
+
lOlOlOlOlOll
)
*
lOlOl\
OlOllO\
O
.
lOlO\
lO\
lOlllO
;
}
else
if
(
lOlOlOlOllO\
O
.
lOl\
O\
lO\
l\
OlllO
<
0.0f
)
{
if
(
lOl\
O\
l\
OlOlO\
lO
-
lO\
l\
OlOl\
OlO\
ll
>
0.0f
)
lOl\
O\
lO\
lO\
Ol\
lO
=
0.0f
;
else
lOl\
Ol\
O\
l\
OO\
l\
l\
O
=
-
(
lO\
lOlOlOlOlO
-
lO\
lOlOlOlO\
l\
l
)
*
lOl\
O\
lO\
lOllOO\

.
lOlO\
lOlOl\
ll\
O
;
}
}
const
floa\
t
lOlO\
lO\
lOll\
ll
=
0.75f
;
Clam\
p
(
lOl\
OlOl\
OOll\
O\

,
-
lOl\
OlOl\
Oll\
ll
,
lOl\
OlO\
lOll\
ll
)
;
}
for\

(
in\
t
lOlOlOll\
l\
Ol\

=
0
;
lOlOlOlllO\
l
<
lOlOl\
OOlO\
OOl
.
lOOOl\
llOO\
l\

(
)
;
lOl\
Ol\
O\
lllOl
++
)
{
Wheel\

&
lOl\
O\
l\
OllllO\

=
lO\
l\
Ol\
OO\
l\
O\
OOl
[
lO\
lO\
lO\
lllO\
l
]
;
lOlOlOll\
l\
lO
.
lO\
lO\
lOl\
lOOOO\

.
Clear
(
)
;
if\

(
lOlOlOlll\
l\
O
.
ll\
l\
OlO\
l\
llO
&
lOlOlO\
llO\
OO\
l
)
lO\
lO\
lOlOO\
OOO\

(
lOl\
O\
l\
O\
l\
l\
ll\
O
)
;
if\

(
lOlOlOl\
lllO
.
lllOlOll\
lO
&
lOlO\
lO\
OlOl\
OO\

)
{
lOlO\
lOll\
ll\
O\

.
lOlO\
lOOll\
OO\
l\

=
lOl\
OlOllllO
.
lOlOl\
OOl\
lOOO
;
lOl\
O\
lOllllO
.
lO\
lO\
lOO\
llOO\
l
.
Pre\
Rotate
(
Mat\
33
::
ROTATIO\
N_A\
XIS_Y\

,
-
lOlOlOlO\
Ol\
lO\

)
;
}
}
#ifdef lOlOlOllOOlO
lOl\
OlOllOOll
(
lO\
lO\
lOl\
lO\
lOO\

::
Ge\
tIns\
tan\
ce
(
)
.
lOlO\
lOllO\
lOl
(
"Rads per sec : %f",
lOlOlOlO\
OOl\
l\

)
)
;
lO\
l\
OlOll\
O\
O\
ll
(
lOlO\
lOllOl\
OO\

::
GetIn\
stance\

(
)
.
lOlOlOllOlOl\

(
"RPM : %f",
GetR\
PM\

(
)
)
)
;
lOl\
OlO\
llOO\
ll
(
lOlOlO\
ll\
O\
lO\
O
::
GetIns\
tan\
c\
e
(
)
.
lOlOlOl\
lOl\
Ol
(
"Speed : %f mps, %f kmph",
GetLine\
arV\
el\
ocity
(
)
.
Ge\
tM\
a\
gnitu\
d\
e
(
)
,
Get\
L\
inearVe\
loci\
t\
y
(
)
.
Ge\
tM\
agn\
itude\

(
)
*
3.6f
)
)
;
lOlOlO\
l\
lOOll
(
lOl\
OlO\
l\
l\
OlOO
::
GetInstanc\
e
(
)
.
lOlOlOllOlO\
l\

(
"Gear : %d",
lOlOlO\
llOllO\

)
)
;
#endif
float
lOl\
O\
l\
Oll\
Olll\

=
1.0f
/
300.0f
;
int\

lOlOlOlllO\
OO\

=
FastFloatToI\
nt
(
ceil
(
lOOlllO\
Ol\
l\
Ol
/
lO\
lOlO\
l\
lO\
lll
)
)
;
if
(
lOl\
OlO\
lll\
OO\
O
<
1
)
lOlOlOl\
ll\
O\
OO
=
1
;
flo\
at\

lOlOlO\
lllOO\
l
=
lOO\
l\
llOOllOl\

/
(
fl\
oa\
t\

)
lOlOlOlllOOO
;
MFrame
lOlOlOlllOlO\

=
GetFr\
am\
e
(
)
;
TA_ASSERT
(
lOlOlOOlOOOl
.
lOOOlll\
OOl\

(
)
==
GetNu\
m\
LineCo\
l\
lisions\

(
)
)
;
for\

(
in\
t
lOOOll\
OOOl
=
0
;
lO\
OOll\
OOOl
<
lOl\
OlOl\
l\
lO\
OO
;
lOOOl\
lOO\
Ol
++
)
{
float
lO\
lO\
lOlll\
Ol\
l
=
0.0f
;
for
(
in\
t
lOlO\
l\
O\
lllOl
=
0
;
lOlO\
lOll\
lOl
<
lOlOlOOl\
OOOl
.
lOOO\
l\
ll\
OO\
l
(
)
;
lOlOlO\
ll\
lOl
++
)
{
Wheel
&
lOl\
OlO\
llll\
O
=
lO\
lO\
lOOlO\
OOl\

[
lOl\
OlO\
lllOl
]
;
if
(
lO\
lO\
lO\
llllO
.
ll\
l\
Ol\
O\
lllO
&
lOlOl\
OO\
lO\
lOl
)
lO\
lOl\
O\
l\
l\
l\
Oll
+=
lO\
lOlOllllO
.
lO\
lOl\
OOllO\
l\
l\

;
}
lOlOlOlll\
Oll\

*=
lOlOl\
Ol\
OOlOO
;
fl\
oat\

lO\
l\
OlOllllOO
;
float
lOlO\
lO\
ll\
l\
lO\
l
;
bool\

lO\
lOlOl\
l\
lllO
=
lOl\
OlO\
lO\
ll\
OO
.
lOlOlOlOOOlO\

==
-
1
;
if
(
lO\
lOlOl\
llllO\

)
{
fl\
oat\

lOlOl\
Ollll\
ll
=
-
0.5f
;
if\

(
lOl\
OlOlOl\
l\
OO
.
lOlO\
l\
O\
l\
lllOl
<
lOlOl\
O\
lO\
llOO
.
lOlO\
lO\
llllOO\

)
lOl\
Ol\
Oll\
l\
lll
=
-
lOlOlO\
lllll\
l\

;
if
(
lOlOlOll\
lOll
>=
lO\
l\
O\
lOllllll
)
{
lOlOl\
O\
llllO\
O\

=
lOlO\
lOlOl\
lO\
O
.
lOlOl\
Olll\
l\
O\
O
;
lOl\
O\
lOll\
llOl
=
lO\
l\
OlOl\
OllO\
O
.
lOlOlOlll\
lOl
;
lOlO\
lOllOllO\

=
1
;
}
else
{
lOlOlOllll\
OO
=
-
lOl\
O\
l\
OlOllOO\

.
lOlOl\
O\
llllOl
;
lOlOlO\
llllOl
=
lO\
l\
OlOlOl\
lOO
.
lOlOlOllllOO\

;
lOlOl\
OllOllO
=
0
;
}
}
else
{
lO\
lO\
lOl\
lO\
llO\

=
lO\
lO\
lO\
lO\
llOO\

.
lOlO\
lO\
lOOOlO\

;
lOl\
Ol\
O\
l\
lllO\
O
=
lOl\
OlO\
l\
OllOO
.
lOl\
OlOlll\
lO\
O
;
lOlOlO\
l\
lllOl
=
lO\
lOlOl\
Oll\
OO
.
lOl\
OlOllllO\
l\

;
}
if\

(
lO\
lOl\
OlllOll
<
0.0f
)
lOl\
OlOl\
llOll
=
0.0f
;
fl\
oa\
t
lOlOl\
lO\
OO\
OOO\

=
1.0f
;
lOlOl\
lO\
O\
O\
OOO\

=
lO\
l\
Ol\
O\
lOl\
ll
*
lOl\
O\
lOlOO\
O\
Ol
[
lOlOlOl\
lO\
llO
]
;
lO\
l\
Ol\
OlO\
O\
Oll
=
lO\
lO\
lOlllO\
l\
l
*
lOlOllOO\
OO\
OO
;
TA_A\
SSERT
(
lOlO\
lOl\
OlOO
)
;
flo\
at
lOl\
OllOOOOOl
=
lOlOl\
Ol\
Ol\
OO
(
lOl\
Ol\
Ol\
OOOll
)
*
lO\
lO\
lOlOO\
l\
l
;
lOlO\
llOOOOOl
*=
lOl\
O\
llOOOO\
OO
*
lOlOlO\
lOlOl
;
if\

(
lOlOl\
Ollll\
lO
&&
lOlOl\
O\
l\
l\
OllO\

==
1
)
{
for
(
int
lOlO\
lO\
lOOOl\
O
=
2
;
lOl\
OlOlO\
OO\
lO\

<
lOlOlOlOOOO\
l
.
lOO\
Ol\
llO\
Ol
(
)
;
lOl\
O\
lOlO\
OOlO\

++
)
{
lOl\
OllO\
OOOO\
O
=
lOlOl\
OlO\
l\
ll
*
lOlO\
lOlO\
O\
O\
O\
l\

[
lOlOlO\
l\
OOOlO
]
;
fl\
o\
at\

lO\
lOllOO\
OOlO\

=
lOlO\
lOlllOll
*
lOlO\
ll\
OOO\
OO\
O
;
TA\
_AS\
SERT
(
lOl\
O\
lOlOl\
O\
O
)
;
floa\
t
lO\
lOllO\
OOOl\
l
=
lO\
l\
OlOlO\
lOO
(
lOlO\
llOOO\
Ol\
O
)
*
lOlOlO\
lO\
Oll
;
lOlOllO\
O\
OOll\

*=
lOlOllOOOOOO\

*
lOlOlOl\
OlOl\

;
TA_ASS\
ERT
(
lOlOllOOOOlO\

>=
0.0f
)
;
if
(
lOlOllO\
O\
OOll
>
lO\
l\
Ol\
lO\
O\
O\
O\
O\
l\

)
{
lOl\
O\
lOllO\
llO
=
lO\
lOlOlOOO\
l\
O
;
lOlOllO\
O\
O\
OOl\

=
lO\
lOl\
lO\
OOOll\

;
lOlOl\
OlOO\
O\
l\
l
=
lOlOll\
OOO\
OlO
;
}
els\
e\

{
}
}
}
lOl\
OllOOO\
OOl\

*=
lOlOlOlll\
l\
Ol
;
As\
sertForc\
eAn\
dT\
o\
rq\
ueCl\
e\
ar\
e\
d\

(
)
;
Ac\
cum\
ulat\
eG\
r\
a\
vity
(
)
;
in\
t\

lOl\
O\
llOOO\
lOO
=
0
;
int
lllO\
OOOOlO
;
for\

(
lllOO\
OOO\
lO\

=
0
;
lllO\
OOOOlO
<
GetNumLi\
n\
eC\
ollisio\
ns\

(
)
;
lllOOOOOl\
O
++
)
{
const
LineI\
nterse\
c\
ti\
o\
n
&
lOOll\
llOl\
llO
=
Get\
L\
ineC\
ollisio\
n
(
lllOOOO\
OlO
)
;
Wh\
e\
e\
l
&
lOlOlO\
llllO\

=
lO\
lOlOOlOO\
O\
l
[
ll\
l\
OOOO\
Ol\
O
]
;
fl\
oat
lOlOllO\
OO\
l\
Ol
=
0.0f
;
if\

(
lOOllllOl\
ll\
O
.
lO\
llOOl\
OO\
Ol
>
0.0f
)
{
lO\
l\
OllO\
OOlOO
++
;
Vec3
lOOOOl\
l\
l\
ll
=
lOO\
llll\
OlllO
.
lOO\
O\
O\
lllll
*
Get\
F\
rame
(
)
;
SurfaceAtt\
ribut\
e\

&
lOl\
O\
l\
lOlOll
=
lO\
lOlOl\
OOlOl
.
Get\
Surface\
A\
ttribute
(
lO\
Ollll\
O\
lllO\

.
llOlllOO\
llO
)
;
float
lOlOllO\
OO\
ll\
O
=
(
1.0f
-
lO\
Ollll\
OlllO\

.
lOl\
lOOlO\
OOl
)
*
lOl\
Ol\
Ol\
lllO
.
lOlOl\
OOllOO
;
Vec3
lOlOlOlOO\
l\
l\
l
=
GetV\
elo\
city\
AtWorl\
dPosition\

(
lOOO\
Olllll
)
;
if
(
lO\
OllllOlll\
O
.
lOlllOO\
OllO\

&&
lOOl\
lllOlll\
O
.
lOlllO\
OOllO
->
Ad\
dedTo\
Phys\
ics
(
)
)
{
lOlOlO\
lO\
Ol\
ll
-=
lOOlll\
lO\
lllO\

.
lOlll\
OOOllO
->
GetV\
e\
loc\
i\
tyAtWorldPosi\
tion\

(
lO\
OOOl\
llll
)
;
}
floa\
t\

lOOlOllO\
l\
lOl
=
lOOllllOlll\
O\

.
lOOOlOO\
OO\
O
.
Dot
(
lOlOlOlOOl\
ll
)
;
lOlOl\
OlOOlll
-=
lOOllll\
Olll\
O
.
lOOO\
lOO\
OOO
*
lOOl\
OllO\
l\
l\
Ol
;
if
(
Fab\
s
(
lOOlOllOl\
l\
O\
l
)
>
1.0f
)
lOOlOll\
O\
l\
lO\
l\

=
Si\
g\
n
(
lOOlOllOllOl\

)
*
1.0f
;
lOlOl\
lOOOl\
l\
O
-=
lOlOlOllllO
.
lO\
lOlOO\
ll\
Ol
*
lOO\
lOl\
lOllOl\

;
Vec3
lOl\
Oll\
OOOlll
=
lOlOlOl\
lllO
.
lOl\
OlOOl\
l\
OO\
l
.
v3Z\

*
GetFr\
a\
m\
e
(
)
.
m33Ro\
tat\
ion
;
lOl\
Ol\
l\
O\
OOlll
-=
lOOllll\
OlllO
.
lOOOl\
OOO\
OO
*
lOO\
llll\
OlllO
.
lOOO\
lOOO\
O\
O
.
Do\
t
(
lOlO\
lO\
lOOll\
l
)
;
float\

lOllll\
OO\
l\
l\

=
lOlO\
llOOO\
lll
.
Ge\
tMagni\
tud\
e
(
)
;
if
(
lO\
llll\
OO\
ll
<
0.001f
)
conti\
nu\
e
;
lOlOllOO\
Olll\

/=
lOlll\
lOO\
l\
l
;
floa\
t
lO\
lOllOOl\
OO\
O
=
0.0f
;
float\

lOl\
OlllOlll
=
0.0f
;
{
floa\
t
lOlOllOOl\
OOl\

=
lO\
lOl\
lOO\
Olll
.
Dot
(
lO\
lOl\
O\
lOOl\
ll
)
;
float
lOl\
OllOlO\
l\
O\

=
0.0f
;
if\

(
Fabs
(
lO\
lOll\
OO\
lOOl\

)
>
0.1f
)
{
lOl\
OllOlOlO
=
(
lOl\
Ol\
O\
ll\
llO\

.
lOlOl\
OOl\
O\
OO
*
lO\
l\
O\
lOllllO
.
lO\
lOlOOll\
O\
ll\

-
lOlOl\
lOOlOOl
)
/
Fabs
(
lO\
lOl\
lO\
OlOOl
)
;
TA_ASSERT
(
lOlOlOll\
ll\
O\

.
lOl\
O\
lOO\
lll\
O
)
;
if
(
Fabs\

(
lO\
lOllOlOlO
)
>
lO\
lOlOOlOOOO
*
1.1f
)
{
lOl\
OllOlOlO
=
lOlOl\
OlOllO\
O
.
lO\
l\
OllOOlOlO\

*
Sign
(
lOlOllO\
lOlO
)
*
lO\
lOlOOlOOOO\

+
(
1.0f
-
lOl\
OlO\
lO\
llOO\

.
lOlOllOOlOl\
O
)
*
lO\
l\
Oll\
OlOlO
;
}
lO\
lOl\
lOOlOOO\

=
lOlOlO\
lll\
lO
.
lOlOlOO\
ll\
lO\

(
lOlOllO\
lOlO
,
lOlOllOlOll
)
;
}
else
{
lO\
lOll\
OOlO\
O\
O
=
(
lOl\
OlOl\
lllO
.
lOlO\
lOO\
lOO\
O\

*
lOl\
O\
lOl\
l\
llO\

.
lOlOlOOllOll
-
lOlOl\
lO\
OlO\
Ol
)
*
0.02f
;
}
Cla\
mpPosNe\
g\

(
lO\
lO\
ll\
O\
Ol\
OOO\

,
200.0f
)
;
lOl\
OlllOlll
=
lO\
lOllOlOlO\

;
if
(
lOlO\
lOllllO\

.
lllOlOlllO\

&
lO\
lOl\
O\
OlOlOl
)
{
float
lOl\
O\
llOO\
l\
O\
ll
=
lOlOl\
lOO\
OO\
Ol
*
lO\
lOl\
OlOO\
lO\
O
;
if
(
Fab\
s\

(
lO\
lOllOl\
OlO\

)
>
lOlOlO\
O\
lOOOO
)
lOl\
Oll\
OO\
lOl\
l
*=
(
1.0f
-
lOlOl\
O\
lOllOO
.
lO\
l\
Oll\
OO\
l\
O\
lO
)
;
lOlOll\
OOOl\
Ol\

+=
lOlOllOOlO\
ll
;
TA\
_\
AS\
SE\
RT
(
FloatIsO\
K
(
lOlOl\
lO\
O\
OlO\
l
)
)
;
floa\
t
lOlO\
llO\
Ol\
lOO
=
lO\
lOl\
OlllOll\

-
lOl\
OlO\
l\
lllO
.
lO\
lOlO\
O\
llOll\

;
lOlOl\
lOOO\
l\
Ol\

+=
lOl\
Oll\
O\
OllOO
*
Fa\
bs
(
lO\
lOllOO\
llO\
O
)
*
lOlOlO\
OOlllO
;
TA_AS\
SER\
T
(
Float\
IsOK
(
lOl\
O\
llOOO\
lO\
l
)
)
;
}
}
Vec\
3
lOlO\
llOO\
l\
lOl
=
lOOllllOlll\
O
.
lOO\
Ol\
OOOOO
.
Cross
(
lO\
l\
Oll\
OOOl\
ll\

)
;
fl\
oat
lOlOllOO\
lll\
O
=
0.0f
;
float
lOlOl\
l\
OOllll\

=
lOlOl\
Ol\
OOlll
.
Get\
M\
a\
gni\
tu\
de\
Sqr\
d
(
)
;
if
(
lOlOl\
lOOllll
>
0.25f
)
{
lOl\
Ol\
OlO\
Olll
;
#ifdef lOlOllOlOOOO
floa\
t
lOl\
Olll\
Ol\
l\
O
=
-
lOlOl\
l\
O\
O\
l\
lO\
l
.
Dot
(
lOl\
Ol\
Ol\
OOll\
l
)
/
Fa\
bs\

(
lOlO\
l\
l\
O\
OOl\
ll
.
Do\
t
(
lOlOl\
OlOOl\
l\
l
)
)
;
#else
fl\
oa\
t
lOl\
O\
ll\
lO\
l\
l\
O
=
-
AT\
an\
2
(
lOlOllO\
OllO\
l
.
Dot\

(
lO\
lO\
l\
Ol\
OOll\
l
)
,
Fa\
b\
s
(
lOlOl\
lOO\
Olll
.
Dot
(
lOlOlOlOO\
lll
)
)
)
;
#endif //
TA_AS\
SERT
(
lOlOlOllllO
.
lOl\
OlOOll\
ll
)
;
lOlOll\
OO\
lll\
O
=
lOlOlOl\
lllO
.
lO\
lOlO\
Ol\
lll
(
lOl\
Oll\
l\
OllO
,
lO\
lOll\
l\
Olll
,
lO\
lOll\
Ol\
Oll
)
;
}
else
{
lOl\
O\
l\
lOO\
lll\
O
=
-
lO\
lOll\
OOllOl\

.
Dot
(
lOlOl\
OlOOl\
ll
)
*
2.0f
;
}
{
Vec3
lOl\
O\
ll\
OOllO\
l
=
lO\
l\
OlOlll\
lO
.
lO\
lOl\
OOllO\
Ol
.
v3X
*
GetFram\
e\

(
)
.
m3\
3R\
o\
tation
;
float
lOlOllOlOOO\
l
=
lO\
lOllOOllOl
.
Do\
t
(
lOOl\
l\
llO\
l\
ll\
O
.
lOO\
O\
lO\
OOOO
)
;
lOlO\
llOlOOOl\

=
1.0f
-
Fabs
(
lOl\
OllO\
l\
O\
OOl\

)
*
1.0f
;
Cl\
amp
(
lOlOl\
l\
OlOO\
Ol
,
0.0f
,
1.0f
)
;
lOlOllOO\
lllO\

*=
lO\
lOl\
lO\
lOO\
Ol
;
}
if
(
lOlO\
llOOOl\
lO
>
0.0f
)
{
Vec3
lOlO\
llOlOOlO\

;
lO\
lOl\
l\
O\
Olll\
O
*=
lOlOll\
O\
OOl\
l\
O
;
lOlOl\
lO\
O\
l\
OO\
O
*=
lOlOllOOOllO
;
lOlOl\
lO\
lOO\
lO\

=
lOl\
OllOOllOl\

*
lO\
l\
OllOOl\
llO\

+
lOlO\
llO\
OOll\
l\

*
lOlOl\
lO\
Ol\
OOO\

;
Ve\
c3
lOlOllO\
lO\
O\
ll
=
lOO\
OOll\
lll
;
lOlOlOll\
ll\
O
.
lO\
lOl\
OllO\
OOO
+=
lOOl\
lllOl\
llO
.
lOOO\
lOOOOO
*
(
lOlOllO\
O\
Oll\
O\

*
lO\
lO\
lOlllO\
Ol\

)
;
if
(
lOOlll\
lOl\
llO
.
lOlllOOOllO\

&&
lOOll\
ll\
Ol\
l\
l\
O\

.
lOll\
lOOOl\
lO
->
AddedToPhysics
(
)
)
{
if
(
!
lOOlll\
lOl\
llO\

.
lO\
ll\
lO\
OOllO
->
InfiniteMa\
ss\

(
)
&&
!
lOOllll\
O\
lllO\

.
lO\
ll\
lOOOllO
->
Mov\
em\
en\
tDi\
sa\
b\
led
(
)
)
{
lOOll\
llOl\
llO\

.
lOlllOO\
OllO
->
SetT\
o\
Movi\
ng
(
)
;
TA_ASSE\
RT
(
GetM\
a\
ss
(
)
>
0.0f
)
;
floa\
t
ll\
O\
l\
OlOl\
ll\
O
=
10.0f
*
lO\
O\
ll\
llOlllO
.
lOlllOOOllO\

->
Ge\
t\
Ma\
ss
(
)
/
GetMass
(
)
;
if
(
llOlOl\
Oll\
lO
>
1.0f
)
llOlO\
lOll\
l\
O
=
1.0f
;
llOlOlO\
lllO
*=
0.25f
;
Ve\
c3
lOO\
OOll\
ll\
l\

=
lOO\
llllOlllO
.
lOO\
OOll\
lll
*
GetFrame
(
)
;
lOOllllOll\
l\
O\

.
lO\
l\
llOOOllO
->
Ap\
ply\
Imp\
ul\
se
(
lO\
lO\
llOlOOlO\

*
(
-
llOl\
Ol\
Olll\
O
*
lOlOlOlll\
O\
Ol
)
,
lOOOOll\
lll
)
;
}
}
lOlO\
llOlOOlO
+=
lOOll\
ll\
OlllO
.
lO\
OOl\
OOOOO
*
lOlOl\
l\
OOOllO\

;
if\

(
lOl\
O\
lO\
llOlO\

!=
0.0f
)
{
lO\
lO\
ll\
OlO\
Oll
+=
(
lOlOllOOlOl
*
Ge\
tFrame
(
)
.
m3\
3Rotation
)
*
lOl\
OlOllO\
lO
;
}
Ac\
cum\
ulateF\
o\
rceAn\
dT\
or\
que
(
lO\
l\
OllOlOOlO
,
lO\
lOllOlOOll
)
;
}
lO\
lOllOOOlOl
-=
lO\
lOll\
O\
OlO\
OO
*
lOl\
OlOllllO
.
lOl\
OlO\
O\
lO\
OO
;
TA_ASSE\
RT
(
Fl\
oatIs\
OK\

(
lOlO\
ll\
OOOlOl\

)
)
;
}
else
{
if
(
lOl\
Ol\
OllllO\

.
lll\
O\
lO\
l\
llO
&
lO\
lOl\
OOl\
Ol\
O\
l
)
{
float\

lOlOllOOl\
lOO
=
lO\
lOl\
OlllOl\
l
-
lOlO\
l\
OllllO\

.
lOlOlO\
Ol\
lO\
ll
;
lOlO\
l\
l\
OOOlOl
+=
lOl\
O\
llOOl\
l\
O\
O
*
Fab\
s
(
lOl\
O\
llOO\
llOO
)
*
lO\
l\
OlOOOlllO\

;
TA\
_A\
SSER\
T
(
Fl\
oatIsO\
K
(
lOlOll\
OO\
OlO\
l
)
)
;
lOlOl\
lO\
O\
OlOl
+=
lOlOllO\
OO\
OOl
*
lOlO\
lOlO\
O\
lOO
;
TA_ASSERT
(
Floa\
tIs\
OK\

(
lO\
lOllOOOlOl
)
)
;
}
}
lO\
l\
O\
l\
lOOO\
l\
Ol\

-=
lOlO\
lOl\
l\
ll\
O\

.
lOlOlOOlOl\
l
*
lOlO\
lOl\
ll\
lO
.
lOlO\
lOOl\
l\
Ol\
l
;
lOlO\
llO\
OO\
lO\
l
-=
lO\
l\
OlO\
llllO
.
lOlOlOOl\
OlO
*
lO\
lOlOllllO\
O
;
if
(
lOlOlOl\
l\
llO
.
lll\
O\
lOlll\
O\

&
lOlOlO\
O\
lO\
l\
lO\

)
{
lOlOllOOO\
lOl
-=
lO\
l\
Ol\
OllllO
.
lOlO\
l\
OOlOlO
*
2.0f
*
Si\
g\
n
(
lOl\
OlOl\
lllO
.
lOlOl\
OOllOll\

)
*
lOlOlO\
lOl\
lOO
.
lOl\
Oll\
O\
lOlOO
;
}
TA_\
ASSERT
(
Fl\
oat\
IsOK
(
lOlOllOOO\
lO\
l
)
)
;
fl\
oat
lOlOllOl\
O\
lOl
=
lOl\
O\
l\
Ollll\
O
.
lO\
lO\
lO\
Oll\
Oll
;
lO\
lOlO\
llll\
O
.
lOlOlOOllOl\
l
+=
lO\
lOllOOO\
lOl
*
lO\
l\
O\
l\
Ol\
l\
lOOl
*
lOlOlOl\
lllO
.
lO\
lOlOOlll\
ll\

;
if
(
Fab\
s\

(
lOlOlOl\
l\
llO\

.
lOlO\
lOOll\
Oll
)
>
lOl\
OlO\
OOllll
)
lOlO\
lO\
llllO\

.
lO\
lOlO\
OllOll\

=
Sign
(
lOlOl\
Oll\
llO\

.
lOlOlOOllO\
ll
)
*
lOlOl\
OOOl\
lll
;
if\

(
(
lOl\
OlOlOllOO
.
lO\
lOllOl\
O\
lOO
>
0.0f
&&
(
lO\
l\
Ol\
O\
l\
lll\
O\

.
lllOlOlllO
&
lO\
lOlOOlOl\
lO
)
)
||
(
!
lOlO\
lOlllll\
O
&&
lOlO\
l\
OllllOO
>
0.0f
)
)
{
if
(
lOl\
O\
ll\
Ol\
O\
l\
Ol
*
lOlO\
lOl\
lllO
.
lOlO\
lO\
O\
ll\
Oll
<=
0.0f
)
lOlOlO\
llllO
.
lOlOl\
OOl\
l\
Oll
=
0.0f
;
}
}
Ac\
cu\
m\
u\
lateLinearF\
o\
rc\
e
(
-
lOlOlO\
ll\
OOO
*
GetLinea\
r\
Ve\
locit\
y
(
)
.
Ge\
tMagnit\
ude
(
)
*
Get\
LinearVelocity
(
)
)
;
if
(
lO\
lO\
llOOOlOO\

)
Accu\
mula\
teLi\
nearForc\
e\

(
-
lOlOl\
O\
llOOl
*
GetLinearV\
e\
lo\
c\
ity
(
)
.
Ge\
t\
Ma\
gnitudeSqr\
d
(
)
*
lO\
l\
Ol\
lOOl\
Ol
*
Ge\
tF\
r\
a\
me\

(
)
.
m33Rotation
)
;
Ap\
ply\
F\
orceA\
ndT\
orq\
u\
eToVelo\
ci\
ties
(
lOlOlOlll\
O\
Ol
)
;
ClearForc\
e\
AndTorq\
ue
(
)
;
Ap\
plyVeloc\
ityT\
oNex\
tFrame\

(
lOlOl\
O\
lllOO\
l
)
;
fo\
r
(
lllOOOOO\
lO
=
0
;
lll\
OOOOOlO
<
GetNu\
mLin\
eC\
o\
llisi\
ons
(
)
;
lllO\
O\
O\
OOl\
O
++
)
{
cons\
t
Line\
Inter\
s\
ecti\
o\
n
*
lOOlOOOl\
O\
O\
l
=
&
GetLine\
Collis\
io\
n
(
lllOOOO\
O\
lO\

)
;
Li\
n\
eI\
n\
terse\
ct\
ion
&
lOOl\
lllO\
lllO\

=
*
(
Li\
n\
eIn\
terse\
ctio\
n
*
)
lOOl\
OOOl\
OOl
;
Whee\
l\

&
lO\
lOlOllllO
=
lO\
l\
OlO\
OlO\
O\
Ol
[
ll\
lOOOOOlO
]
;
if
(
lOOll\
ll\
Oll\
lO
.
lO\
llOOlOO\
O\
l\

<=
0.0f
)
con\
ti\
nue
;
lOOll\
llOlll\
O\

.
lO\
OOOlllll
*=
GetF\
ra\
m\
e
(
)
;
Vec\
3\

llOOllllOO
=
(
lOOl\
ll\
lO\
lllO
.
lOOO\
O\
lllll\

/
Ge\
t\
Frame\

(
)
)
*
Get\
Ne\
xtFrame
(
)
;
float
lll\
O\
lllll\
O\
l
=
(
lOOllllOlll\
O
.
lOOOOlllll
-
llOO\
l\
l\
l\
lO\
O
)
.
Dot
(
lO\
Ol\
ll\
lOll\
l\
O\

.
lO\
O\
Ol\
OOOOO
)
;
llOOll\
l\
l\
OO
+=
ll\
l\
Ol\
llllO\
l
*
lOOllll\
OlllO
.
lOOOlOO\
OOO
;
lO\
O\
ll\
l\
l\
OlllO
.
lOllOOlOOOl
+=
lllO\
lllllO\
l
;
lOOlll\
lOl\
llO
.
lO\
O\
OOllll\
l\

=
llOOllllOO
;
lO\
OllllOl\
ll\
O
.
lOOOOllll\
l\

/=
Ge\
tN\
extFra\
me
(
)
;
}
App\
ly\
Ne\
xtFr\
ame
(
)
;
}
SetFram\
eDir\
ect\

(
lOlOlO\
lllOlO
)
;
Upd\
ate\
WorldSpace\
Ine\
r\
tia\
lT\
en\
sor\

(
)
;
if
(
lOlOlOlllOOO
<=
2
)
{
App\
ly\
Veloci\
tyToN\
ext\
Frame
(
lO\
O\
ll\
lOO\
ll\
Ol
)
;
}
el\
se
{
if
(
lOOlllOOll\
O\
l
>
0.0f
)
{
Set\
Lin\
ear\
V\
el\
ocity
(
(
GetN\
ex\
tC\
ent\
erO\
fMas\
s
(
)
-
GetCente\
rO\
fMass
(
)
)
/
lOOlllOOl\
lOl
)
;
Mat3\
3
lOOlll\
OOlllO\

=
Ge\
tF\
ra\
me
(
)
.
m33\
R\
o\
t\
at\
ion\

.
Get\
T\
r\
ans\
pose\
As\
Inverse
(
)
*
GetNext\
Fra\
me
(
)
.
m33\
Ro\
tati\
on
;
Ve\
c\
3
lOO\
OOO\
ll\
l\
Ol
;
flo\
a\
t
lO\
O\
OOO\
l\
lllO\

;
lOOlll\
OOlllO
.
Get\
Ro\
t\
ationAxis\
A\
n\
dMa\
gnitude
(
lOOOOO\
lllOl
,
lOOOOOllllO
)
;
SetAn\
gul\
arV\
elocit\
y\

(
lOOOOOlllOl
*
lOOO\
O\
O\
llllO\

/
lO\
OlllOOllOl
)
;
}
}
for\

(
int
lllOOO\
O\
O\
lO
=
0
;
ll\
lO\
O\
OO\
O\
l\
O
<
Get\
Num\
Lin\
e\
Col\
l\
isi\
ons
(
)
;
lll\
OOOOO\
lO
++
)
{
cons\
t\

Line\
Inters\
ectio\
n
&
lO\
Oll\
llOl\
l\
l\
O
=
GetL\
in\
eCollision
(
lll\
O\
OOOOl\
O\

)
;
Wheel
&
lOlO\
lO\
llll\
O
=
lO\
lO\
lOOl\
OOOl
[
lllO\
OO\
O\
OlO
]
;
lOlOlOlll\
l\
O
.
lOl\
O\
l\
O\
O\
l\
llOO
+=
lOlO\
lO\
ll\
ll\
O
.
lOlO\
l\
OOllOll
*
1.0f
*
lOO\
lllOO\
l\
lOl\

;
Wr\
ap\
Angle
(
lO\
lO\
l\
O\
llllO\

.
lOlOl\
OO\
ll\
lOO\

)
;
lOlOlOllllO\

.
lOlOlOOl\
Oll\
l
.
v3Trans\
latio\
n
=
lOOll\
l\
lO\
l\
l\
lO\

.
lOO\
OO\
lllll
;
lOlOlOl\
l\
l\
lO
.
lOl\
OlO\
Ol\
Olll\

.
v3\
T\
ra\
n\
s\
l\
ati\
on\

+=
lOlOlOlll\
lO\

.
lOlOl\
OOlOOO\

*
lO\
lOlOll\
llO\

.
lOlOlOO\
llO\
O\
l
.
v3Y\

;
lOl\
Ol\
Oll\
ll\
O
.
lO\
lOlOOlOll\
l
.
m3\
3Ro\
tation\

=
lOlO\
lO\
llll\
O
.
lOlO\
lOO\
ll\
OO\
l\

;
lO\
l\
OlOll\
llO
.
lOlOlOO\
lOlll\

=
MFrame
(
Mat33\

(
Mat33\

::
ROTATION_AXIS_X
,
lOlOlOl\
lll\
O
.
lOl\
Ol\
OO\
lllOO
)
)
*
lOlO\
lOllllO
.
lOl\
O\
lOOl\
Oll\
l\

;
if
(
lOOll\
l\
l\
Olll\
O\

.
lOlllOO\
Ol\
lO
&&
lOOllll\
O\
lllO\

.
lO\
l\
ll\
OO\
OllO
->
AddedToPhy\
si\
c\
s
(
)
)
{
if\

(
!
lO\
O\
ll\
llOlllO
.
lOlllOOO\
llO
->
Infinit\
eMass
(
)
&&
!
lO\
O\
llllO\
lllO
.
lOlllOOOllO
->
Mo\
vementD\
i\
sabl\
ed
(
)
)
{
lO\
lOlOl\
OOlOl
.
SetD\
ynamicOb\
ject\
I\
sM\
ov\
ing
(
lO\
OllllOlllO\

.
lO\
ll\
lOOOll\
O\

)
;
TA_ASSERT
(
Ge\
tMas\
s
(
)
>
0.0f
)
;
fl\
oat\

llOl\
O\
lO\
lllO
=
10.0f
*
lOO\
llllOl\
l\
lO
.
lOl\
ll\
OO\
OllO\

->
GetMas\
s
(
)
/
Ge\
t\
M\
ass
(
)
;
if\

(
llOl\
OlOll\
l\
O\

>
1.0f
)
llOlOl\
Ol\
llO
=
1.0f
;
Vec\
3
lOOOO\
l\
l\
ll\
l
=
lOO\
ll\
llOlll\
O
.
lOOOOlllll
*
Ge\
t\
Fr\
am\
e
(
)
;
lO\
Ollll\
Ol\
llO
.
lOll\
lOO\
OllO\

->
Apply\
Imp\
ul\
se
(
lOl\
O\
lOll\
ll\
O
.
lOlOlOllOOOO\

*
-
llOlOl\
O\
lllO
,
lOOO\
Oll\
l\
ll
)
;
}
}
}
Cl\
earLi\
neIn\
terse\
ct\
ions\

(
)
;
}
void
Dyn\
amic\
ObjectCar\

::
ClearContr\
ols
(
)
{
lOlO\
l\
Ol\
OllOO\

.
lOl\
Ol\
Ol\
Ol\
l\
lO
=
0.0f
;
lOlO\
l\
OlOl\
lOO\

.
lOlOlOllll\
Ol
=
0.0f
;
lOlO\
lOl\
Oll\
O\
O
.
lOlOlO\
l\
l\
llOO
=
0.0f
;
lO\
lOlOl\
O\
llO\
O
.
lOlO\
l\
lO\
l\
OlOO
=
0.0f
;
lO\
lOlO\
lOllOO
.
lO\
l\
OlOl\
OllO\
l\

=
0.0f
;
lOlO\
lOlOl\
lOO
.
lOlOl\
l\
O\
O\
lO\
l\
O
=
0.0f
;
lOlOl\
Oll\
Ol\
lO\

=
1
;
}
vo\
i\
d
DynamicObj\
ectCa\
r
::
UpdateC\
on\
trol\
s
(
float
lOlOlO\
lOlllO
,
float
lO\
lOlOllllOl
,
floa\
t\

lOl\
OlOlll\
lOO\

,
float
lOl\
O\
llOl\
Ol\
OO\

,
float
lO\
lOlOl\
Oll\
O\
l
,
flo\
a\
t\

lOlO\
l\
lOOlO\
lO
,
int
lOl\
Ol\
Ol\
OOO\
lO
)
{
lOlOl\
Ol\
Oll\
O\
O
.
lOlOlOlOlllO
=
lOlOlOl\
O\
lllO
;
lOlOlOlO\
llO\
O
.
lO\
l\
Ol\
Oll\
llO\
l
=
lOlO\
lOl\
lllOl\

;
lOlOlOl\
O\
ll\
OO\

.
lOlOlO\
llllO\
O
=
lOlO\
lOllll\
OO
;
lOlOlOlOllOO
.
lO\
lOl\
l\
OlOl\
OO
=
lO\
l\
OllOlO\
l\
O\
O
;
lOlOl\
O\
lOl\
lOO\

.
lOlOlOl\
O\
ll\
O\
l
=
lOlOlOlO\
ll\
Ol
;
lOlOl\
OlO\
llOO
.
lOlOllOOlOlO
=
lOlOl\
l\
OO\
lOlO
;
lO\
lOlOlOll\
OO
.
lOl\
OlO\
l\
OOO\
lO\

=
lOlO\
lOl\
OOOlO\

;
}
fl\
oa\
t\

DynamicObj\
ectC\
ar
::
Get\
CarSpeedF\
r\
om\
Whee\
ls
(
)
{
float
lOOlll\
lOO\
OOl
=
0.0f
;
for\

(
int\

lOlOl\
O\
l\
ll\
O\
l\

=
0
;
lO\
l\
Ol\
OlllO\
l
<
lOlO\
l\
OO\
lOOOl
.
lOOO\
lll\
O\
Ol
(
)
;
lOlO\
lOlllOl
++
)
{
Whe\
e\
l
&
lOlOl\
O\
ll\
l\
lO
=
lOl\
O\
l\
OO\
l\
O\
OOl
[
lOl\
OlOlll\
Ol\

]
;
if
(
lOlO\
l\
OllllO
.
lll\
O\
l\
Ol\
l\
lO
&
lOl\
O\
lOOlOlO\
l\

)
lOOl\
l\
llO\
OOOl
+=
lOlOlOllllO
.
lOlOlOOl\
lOll
*
lOlOlOl\
lllO
.
lO\
lOl\
O\
O\
lO\
O\
O
;
}
lOOllllOO\
O\
O\
l\

*=
lOlOlOlOOlOO
;
retu\
r\
n
lOOlll\
lO\
OOOl\

;
}
Dyna\
m\
i\
cObject\
Car
*
TAC_CA\
LL
DynamicOb\
jec\
t\
Car
::
Cr\
ea\
teNe\
w
(
)
{
DynamicObjectCar
*
lOlOll\
OO\
lll
;
lOOOOOllOOO
(
lOlO\
llOOlll
,
DynamicObje\
c\
tCar
)
;
return
lOl\
O\
llOOlll
;
}
DynamicO\
bje\
ctCar
::
Dyna\
micO\
b\
jectCar
(
)
:
Dyn\
amic\
Ob\
jec\
t
(
)
{
Cl\
e\
ar\
Contro\
l\
s\

(
)
;
lOl\
OlO\
lOlll
=
0.0f
;
lOlOlO\
lOlO\
l
=
0.0f
;
lOl\
Ol\
OlOOll
=
0.0f
;
lOlOl\
O\
lOlOO
=
0
;
lOl\
OlOllOO\
O
=
0.0f
;
lOlOl\
OllO\
Ol\

=
0.0f
;
}
DynamicObject\
Car
::
~
Dynami\
cObj\
e\
ctCa\
r
(
)
{
Finalise
(
)
;
lOlOlOlOOO\
ll
=
0.0f
;
lO\
lO\
l\
OlO\
OlOO
=
0.0f
;
lOlO\
lOl\
OOOOl
.
Fi\
nalise
(
)
;
lO\
lO\
l\
OlOl\
ll
=
0.0f
;
lOlO\
lO\
l\
OlOl\

=
0.0f
;
lO\
l\
Ol\
OlO\
O\
ll
=
0.0f
;
lOlO\
lOlO\
l\
O\
O
=
0
;
lOlOl\
OllOO\
O
=
0.0f
;
lOl\
O\
lOl\
lOOl\

=
0.0f
;
}
void
Dyn\
a\
micO\
b\
jec\
t\
Car\

::
In\
itia\
liseC\
o\
m\
mon
(
)
{
lOlOlOl\
OO\
lOO
=
0.0f
;
for
(
int
lOl\
OlOl\
l\
l\
O\
l\

=
0
;
lOlOlO\
ll\
l\
Ol\

<
lOlOl\
O\
OlOOOl\

.
lOOO\
ll\
l\
OOl
(
)
;
lOlO\
l\
Ol\
llOl
++
)
{
Whe\
el
&
lOlOlOllll\
O\

=
lO\
l\
OlOOl\
O\
OOl\

[
lOlOlOl\
llOl
]
;
if
(
lO\
lOlOl\
l\
llO
.
ll\
l\
O\
lOl\
llO\

&
lOlOlOO\
l\
OlOl
)
lOlOlOlO\
OlOO
+=
1.0f
;
}
if\

(
lOlOlOlO\
O\
lOO
>
0.0f
)
lOlOl\
OlOOlOO
=
1.0f
/
lOlOl\
O\
lO\
O\
lOO
;
el\
se\

lOlOlOlO\
OlO\
O
=
1.0f
;
lOl\
O\
lOlOOOl\
l\

=
0.0f
;
}
voi\
d
Dyn\
a\
micOb\
je\
c\
tCar
::
lO\
l\
Ol\
OlO\
OO\
OO
(
Whee\
l\

&
lOlO\
lOllllO
)
{
lOlO\
lOllllO\

.
lOl\
OlOOllO\
OO\

.
SetToLoo\
k\
At
(
Ge\
tFo\
rward
(
)
,
Ge\
tUp\

(
)
)
;
lOlOlOll\
ll\
O\

.
lO\
lOl\
O\
OllOOO\

.
PreRotate
(
Ma\
t3\
3
::
ROTA\
T\
ION_A\
X\
IS_Z\

,
lO\
lOlOll\
llO
.
lOlOlOOlllOl
)
;
lO\
l\
OlOll\
llO
.
lOlOlOO\
llOOl
=
lOlOlOlll\
lO\

.
lOlOlOO\
ll\
OOO
;
lOlOl\
Ol\
lllO\

.
lll\
Ol\
OlllO
&=
~
lOlOlO\
llOOOl\

;
}
}
