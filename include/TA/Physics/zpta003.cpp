//---------------------------------------------------------------------------------
// File Name: zpta003.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#include "../Physics/zpta002.h"
#ifndef TA_AABB_H
#include "../Common/AABB.h"
#endif //
#include <memory.h>
na\
mes\
p\
ace\

TA
{
ll\
OlOO\
lllll
::
llOlOOll\
l\
l\
l
(
)
{
llOlOlOO\
OOO
=
0
;
llOlOlOOOO\
l\

=
0
;
llOl\
O\
lOO\
OlO
=
0
;
llOlOlOOOll
=
0
;
llOl\
O\
lO\
OlOO
=
0.0f
;
ll\
Ol\
OlOO\
lOl\

=
0.0f
;
llO\
lOlOOll\
O
=
0.0f
;
llOlOlOOlll
=
0.0f
;
llOlOl\
OlOOO
=
0
;
}
llO\
lOOlllll
::
~
llOl\
O\
Oll\
lll
(
)
{
Fina\
l\
ise
(
)
;
}
void
llOl\
OOll\
lll
::
Ini\
tia\
lise
(
float
llOlO\
lOlOO\
l\

,
int\

llOlOlOlOlO
,
const\

AA\
BB
&
lOOOOOOl\
ll
,
int\

llO\
lOlO\
lO\
l\
l\

,
int\

llOl\
OlOllOO\

)
{
TA_AS\
SERT
(
llOlOlO\
l\
OOO
==
0
)
;
if
(
llO\
lOlOlOlO
<
sizeo\
f
(
Sp\
ace\
DivisionObj\
ect
*
)
)
llOlOlOl\
OlO
=
sizeo\
f
(
Spa\
c\
eDivisi\
o\
n\
Object
*
)
;
llO\
lOlOO\
OO\
O
=
ll\
OlOlOl\
O\
l\
l
;
llO\
lOl\
OOOOl
=
ll\
O\
lO\
lOll\
OO\

;
ll\
Ol\
O\
lOOOlO
=
(
int
)
(
lOO\
OOOO\
lll
.
v3Exte\
n\
t\

[
llOlOlOO\
OOO\

]
*
2.0f
/
ll\
OlO\
lOlOOl
)
;
llOlOlOOOl\
l\

=
(
int
)
(
lOOOOOOlll
.
v3E\
xte\
n\
t\

[
llOlO\
lOOOO\
l
]
*
2.0f
/
llOlO\
lOl\
O\
Ol
)
;
if
(
llOlOlOOOlO
<
1
)
llOl\
O\
lOO\
O\
lO
=
1
;
if
(
llOlO\
lOO\
Ol\
l
<
1
)
llOl\
Ol\
OOO\
l\
l
=
1
;
in\
t\

llOlOl\
OllO\
l
=
llOlO\
lOOOlO
*
ll\
OlO\
lO\
OO\
ll
*
siz\
eof
(
Sp\
ace\
DivisionObje\
ct
*
)
;
if
(
llOlO\
l\
O\
llO\
l
>
llOlOlO\
l\
Ol\
O\

)
{
floa\
t
llO\
lOlOll\
lO\

=
Sqr\
t
(
(
float
)
ll\
OlOlOlOlO
/
(
flo\
a\
t\

)
llOl\
O\
lO\
ll\
Ol
)
;
ll\
OlOlO\
OOlO\

=
(
int
)
floor
(
(
float
)
llOl\
Ol\
OOO\
l\
O
*
llOlOlOlll\
O
)
;
ll\
O\
lO\
lOOOl\
l\

=
(
in\
t\

)
fl\
o\
or
(
(
fl\
oat\

)
llOlOlOOOl\
l
*
llOl\
Ol\
Olll\
O
)
;
if\

(
llOlOl\
O\
OOlO
<
1
)
{
llOlOlOOOlO\

=
1
;
if\

(
ll\
Ol\
OlOOOlO
*
ll\
OlOlOO\
Oll\

*
sizeo\
f
(
SpaceDi\
vision\
Objec\
t\

*
)
>
(
u32\

)
llOlO\
l\
OlOl\
O
)
llOlOl\
OOOll\

=
llO\
lOlOl\
OlO\

/
sizeof
(
SpaceDi\
visionO\
bj\
ect
*
)
;
}
if
(
llOlOl\
OOOll
<
1
)
{
llOlOlOOO\
ll
=
1
;
if
(
llOl\
OlO\
OO\
lO
*
llOlOlO\
OOll
*
si\
zeof
(
Spac\
eDivisionObjec\
t\

*
)
>
(
u3\
2
)
llOlOlOlOlO
)
llOlO\
lOOOlO
=
llOlOlOlOl\
O
/
size\
of\

(
SpaceDi\
visionObject
*
)
;
}
}
llOlO\
lO\
OllO
=
(
flo\
at\

)
llOl\
Ol\
OOOl\
O\

/
(
lOO\
OO\
O\
Olll
.
v3Ex\
tent
[
llOlOlO\
OO\
O\
O\

]
*
2.0f
)
;
llOlOlOOlll\

=
(
float
)
llOl\
OlOOOll
/
(
lOO\
OOO\
Olll
.
v3\
Extent
[
ll\
OlOlOO\
OOl
]
*
2.0f
)
;
TA\
_ASSERT
(
llOlOl\
O\
OOl\
O
>
0
)
;
TA_A\
SSER\
T\

(
llO\
lOlOOOl\
l
>
0
)
;
llO\
lOl\
OOl\
OO
=
-
(
lOOO\
OOO\
l\
ll
.
v3\
C\
enter
[
llOlO\
lO\
OOOO
]
-
lO\
OOOOOlll
.
v3\
Extent
[
llOlOlOOOOO
]
)
;
llOlOlOOlOl
=
-
(
lOOO\
OOOlll
.
v3C\
ente\
r
[
ll\
OlO\
lOOOOl\

]
-
lOOOOOOl\
ll
.
v3\
E\
x\
tent
[
ll\
Ol\
OlO\
O\
O\
Ol
]
)
;
llOlO\
lOO\
l\
lO
=
(
fl\
o\
at
)
ll\
OlO\
lOO\
OlO
/
(
lOO\
O\
OOOl\
ll
.
v3\
E\
xtent\

[
llOlOlOOOOO
]
*
2.0f
)
;
llOl\
OlOO\
lll
=
(
float
)
llOlOlO\
OOl\
l
/
(
lOOO\
OOOlll\

.
v3Exten\
t
[
llOlOlOOOOl\

]
*
2.0f
)
;
llOl\
Ol\
Ollll
.
Initia\
lis\
e
(
llO\
l\
O\
lO\
OOl\
O
*
ll\
OlOlOO\
O\
ll
,
ll\
O\
lOl\
OO\
Ol\
O
*
ll\
OlOlO\
OO\
l\
l
)
;
memset
(
&
ll\
Ol\
O\
lO\
l\
lll
[
0
]
,
0
,
siz\
eof\

(
Spa\
c\
e\
Divi\
s\
i\
onO\
bje\
c\
t
*
)
*
llOlO\
l\
OOOlO\

*
ll\
Ol\
OlOO\
Oll
)
;
}
void
ll\
OlO\
Ol\
llll
::
Fin\
alis\
e
(
)
{
llOlOlOOOOO\

=
0
;
llO\
lOlOOOOl
=
0
;
llO\
l\
OlO\
OOlO
=
0
;
llOl\
OlOOO\
ll
=
0
;
llOl\
Ol\
OOlO\
O
=
0.0f
;
llOlO\
lOO\
lOl\

=
0.0f
;
llOlOlOO\
l\
lO\

=
0.0f
;
llOlOlO\
Olll
=
0.0f
;
llO\
lOlOllll
.
Finalise
(
)
;
llOl\
O\
lO\
lO\
OO
=
0
;
}
voi\
d
llOl\
OOlll\
ll
::
lOlOlOOOOl
(
SpaceDiv\
i\
sionO\
b\
ject
&
lOllllllllO\

)
{
if\

(
lOl\
lllllllO
.
llOOO\
OlOlOl
)
lOO\
lllll\
ll
(
lO\
l\
l\
llllllO
)
;
flo\
at
ll\
OlOl\
l\
OO\
O\
O
=
Fas\
tMax
(
lOlllll\
l\
llO\

.
GetCol\
lisi\
onGrid\
G\
e\
tLoca\
lAABB
(
)
.
v3\
Extent\

[
ll\
Ol\
O\
lOOOOO
]
*
llOlOlO\
Oll\
O
,
lO\
l\
lllll\
llO
.
Get\
Co\
l\
lisionGr\
i\
d\
G\
etLoc\
al\
AA\
BB
(
)
.
v3Ext\
ent
[
llOlOlOOOOl
]
*
ll\
OlO\
l\
O\
Ol\
ll
)
;
Spa\
c\
eDivisi\
o\
nObjec\
t\

*
*
llO\
lOllOOOl
;
if
(
llOlOl\
lOOO\
O\

>
1.0f
)
{
llOlOllOOO\
l\

=
&
llO\
l\
OlOlO\
OO
;
}
else\

{
int\

llO\
OO\
OllOl\
O
=
ll\
OlOll\
O\
OlO
(
lOl\
lllll\
llO\

.
Get\
C\
ol\
l\
is\
i\
on\
G\
rid\
W\
orld\
P\
os
(
)
[
ll\
Ol\
Ol\
OOOOO\

]
)
;
Cla\
mp\

(
ll\
OOOO\
llOlO
,
0
,
llO\
l\
OlOOOl\
O
-
1
)
;
in\
t
llOOOO\
llOl\
l
=
llOlO\
l\
l\
O\
Oll
(
lOllllllllO\

.
Ge\
tColl\
i\
sionG\
ri\
d\
World\
P\
os
(
)
[
llOlOlO\
OOOl
]
)
;
Cl\
a\
m\
p
(
llOO\
O\
OllOll
,
0
,
llOlO\
l\
OOOl\
l
-
1
)
;
llO\
l\
O\
l\
lOO\
Ol
=
llOlOllO\
lOO
(
llO\
OOOll\
Ol\
O\

,
ll\
OOOOllOll\

)
;
}
lO\
lll\
ll\
lllO\

.
llO\
OOOl\
l\
lll\

=
*
llOlOllO\
OOl
;
if\

(
lOllll\
ll\
llO
.
llOOOOlllll
)
lO\
llllllllO
.
llO\
OOOlllll
->
llOOOO\
lOlOl
=
&
lO\
ll\
lllll\
l\
O
.
llOOOOll\
lll
;
*
llOl\
Ol\
lO\
OOl
=
&
lOllll\
llllO
;
lO\
lllllll\
l\
O\

.
llOOO\
O\
lOlOl
=
llOl\
Ol\
lOOOl\

;
}
void
llOlO\
Olll\
ll
::
lOOlllllll
(
Spa\
ceDivisio\
n\
O\
bj\
ect\

&
lOllllllllO
)
{
if
(
!
lOl\
lll\
l\
ll\
lO\

.
ll\
O\
O\
OOlOl\
O\
l
)
{
TA_\
A\
SS\
E\
RT
(
lOl\
l\
ll\
lll\
lO
.
llO\
OOOlllll
==
0
)
;
ret\
ur\
n
;
}
TA_A\
SS\
ER\
T
(
lOll\
ll\
l\
lllO
.
llO\
O\
O\
O\
l\
OlOl
)
;
TA_AS\
S\
ERT
(
*
lO\
ll\
lllll\
l\
O\

.
llOOOO\
lOl\
O\
l\

==
&
lOllllllllO
)
;
*
lOllll\
llllO
.
llOOOOlOlOl
=
lO\
ll\
ll\
l\
lllO
.
llOOO\
Olllll
;
if
(
lOll\
lll\
lll\
O\

.
llOOO\
Ol\
l\
lll\

)
{
TA_\
AS\
SE\
RT\

(
lOl\
lllllllO
.
llOOO\
O\
l\
llll
->
ll\
O\
O\
OO\
lOlOl
==
&
lOl\
lllllllO\

.
llOOOOllll\
l
)
;
lOllllllll\
O
.
llOO\
OO\
lllll
->
llOOO\
O\
l\
OlOl
=
lO\
l\
lll\
lll\
lO
.
llOO\
OOl\
OlO\
l
;
}
lO\
llllllllO
.
llO\
O\
O\
OlOl\
Ol\

=
0
;
lO\
lllll\
lllO\

.
llOO\
OOlll\
l\
l
=
0
;
}
void
llOlOOllll\
l
::
llOOOlOOlOO
(
const
AA\
BB
&
lOOO\
OOO\
lll
,
void\

(
TAC_\
C\
AL\
L
*
llOO\
lOllOO\
O
)
(
Spa\
ceDi\
vi\
sio\
nObj\
e\
ct
&
lOllllllllO
,
void
*
lO\
OlllOOOO\

)
,
void
*
lOOOOllllO\

)
{
AABB\

llO\
l\
O\
ll\
OlOl
;
llOl\
O\
llO\
lO\
l
=
lOO\
OOOOlll
*
2.0f
;
if
(
llOl\
OllOl\
O\
l
.
v3\
Exte\
nt
[
ll\
OlOlOOO\
OO
]
<
llOlO\
llOlOl
.
v3\
Ex\
tent
[
llO\
lOl\
OOOO\
l
]
)
llO\
l\
Oll\
OlOl\

.
v3Exte\
nt
[
llO\
lO\
l\
OOOOO
]
=
llOlOl\
lOl\
Ol\

.
v3Exte\
nt\

[
ll\
OlO\
l\
OOOOl
]
;
else
llOlOllOlO\
l
.
v3Exten\
t
[
llOlOlO\
O\
OOl
]
=
ll\
OlO\
llO\
lOl
.
v3Ex\
t\
ent
[
llOlOl\
O\
OOOO
]
;
float\

llOlO\
l\
lO\
l\
lO
=
0.5f
;
int\

llOl\
O\
llOlll
=
FastFloa\
tTo\
Int
(
(
lOOOOO\
Olll\

.
v3\
Cen\
ter
[
llO\
lO\
lOO\
OOO
]
-
llO\
lOll\
OlO\
l
.
v3Extent
[
ll\
OlO\
lOO\
O\
O\
O
]
+
llOlO\
l\
OO\
lO\
O
)
*
llOlOlOOllO
-
llOlOl\
lOllO
)
;
Clam\
p
(
llOlOllOlll
,
0
,
ll\
OlOl\
O\
O\
OlO
-
1
)
;
int
llOl\
Olll\
OO\
O
=
Fa\
stFlo\
atToI\
n\
t\

(
(
lOO\
OO\
OOl\
ll
.
v3Ce\
nter
[
llO\
l\
OlOOOO\
O
]
+
llOlOl\
lO\
lOl
.
v3\
Ext\
en\
t
[
llOlO\
lO\
OOOO
]
+
llOl\
Ol\
OOlOO\

)
*
llO\
lOlOOl\
l\
O
+
llOlO\
llOllO
)
;
Cl\
amp
(
llOlOll\
lOOO\

,
0
,
ll\
OlO\
l\
OOOlO
-
1
)
;
int
llOlO\
ll\
lOOl
=
FastFlo\
atToInt
(
(
lO\
O\
O\
OOOll\
l
.
v3C\
ente\
r\

[
llOlOlOOO\
Ol
]
-
ll\
OlOllOlOl
.
v3Extent
[
llOl\
OlOOOO\
l
]
+
llOl\
Ol\
O\
O\
lOl
)
*
llOlOlO\
Oll\
l\

-
llOlOllO\
l\
lO
)
;
Clam\
p
(
llO\
l\
Ol\
ll\
OOl
,
0
,
llO\
lOlO\
OOll
-
1
)
;
int\

ll\
O\
lOlllOlO
=
FastF\
loatT\
oI\
nt
(
(
lOOOO\
OOlll
.
v3\
C\
e\
nter\

[
llO\
lOlOOOOl
]
+
ll\
Ol\
OllOlOl
.
v3Exten\
t
[
llOl\
O\
lOOOOl\

]
+
llOlOlOOlOl
)
*
llOlOlOOlll
+
ll\
O\
l\
OllOllO\

)
;
Clamp\

(
ll\
O\
lOl\
ll\
OlO\

,
0
,
llOlO\
l\
OOO\
ll\

-
1
)
;
{
SpaceDi\
visionO\
bje\
ct\

*
llOOOOlOll\
O
=
llOlOl\
Ol\
OOO
;
for
(
;
llO\
OOO\
lO\
llO\

;
llOOOO\
l\
OllO
=
llOOOO\
lO\
llO
->
llOO\
OOlllll
)
llO\
OlO\
ll\
OOO
(
*
llOOO\
O\
lOllO
,
lOO\
OOllllO
)
;
}
for
(
int
ll\
OOOO\
O\
OOl
=
llO\
l\
Oll\
Olll
;
llOOOO\
OOOl
<=
llO\
lOlllO\
O\
O\

;
llOOOOO\
OOl
++
)
{
fo\
r
(
int
ll\
O\
OOOOOlO
=
llOlOll\
lO\
O\
l
;
llOOOOOOl\
O
<=
llOl\
O\
lllOlO
;
llOOOO\
O\
O\
lO
++
)
{
Space\
Divisi\
onOb\
ject
*
llOO\
OOlOllO\

=
*
ll\
O\
lO\
llOlOO\

(
llOO\
OOOOOl
,
llOOO\
O\
OOl\
O
)
;
fo\
r\

(
;
llOOOOlOllO\

;
ll\
OOO\
OlOll\
O
=
ll\
OOOOlO\
llO\

->
ll\
OOOOll\
l\
ll\

)
llO\
OlOllO\
OO\

(
*
llOO\
OO\
lO\
llO\

,
lOOO\
Ol\
l\
ll\
O\

)
;
}
}
}
void
llO\
l\
O\
O\
ll\
lll\

::
llO\
OOl\
O\
llO\
O\

(
con\
st
Vec3
&
lO\
O\
lO\
lOlll
,
cons\
t\

Vec3
&
lOOlOllO\
Ol
,
voi\
d
(
TAC_\
C\
ALL
*
llOOlOll\
OOO
)
(
Space\
Di\
visi\
onO\
b\
j\
ect
&
lO\
l\
llllll\
l\
O
,
void\

*
lOOl\
l\
lO\
OOO\

)
,
void
*
lO\
O\
O\
OllllO
)
{
{
Space\
Divi\
sion\
Obje\
ct
*
ll\
OO\
O\
OlOl\
l\
O
=
llOlOl\
O\
l\
O\
O\
O
;
fo\
r\

(
;
ll\
OOOOlOllO\

;
llOOOOl\
Oll\
O
=
ll\
O\
OOOlOl\
lO
->
llOOOOlll\
ll
)
llO\
OlOllO\
OO
(
*
llOOOOlOllO\

,
lOO\
O\
OllllO\

)
;
}
co\
nst
Vec\
2\

llOl\
Ol\
llO\
l\
l\

(
lOOlOlOlll\

[
llOlOlOOOOO
]
,
lOOlO\
l\
Ol\
l\
l
[
ll\
OlOlO\
O\
OOl
]
)
;
cons\
t
Ve\
c\
2
llOlOlll\
l\
O\
O
(
lOOlOll\
OO\
l\

[
llOlO\
l\
O\
O\
OOO
]
,
lOO\
l\
Ol\
lOOl
[
llOlOlOO\
OOl
]
)
;
Ve\
c2
llOlOl\
lllO\
l\

;
ll\
OlOllllOl
.
x
=
(
llOlOll\
lOll
.
x
+
llOlOlOOlO\
O\

)
*
llOlO\
lOOllO\

;
llO\
lO\
lll\
lOl
.
y
=
(
ll\
OlOl\
llOll\

.
y
+
llOlO\
lO\
OlO\
l
)
*
ll\
O\
lO\
l\
OOll\
l
;
Ve\
c2
llOlOl\
lll\
lO
;
llOlOllll\
lO\

.
x
=
(
llOlOllll\
OO
.
x
+
llO\
lOlOOl\
OO\

)
*
ll\
Ol\
OlOOl\
l\
O
;
llOl\
OlllllO
.
y
=
(
llO\
l\
Ol\
lll\
OO\

.
y
+
llOlO\
l\
OOlOl
)
*
llOlOlOOlll
;
if
(
Fab\
s
(
ll\
O\
lOlllll\
O
.
x
-
ll\
OlOllllOl
.
x
)
>
Fabs
(
llOlOl\
lll\
lO\

.
y
-
ll\
OlOllll\
O\
l\

.
y
)
)
{
if
(
llOlOllll\
lO
.
x
<
llO\
lOl\
ll\
lOl
.
x
)
Swap
(
llOlOllll\
l\
O
,
llOlOlll\
lOl
)
;
floa\
t\

llO\
lOllll\
ll\

=
(
llOlOlllll\
O
.
y
-
llOlOl\
lllOl
.
y
)
/
(
ll\
O\
lOlll\
llO\

.
x
-
llOl\
OllllO\
l
.
x
)
;
fl\
o\
at
llOlOOllOlO
=
ll\
O\
lOlll\
lO\
l
.
y
-
ll\
O\
lOllll\
Ol
.
x
*
ll\
O\
l\
Oll\
llll
;
in\
t\

llOOOOOOO\
l
=
Fast\
Fl\
oatToI\
nt
(
llOl\
OllllOl
.
x
)
-
1
;
if\

(
llOOOO\
OOOl
<
0
)
ll\
O\
OOOO\
OOl
=
0
;
else
if
(
llOOOOO\
OOl
>=
llOlOl\
OOO\
l\
O\

)
re\
turn
;
int
ll\
Oll\
OOO\
OO\
O\

=
Fast\
FloatToInt
(
llO\
lOlllll\
O
.
x
)
+
1
;
if\

(
llOll\
O\
OOOOO
<
0
)
re\
turn
;
els\
e
if
(
llOll\
OOOOO\
O
>
ll\
Ol\
OlOOO\
l\
O
-
1
)
llO\
llOOOOOO
=
llOlO\
lOOOlO\

-
1
;
for\

(
;
ll\
OOOOO\
O\
Ol
<=
llOllOOOOOO
;
ll\
O\
O\
O\
OOOO\
l
++
)
{
in\
t
ll\
OOOOO\
Ol\
O
=
Fas\
tFloatToInt\

(
llO\
l\
Ollllll
*
(
flo\
a\
t\

)
llOOOOOO\
Ol
+
llOl\
OOllOlO
)
;
if
(
llOOOO\
OO\
lO
<
0
||
ll\
OOO\
O\
OOlO
>=
llOlOl\
OOOl\
l
)
cont\
i\
nue
;
in\
t
llOl\
lO\
O\
O\
OOl
=
llOOOOOOlO
+
1
;
if
(
llOllOOOOOl\

>=
llO\
l\
Ol\
OOOll
)
llOllOOOOO\
l
=
llO\
lOl\
O\
OO\
ll
-
1
;
ll\
O\
O\
O\
OOO\
lO
--
;
if
(
llOO\
OOO\
OlO
<
0
)
llOOOO\
OOlO
=
0
;
for\

(
;
llO\
O\
OO\
OOl\
O
<=
llO\
ll\
O\
O\
OO\
Ol
;
ll\
OOOOOOlO
++
)
{
Space\
Di\
visi\
onObject\

*
llOOOOlOllO\

=
*
llOlOl\
l\
OlOO
(
ll\
O\
O\
OOOOO\
l
,
llOOOOO\
OlO
)
;
for\

(
;
llOOOOl\
OllO\

;
llOOOOlO\
ll\
O\

=
llOOOOlO\
l\
lO\

->
llOOOOl\
ll\
ll
)
llOO\
lOl\
lOOO
(
*
llO\
OOO\
lO\
ll\
O
,
lOOOOl\
lll\
O
)
;
}
}
}
else
{
if\

(
llOlOllll\
l\
O
.
y
<
llOlOllllOl\

.
y
)
Swap
(
llOl\
O\
l\
ll\
ll\
O
,
llO\
lOll\
llOl
)
;
const\

float\

lOl\
lOlOl\
Ol
=
0.0001f
;
if\

(
llOlOllll\
lO
.
y
-
llOlOll\
l\
lOl
.
y
<
lO\
llOlOlOl
)
{
AABB\

lOO\
OOOO\
lll\

;
lOOO\
O\
O\
Olll
.
v3\
Cen\
t\
er\

.
Ini\
tialise\

(
ll\
Ol\
O\
ll\
lO\
l\
l\

.
x
,
0.0f
,
llOlOl\
llOll
.
y
)
;
lOO\
O\
O\
OO\
lll
.
v3Exten\
t
.
Init\
ialise
(
0.0f
,
0.0f
,
0.0f
)
;
llOOO\
lOOl\
OO\

(
lO\
OO\
OO\
O\
l\
ll
,
llO\
O\
lOllOOO
,
lOOOOll\
llO
)
;
return\

;
}
fl\
oat\

ll\
OlOl\
l\
llll\

=
(
llOlOlll\
ll\
O
.
x
-
llO\
l\
Olll\
lOl
.
x
)
/
(
llO\
lOl\
llllO
.
y
-
llOlOllll\
O\
l
.
y
)
;
fl\
oat
llO\
lOO\
llOlO\

=
ll\
O\
lOllllOl
.
x
-
llOlOl\
ll\
lO\
l
.
y
*
llOl\
Ol\
ll\
l\
ll
;
in\
t
llOOOOO\
OlO\

=
Fa\
s\
t\
Fl\
oa\
tToI\
nt
(
llOl\
Ol\
lll\
O\
l
.
y
)
-
1
;
if\

(
llOOOO\
O\
OlO
<
0
)
ll\
OOOOOOlO
=
0
;
els\
e\

if
(
llOOOO\
OOlO\

>=
llOl\
OlOO\
OlO
)
ret\
ur\
n
;
int
llOllO\
OOOOl
=
Fas\
tFloatToIn\
t
(
llO\
lOlllllO
.
y
)
+
1
;
if
(
llOllOO\
OOOl\

<
0
)
retu\
r\
n
;
else
if
(
llOllOOOOO\
l
>
llO\
lOlOO\
Oll
-
1
)
ll\
Ol\
lOOO\
OOl
=
llO\
l\
Ol\
OOOll
-
1
;
for
(
;
llOOOOOOlO
<=
llOllOOOOOl
;
llOOO\
OOOlO
++
)
{
in\
t
llOOO\
OOOO\
l
=
Fas\
tFloat\
ToInt
(
llO\
lOllllll
*
(
float
)
llOO\
OOOOl\
O
+
llOlOOllOlO
)
;
if
(
llO\
OO\
OOOO\
l
<
0
||
llO\
O\
OOO\
OO\
l\

>=
ll\
OlOlOOO\
lO
)
co\
nt\
i\
nu\
e
;
int
llOl\
lOO\
OOOO\

=
llOOOO\
OOO\
l
+
1
;
if
(
llOl\
lOOOOO\
O\

>=
llO\
l\
OlO\
OOlO\

)
llO\
l\
lOOOOOO
=
llOlO\
lOOOl\
O
-
1
;
llO\
OOOO\
OO\
l
--
;
if
(
ll\
OO\
O\
OOOOl
<
0
)
ll\
O\
OOOOO\
Ol\

=
0
;
fo\
r
(
;
llOOOOO\
O\
O\
l
<=
llOllOOOOOO
;
ll\
OO\
O\
O\
OOOl
++
)
{
Spac\
eD\
ivi\
sio\
n\
Objec\
t\

*
ll\
OOOOlOl\
lO\

=
*
llOlOllOl\
OO\

(
llOOO\
OOOO\
l
,
ll\
O\
OOOOO\
lO
)
;
fo\
r
(
;
llO\
O\
OOl\
OllO\

;
llOOOOlOll\
O
=
llOO\
OOlO\
l\
l\
O
->
llO\
O\
OO\
l\
ll\
ll
)
llOOlOllOOO
(
*
llOOOOlOl\
l\
O\

,
lOO\
OO\
l\
lllO
)
;
}
}
}
}
}
