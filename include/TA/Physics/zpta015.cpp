//---------------------------------------------------------------------------------
// File Name: zpta015.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#define llOllOlOOOl
#define lOllOllOOOO
#include "CollisionObjectSphere.h"
#ifndef TA_MFRAME_H
#include "../Common/MFrame.h"
#endif //
#ifndef TA_GEOMETRY_H
#include "../Common/Geometry.h"
#endif //
#ifndef llOllOOOllO
#include "../Physics/zpta013.h"
#endif //
#ifndef TA_COLLISIONOBJECTCACHEDPOLYDATA_H
#include "CollisionObjectCachedPolyData.h"
#endif //
#ifndef TA_COLLISIONOBJECTLINELIST_H
#include "CollisionObjectLineList.h"
#endif //
#ifndef lllOOOlOllO
#include "../Physics/zpta007.h"
#endif //
#ifndef TA_PHYSICSRENDER_H
#include "PhysicsRender.h"
#endif //
#ifndef TA_COLLISION_H
#include "Collision.h"
#endif //
namespac\
e
TA
{
void\

Colli\
s\
ionObje\
ctSph\
er\
e
::
Initialise
(
con\
st
Vec\
3
&
v3Cent\
e\
r
,
float
lll\
l\
Olllll
)
{
lll\
OOOO\
lOl\
O
=
v3Ce\
nter
;
lO\
lOlOOlOOO
=
llllO\
llll\
l
;
lOOOOOOl\
lO
(
lll\
lOlllll
>=
0.0f
,
"CollisionObjectSphere::Initialise. fRadius is <= 0.0f")
;
}
void
Col\
li\
sion\
Obj\
ectSph\
ere
::
Finalis\
e
(
)
{
lllOOOOlOlO
.
Cl\
ea\
r
(
)
;
lOlOlOOlOOO
=
0.0f
;
}
vo\
id
Colli\
si\
onObjec\
t\
Sphere
::
Seri\
al\
ise
(
Seriali\
s\
er\

&
lOOOl\
OllOl
,
const
Ver\
s\
ion
&
lll\
Ol\
OOOlO
)
{
lOOOOOOl\
lO
(
lllOl\
OOOl\
O\

<=
ll\
OllOOl\
OlO\

,
"CollisionObjectSphere::Serialise. The version number is too new.")
;
lO\
OOl\
Ol\
lOl
.
Seri\
al\
ise\

(
lllO\
OOOlOl\
O
)
;
lOOOlO\
llOl
.
Seria\
l\
ise
(
lOlOlOO\
lOO\
O
)
;
}
void
Collis\
io\
n\
ObjectSphere
::
Re\
nde\
r
(
con\
s\
t\

MFr\
a\
me\

&
lOOO\
OO\
OOOl
)
{
cons\
t
in\
t
lllO\
lOlOOlO
=
6
;
co\
n\
st
in\
t
lllOlOlOOl\
l
=
4
;
Mat3\
3
ll\
lO\
lOlOlOO
;
lllOlOlOlOO
.
SetToIdent\
i\
ty
(
)
;
for\

(
in\
t
lllOlOlOl\
Ol
=
0
;
ll\
lOl\
OlOlOl
<
lllOlO\
l\
O\
OlO\

;
lllOlOlOlOl
++
)
{
fl\
o\
at\

lOO\
OOllOOOl
;
floa\
t\

lOOOO\
l\
l\
OOlO
;
SinAn\
d\
Cos
(
(
fl\
oa\
t\

)
lllO\
lOl\
OlOl
/
(
floa\
t\

)
ll\
lOlOlOOlO\

*
(
k_fPi
*
2.0f
)
,
lOOOOllOOO\
l\

,
lO\
OOOllOOl\
O
)
;
Vec3\

lll\
OlOl\
O\
llO
=
(
lllOlOlO\
lO\
O
.
v3\
X\

*
lOO\
OOll\
OOlO\

+
lll\
OlOlOlOO\

.
v3\
Y
*
lOO\
OO\
l\
l\
OO\
Ol
)
;
SinAn\
dCos
(
(
float\

)
(
ll\
l\
OlOlOlO\
l
+
1
)
/
(
float
)
lll\
Ol\
Ol\
OOlO
*
(
k_f\
Pi
*
2.0f
)
,
lO\
OOOllOOO\
l
,
lOOO\
OllOOlO
)
;
Ve\
c\
3
lll\
OlOlOll\
l
=
(
lllOlO\
l\
OlO\
O
.
v3\
X
*
lOOO\
Ol\
lO\
OlO
+
lllOlOlOlO\
O
.
v3\
Y\

*
lOOO\
OllO\
OOl
)
;
{
con\
s\
t
Vec3
lllOlOllOO\
O
[
4
]
=
{
(
lllOOO\
OlOlO
+
lllOlOlOllO
*
lOlOlOO\
lOOO\

)
*
lOOOOO\
OOO\
l
,
(
lll\
OO\
O\
OlOlO\

+
lllOlOlOlll\

*
lOlOlOOl\
OO\
O
)
*
lO\
O\
OO\
O\
OOO\
l
,
(
ll\
lO\
O\
O\
OlOlO
+
ll\
l\
O\
l\
OlOlll
*
lOlOlOOlO\
O\
O\

)
*
lO\
OOO\
O\
OOOl
,
(
lllO\
OOOlOl\
O
+
ll\
lO\
lO\
lO\
l\
lO
*
lOl\
Ol\
OO\
l\
OOO\

)
*
lOOOO\
OOO\
Ol
,
}
;
cons\
t
Ve\
c\
3
lllO\
lO\
llOO\
l
[
4
]
=
{
lll\
Ol\
OlO\
llO
*
lO\
O\
OOOOO\
Ol
.
m33Rotation
,
ll\
lOlOlOlll\

*
lOOOO\
OO\
OOl
.
m33R\
ot\
ation\

,
lllOlOlOll\
l\

*
lOO\
O\
OOOOO\
l
.
m33R\
ot\
at\
ion
,
lllOlOlOllO
*
lOOO\
OO\
OOOl\

.
m33\
Ro\
tation\

,
}
;
Phy\
sics\
Re\
n\
der
::
Rende\
rPolygo\
n
(
4
,
lll\
O\
l\
O\
llOOO
,
lllO\
lOl\
l\
O\
Ol
)
;
}
for
(
int
lllOlO\
llOlO
=
0
;
lllOl\
Oll\
OlO\

<
lllOlOlOOl\
l
;
ll\
l\
Ol\
OllOlO
++
)
{
Sin\
A\
n\
dC\
os
(
(
float
)
lllOlOl\
l\
OlO\

/
(
fl\
oa\
t\

)
ll\
lOlOl\
OOll
*
(
k_fPi
)
,
lOO\
OO\
llOOOl
,
lOO\
OOllOO\
l\
O
)
;
Vec3
lllOlOl\
lOl\
l
=
lllOlOlO\
ll\
O
*
lOOOOl\
l\
OOlO
+
lllOlOlOlOO
.
v3Z
*
lOOOOll\
OOO\
l\

;
Vec3
lllOlOlllOO\

=
ll\
lO\
l\
OlOlll
*
lOO\
OOll\
OOlO
+
lllOlOlOl\
OO
.
v3Z
*
lOOOOllOOOl
;
SinA\
ndCos
(
(
float
)
(
ll\
lOl\
Ol\
lOlO\

+
1
)
/
(
float\

)
lllOlO\
lOOl\
l
*
(
k_fPi
)
,
lOOOOl\
lOOOl
,
lOOOO\
llOOlO
)
;
Vec3
lllO\
lO\
ll\
l\
O\
l\

=
ll\
lOlOl\
OllO\

*
lOO\
OOllOO\
l\
O
+
lllO\
lO\
lOlOO
.
v3Z\

*
lOO\
OOllOOOl
;
Vec3
ll\
l\
Ol\
O\
l\
lllO
=
lllO\
l\
Ol\
Olll
*
lOO\
OOllOOl\
O
+
lllO\
l\
OlOlOO
.
v3\
Z
*
lO\
OO\
OllOOOl
;
{
co\
n\
s\
t
Vec3
ll\
l\
OlOllO\
OO\

[
4
]
=
{
(
lllO\
OO\
Ol\
OlO
-
lll\
OlOllOll
*
lOlOl\
OOlO\
OO
)
*
lOOOOOO\
OO\
l\

,
(
lllOOO\
O\
lO\
l\
O\

-
lllOlOlllO\
l
*
lOl\
O\
lO\
OlOO\
O
)
*
lO\
OOOO\
OO\
Ol
,
(
lllOOO\
O\
l\
O\
lO
-
lllOl\
OllllO\

*
lO\
lOlOO\
l\
OOO\

)
*
lO\
OOOO\
OOO\
l
,
(
lllOOOOlOlO
-
lllOl\
OlllOO
*
lO\
lOlOOlOOO
)
*
lOO\
OO\
O\
OOOl
,
}
;
co\
nst
Vec3\

lllOl\
O\
llOOl\

[
4
]
=
{
-
lll\
OlOllOll
*
lOO\
OOOOOOl\

.
m33Rota\
t\
ion
,
-
lllOl\
Ol\
llO\
l
*
lO\
OO\
O\
OO\
OOl\

.
m33Rotatio\
n
,
-
lllOlOlll\
lO\

*
lO\
OOOOO\
OOl
.
m3\
3\
Rotati\
on
,
-
lllOlOlllOO\

*
lOOO\
O\
OOOOl
.
m3\
3Rotatio\
n\

,
}
;
Ph\
ys\
icsRe\
nder
::
Ren\
derP\
olyg\
o\
n
(
4
,
ll\
lOl\
Ol\
l\
OOO\

,
lllOlO\
ll\
OO\
l
)
;
}
{
const
Ve\
c\
3\

lllOlO\
ll\
OOO
[
4
]
=
{
(
lllO\
O\
OOlOlO
+
lllOl\
Ol\
lO\
ll
*
lOlOlOOlOOO\

)
*
lOOO\
OOOO\
Ol
,
(
ll\
lOOOOlO\
l\
O
+
lll\
O\
lO\
lllO\
l
*
lOl\
Ol\
OOl\
O\
O\
O
)
*
lOOOOOOOO\
l
,
(
lllOOO\
O\
lO\
lO
+
lll\
O\
lOl\
lllO
*
lOlOlOOlO\
O\
O
)
*
lOOO\
OOO\
OOl
,
(
lll\
OOOOlOl\
O\

+
lllOl\
OlllO\
O\

*
lOlOl\
O\
OlO\
OO
)
*
lOOOOOOO\
Ol\

,
}
;
co\
n\
st
Ve\
c3
lllOl\
OllO\
Ol
[
4
]
=
{
lllOlOllOll
*
lOOOOOOO\
O\
l
.
m33Rotati\
on\

,
lllO\
lOlllO\
l
*
lOOO\
OOOO\
Ol
.
m3\
3Rot\
a\
tion
,
lll\
Ol\
O\
llllO\

*
lO\
OOOOO\
OOl
.
m33\
R\
otat\
ion
,
lllOl\
Olll\
OO
*
lOO\
OOO\
OOOl
.
m33Rotati\
o\
n\

,
}
;
Ph\
y\
sicsRender
::
Rend\
erPoly\
go\
n
(
4
,
lllOlOllOOO
,
lllO\
lOl\
lOOl
)
;
}
}
}
}
AABB
CollisionObj\
ectSph\
er\
e\

::
Ca\
lculat\
eBounding\
Bo\
x\

(
)
con\
s\
t
{
AAB\
B
lOOO\
O\
OOlll\

;
lO\
OOOOOlll\

.
v3Cent\
er\

=
lllOOOOlO\
lO\

;
lOOOOO\
Olll\

.
v3Ext\
ent
.
x
=
lO\
lOlOOlO\
OO
;
lOOOO\
OOlll\

.
v3Exte\
nt
.
y
=
lOlOlO\
OlOOO
;
lOOOOO\
Oll\
l\

.
v3Extent
.
z
=
lOl\
Ol\
O\
OlO\
OO\

;
return
lOOOOOO\
l\
ll\

;
}
voi\
d
Colli\
sion\
ObjectSpher\
e\

::
Ca\
lcu\
late\
M\
as\
s
(
float
lll\
Ol\
Ol\
l\
ll\
l
,
flo\
at
&
lO\
llOOOOlOO\

,
Vec3\

&
ll\
l\
O\
llO\
OOO\
O
,
Mat33
&
lllOllOOOO\
l\

)
co\
ns\
t
{
lO\
l\
lO\
OOOlOO
=
4.0f
/
3.0f
*
k_f\
Pi\

*
lOlOl\
O\
O\
lOOO
*
lOlOlO\
OlOO\
O
*
lOlOl\
OOlO\
OO
*
lllOlO\
ll\
lll
;
lllOllOO\
OOl
.
SetT\
o\
Identity
(
)
;
lll\
OllO\
OO\
Ol
.
M11\

(
)
=
2.0f
/
5.0f
*
lO\
ll\
OOO\
OlOO
*
lOlOlOOl\
OOO\

*
lOlOlOO\
lOOO\

;
lllO\
llOOOOl
.
M2\
2\

(
)
=
ll\
lO\
llO\
OOO\
l
.
M11\

(
)
;
ll\
lOll\
OO\
OOl\

.
M33
(
)
=
ll\
lOll\
O\
O\
OOl
.
M11
(
)
;
lll\
O\
llOOO\
OO
=
lllOOOOlO\
lO
;
}
boo\
l
Collisi\
onO\
bject\
Sphe\
re
::
Test\
L\
i\
neForC\
ol\
l\
i\
s\
i\
o\
n
(
co\
ns\
t
Vec3
&
lO\
OlOlOlll\

,
const
Ve\
c\
3
&
lOO\
OlOOO\
O\
O
,
float
lOOlO\
llOOO
,
Co\
l\
lision
&
llOllllO\
l\
Ol
)
co\
n\
st
{
Vec\
3
lOOl\
O\
ll\
OOl
=
lOO\
lOlOll\
l
+
lOOO\
lOOOOO\

*
lO\
O\
lOllOOO\

;
flo\
at
lll\
lOlO\
OOl
;
Vec\
3
lOllllOOOl\

;
Vec\
3\

lOl\
lllO\
OlO
;
if
(
Ge\
ometry
::
TestP\
oi\
nt\
Mo\
vem\
en\
tAgai\
nst\
Sp\
here\

(
lOOlOlOll\
l
,
lOOlOllO\
Ol
,
lllOOO\
OlO\
lO
,
lOlOlO\
O\
lOOO
,
llllOlOOOl
,
lOlll\
lOOOl
,
lO\
llllOOlO
)
)
{
flo\
at
lO\
lOllO\
l\
l\
l
=
lOOOl\
OOOOO
.
Dot
(
lOll\
llOO\
Ol
-
lO\
OlOlOlll
)
;
if
(
lO\
lOllOlll\

<
ll\
Olll\
lOlO\
l\

.
lOl\
l\
OOlOOO\
l
)
{
Vec3
ll\
lOl\
lOOl\
l\
O\

=
lO\
OlO\
lO\
l\
l\
l
+
lOlOl\
lOlll
*
lO\
OOlOOOOO
;
ll\
Oll\
llOl\
Ol
.
Initial\
ise
(
0
,
0
,
lOl\
O\
l\
lOll\
l\

/
lOOl\
Ol\
lOO\
O\

,
lOlOllOlll\

,
lOllllOOOl
,
lOllllOOl\
O
)
;
llOlll\
l\
O\
lO\
l\

.
SetC\
o\
llisio\
nObj\
ect\
A
(
con\
st_cast
<
Col\
li\
sio\
nObjec\
tS\
pher\
e
*
>
(
this
)
)
;
ret\
u\
rn
tru\
e
;
}
}
ret\
urn\

false
;
}
Coll\
isionObj\
ectSpher\
e\

*
TAC_CAL\
L
CollisionOb\
jectSphere\

::
CreateN\
ew
(
)
{
Coll\
isi\
onOb\
jectSph\
e\
re
*
lOlOl\
lOO\
lll
;
lOOO\
OOllO\
O\
O\

(
lOl\
OllO\
Olll
,
Col\
lisionObjectS\
p\
here
)
;
return\

lO\
lOllOOll\
l
;
}
Collisi\
onO\
b\
je\
c\
tSph\
er\
e
::
Coll\
isi\
onObj\
ect\
Sphere
(
)
:
Coll\
i\
s\
ionObjec\
tS\
im\
pl\
e
(
Col\
lis\
ionO\
bject
::
TYPE_S\
PHERE
)
{
lllOO\
O\
O\
l\
OlO
.
Cl\
ear
(
)
;
lOlO\
l\
OOlOO\
O\

=
0.0f
;
}
Co\
l\
lisi\
onObjec\
tSp\
h\
ere\

::
~
Col\
lisionOb\
j\
ec\
tSphere\

(
)
{
Finali\
se
(
)
;
}
#ifndef DOXYGEN
void
TAC_\
CALL
llllOOllOOO\

(
cons\
t
MFrame
&
lOl\
lOl\
l\
llll\

,
const
MFra\
m\
e\

&
lOl\
ll\
OO\
OOO\
O
,
lOllO\
llO\
llO
*
lOl\
llO\
O\
OOOl
)
{
TA_AS\
SERT
(
lOlll\
OOO\
OOl
->
lO\
l\
lOO\
OllOl
->
GetColli\
sionOb\
jec\
tType
(
)
==
Co\
llis\
ionO\
bj\
ect
::
TYPE_SPHE\
RE\

)
;
co\
nst
CollisionOb\
jectS\
ph\
ere\

&
ll\
lO\
llOl\
lOO\

=
*
(
const
Col\
lisi\
onObj\
ectSph\
e\
re
*
)
lOll\
l\
OOOOOl\

->
lOll\
OOOll\
O\
l
;
TA_AS\
SERT\

(
lOlllOOOOOl\

->
lOl\
lOO\
OlllO
->
Ge\
t\
Co\
llisionO\
bje\
ctT\
y\
pe
(
)
==
Co\
lli\
sionObj\
ect
::
TYPE_SPHERE
)
;
cons\
t\

Coll\
ision\
Objec\
tSpher\
e
&
ll\
lOll\
O\
llOl
=
*
(
co\
nst
Co\
ll\
isionO\
bje\
ct\
Sp\
he\
re\

*
)
lOlllOOOOOl
->
lOl\
lO\
OO\
l\
l\
lO\

;
cons\
t
float
lOllOlOlOl\

=
0.0001f
;
Vec3
lOOOlllll\
OlO
=
lllOllOllO\
O
.
lllOO\
OOlO\
lO
*
lOl\
l\
Ollllll
;
flo\
at\

ll\
lOl\
llOOlO
=
ll\
l\
Ol\
l\
OllOO
.
lOlOlOOlOOO
+
ll\
lOllOllOl
.
lO\
l\
Ol\
O\
OlOO\
O\

;
Vec3
lO\
OO\
lO\
O\
OOO
=
lO\
OOllll\
lOlO
-
lllO\
llOl\
lOl
.
ll\
lOOO\
O\
l\
OlO
;
float\

lll\
OO\
lOlO\
l\

=
lO\
O\
OlOOOOO
.
GetMa\
g\
nitude\
Sqr\
d
(
)
;
if
(
lllOOlOlOl
<
lllOlllOO\
lO
*
ll\
l\
O\
lll\
OO\
lO
&&
lllOOlOlO\
l\

>
lOl\
l\
OlOlOl
)
{
fl\
o\
a\
t
lOl\
ll\
l\
OO\
ll
=
Sq\
rt
(
lllOO\
lOlOl
)
;
lOOOl\
OOOOO
/=
lOllllOOll\

;
Collisio\
n\

lOllO\
ll\
OlO\
l
;
lOl\
l\
O\
llOl\
Ol
.
In\
itialise
(
Collisi\
on\

::
lOl\
l\
O\
Ol\
lllO\

,
0.0f
,
lllOlllOOlO
-
lOlll\
lO\
Oll
,
(
ll\
l\
O\
llOl\
l\
O\
l
.
lllOOOOlOl\
O
+
lO\
OOll\
lll\
Ol\
O\

)
*
0.5f
,
lOO\
Ol\
OOO\
OO
)
;
ll\
l\
Olll\
O\
llO\

(
lOllOl\
lO\
lOl\

,
lOl\
llOOOO\
O\
l
)
;
return\

;
}
Vec\
3
lO\
O\
O\
llll\
lOl\
l
=
lllOll\
Ol\
lOO
.
lllOOOOlOlO\

*
lOlll\
OOOOO\
O
;
if
(
!
lOl\
l\
l\
O\
O\
OO\
Ol
->
lOl\
l\
O\
lllOOl
)
retur\
n
;
fl\
oa\
t\

llllOl\
OOOl
;
Ve\
c\
3\

lOlllOlOl\
O
;
if
(
Geo\
met\
ry
::
Te\
s\
tPoi\
nt\
M\
o\
vementAg\
ainst\
Sphere\

(
lOO\
OlllllOl\
O
,
lOO\
OlllllOll\

,
lllO\
llOllOl
.
lllOOO\
OlO\
lO\

,
ll\
lO\
ll\
lOO\
l\
O\

,
llllO\
lOO\
Ol
,
lO\
lllOlOlO
,
lOO\
O\
lOOOOO\

)
)
{
Co\
l\
lisio\
n
lOll\
OllOl\
Ol
;
lOllO\
ll\
OlOl
.
In\
iti\
alise
(
Colli\
sion
::
lO\
llOOllllO\

,
ll\
ll\
Ol\
OOO\
l
,
0
,
lOll\
lO\
lOlO
+
(
lO\
OOlOOOOO
*
lllOllO\
ll\
O\
l
.
lOl\
O\
lOOlOOO
)
,
lOOOl\
O\
O\
OO\
O
)
;
lllOll\
lOllO
(
lOllOl\
lOl\
Ol
,
lOll\
lOOOOOl
)
;
retu\
r\
n
;
}
}
void
TA\
C\
_CAL\
L\

llllOOllllO
(
con\
s\
t\

MFr\
ame
&
lO\
llOllllll
,
const
MFrame
&
lOll\
lOOOOOO\

,
lOllOll\
OllO\

*
lOlllOOOO\
Ol
)
{
lllOOllOOOO
(
)
;
TA_ASSERT
(
lOlllOOOOOl\

->
lOllO\
OOllOl
->
GetCollisi\
onO\
b\
jectT\
y\
pe\

(
)
==
Col\
li\
s\
ionO\
bj\
ect\

::
TY\
PE_SPHERE
)
;
co\
nst\

Coll\
isionObjec\
t\
Sphere
&
ll\
lOlll\
lOOO
=
*
(
co\
ns\
t
Co\
ll\
isio\
nO\
bje\
ct\
Sphe\
re
*
)
lO\
lllO\
OOOO\
l
->
lOl\
l\
O\
OOl\
lOl
;
TA_AS\
SER\
T\

(
lO\
lll\
OOOOOl
->
lO\
llOOOl\
llO\

->
GetCo\
lli\
si\
o\
nObjectT\
yp\
e
(
)
==
Coll\
isionOb\
ject
::
TYPE_CACH\
ED_POL\
Y\
_D\
A\
T\
A
)
;
co\
n\
s\
t
Co\
l\
lis\
io\
nOb\
j\
e\
ctCac\
he\
dPolyData\

&
llOlll\
lOlll
=
*
(
const
Co\
lli\
sionObjectC\
a\
chedP\
ol\
y\
D\
a\
t\
a
*
)
lOl\
llO\
OO\
OOl
->
lOll\
O\
O\
O\
ll\
lO
;
Ve\
c3
lOOlO\
l\
O\
ll\
l\

=
lll\
Olll\
lOO\
O
.
lll\
OOO\
OlO\
lO
*
lO\
llOl\
lllll\

;
Ve\
c\
3
lOO\
lOll\
O\
Ol\

=
lllO\
llllOOO\

.
ll\
lOO\
OOlO\
lO\

*
lOlllO\
OO\
OOO
;
fo\
r\

(
int
lllO\
l\
ll\
llOO
=
0
;
lllOll\
lll\
OO
<
llOllll\
Olll
.
ll\
lOlOOlOOO
(
)
;
)
{
con\
st\

Colli\
sion\
O\
bj\
ec\
tCa\
ch\
ed\
Po\
lyDat\
a
::
Poly\
go\
n
*
ll\
OOOl\
OOlO
=
(
co\
nst
Col\
li\
sionObjectCa\
ch\
e\
d\
Po\
ly\
D\
a\
ta
::
Polyg\
o\
n
*
)
llOllll\
Oll\
l
.
lll\
O\
lOOO\
lll
(
lllOl\
lll\
lOO\

)
;
lll\
Olll\
llOO
+=
ll\
Ol\
l\
l\
lOll\
l
.
lllOOlOllll
(
ll\
OOOlOO\
lO\

->
lOl\
lOllO\
ll\

)
;
#define lOlllOlOOll(lOOOllOOOl) llOOOlOOlO->llOllllOOO[lOOOllOOOl].lOOOOlllll
#define lOllllOOOOO(lllOllllOO, lllOlllllOl, llOOOlOOlO, lOOOOlllll, lOOOlOOOOO)							\
{																											\
	Collision lOllOllOlOl;																				\
	lOllOllOlOl.Initialise(																				\
		Collision::lOllOOllllO,																				\
		lllOllllOO,																								\
		lllOlllllOl,																								\
		lOOOOlllll,																							\
		lOOOlOOOOO);																							\
	lOllOllOlOl.lOllOOlOOOO = llOOOlOOlO->llOlllOOllO;																\
	lllOOllOlOl(lOllOllOlOl, lOlllOOOOOl);							\
}
#define lOlllOllOll(lllOllllOO, lllOlllllOl, llOOOlOOlO, lllllllll, lOOOOOOOOO, lOOOOlllll, lOOOlOOOOO, lOllOlOlOOO) \
	lllOlOOOlOO(lllOllllOO, lllOlllllOl, llOOOlOOlO->llOlllOOllO, lllllllll, lOOOOOOOOO, lOOOOlllll, lOOOlOOOOO, lOllOlOlOOO)
#define lOlllOlllll(lllOllllOO, lllOlllllOl, llOOOlOOlO, lOlllOOlll, lllOOlllOOl, lllOOOllOlO, lOOOOlllll, lOOOlOOOOO) \
	lllOOlllOOO(lllOllllOO, lllOlllllOl, llOOOlOOlO, lOlllOOlll, lllOOlllOOl, lllOOOllOlO, lOOOOlllll, lOOOlOOOOO)
#define lOlllOllOOl(lllllllll, lOOOOOOOOO, lOllOlOlOOO) \
	lllOlOOOlOl(lllllllll, lOOOOOOOOO, lOllOlOlOOO)
#define lOlllOllllO(lllOOOllOlO) \
	lllOOlllllO(lllOOOllOlO, lllOOllllll)
#define lOlllOOllll(llOOllllOO) (llOOOlOOlO->lOOOlOOOOO.Dot((llOOllllOO) - llOOOlOOlO->llOllllOOO[0].lOOOOlllll))
co\
nst
boo\
l
lO\
llllOOlll\

=
fal\
se
;
#include "../Physics/zpta004.inl"
#undef lOlllOlOOll
#undef lOllllOOOOO
#undef lOlllOOllll
#undef lOlllOllOll
#undef lOlllOlllll
#undef lOlllOllOOl
#undef lOlllOllllO
}
lllOOllOOOl\

(
lOlllOOOO\
Ol\

)
;
}
void
TAC_CALL
lll\
lO\
Ol\
OllO
(
const
MFr\
ame\

&
lOll\
O\
llllll
,
const
MFrame
&
lOl\
ll\
OOO\
O\
OO
,
lOllOllOllO
*
lOll\
lOOOOOl
)
{
TA\
_AS\
SE\
R\
T\

(
lOl\
llOOOO\
Ol\

->
lO\
llO\
OOllO\
l
->
Ge\
tColl\
ision\
Obje\
c\
tTy\
pe
(
)
==
Co\
llisi\
onOb\
je\
ct
::
TYP\
E\
_SP\
HER\
E\

)
;
TA_\
A\
S\
S\
ER\
T\

(
lO\
ll\
l\
OOOO\
O\
l
->
lOllOOOlllO
->
GetCo\
l\
lisionObj\
ectT\
y\
pe\

(
)
==
Colli\
sio\
n\
O\
b\
j\
ec\
t\

::
TYPE_\
LIN\
E_L\
IST
)
;
const
Collision\
Objec\
tSphe\
re\

&
lllOl\
l\
ll\
OOO
=
*
(
Co\
lli\
sionObjectSph\
e\
re
*
)
lO\
l\
ll\
O\
OOOO\
l
->
lO\
llOOOl\
lO\
l\

;
const\

Col\
lision\
O\
bj\
ectLineList\

&
lllOlllllll
=
*
(
Co\
llisi\
onOb\
je\
c\
tL\
i\
neLis\
t
*
)
lOlllOOO\
O\
Ol
->
lO\
ll\
O\
OOl\
llO\

;
Vec3
lO\
l\
llOO\
ll\
Ol
=
lllOllllOOO
.
lllOOOOl\
OlO\

*
lOllOlllll\
l
;
fo\
r
(
in\
t\

lllO\
OOOOlO
=
0
;
lllOOOOOlO
<
ll\
l\
O\
lllll\
l\
l
.
lll\
l\
OOOO\
O\
Ol
.
lOOO\
ll\
lOO\
l
(
)
;
lllOOOOOlO
++
)
{
float
lll\
lOlOOOl\

;
Vec\
3
lOllllOOOl\

;
Vec3
lOll\
llOOlO
;
if
(
Geo\
met\
ry
::
Tes\
tPoin\
tMovem\
entAga\
ins\
t\
Sphere\

(
lllOlll\
llll\

.
lll\
l\
OOOOOOl
[
lllOO\
OOO\
lO
]
.
lOO\
lOlO\
lll
,
lllOl\
ll\
ll\
ll
.
llllOOO\
OO\
Ol
[
ll\
l\
O\
O\
OOOlO
]
.
lOOl\
O\
llO\
Ol
,
lOl\
llO\
O\
llOl\

,
lllO\
llllOOO\

.
lO\
lO\
l\
OOlO\
O\
O
,
lll\
lOlO\
OOl
,
lOllllOO\
Ol
,
lOllll\
OOl\
O
)
)
{
Collis\
i\
o\
n
lOllOll\
OlO\
l
;
lOll\
O\
llOl\
Ol
.
Init\
ialis\
e\

(
Collision
::
lOll\
OlOOO\
lO
,
0.0f
,
lll\
lOl\
OOOl
,
lOllllO\
O\
Ol
,
lOllllOO\
l\
O
)
;
lOl\
lO\
llOlOl
.
lO\
l\
lOOOl\
lll\

=
lllOOOOOlO\

;
if\

(
!
lOlllOO\
OOO\
l\

->
lOl\
l\
O\
lllOl\
O
)
lO\
ll\
Oll\
OlOl
.
lOll\
OO\
lO\
OOO
=
0
;
el\
se
lOl\
lOllO\
l\
Ol
.
lOllO\
O\
lOOOO
=
1
;
if
(
!
lllOlllO\
llO
(
lOl\
l\
O\
l\
lOlOl
,
lOl\
llOOOO\
Ol
)
)
re\
t\
urn
;
}
}
}
#endif //
}
