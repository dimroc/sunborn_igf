//---------------------------------------------------------------------------------
// File Name: zpta023.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#define TA_PHYSICS_INTERNAL
#define lOllOllOOOO
#ifdef _DEBUG
#endif //
#include "Physics.h"
#ifndef TA_GEOMETRY_H
#include "../Common/Geometry.h"
#endif //
#ifndef lOOllOllll
#include "../Common/zcta001.h"
#endif //
#ifndef lOOlOOlllOl
#include "../Common/zcta010.h"
#endif //
#ifndef TA_RANDFUNC_H
#include "../Common/RandFunc.h"
#endif //
#ifndef lOOOOlOlOl
#include "../Common/zcta006.h"
#endif //
#ifndef TA_STACKALLOC_H
#include "../Common/StackAlloc.h"
#endif //
#ifndef lOllOOOlllOO
#include "../Physics/zpta014.h"
#endif //
#ifndef TA_DYNAMICOBJECT_H
#include "DynamicObject.h"
#endif //
#ifndef lOlOlllOllOl
#include "../Physics/zpta008.h"
#endif //
#ifndef TA_COLLISIONOBJECTCOMBO_H
#include "CollisionObjectCombo.h"
#endif //
#ifndef TA_COLLISIONOBJECTCOMPLEX_H
#include "CollisionObjectComplex.h"
#endif //
#ifndef TA_COLLISIONOBJECTAABBMESH_H
#include "CollisionObjectAABBMesh.h"
#endif //
#ifndef TA_COLLISIONOBJECTCACHEDPOLYDATA_H
#include "CollisionObjectCachedPolyData.h"
#endif //
#ifndef llOllOOOOlO
#include "../Physics/zpta002.h"
#endif //
#ifndef lOOlOOlllOlO
#include "../Physics/zpta005.h"
#endif //
#ifndef llOOlOlOlOl
#include "../Physics/zpta000.h"
#endif //
#ifndef llllOOOOlOO
#endif //
#ifndef lOOllOOOllll
#include "../Physics/zpta011.h"
#endif //
#ifndef TA_PHYSICSJOINT_H
#include "PhysicsJoint.h"
#endif //
#ifndef TA_PHYSICSRENDER_H
#include "PhysicsRender.h"
#endif //
#ifndef llllOOOOlOl
#include "../Physics/zpta010.h"
#endif //
#include <memory.h>
#ifdef lOllOOOlllOl
#include <crtdbg.h>
#endif //
#ifdef TA_ENABLE_PRE_FETCH
#define lOllOOOllllO
#endif //
#ifdef lOllOOOllllO
#include <mm3dnow.h>
#include <xmmintrin.h>
#include <emmintrin.h>
#define lOllOOOlllll(lOllOOlOOOOO) lOllOOlOOOOl((char*)(lOllOOlOOOOO), lOllOOlOOOlO)
#define lOllOOlOOOll(lOllOOlOOOOO) lOllOOlOOOOl((char*)(lOllOOlOOOOO), lOllOOlOOOlO)
#else
#define lOllOOOlllll(lOllOOlOOOOO)
#define lOllOOlOOOll(lOllOOlOOOOO)
#endif //
namesp\
ac\
e
TA\

{
extern
float\

lO\
OlOll\
l\
llOO\

;
#define lOllOOlOOlOO
#define lOllOOlOOlOl	
#define lOllOOlOOllO
lO\
OlOll\
OlOO
(
lOl\
lO\
O\
l\
O\
Oll\
l\

)
;
lO\
Ol\
Ol\
lOlOO
(
lOllOOlOlO\
OO
)
;
lO\
OlOllOl\
OO\

(
lOll\
OO\
lOlOOl\

)
;
lOOlO\
l\
lOlOO
(
lOl\
lO\
OlOlOlO\

)
;
lOO\
lOllOlO\
O
(
lOl\
lO\
OlOlOll
)
;
lOO\
l\
Ol\
lOl\
OO
(
lO\
ll\
OO\
lO\
llOO
)
;
lOOl\
OllOl\
OO
(
lOllO\
OlO\
llOl
)
;
lOO\
lO\
l\
lOlO\
O
(
lOllOOlO\
lllO
)
;
#ifdef lOllOOOlllOl
#define lOllOOlOllll()											\
{																		\
	lOllOOllOOOO lOllOOllOOOl;											\
	lOllOOllOOlO(&lOllOOllOOOl);
#define lOllOOllOOll(lllOOOOlOO)										\
	 lOllOOllOOOO lOllOOllOlOO;											\
	 lOllOOllOOlO(&lOllOOllOlOO);									\
	lOllOOllOOOO lOllOOllOlOl;											\
	_CrtDbgReport(_CRT_WARN, 0, 0, 0, "---------------------------\n");	\
	_CrtDbgReport(_CRT_WARN, 0, 0, 0, lllOOOOlOO);							\
	_CrtDbgReport(_CRT_WARN, 0, 0, 0, "---------------------------\n");	\
	lOllOOllOllO(&lOllOOllOlOl, &lOllOOllOOOl, &lOllOOllOlOO);			\
	lOllOOllOlll(&lOllOOllOlOl);								\
}
#else
#define lOllOOlOllll()
#define lOllOOllOOll(lllOOOOlOO)
#endif
ex\
tern\

voi\
d
lOllO\
l\
OlllO
(
Col\
l\
isi\
on\

*
lOllO\
l\
Ol\
lll
,
Collision\

*
lOO\
OOOOl\
lll
)
;
struct
lOllO\
OlllOOO
{
lO\
llO\
OlllOOO
(
Co\
lli\
sion
&
lO\
l\
lOOll\
lOOl
)
:
ll\
OllllOlO\
l
(
lOl\
l\
OOlllOOl
)
{
}
flo\
at\

lO\
O\
l\
Ol\
lO\
OO\

;
in\
t
lOlOl\
lOOOl
;
Dy\
n\
a\
mi\
c\
O\
bjec\
t
*
lO\
l\
llOOOllO\

;
Vec\
3
lOO\
l\
OlOlll
;
Vec3\

lO\
OO\
lO\
OO\
OO
;
Coll\
i\
sion\

&
llO\
l\
l\
llO\
lOl\

;
}
;
st\
ru\
ct
lO\
llOOlllOlO
{
Phy\
sic\
s
*
lO\
lOl\
lllOO\
OO
;
lOlO\
O\
OOOO\
lOl\

*
lOlO\
OOO\
OlO\
l\
O
;
Dyna\
micObjec\
t
*
lOlOO\
OOOlOll
;
Dy\
nam\
icObject
*
lOlOO\
OOOl\
l\
OO
;
vo\
id\

Initiali\
s\
e
(
Physic\
s
*
lOl\
lO\
Olll\
Oll
)
{
lO\
lOll\
ll\
OOO\
O
=
lOl\
lO\
Olll\
Ol\
l
;
lOlO\
OOOOl\
Oll
=
0
;
lOlOO\
OOOllOO
=
0
;
lOlOOOO\
OlO\
lO
=
0
;
}
}
;
sta\
ti\
c
const\

fl\
o\
a\
t
lO\
l\
lO\
Oll\
ll\
OO\

=
0.6f
;
st\
a\
tic
const\

float
lOll\
OOlll\
lO\
l\

=
0.005f
;
sta\
t\
ic
const\

float
lOll\
O\
OlllllO\

=
0.002f
;
st\
a\
ti\
c\

co\
nst
in\
t
lOllOOlll\
lll
=
4
;
flo\
at
lO\
l\
Olll\
l\
l\
O\
Ol
=
1.0f
;
cons\
t
flo\
at
lO\
ll\
O\
l\
OO\
OO\
OO
=
100000000000.0f
;
Physics
*
Physi\
cs
::
lOl\
lO\
lOO\
OOOl
=
0
;
#ifndef DOXYGEN
static
inli\
ne
float\

lOl\
l\
OlO\
OOOlO\

(
const
Vec3\

&
lOll\
OlOO\
OOll
)
{
return
lO\
ll\
O\
lOOOOll\

.
x
*
lO\
l\
lOlOOOOl\
l\

.
x
+
lOl\
lOlOOO\
O\
ll
.
z
*
lO\
llO\
lO\
OOOll
.
z
;
}
static
inli\
ne\

float
lOl\
lOlO\
O\
O\
lOO
(
flo\
a\
t
lOOll\
lOOl\
lOl
)
{
return
1.0f
-
Ex\
p
(
-
lOO\
lll\
OOllOl
*
3.0f
)
;
}
str\
uct
Phy\
sic\
s
::
lOllO\
l\
O\
OOlOl
{
float
lOOOl\
OO\
llO
;
Collisi\
o\
n
*
llO\
llOlOl\
O\
l\

;
}
;
#endif //
vo\
id
TAC_CA\
LL\

lOllOlO\
O\
OllO
(
co\
ns\
t
AABB
&
lOllO\
lOOO\
lll
,
cons\
t
Ve\
c\
3
&
lO\
ll\
O\
lOO\
lOOO\

,
u32
lOlOllO\
OOl
,
flo\
a\
t
lOl\
lOl\
OOl\
OOl
,
int
lOll\
Ol\
OOlOlO
)
{
TA\

::
Physics\

::
Cr\
eate\
I\
nst\
ance
(
lO\
l\
lO\
l\
OO\
Olll
,
lOl\
lO\
lOOlOOO
,
lOl\
Oll\
OOOl
,
lO\
llOl\
OOlOO\
l
,
lO\
llOlOOlOlO
)
;
}
void
TAC_CALL
lOllOlOOO\
llO
(
)
{
TA\

::
Physi\
cs
::
Cr\
eateIns\
tanc\
e\

(
)
;
}
#ifndef TA_REMOVE_DEPRECATED
vo\
id
TAC_CALL
Ph\
ysi\
cs
::
Cr\
ea\
teInstance
(
const
AA\
B\
B
&
lOllOlO\
OOl\
l\
l\

,
con\
st
Vec3\

&
lOllO\
lOOlO\
OO
,
u32
lO\
l\
O\
l\
lOOO\
l
,
float
lOll\
OlOOl\
O\
Ol
,
int
lOllOl\
O\
OlO\
l\
O
)
{
if\

(
lO\
llOlOOOOOl
)
retur\
n
;
lOOOOOllOOO
(
lOllOlO\
OOOOl
,
Ph\
y\
s\
ics\

)
;
lOl\
lO\
lOOO\
OOl
->
Init\
iali\
se
(
lOl\
l\
OlOO\
Olll
,
lOllOlO\
O\
lO\
OO\

,
lOlOl\
lO\
OO\
l
,
lOll\
O\
lOOl\
OO\
l
,
lOllOlO\
OlO\
lO
)
;
}
#endif //
void\

TAC_CA\
LL
Physics
::
Cre\
ate\
Instance\

(
)
{
if
(
lO\
llOlOOOOO\
l\

)
retur\
n
;
lOOO\
O\
OllO\
O\
O\

(
lOllOlOOOOOl
,
Physics
)
;
lOl\
lOl\
OOOOOl\

->
In\
iti\
a\
li\
se\

(
)
;
}
voi\
d\

TAC\
_CALL\

Physi\
c\
s
::
De\
stroyI\
nst\
an\
ce\

(
)
{
if
(
!
lOllOlOO\
O\
OOl\

)
ret\
urn\

;
lOO\
lOOOOO\
O
(
lOllO\
lO\
OOOOl
,
Physi\
c\
s
)
;
lOll\
OlOOOO\
Ol
=
0
;
}
void
Phy\
sics
::
SetupS\
im\
ulation
(
)
{
if
(
(
lllOlO\
ll\
lO
&
lOllOl\
OO\
l\
Oll
)
==
0
)
re\
tu\
rn
;
TA_ASSE\
RT\

(
lOO\
l\
l\
Ol\
l\
lOl\
O
)
;
ll\
lOl\
Ol\
l\
lO
|=
lOll\
OlOOll\
OO\

;
lll\
OlO\
lllO
&=
~
lO\
llOlOOlOll\

;
if\

(
lOll\
Ol\
OOllOl
)
{
if\

(
lOl\
l\
Ol\
O\
O\
lll\
O
.
lOllOlOOl\
ll\
l
!=
lOl\
lOlOlOOOO\

.
lOllOlOOlll\
l
||
lO\
llOlOOlll\
O
.
lOlOll\
llOlOl
!=
lOllOlOl\
OOOO\

.
lOlO\
l\
lllOlOl
)
{
lOOlOOO\
OO\
O
(
lOllOlOOl\
lOl
,
lO\
l\
lOlO\
l\
O\
OOl
)
;
lOllOlOOllOl
=
0
;
}
}
if
(
lOl\
lO\
lOl\
OOlO
)
{
if
(
lO\
llOl\
OOlllO
.
lOll\
O\
lOlOO\
ll
!=
lOllOlOlOOOO\

.
lOllOlOlOO\
ll
||
lOl\
lOlOO\
l\
llO\

.
lOllOlOO\
O\
ll\
l
.
v3Cent\
er
!=
lOll\
OlO\
O\
lllO
.
lOllOl\
OO\
Ol\
ll
.
v3C\
ent\
er
||
lOllOlOOlll\
O
.
lOll\
OlOOOlll
.
v3E\
xten\
t\

!=
lOllOl\
OOl\
llO
.
lO\
llOlOOO\
lll\

.
v3E\
x\
t\
en\
t\

||
lOl\
l\
Ol\
O\
OlllO
.
lOllOlOlOlOO
!=
lOll\
Ol\
OlOOO\
O
.
lOllO\
lOl\
OlO\
O
||
lO\
llOlO\
Oll\
lO
.
lOll\
Ol\
OlOl\
Ol
!=
lOllOl\
OlOOOO\

.
lOllOlOl\
OlOl
)
{
lO\
ll\
O\
lOlOllO\

lO\
l\
OOlO\
O\
l\
O\

=
lOl\
lOlOlOlll
.
lOlO\
O\
O\
OlOO
(
)
;
for\

(
;
!
lOlOOlOO\
l\
O
.
At\
E\
nd
(
)
;
++
lOlOOlOO\
lO
)
{
Dyna\
micObject
&
lOll\
OlO\
llOOO\

=
*
*
lOl\
O\
OlOOlO
;
lOllOlOlOOl\
O
->
lOOlllll\
l\
l
(
lO\
llOl\
OllOOO
)
;
lOllOlOl\
OOl\
O
->
llOOOOOOlOl
(
lO\
l\
l\
OlOl\
l\
O\
O\
O
)
;
if
(
lOllOlOlO\
OO\
O
.
lOl\
lOlOlOO\
l\
l\

==
SPACIAL_D\
IVISION_\
TYP\
E_\
C\
TREE
)
lOl\
lOlO\
llOOO
.
lOlO\
OOl\
lO\
OOO\

(
)
;
}
lOOlOOO\
OOO\

(
lOllOl\
Ol\
OOlO
,
ll\
OOlOl\
Olll\

)
;
lOll\
Ol\
Ol\
OOlO
=
0
;
}
}
if
(
lOllOlOll\
OOl
)
{
if
(
lOllOlO\
Oll\
lO
.
lOlOll\
llO\
OOl
!=
lOl\
lOlOl\
OO\
OO
.
lOlOllllOOOl
)
{
lOO\
l\
OO\
OOOO
(
lOllO\
lO\
l\
lOOl\

,
lO\
llO\
lOllOlO
)
;
lOllOlOll\
OOl
=
0
;
}
}
if
(
lOllO\
lOl\
l\
Ol\
l
.
lOO\
lOOlOOOl
(
)
)
{
if
(
lO\
llOlOOll\
lO
.
lOlOll\
llOOlO
!=
lOllOlOlOOOO\

.
lO\
lOllllOOl\
O
)
{
lOll\
OlOl\
ll\
O\
O
.
Fi\
n\
alise
(
)
;
lOl\
l\
O\
lO\
l\
lOl\
l
.
Fin\
alise
(
)
;
}
}
lO\
llO\
Ol\
O\
llll
(
)
;
lOllOOlO\
ll\
ll
(
)
;
if\

(
!
lOllOlOOll\
O\
l
)
{
lOOl\
lOlll\
O\
lO\

->
lOlOlll\
l\
OlOO
=
lOllOlOOl\
llO
.
lOl\
lOlOOllll
;
lOOllOlll\
OlO\

->
lOlOll\
l\
l\
O\
lO\
l
=
lO\
llOlOOll\
lO\

.
lO\
lOll\
llOlOl\

;
lO\
O\
OOOllOOO
(
lOllOlOOl\
lO\
l
,
lO\
llOlO\
lOOO\
l
)
;
lOl\
lOlOOllOl\

->
In\
itialise
(
lOO\
llO\
l\
llOl\
O
->
lO\
lOlll\
lO\
lOO
,
lOOll\
OlllOl\
O
->
lOlOlll\
lOlO\
l\

)
;
}
lOllOOl\
l\
OOll
(
"Memory report for matrix solver:\n")
;
lOl\
lOOlOllll
(
)
;
if
(
!
lOllOlOlOOlO
)
{
lllO\
l\
Ol\
ll\
O\

&=
~
(
Physi\
c\
s\

::
FLA\
G_\
X\
Y_\
COLLIS\
ION_GR\
ID
|
Ph\
y\
s\
i\
cs\

::
FLAG_XZ\
_C\
OLLISION_GRID
|
Physics
::
FLAG\
_YZ_COLLI\
SION_G\
RID
)
;
swit\
c\
h\

(
lOll\
OlOOl\
llO\

.
lO\
ll\
OlOlO\
Oll
)
{
ca\
se\

SP\
ACIA\
L_D\
IV\
IS\
ION\
_TYP\
E_XY\
_COLL\
ISION_GRID\

:
case\

SPA\
CIA\
L_\
DI\
VIS\
ION\
_\
TYPE\
_\
XZ_COLLISION_GRID
:
ca\
se
SP\
ACI\
AL_DIVI\
SION_\
TYPE\
_YZ_C\
OLLISI\
ON_\
GRI\
D
:
{
int
llOlO\
lOlO\
ll
=
0
;
int\

llO\
lOlO\
ll\
OO\

=
2
;
switch
(
lO\
ll\
OlOOl\
l\
lO
.
lO\
l\
lO\
lO\
lOOll
)
{
case
SPAC\
I\
AL_DIVISI\
ON\
_TYPE_XY_COL\
L\
ISION_G\
R\
ID
:
llO\
lO\
lO\
lOll\

=
0
;
llOlO\
lO\
l\
lOO
=
1
;
lllOlOlllO\

|=
FLA\
G_XY_C\
OLL\
I\
SION_GRI\
D
;
bre\
ak\

;
case
SPA\
CIAL_DI\
VI\
SI\
ON_\
TYPE_\
XZ_\
C\
OLLIS\
IO\
N_GRID
:
llO\
lOl\
OlOll
=
0
;
ll\
Ol\
Ol\
OllOO
=
2
;
lllO\
lOlllO
|=
FL\
AG\
_XZ_\
COLLI\
SION_GR\
I\
D\

;
bre\
ak\

;
case
SPAC\
IA\
L\
_DIV\
I\
SION_\
TYPE_\
YZ_COLLISION_GRI\
D
:
llOl\
O\
lOlOl\
l
=
1
;
ll\
O\
lOlOllO\
O
=
2
;
ll\
lOl\
Ol\
l\
lO
|=
FLAG_Y\
Z_C\
OLLISI\
ON\
_GRI\
D
;
break
;
}
llOl\
OOl\
ll\
ll
*
lO\
llOlOll\
lOl\

;
lOOOOOllO\
OO
(
lOl\
lOlOl\
ll\
Ol\

,
ll\
OlOO\
ll\
l\
ll
)
;
lOllOlO\
l\
llOl
->
Init\
ialise
(
lO\
llOlOOll\
lO
.
lOllO\
l\
OlO\
l\
OO
,
lOll\
OlOOll\
lO
.
lOl\
lOlOlOlOl
,
lOll\
O\
l\
OOll\
lO
.
lOllOlOOOlll
,
llOlOlOlOll
,
ll\
OlOlO\
l\
l\
OO\

)
;
lOl\
l\
OlO\
lO\
OlO
=
lO\
ll\
Ol\
Ol\
llOl
;
}
br\
eak
;
case
SPAC\
IAL_\
DI\
VIS\
ION_\
T\
Y\
P\
E_DYNAMI\
C_OCTREE
:
{
lOO\
lOOO\
lOlO\
O
*
lOllO\
lOll\
llO
;
lOO\
OO\
OllOO\
O
(
lOllO\
l\
Oll\
llO
,
lO\
O\
lOO\
OlOlOO
)
;
lOllO\
l\
Ollll\
O
->
Initia\
li\
se
(
lO\
l\
lOl\
OOll\
lO\

.
lOl\
l\
OlOl\
OlOO\

,
lOllO\
lO\
O\
l\
llO
.
lOll\
OlOlO\
lO\
l
,
lOll\
OlOOl\
ll\
O
.
lOllOlO\
OOl\
l\
l
)
;
lOll\
OlO\
lOOlO
=
lOl\
l\
O\
l\
O\
llllO
;
}
br\
e\
ak\

;
cas\
e
SP\
ACI\
AL_D\
IVISION_TYPE_CT\
RE\
E
:
{
lOll\
l\
l\
lO\
Oll\

*
lOll\
OlO\
llll\
l
;
lOOOO\
O\
llOOO
(
lOll\
OlOlllll
,
lOll\
ll\
lOOll\

)
;
lO\
ll\
OlOlll\
ll
->
Initialise\

(
lO\
llOlOOlllO
.
lO\
llOlO\
OOll\
l\

.
v3C\
ent\
er\

,
lOllOlOOll\
lO\

.
lOllOl\
OOOlll
.
v3\
Exte\
n\
t
.
GetM\
ax
(
)
*
2
)
;
lOllOlO\
l\
OO\
lO
=
lOllO\
l\
Olllll
;
}
break\

;
def\
ault
:
lllOO\
OlllO
;
}
lO\
llOlOlOllO
lOlO\
O\
lOOlO
=
lOllO\
lOlOlll
.
lO\
lOOOO\
lOO
(
)
;
for
(
;
!
lOlOO\
lO\
Ol\
O\

.
At\
End
(
)
;
++
lO\
lO\
O\
lO\
Ol\
O
)
{
Dyna\
micO\
bject
&
lOllO\
lOllOO\
O
=
*
*
lOlOOlOOlO
;
if\

(
GetSpaci\
alDi\
vis\
ion\
T\
yp\
e
(
)
==
SPACIAL_D\
IVI\
SION_\
TYPE_CT\
REE\

)
lOllOl\
Ol\
lOOO\

.
lO\
l\
OOOlOl\
llO
(
)
;
lO\
ll\
O\
lOlO\
Ol\
O
->
lOlllll\
llOl\

(
lOllOlOllOOO\

)
;
lOllOlOl\
OOl\
O
->
lOlOlOOOOl
(
lO\
l\
l\
Ol\
OllOOO
)
;
}
}
lOl\
l\
OOllOOll
(
"Memory report for spacial division:\n")
;
lOl\
lOOlOllll
(
)
;
if
(
!
lOllO\
lO\
llOll
.
lOOl\
O\
OlOOOl
(
)
)
{
lOOllOlllOl\
O
->
lOlOllllO\
OlO
=
lOllO\
lO\
O\
lllO\

.
lO\
lOl\
ll\
lOOlO
;
lOll\
O\
lOll\
Oll
.
In\
it\
ial\
ise
(
lOOll\
Olll\
OlO
->
lOlOllll\
O\
OlO\

)
;
lOl\
lOl\
OlO\
l\
lO
lOl\
OOlOOlO
=
lO\
l\
lO\
l\
OlOlll\

.
lOlOOO\
OlO\
O
(
)
;
for
(
;
!
lOlOO\
lOOlO\

.
At\
E\
nd
(
)
;
++
lOl\
OO\
l\
OOlO
)
{
Dynami\
cO\
bjec\
t\

&
lOllOlO\
llOOO
=
*
*
lO\
lO\
Ol\
OOl\
O\

;
if
(
lO\
llO\
lOllOOO
.
IsInM\
ovin\
gList
(
)
)
{
Dyn\
amic\
O\
bj\
ect\

*
*
lOllOll\
OOO\
OO\

=
lO\
llOlOl\
lOll
.
Alloc
(
)
;
TA_A\
S\
SERT
(
lOllO\
l\
l\
OO\
O\
O\
O
)
;
*
lOl\
l\
O\
llOOO\
OO
=
&
lOl\
l\
O\
l\
O\
llO\
O\
O\

;
lOl\
l\
OlOlllOO
.
lOOlOOOOl\
OO
(
lOllOl\
l\
OO\
OOO
)
;
lOllOl\
OllOOO\

.
lOlO\
O\
lOOl\
Ol\
O
(
lOllO\
lOl\
llOO
.
lOOlOOlOOO\
O
(
)
)
;
}
else\

{
lOllO\
l\
O\
llO\
OO
.
lO\
lO\
Ol\
O\
O\
lO\
l\
O
(
0
)
;
if
(
lOllO\
ll\
O\
OO\
Ol
)
lOll\
Oll\
OO\
O\
Ol
(
lOllO\
lO\
l\
lOOO\

,
lO\
llOllOOOlO
)
;
}
}
}
lO\
ll\
O\
O\
llOOll
(
"Memory report for others:\n")
;
lOllOOlOlll\
l
(
)
;
if
(
!
lOllOlO\
l\
lOOl
)
{
lOOOOO\
l\
l\
OOO
(
lOllO\
lOllOOl
,
lOllOlOllOlO
)
;
lO\
OllOl\
l\
lOlO
->
lOlOllllOOOl\

=
lO\
llO\
l\
OOlllO
.
lOl\
Olll\
l\
O\
O\
Ol
;
lOOllO\
l\
llOl\
O\

->
lOlO\
l\
lllOOll
=
lOl\
lOl\
OOlllO
.
lOl\
lO\
ll\
OOOl\
l
;
lO\
llOlO\
llO\
Ol\

->
Initi\
al\
ise
(
lOOl\
lOll\
l\
O\
lO
,
lOO\
llO\
lllOlO\

->
lOlOlll\
lOOOl\

)
;
}
lOll\
OOllOOl\
l
(
"Memory report for collision group manager:\n")
;
lOllOOllOOll
(
"Total memory report:\n")
;
lO\
llOl\
O\
l\
O\
OOO
=
lOllOlOOl\
l\
lO\

;
}
void
Ph\
ys\
ics\

::
Upda\
te
(
fl\
oat
lOOlllOOl\
lOl\

)
{
lOllOllOOlOO
++
;
if
(
lOl\
lOllOO\
l\
O\
O
==
0
)
lOllOll\
O\
OlOl\

(
)
;
lOOlOlllOl\
l
(
lOl\
lOOlOlOOO
)
;
if
(
lO\
OlllOOllOl
<=
0.0f
)
re\
turn
;
lOO\
llO\
lllOlO
->
lO\
l\
O\
l\
lllOlll
=
-
1
;
Set\
u\
pS\
imulatio\
n
(
)
;
lOO\
OOOOl\
l\
O
(
lO\
OllO\
lllOlO
,
"Physics::Update: Error, Physics class not initialised")
;
lOO\
ll\
O\
l\
l\
lOlO
->
lOlO\
ll\
l\
lO\
llO
=
lOOll\
lO\
Oll\
Ol
;
lOll\
O\
llOOll\
O\

(
lOOlllOOl\
lOl
)
;
lO\
O\
l\
l\
O\
ll\
l\
O\
l\
O
->
lO\
l\
Ol\
lllOlll\

=
0
;
lOll\
OlO\
ll\
OOl
->
Cle\
ar
(
tr\
ue\

)
;
#ifdef _DEBUG
#endif //
for\

(
int\

lO\
llOllO\
Olll
=
0
;
lO\
llOl\
lOOl\
ll
<
2
;
lOll\
O\
l\
lOOll\
l
++
)
{
lO\
Ol\
lOll\
lOlO
->
lOlOllllOll\
l
=
lO\
l\
l\
O\
ll\
OOlll
;
lOllO\
ll\
O\
l\
OO\
O\

(
lOOll\
lOOllOl
,
lOllOl\
lOO\
lll
)
;
lO\
ll\
OlO\
ll\
Ol\
O
::
Ite\
rat\
or
lOl\
lO\
ll\
OlOOl
=
lOllOlOll\
OO\
l\

->
lOlOOOOlOO
(
)
;
for\

(
;
!
lOllO\
llOl\
OO\
l
.
AtEnd
(
)
;
++
lOllOllO\
lOO\
l\

)
{
lOl\
O\
ll\
lOll\
l\
O
&
lO\
ll\
Oll\
OlOlO
=
(
*
lO\
llOllOlOOl
)
;
bool
lOllOllOlOl\
l
=
lOllOl\
lOl\
OlO\

.
lOll\
OllOllOO
(
)
;
if
(
!
lOll\
OllOlOll
)
{
boo\
l
lOllO\
ll\
O\
llOl
=
fal\
se
;
{
lOll\
Ol\
lO\
ll\
lO
(
lOllO\
l\
l\
OlOl\
O\

)
;
lO\
ll\
OllOl\
l\
ll
(
lO\
Olll\
OOl\
l\
O\
l
,
lOllOllO\
lO\
lO
,
lOllOl\
lOOl\
ll\

)
;
if
(
lOl\
lOlllOOOO\

(
)
)
{
if
(
lOllOl\
ll\
OOO\
l
(
lOllOllOlOl\
O
)
)
{
if
(
lOllOllOOlll
==
0
)
lOl\
lO\
lllOO\
lO
(
lOllO\
l\
lO\
lOl\
O
)
;
else
lOllOllOllOl\

=
tru\
e
;
}
els\
e
{
lOl\
lOllOlOll\

=
tru\
e
;
}
}
else\

{
lOllOl\
lO\
lOl\
l
=
tru\
e
;
}
}
if
(
lOllOll\
OllOl
)
{
int
lOl\
lOl\
l\
lO\
Oll\

=
0
;
int
lOll\
OlllOl\
O\
O
=
lO\
ll\
Oll\
O\
lOl\
O
.
lOllOll\
lO\
lOl
(
)
*
2
+
2
;
int
lOllOlll\
OllO
=
0
;
int
lO\
llOlllOlll
=
lOllOllOl\
OlO\

.
lOl\
lOll\
llOOO
(
)
*
2
+
2
;
lOOl\
ll\
OO\
O\
O\
l
(
Dyn\
am\
icObject
*
,
lO\
ll\
Ol\
lll\
O\
Ol\

,
lOl\
lOlllO\
l\
ll
)
;
lOOll\
lOOOO\
l
(
Co\
l\
l\
isi\
on\

*
,
lOl\
lOlll\
l\
O\
l\
O
,
lOl\
lO\
ll\
lOlO\
O
)
;
lOllOl\
lllOll
(
lOllO\
ll\
OlOlO
,
lOl\
lOllllOOl
,
lO\
llOlllOllO
,
lO\
llOlllO\
l\
ll
,
lOll\
OllllOlO\

,
lOl\
l\
OlllOOll\

,
lOll\
Ol\
llO\
lOO\

)
;
lO\
llO\
l\
llllO\
O\

(
lO\
ll\
Oll\
OlOlO
,
lO\
ll\
O\
l\
ll\
l\
OOl
,
lOll\
OlllO\
l\
lO
,
lOllOllllOlO
,
lO\
ll\
OlllOO\
ll
)
;
lOll\
Olll\
l\
lO\
l\

(
lOOll\
lOOl\
lO\
l
,
lO\
l\
l\
OllOl\
Ol\
O
)
;
}
}
if
(
lOl\
lOllOlOl\
l\

)
{
lO\
ll\
OllOlOlO\

.
lOllOlllll\
lO\

(
true
)
;
if
(
lOllOl\
lOO\
ll\
l
==
0
)
{
int
lO\
l\
lOlllOOll
=
0
;
int
lOllOll\
lOlOO
=
lOllOll\
Ol\
Ol\
O
.
lOllOl\
l\
l\
Ol\
Ol\

(
)
*
2
+
2
;
in\
t\

lOl\
lOlllOllO
=
0
;
int\

lOl\
lOlllOl\
ll
=
lOllO\
llOl\
Ol\
O
.
lO\
ll\
Ollll\
O\
O\
O
(
)
*
2
+
2
;
lOO\
l\
llO\
O\
OOl
(
Dy\
namicObject
*
,
lOllOllllOOl
,
lOl\
lOl\
ll\
Oll\
l
)
;
lO\
Ol\
ll\
OOOO\
l
(
Collisi\
o\
n
*
,
lOl\
l\
OllllOlO
,
lO\
llOl\
ll\
OlO\
O
)
;
lOllOllllOll
(
lO\
llOllOlOlO
,
lOl\
lOl\
lllO\
Ol
,
lOl\
lOl\
llOl\
lO
,
lOll\
O\
lll\
Oll\
l
,
lOllOl\
lll\
Ol\
O
,
lO\
llO\
ll\
lOO\
ll
,
lOll\
OlllOlOO
)
;
lO\
llOlllllll
(
lO\
llOl\
ll\
lOOl
,
lOllO\
ll\
l\
O\
llO
,
lOllOll\
llOlO\

,
lOll\
OlllO\
O\
ll
)
;
lOlllOOOOO\
O\
O
(
lOl\
l\
OllOl\
O\
lO
,
lOllO\
ll\
l\
lOO\
l
,
lOllOl\
llOllO
,
lOll\
O\
llllOl\
O
,
lOllOlllOOll\

)
;
}
else\

{
int\

lO\
lll\
OOOOOOl
=
lO\
llO\
llOlOlO
.
lOllOlllOlOl
(
)
;
lOO\
ll\
lOOOO\
l
(
lOl\
lOlOOOl\
Ol
,
lOlllOOO\
O\
OlO
,
lOlllOOOOOOl\

)
;
lOll\
l\
OO\
O\
OOl\
l
(
lOllOllOlOlO\

,
lOlllOOOOOlO
,
lOll\
lOOOOOO\
l\

)
;
lOOO\
ll\
lllO
<
lOl\
lO\
lOOOl\
O\
l
>
::
lOOO\
ll\
ll\
ll
(
lOlllO\
OOOOlO
,
lOlllOO\
OOO\
Ol
)
;
lO\
l\
llO\
OOOlOO
(
lOll\
lOOO\
OO\
lO
,
lO\
l\
llOOOO\
O\
Ol
,
4
,
GetG\
ra\
vit\
y
(
)
)
;
lOlllO\
OO\
O\
lOl
(
lOlllOO\
OOO\
lO
,
lO\
lllOOOOOO\
l\

,
3
,
Ge\
tGr\
avi\
ty
(
)
)
;
}
if\

(
lOllOll\
O\
Olll
!=
0
)
lOll\
Oll\
lllOl
(
lOO\
lllO\
Oll\
Ol\

,
lOllOllOlOlO
)
;
}
lOlllOOOO\
llO
(
lO\
Oll\
lOOllO\
l
,
lOll\
Oll\
O\
Oll\
l
==
1
,
lOllO\
llO\
l\
OlO
)
;
}
lOlllO\
O\
OOlll
(
lO\
O\
lllOO\
ll\
Ol
,
lOllOllO\
Olll
==
1
)
;
}
lO\
Oll\
Ol\
llO\
l\
O
->
lOlOll\
ll\
Oll\
l\

=
-
1
;
lOlllOOOl\
OOO\

(
)
;
}
void
Physics\

::
Rende\
r
(
)
{
#ifdef lOllOOlOOlOO
lOOlOll\
lOl\
l\

(
lOl\
lO\
Ol\
OOll\
l
)
;
lO\
l\
l\
OlOlO\
llO
lOlO\
O\
lOO\
lO
=
lOll\
OlOlOlll
.
lO\
lO\
OO\
OlOO
(
)
;
for
(
;
!
lOlO\
OlOOlO
.
AtEn\
d
(
)
;
++
lOlO\
O\
lOOlO
)
{
Dynami\
cObj\
e\
ct
&
lOllOl\
Ol\
lOO\
O
=
*
*
lO\
lOOlOOlO\

;
lO\
llOlO\
llOOO\

.
Render\

(
)
;
}
#endif //
}
Physi\
cs
::
Ph\
ysics
(
)
{
lOllOl\
OOll\
Ol
=
0
;
lOOllOll\
lOl\
O\

=
0
;
lO\
llOl\
OlOO\
lO\

=
0
;
lOllOlOllO\
Ol
=
0
;
lOl\
llOOOlOOl
=
0
;
lO\
l\
l\
lOO\
OlOl\
O\

=
0
;
lO\
lllOO\
Ol\
Oll\

=
0
;
lOll\
lOOO\
llOO
=
0
;
lOl\
llO\
OOllO\
l\

.
Clear\

(
)
;
lOlll\
OOOlll\
O
=
0.0f
;
lOl\
llOOOl\
l\
ll
=
0.0f
;
ll\
l\
OlOll\
l\
O
=
0
;
lOl\
llOOlO\
O\
OO
=
0
;
lOlllOOlOOOl
=
0
;
lOlllOOlOOl\
O\

=
0
;
lOlll\
OO\
lOOll\

=
0
;
me\
mse\
t
(
&
lOl\
lOlOOl\
l\
lO
,
0
,
size\
of
(
lOll\
OlOOl\
llO
)
)
;
memset
(
&
lOl\
l\
Ol\
OlOOOO
,
0
,
siz\
eof
(
lOl\
lO\
lOlOOOO
)
)
;
}
Phy\
sics\

::
~
Physi\
cs\

(
)
{
Fi\
nalise\

(
)
;
}
void
Phy\
s\
ics
::
Initiali\
se
(
cons\
t
AAB\
B
&
lOl\
lO\
l\
OO\
Ol\
l\
l\

,
const
Ve\
c3
&
lOll\
OlO\
OlOOO
,
u32
lOlOll\
OOO\
l
,
flo\
at
lOllO\
lOO\
l\
O\
Ol
,
in\
t\

lOll\
OlOOlO\
lO
)
{
Initialise\

(
)
;
SetWorldDi\
m\
e\
ns\
io\
n\
s\

(
lOl\
lO\
l\
OOO\
lll
)
;
SetGravity
(
lOllOlOO\
lOOO
)
;
switc\
h
(
lO\
lOl\
lOOOl
&
FLA\
G_SP\
ACI\
A\
L_DI\
VISION_MA\
SK
)
{
case
FLAG_XY_COLLISION_GRID
:
Se\
tSpacia\
l\
Div\
i\
sionType
(
SPACIAL_\
DI\
VI\
SI\
ON_TY\
PE\
_\
X\
Y_COLLI\
SIO\
N_GR\
ID
)
;
br\
eak
;
case\

FLAG_XZ_\
C\
O\
LLI\
SION_GR\
ID
:
Se\
t\
S\
pa\
cia\
lDivis\
ionT\
y\
pe
(
SP\
ACIAL_\
DIV\
ISIO\
N\
_TYP\
E_XZ_COLL\
ISI\
ON\
_G\
RID
)
;
break
;
case
FLAG_\
YZ\
_\
COLLISI\
ON_GR\
I\
D
:
Set\
Sp\
a\
ci\
alD\
ivisionTy\
p\
e
(
SP\
ACIAL_DIVISION\
_\
TYPE_YZ_\
C\
OLLISION\
_GRID
)
;
br\
eak\

;
ca\
se
FLA\
G_DY\
NAMI\
C_O\
CTRE\
E\

:
Se\
tSpacia\
lD\
i\
vis\
ionT\
ype\

(
SPA\
CI\
AL_DIVISI\
ON_T\
Y\
PE_\
DYNAMIC\
_OCTREE
)
;
break
;
cas\
e
FLAG\
_CTR\
E\
E\

:
Se\
tS\
pacial\
Di\
v\
i\
s\
io\
nTy\
pe
(
SPA\
CIA\
L_DI\
VIS\
ION_TYPE_CT\
REE
)
;
brea\
k
;
default\

:
Se\
tS\
p\
ac\
ialDivi\
s\
io\
nType
(
SPA\
C\
IAL_\
D\
IVISI\
ON\
_T\
YPE_C\
TRE\
E
)
;
break
;
}
Set\
S\
pac\
ialDi\
visionMi\
nSize
(
lOllOl\
OO\
lOOl
)
;
SetSpacia\
lDi\
visionMa\
xM\
e\
mor\
y\

(
lOllOlO\
OlOlO
)
;
Se\
tu\
pS\
im\
ulatio\
n\

(
)
;
}
void
Physics
::
In\
itial\
ise
(
)
{
if
(
lllOlO\
lllO
&
lOlllOOlO\
lOO
)
{
lOOOl\
llO\
lO
(
0
,
"Physics::Initialise. Already initialised.")
;
Fina\
l\
i\
se
(
)
;
}
TA\
_A\
SSERT
(
lllOlOlllO\

==
0
)
;
TA_ASSERT
(
(
lllOlOlllO
&
lO\
ll\
OlOO\
llOO
)
==
0
)
;
lllOlO\
lllO
|=
lO\
lll\
O\
OlOlOO
|
lO\
llOlOO\
lOl\
l
|
lO\
l\
llOOl\
OlOl
;
mem\
se\
t
(
&
lOll\
OlOlOOOO
,
0
,
si\
zeof
(
lO\
ll\
O\
lO\
lOOO\
O
)
)
;
lOllO\
lOOl\
llO
.
lO\
l\
lO\
lOO\
O\
l\
ll
.
v3Ce\
nter
.
Clea\
r
(
)
;
lOl\
lOlOOl\
llO
.
lOl\
lOlO\
OOl\
ll
.
v3Extent\

.
Initialise
(
1000.0f
,
1000.0f
,
1000.0f
)
;
lOll\
O\
lO\
Ol\
llO
.
lOl\
Oll\
llOO\
Ol\

=
4096
;
lOllO\
l\
OOlllO
.
lOlO\
llllOOlO
=
1024
;
lOllO\
lOOlllO
.
lO\
llOl\
OOllll
=
128
;
lOllOl\
OO\
lllO
.
lOlOllll\
OlO\
l
=
129
;
lOllOlOOlllO
.
lOllO\
llO\
OOll
=
lOll\
OlOOll\
l\
O
.
lO\
l\
OllllOOOl
*
2
;
lOll\
OlOO\
l\
llO
.
lOllOlOl\
O\
Oll
=
SPACIAL_D\
IVI\
SION_\
T\
YP\
E\
_\
DYN\
AM\
IC_O\
C\
TREE
;
lO\
l\
lOlOOll\
lO
.
lOl\
lOl\
OlO\
lOO\

=
1.0f
;
lO\
llOlO\
O\
lllO
.
lO\
llOlO\
l\
OlOl
=
0x40000
;
TA\
_ASSER\
T
(
lOOll\
Olll\
OlO
==
0
)
;
lOOO\
OOllOOO\

(
lOOl\
l\
Ol\
l\
lOlO\

,
llllOllOl\
OO
)
;
lOOll\
Ol\
llOlO\

->
lOlOlll\
lO\
O\
OO\

=
this\

;
lO\
Oll\
Oll\
lOlO
->
lOl\
Ol\
l\
llOOOl\

=
0
;
lO\
O\
llOlllOl\
O
->
lO\
lOll\
llO\
OlO
=
0
;
lO\
OllOll\
l\
OlO
->
lOlOll\
llO\
Oll
=
0
;
lOOllOll\
lO\
l\
O
->
lOl\
OllllO\
llO
=
0.0f
;
lOO\
ll\
OlllO\
l\
O
->
lOlOl\
lllOlll\

=
-
1
;
TA_\
A\
SS\
E\
RT
(
lOl\
lOl\
OlOO\
lO\

==
0
)
;
#define lOlllOOlOllO(lOlOOOlllOlO)									\
	lOlllOOlOOOO = &lOlOOOlllOlO::lOlOOOlllOll;									\
	lOlllOOlOOOl = &lOlOOOlllOlO::lOlOOOllllOO;				\
	lOlllOOlOOlO = &lOlOOOlllOlO::lOlOOOlllllO;									\
	lOlllOOlOOll = &lOlOOOlllOlO::lOlOOOllllll;				\
	lOlllOOlOlll = &lOlOOOlllOlO::lOlOOlOOOOOO;
lO\
lll\
OOl\
OllO\

(
lOl\
OOlOOOO\
Ol
)
TA_A\
SSE\
RT\

(
lOllOlOOll\
Ol
==
0
)
;
TA_ASSERT
(
lOl\
lO\
lOl\
lO\
O\
l
==
0
)
;
TA_ASSERT\

(
lOlll\
OOO\
l\
l\
OO
==
0
)
;
lOll\
lOOOllOO
=
Co\
l\
l\
is\
i\
o\
nObje\
ctCa\
c\
h\
edPolyD\
a\
ta
::
Creat\
eN\
ew\

(
)
;
lO\
ll\
lOOOllO\
O
->
Initi\
alise\

(
)
;
SetGr\
a\
vi\
ty
(
Vec3\

(
0.0f
,
-
9.81f
,
0.0f
)
)
;
lOl\
llOO\
llO\
OO
=
0
;
lO\
lllO\
Oll\
O\
Ol
=
0
;
lO\
lll\
O\
Ol\
l\
OlO
=
0
;
lO\
ll\
lOOllOll\

=
0
;
lO\
l\
llOO\
lllOO\

=
0
;
lOl\
l\
lOOl\
llO\
l
=
0
;
lOllOllOOOO\
l
=
0
;
lOl\
lO\
llOOOlO\

=
0
;
lOll\
lOO\
Ollll
=
1.0f
;
lOl\
lO\
llOOlOO
=
0
;
lOlllO\
OllllO
.
Clea\
r\

(
)
;
lOl\
llOOl\
lll\
l
.
Initiali\
se
(
0
,
8
)
;
TA_\
ASSER\
T
(
lO\
lll\
OOO\
lOOl
==
0
)
;
lOlllOOOlOO\
l\

=
Dyna\
micOb\
ject
::
Crea\
teNew
(
)
;
lOlllOO\
Ol\
OOl
->
Initialise\
AsWorl\
dObjec\
t
(
)
;
lOlllOOOlOOl\

->
lOlll\
Ol\
O\
OOOO\

(
tr\
ue
)
;
lOll\
lO\
OOlOO\
l
->
lO\
lOO\
llOOO\
OO
(
lOO\
llOll\
lO\
lO
)
;
TA_ASSE\
RT
(
lOl\
ll\
O\
OOlOlO
==
0
)
;
}
voi\
d
Phy\
s\
ic\
s
::
Finali\
se\

(
)
{
SetupSimulati\
o\
n
(
)
;
if
(
lOlllOOOl\
OOl
)
{
lOlllOO\
Ol\
OOl
->
lOlOOOO\
ll\
Oll
(
)
;
lO\
lllOO\
O\
lOO\
l\

->
lO\
lll\
O\
lOOOOO
(
fal\
se
)
;
lO\
lll\
OOOlOOl
->
lOlOOllO\
OOO\
O
(
0
)
;
lOlllO\
OOlOO\
l
->
Release
(
)
;
lOlll\
O\
OOlOO\
l\

=
0
;
}
lOl\
ll\
OO\
OlOl\
O\

=
0
;
lOlllOOOlOll\

=
0
;
if\

(
lOll\
OlOOllOl
)
{
lOOlOO\
OOO\
O
(
lOllOl\
OOllOl
,
lO\
llOl\
Ol\
O\
OOl
)
;
lOllOlO\
O\
ll\
Ol\

=
0
;
}
if
(
lOllOl\
Oll\
O\
Ol\

)
{
lOOl\
O\
OOO\
OO
(
lO\
ll\
Ol\
OllO\
O\
l
,
lOllOl\
Ol\
l\
OlO
)
;
lOllO\
l\
Oll\
OO\
l
=
0
;
}
lO\
llOlOlO\
ll\
O\

lO\
lOOlOOlO
=
lO\
l\
lOl\
OlOll\
l\

.
lOlOOOOlOO
(
)
;
wh\
il\
e\

(
!
lOlO\
OlOOlO
.
AtEnd
(
)
)
{
Dyna\
m\
icOb\
j\
e\
c\
t
*
lOlllO\
OOllO
=
*
lOlOOlOOlO\

;
++
lOlOOlOO\
lO
;
Re\
m\
oveDynam\
icO\
b\
jec\
t\

(
lOlllOOOllO
)
;
}
lOl\
l\
Ol\
OllOll
.
Finalise
(
)
;
if
(
lOl\
lOlO\
lO\
OlO
)
{
lOOlOO\
OOOO\

(
lO\
llO\
lOlOOlO
,
ll\
OOl\
OlO\
lll
)
;
lOllO\
l\
OlO\
OlO
=
0
;
}
lOl\
llOlOOO\
Ol
lO\
lllO\
lOO\
OlO
=
lO\
ll\
l\
Ol\
O\
OOll
.
lOl\
OOO\
O\
lOO
(
)
;
for
(
;
!
lO\
l\
llO\
l\
OOOlO
.
AtEn\
d
(
)
;
++
lOll\
lOl\
OO\
Ol\
O
)
{
Stat\
icO\
bjec\
t
&
lO\
ll\
l\
O\
l\
OOlOO
=
*
*
lOlllOlOO\
O\
lO
;
lOlll\
OlOOlOO\

.
Rel\
ease
(
)
;
}
lO\
lllOlOOOll
.
Fi\
nali\
s\
e\

(
)
;
if\

(
lOlll\
OO\
OllOO
)
{
lOl\
ll\
OO\
Ol\
lO\
O
->
Relea\
s\
e
(
)
;
lOlll\
OO\
Oll\
OO
=
0
;
}
lOl\
llO\
O\
Oll\
Ol\

.
Clea\
r
(
)
;
lllO\
lOlll\
O
=
0
;
lOll\
lO\
O\
llllO
.
Cle\
ar
(
)
;
lO\
lllOOl\
ll\
l\
l\

.
Finalise
(
)
;
if\

(
lOOllOlll\
Ol\
O
)
{
lOO\
l\
OOOOO\
O\

(
lO\
O\
ll\
Ol\
llOl\
O
,
llllO\
llOlOO
)
;
lOOllOll\
l\
OlO
=
0
;
}
}
void
Phys\
ics
::
lOl\
ll\
OlOOl\
Ol
(
)
{
lll\
O\
lOl\
ll\
O
|=
lO\
llOlO\
OlO\
l\
l
;
}
vo\
i\
d
Ph\
ysi\
cs\

::
AddSt\
ati\
cOb\
je\
ct
(
Stat\
icObject
*
lO\
lllO\
lOOll\
O
)
{
TA_ASSE\
RT\

(
lO\
lll\
OlOOllO
)
;
if
(
lOlllO\
lOO\
l\
lO
->
Ad\
dedTo\
Phys\
ics
(
)
)
re\
turn
;
lOll\
lO\
lOOllO
->
Ad\
dR\
ef\

(
)
;
lOll\
l\
Ol\
OO\
Oll\

.
lOO\
OlllO\
OO
(
lOlllOlOOllO
)
;
lO\
lll\
OlOOl\
lO
->
lOlllOlOOOOO
(
tru\
e
)
;
AddDy\
n\
ami\
c\
Ob\
ject
(
lOl\
l\
lO\
lOOll\
O
->
GetD\
ynami\
cOb\
je\
ct
(
)
,
fa\
lse
)
;
}
void
Physics
::
Rem\
ov\
eSta\
tic\
Obj\
ec\
t
(
St\
at\
icO\
bjec\
t
*
lO\
l\
llO\
lOOl\
lO
)
{
Setu\
p\
Simulatio\
n
(
)
;
TA_\
A\
S\
SERT\

(
lO\
l\
llO\
l\
OO\
llO
)
;
Remove\
D\
yn\
a\
mi\
cObje\
ct
(
lO\
l\
ll\
Ol\
OOll\
O
->
Ge\
tD\
ynami\
cOb\
ject\

(
)
)
;
if
(
!
lO\
l\
l\
lOlOO\
llO
->
AddedToPhys\
ics
(
)
)
return\

;
lOlllOlOOOl\
l
.
lOOOOOlOOll\

(
lOll\
lO\
lOO\
ll\
O
)
;
lO\
ll\
lOlOO\
llO\

->
Rele\
ase
(
)
;
lOlllOlOOl\
lO
->
lOlllOlOOO\
OO\

(
false
)
;
}
int\

Phy\
sics
::
AddS\
u\
rfaceAt\
tr\
ib\
ute
(
Sur\
f\
ac\
eA\
t\
t\
ri\
bute\

*
lOl\
l\
lOlOOl\
ll
)
{
TA_ASSE\
RT\

(
lOlllOlOOl\
l\
l\

)
;
lOlllO\
Olllll
.
lO\
O\
OlllOO\
O
(
*
lOll\
lOl\
OOlll
)
;
return
lOlllO\
O\
l\
lll\
l\

.
lOOOl\
l\
lO\
Ol
(
)
-
1
;
}
in\
t
Ph\
ysi\
cs
::
Ad\
d\
S\
urfa\
ceAttribute
(
)
{
lOl\
llO\
Oll\
lll
.
lOO\
Olll\
OO\
O
(
)
;
retur\
n\

lOlll\
OOl\
llll
.
lOOOl\
ll\
OOl
(
)
-
1
;
}
void
Ph\
y\
sics
::
Remov\
eSurf\
ac\
e\
Att\
r\
ibute\

(
in\
t
lO\
O\
Ol\
OOlll\

)
{
lOl\
l\
lOOll\
ll\
l\

.
lOO\
lllll\
ll
(
lO\
OOlOOl\
ll\

)
;
}
SurfaceAt\
t\
r\
ib\
ute
&
Physics\

::
GetSurfaceAttribut\
e
(
int
lOOOlOO\
lll\

)
{
if
(
lO\
OOlOOlll
<
0
||
lO\
OOlO\
Olll
>=
lOll\
l\
OOlll\
ll
.
lO\
O\
Ol\
llOOl
(
)
)
re\
tu\
rn
lOlll\
O\
OllllO
;
el\
se
return
lOlll\
OOlllll
[
lOOOlOOlll\

]
;
}
in\
t
Ph\
ys\
ic\
s
::
GetNumSurfaceAtt\
ribu\
tes
(
)
{
re\
turn
lO\
lllOOl\
ll\
ll\

.
lOO\
Oll\
lOOl
(
)
;
}
void\

Ph\
ysic\
s
::
SetDefaultSurfac\
eA\
t\
tribute\

(
Su\
rfaceAtt\
ribute\

*
lO\
lllOl\
OOl\
ll
)
{
if\

(
lOlllOl\
OOlll
)
lO\
lllOOl\
lllO
=
*
lO\
lllO\
l\
OOll\
l
;
el\
s\
e\

lO\
ll\
lO\
Ol\
lllO
.
Clear
(
)
;
}
const
Sur\
f\
aceAtt\
ribute\

&
Physics
::
Get\
Defa\
u\
ltSu\
r\
face\
A\
ttrib\
ut\
e
(
)
{
ret\
urn
lO\
l\
l\
lO\
Ollll\
O\

;
}
void
Phys\
ics
::
Ad\
d\
Dynam\
i\
cObje\
ct\

(
Dyn\
amicO\
bje\
ct
*
lO\
l\
ll\
O\
O\
OllO
,
boo\
l
lOlllOl\
O\
lOO\
O\

)
{
SetupSimulati\
on\

(
)
;
TA\
_\
ASSERT
(
lOlllOOOllO
)
;
if\

(
lOlllO\
O\
OllO
->
Ad\
d\
edT\
oPhysics
(
)
)
retur\
n
;
TA_\
ASSERT
(
lOO\
llOlllOlO
)
;
lO\
lll\
OO\
Oll\
O
->
lOl\
OOl\
l\
O\
OOOO\

(
lOO\
ll\
OlllO\
l\
O\

)
;
lOlllO\
OOll\
O\

->
Ad\
d\
Ref\

(
)
;
lO\
llOlOlOll\
l
.
lOOOlllOOO\

(
lOl\
llOOOll\
O\

)
;
if\

(
lO\
l\
l\
lOlOlO\
OO
)
{
lOOll\
lOOlOll
(
lOl\
llOOOllO\

,
SET_M\
OVI\
NG_PRIO\
RIT\
Y\
_HIGH
)
;
}
lOl\
l\
lOO\
Oll\
O
->
lOlllOlO\
O\
OOO
(
tru\
e
)
;
lO\
lllO\
OO\
llO
->
Ca\
l\
cula\
teWorldAABB
(
)
;
if\

(
GetSpacialDivisi\
onTy\
pe\

(
)
==
SPACIA\
L\
_DIV\
ISION_\
T\
Y\
PE_C\
TRE\
E
)
lOll\
l\
O\
OOllO
->
lOlOOOlOlllO
(
)
;
lOllOlO\
lO\
OlO
->
lO\
lll\
l\
lllO\
l
(
*
lOlllOOO\
l\
lO
)
;
lOll\
O\
lOlO\
O\
lO
->
lOl\
O\
lOOOOl
(
*
lOlll\
OOOll\
O
)
;
}
voi\
d
Physics
::
Rem\
ove\
Dyn\
a\
micObje\
ct
(
Dyn\
a\
micObject
*
lO\
lllOOOl\
lO
)
{
if
(
lllO\
l\
Ol\
l\
lO
&
lOl\
ll\
O\
lOl\
OOl
)
{
lOl\
llO\
OO\
l\
l\
O
->
lOl\
OOlll\
lO\
Ol
(
lO\
ll\
lOO\
OlOl\
l
)
;
lOlll\
OOOl\
Ol\
l
=
lOll\
lO\
OO\
llO
;
lOl\
l\
l\
OOOl\
lO
->
lOlO\
O\
lOllOOl
(
true
)
;
lOlllOO\
OllO
->
AddRef\

(
)
;
return
;
}
Set\
u\
pS\
imulation
(
)
;
TA\
_ASSERT
(
lOlll\
OOOl\
lO
)
;
if
(
!
lO\
ll\
lOO\
O\
llO\

->
Ad\
dedT\
oPhysics
(
)
)
re\
turn\

;
TA_A\
SSE\
R\
T
(
lOllOlOlOOlO
)
;
SetDyna\
m\
ic\
ObjectAtR\
est
(
lOll\
l\
O\
OOll\
O
)
;
lO\
ll\
O\
l\
OlO\
OlO
->
lOOl\
lll\
lll
(
*
lOlllOOO\
l\
lO
)
;
lOl\
lO\
lOlOO\
lO
->
llOOOOOOlO\
l
(
*
lOlll\
OOO\
ll\
O\

)
;
if
(
GetSpacia\
l\
Divis\
i\
onT\
ype
(
)
==
SPACIA\
L_DIVISION_\
TY\
PE\
_\
C\
TREE\

)
lOll\
lOOOllO\

->
lOlOOOllOOOO
(
)
;
lO\
llOlO\
lO\
l\
ll
.
lOOO\
O\
OlOO\
ll\

(
lOl\
ll\
O\
OOl\
l\
O\

)
;
TA\
_ASSE\
R\
T
(
lO\
l\
l\
lOOOl\
lO\

->
Is\
InMov\
ing\
Li\
st
(
)
==
0
)
;
lO\
lllOOOllO
->
lOll\
lO\
lOOOO\
O
(
fal\
se
)
;
lO\
lll\
O\
O\
OllO\

->
lO\
OllOl\
l\
l\
OOl
(
)
;
lOll\
l\
O\
OOl\
l\
O
->
lOl\
O\
O\
OO\
ll\
Oll
(
)
;
TA_AS\
SERT
(
lOlllOOO\
l\
l\
O
->
lOlO\
Ol\
Olllll
(
)
)
;
lOlllOOOllO
->
lOlOOll\
OOO\
OO
(
0
)
;
lOlll\
OOOl\
lO
->
Release\

(
)
;
}
void
Physics\

::
Se\
tD\
y\
n\
a\
micO\
b\
j\
e\
ctI\
sMo\
ving
(
Dyna\
micObje\
ct\

*
lOlll\
O\
OOllO\

,
in\
t
lOOlll\
OOlOlO\

)
{
TA_\
AS\
SE\
RT
(
lO\
lllOOOllO
)
;
lOlllOOO\
llO
->
SetToM\
o\
v\
in\
g
(
lO\
Ol\
llOO\
lO\
l\
O
)
;
}
vo\
id
Physics
::
Se\
tDynam\
icOb\
jec\
tAtRest\

(
Dyn\
am\
icObjec\
t
*
lO\
lOO\
O\
OOlOll
)
{
TA_A\
S\
S\
ERT
(
lOl\
O\
OOOOlOll\

)
;
if
(
!
lOl\
O\
OOO\
O\
lOll
->
Ad\
d\
edTo\
Ph\
ysic\
s
(
)
)
retu\
rn
;
if\

(
lOlO\
O\
OOO\
l\
O\
ll
->
IsI\
nMo\
ving\
Lis\
t
(
)
)
{
DynamicOb\
j\
ect
*
*
lOllOl\
l\
OOOOO\

=
(
Dyn\
amicObject
*
*
)
lOlOOOOOl\
Oll\

->
lOlOOlOOl\
ll\
O
(
)
;
TA\
_\
A\
SSERT
(
*
lOllOl\
lOO\
OOO
==
lOl\
OOOOOlOl\
l
)
;
#ifdef _DEBUG
lOlll\
Ol\
OlOlO\

lOlOOl\
OOl\
O\

=
lO\
ll\
O\
lO\
ll\
l\
OO\

.
lOlO\
OO\
OlOO
(
)
;
while
(
!
lO\
lOOlOO\
lO\

.
AtEn\
d\

(
)
)
{
Dy\
n\
ami\
cO\
b\
j\
ect
*
&
lOlOOO\
OOllOO
=
*
lOlOOlOOl\
O
;
if
(
lOlOOO\
OO\
llOO
==
lOl\
O\
O\
OOO\
l\
Oll
)
{
TA\
_A\
SSER\
T\

(
&
*
lOlOOlOOlO
==
lOll\
Ol\
lOOOOO
)
;
br\
eak
;
}
++
lOlOOlO\
OlO
;
}
#endif //
lOl\
OOOO\
OlOll
->
lOOllOlll\
O\
Ol\

(
)
;
lOlO\
O\
OO\
Ol\
Ol\
l
->
Se\
tLi\
nearVeloc\
i\
ty\

(
k_v\
3Ze\
r\
o
)
;
lOl\
OOOOOlOll
->
Se\
tA\
ngula\
rVe\
loc\
ity\

(
k_v3\
Ze\
r\
o
)
;
lOlOO\
OOOlO\
l\
l
->
SetN\
ex\
tFr\
a\
me
(
lO\
lOOO\
O\
OlOll
->
GetFr\
a\
me
(
)
)
;
lOl\
OOO\
OOl\
Oll
->
lOlOOlO\
OlOlO\

(
0
)
;
lOlOO\
OOOlOl\
l
->
Cal\
cul\
ateW\
orldA\
AB\
B
(
)
;
lOl\
lOlOll\
lOO
.
lOOlllllll
(
lOllOllOO\
OO\
O\

)
;
lOl\
l\
OlO\
llOll
.
Fre\
e
(
lO\
ll\
Ol\
lO\
OOOO
)
;
if
(
lOl\
lOllOOOOl
)
lO\
llOll\
OO\
OOl\

(
*
*
lOll\
OllOOO\
OO
,
lO\
llOllOOOl\
O
)
;
}
}
voi\
d
Phy\
s\
ics
::
Test\
Lin\
eF\
o\
r\
Co\
llisio\
n
(
const\

Ve\
c3\

&
lO\
OlOl\
Olll
,
cons\
t\

Vec3
&
lOOOlOOO\
OO
,
flo\
at\

lOOlOl\
l\
OOO
,
Col\
li\
s\
ion
&
llOllllOlO\
l
,
u32\

lO\
lOllOOOl
)
{
lOllOOlllOOO
lOOO\
OO\
lO\
O\
OO
(
llOllllO\
lOl
)
;
ll\
Ol\
lllOlOl
.
Cle\
ar
(
)
;
lOOOOOlO\
O\
O\
O
.
lOO\
l\
OlOlll\

=
lO\
O\
l\
Ol\
Olll\

;
lOOOOOlOOOO
.
lOOO\
lOOOOO
=
lOOOlOO\
OO\
O
;
lOO\
OO\
Ol\
OOOO
.
lOOl\
O\
llO\
OO\

=
lO\
OlOll\
O\
O\
O
;
lOOO\
OOlOOOO
.
llO\
lll\
lO\
lO\
l\

.
lO\
llO\
OlO\
OOl
=
lOOlO\
l\
lO\
O\
O
;
lOOOOOl\
OOOO
.
llO\
ll\
llOl\
Ol\

.
ll\
lOll\
llOO
=
1.0f
;
lO\
OOO\
OlOOOO
.
lO\
l\
OllOOOl
=
lOlOl\
l\
OOOl
;
lOO\
O\
OOl\
OO\
OO
.
llOllllOlO\
l\

.
lOOOOl\
l\
lll
=
lO\
O\
l\
Ol\
Ol\
ll\

+
lOOOlOO\
OOO\

*
lOO\
lOl\
lO\
OO
;
lOOOOO\
lOO\
OO
.
llOl\
lll\
OlO\
l
.
lOO\
OlOOOOO
=
-
lO\
OOlOOOOO\

;
TA_\
AS\
SERT
(
lO\
llOl\
OlOOlO
)
;
lOl\
lOl\
OlOO\
lO
->
llOOOlOllO\
O\

(
lOOl\
OlOlll
,
lO\
OlOl\
Olll
+
lOOOlOOO\
OO\

*
lO\
OlO\
llOOO
,
lOll\
lOlOlO\
ll
,
&
lO\
OOOOl\
OO\
O\
O
)
;
}
void
Physics
::
Tes\
t\
Lin\
eF\
orCol\
lis\
ion
(
const
Vec3
&
lOOlOl\
Oll\
l
,
cons\
t
Vec3
&
lOOlOl\
lOOl\

,
Coll\
is\
io\
n
&
llO\
l\
lllOl\
O\
l\

,
u3\
2
lOlOl\
lOOOl\

)
{
Vec3
lO\
OOlOOOOO\

=
lOO\
lOll\
OO\
l
-
lOOlO\
l\
Olll
;
fl\
oat
lOOlO\
llOOO\

=
lOOOlOOOOO
.
GetMag\
nitude
(
)
;
if
(
lOOl\
O\
ll\
OO\
O
>
k_f\
Mi\
n\
Float
)
lOOOlOO\
OOO
/=
lOOlO\
llOOO
;
else
lOO\
OlOO\
O\
OO
=
k_v\
3UnitY
;
TestLineForColl\
ision
(
lOOlOl\
Olll
,
lOOOlOOO\
OO
,
lOOl\
OllO\
O\
O
,
llOllllOlO\
l
,
lO\
lOllOOOl
)
;
}
Coll\
ision
Physics\

::
Te\
stLi\
n\
eForCol\
li\
sio\
n
(
con\
st\

Vec3\

&
lO\
Ol\
O\
lOlll\

,
con\
st
Vec3
&
lOOO\
lOO\
OOO\

,
flo\
a\
t
lOOlOllOOO
,
u32\

lO\
lOll\
OOOl\

)
{
Co\
ll\
ision
ll\
OllllOlO\
l
;
Te\
stLi\
n\
eForC\
ol\
lis\
ion
(
lOO\
l\
OlOlll
,
lOO\
OlOO\
OO\
O
,
lOOlOl\
lOOO\

,
llOl\
lllOlO\
l\

,
lOl\
OllOO\
Ol
)
;
retu\
r\
n
llOlll\
lOlOl
;
}
Coll\
isi\
on\

Physi\
cs
::
Te\
stLi\
neFor\
Coll\
ision
(
const
Vec\
3\

&
lO\
Ol\
Ol\
Olll
,
co\
nst
Ve\
c3
&
lOOlO\
llOOl
,
u32
lO\
lOl\
lOOO\
l
)
{
Co\
llision\

llO\
l\
lll\
OlOl\

;
TestL\
in\
e\
ForCol\
l\
is\
ion
(
lOOlOlOlll\

,
lO\
Ol\
O\
llOOl
,
ll\
OllllOlOl\

,
lO\
lO\
llO\
O\
O\
l\

)
;
re\
turn
llOll\
llOl\
O\
l
;
}
vo\
id
Physics
::
Fo\
rAll\
In\
tersecting\
Ob\
jects\

(
const
AA\
BB
&
lOO\
O\
OOOlll
,
In\
tersec\
tin\
gObjectCa\
llBack\

llOOOlOOlO\
l
,
vo\
id
*
lOOOOllllO
)
{
if\

(
lO\
Oll\
OlllOlO
->
lO\
lOllllOl\
ll
!=
-
1
)
{
lOOO\
lllOl\
O
(
0
,
"Physics::ForAllIntersectingObjects: Function is ignored when called from TA::Physics::Update")
;
return
;
}
if\

(
!
llOOO\
lOO\
lO\
l
)
ret\
ur\
n
;
Dy\
namicO\
b\
je\
ct
*
ll\
lll\
llOOO\

=
0
;
lOllOlO\
l\
OOl\
O
->
llOOOl\
OOlO\
O
(
lO\
OOOO\
Ol\
ll
,
lOl\
l\
l\
O\
lOll\
OO
,
&
lllllll\
OO\
O\

)
;
wh\
il\
e
(
lll\
llllOO\
O\

)
{
DynamicO\
bjec\
t
*
lOOOOOOllll
=
ll\
lll\
l\
lOO\
O\

->
lOlO\
OllllOlO
(
)
;
llOOOlOOl\
Ol
(
*
lllllllOOO
,
lO\
OOO\
llllO
)
;
lllllllO\
OO
->
Re\
lea\
s\
e
(
)
;
ll\
lll\
llOOO
=
lOOOOOO\
llll
;
}
}
void
Physics
::
Wake\
UpAl\
lI\
n\
t\
ers\
ectingO\
bjects
(
co\
n\
st
AABB\

&
lOOOOOO\
lll
)
{
if\

(
lO\
OllOll\
lO\
lO\

->
lOlOllll\
Olll
!=
-
1
)
{
lO\
OOlllOlO
(
0
,
"Physics::WakeUpAllIntersectingObjects: Function is ignored when called from TA::Physics::Update")
;
re\
tu\
rn
;
}
Dy\
namic\
O\
bj\
ect
*
llllll\
lOOO\

=
0
;
lOl\
lOlOl\
OOlO\

->
llOOOlOO\
lOO
(
lOO\
OO\
O\
Olll\

,
lOlllO\
lOl\
lO\
O
,
&
ll\
lllllOOO
)
;
for
(
;
lll\
l\
lll\
O\
OO
;
lll\
llllOOO
=
ll\
l\
l\
lll\
OOO
->
lOl\
OO\
l\
ll\
lOlO
(
)
)
{
if
(
!
ll\
ll\
lllOOO
->
IsInMov\
i\
ngList
(
)
)
lOOlllO\
OlOll
(
ll\
l\
lll\
lOOO
,
SET_MOVING_P\
RIORI\
TY\
_HIGH
)
;
llllll\
l\
OOO
->
Release
(
)
;
}
}
#ifdef lOOllllOlll
bo\
ol
Phy\
sic\
s
::
lOlll\
Ol\
OllOl
(
Colli\
sionObjectCo\
mbo
*
lO\
lOllOOO\
Ol
,
co\
nst\

MFrame
&
lOl\
l\
lOlOl\
llO
,
co\
n\
st
MF\
rame
&
lO\
OOl\
l\
l\
lO\
lO\

,
Co\
ll\
ision\
Ca\
llBa\
c\
k
lOl\
llOlOllll\

,
u32\

lOlOllOOOl
)
{
lO\
llOOl\
llOOO
lOOOOOlO\
OO\
O
;
ll\
OO\
llOOOOl\

=
1.0f
;
lOO\
OOO\
lOOOO
.
lOO\
lOl\
Ol\
ll
=
lOOlOl\
Olll
;
lOOOOOlOOO\
O\

.
lOO\
O\
lOO\
OOO
=
lOOOlO\
OOO\
O\

;
lOOO\
OOlOOOO
.
lOOlOl\
lOOO
=
lO\
OlOll\
OO\
O
;
lOOOOO\
l\
OOOO
.
llOllll\
OlOl
.
lOll\
OOlOOO\
l
=
lOO\
l\
Ol\
l\
O\
OO
;
lO\
OOOOlOOOO
.
llOllll\
OlOl
.
ll\
l\
OllllOO
=
1.0f
;
lO\
OO\
OOlOOOO
.
lOlOl\
l\
OOO\
l
=
lOlOl\
lOOO\
l
;
lOOOO\
OlOO\
OO
.
llO\
ll\
l\
lOlOl
.
lOO\
O\
O\
l\
llll
=
lOOlOlOlll
+
lO\
OOlOO\
OOO\

*
lOO\
lOllO\
OO
;
lOOOO\
O\
lOOOO
.
llOlll\
lO\
lO\
l\

.
lOOOlOOOO\
O\

=
-
lOOOlOO\
OO\
O
;
if
(
lOlOllOO\
Ol
&
FL\
AG_DYNA\
MIC_OB\
JECTS\

)
{
TA_ASSE\
RT
(
lO\
l\
lOl\
OlOOl\
O\

)
;
lOll\
OlOlOO\
lO\

->
llOOOlO\
llOO
(
lOOlOlOlll
,
lOOlOlO\
lll
+
lO\
OO\
l\
OOOO\
O
*
lOOlOl\
lOO\
O
,
lOl\
llOl\
OlOll
,
&
lO\
OOOOlOOO\
O
)
;
}
if
(
lOlOllO\
OO\
l
&
FLAG_\
STATIC_O\
BJ\
E\
CT\
S\

)
{
lOl\
llOl\
OOOO\
l
lOl\
llOlOOO\
lO
=
lOl\
llOl\
OO\
Oll
.
lO\
lOOOOlOO\

(
)
;
fo\
r
(
;
!
lOlllOl\
OOOlO
.
At\
E\
nd
(
)
;
++
lO\
lllOl\
OOO\
lO\

)
{
lO\
lll\
Ol\
lOOOO
=
&
lOllOlOllOOO
;
lOlllO\
llOOOl\

=
0
;
if
(
lOl\
ll\
Ol\
OOl\
O\
O\

.
lOl\
llOl\
lOO\
lO
(
)
)
{
lOl\
l\
l\
OllOOl\
l
=
&
lO\
lll\
Ol\
O\
Ol\
OO
;
lll\
lOl\
lO\
O\
ll
(
lOOl\
lOl\
llOlO
,
lO\
lO\
ll\
O\
OOOl
,
lOlllO\
lOlllO\

,
lOOOllll\
OlO
,
lO\
l\
llO\
llOl\
O\
O
,
lOlllO\
llO\
l\
Ol\

,
this\

,
lOllOlOllO\
O\
O
.
Get\
Co\
lli\
sion\
User\
Da\
t\
a
(
)
)
;
lO\
l\
llO\
l\
l\
OOll
=
0
;
}
els\
e
{
MFrame
lOlll\
O\
l\
lOl\
lO\

=
lOll\
lOlOlllO\

/
lOlllOlOOlOO\

.
Get\
Frame\

(
)
;
MFra\
me
lO\
lllOllOlll
=
lOOOl\
lllOl\
O
/
lOlll\
O\
lOOlOO
.
Ge\
t\
N\
e\
xt\
F\
rame\

(
)
;
TA_ASSE\
RT
(
lOll\
lO\
llOOll
==
0
)
;
lOlllO\
l\
l\
OOll
=
&
lO\
l\
llO\
lOO\
lOO
;
lll\
lOllOOll
(
lOOl\
lOl\
llOlO
,
lOl\
llOllOOOO
->
GetCol\
lis\
i\
onObjec\
t
(
)
,
lOlllOl\
lOllO
,
lOl\
llOll\
O\
l\
ll
,
lO\
lllOllO\
lOO
,
lOlllOl\
lOlOl
,
this
,
lO\
llO\
lOllO\
OO
.
GetCollisi\
o\
nUs\
e\
rData
(
)
)
;
lOl\
llOllOOll
=
0
;
}
}
}
}
#endif
exter\
n
flo\
at
lOOlOlll\
ll\
ll
;
vo\
i\
d\

Physic\
s
::
SetGravi\
t\
y
(
con\
st
Vec3
&
lOllO\
lOOlOOO
)
{
lOl\
llOO\
O\
llO\
l
=
lO\
llOlOO\
l\
OOO
;
lOlll\
O\
OOlllO
=
lOlllOO\
O\
l\
lOl
.
GetMagn\
it\
u\
de
(
)
;
lO\
Ol\
O\
l\
llll\
l\
l
=
lO\
l\
l\
l\
OOOlllO
*
0.00001f
;
}
void
Physic\
s
::
Se\
tWo\
r\
ld\
Di\
mensio\
n\
s\

(
con\
s\
t
AABB
&
lOllOlO\
OOl\
ll
)
{
lOllOlOO\
lllO
.
lOll\
OlOOOl\
ll
=
lOl\
lOlOOOlll
;
lO\
lll\
OlOOlO\
l
(
)
;
}
const
AA\
B\
B
&
Ph\
ysics
::
GetWo\
rl\
d\
Dim\
en\
si\
ons
(
)
{
ret\
ur\
n
lOllOl\
OOl\
llO
.
lOll\
O\
lOOO\
l\
ll
;
}
void\

Phys\
i\
c\
s\

::
Se\
tMax\
Num\
Collisions
(
in\
t
lOlOll\
llOOOl
)
{
lOllO\
lO\
Ol\
llO
.
lOlOl\
lll\
OOOl
=
lOlOl\
lllOO\
Ol
;
lOlll\
Ol\
OOlOl
(
)
;
}
int
Physi\
cs
::
Ge\
t\
M\
a\
xNum\
Coll\
isio\
n\
s
(
)
{
re\
turn
lOllOlOOl\
llO\

.
lOl\
OllllO\
OOl
;
}
vo\
id
Physics
::
Set\
M\
axN\
umMov\
ingO\
bject\
s
(
int
lOlO\
llll\
OOlO\

)
{
lOllOlOOlllO
.
lO\
lOl\
lllOOl\
O\

=
lOlO\
lll\
lO\
Ol\
O
;
lOlll\
OlOOlOl\

(
)
;
}
int
Physics\

::
GetMaxNu\
mMov\
ingObj\
ect\
s
(
)
{
retur\
n
lOl\
lOlOOll\
lO
.
lOlO\
ll\
llO\
O\
lO\

;
}
voi\
d\

Physi\
cs
::
SetSlow\
S\
o\
l\
v\
erM\
axNu\
mC\
oll\
isi\
o\
ns
(
in\
t
lOllOl\
OOl\
lll
)
{
lOllO\
l\
OOlllO\

.
lOl\
lOlOOl\
lll
=
lOll\
OlOOllll\

;
lOll\
lO\
lOOlO\
l
(
)
;
}
in\
t
Phys\
i\
c\
s
::
GetS\
lowSo\
lv\
er\
M\
a\
xNum\
Collisions\

(
)
{
retu\
rn\

lO\
l\
l\
OlO\
Olll\
O
.
lOllOlOOl\
l\
ll\

;
}
void
Ph\
ysics
::
SetSl\
owSolverMa\
x\
NumObject\
s
(
int\

lO\
lO\
llll\
OlOl
)
{
lOll\
O\
lOOl\
l\
lO
.
lO\
lO\
llllOlO\
l
=
lOl\
Ollll\
Ol\
Ol
;
lOl\
llOlO\
OlOl
(
)
;
}
int
Physic\
s
::
Ge\
tSlowS\
o\
lv\
erM\
axNumO\
bje\
cts\

(
)
{
return
lOl\
lOlO\
Ol\
llO
.
lOlOllllOlOl
;
}
void
Ph\
ysi\
cs
::
SetMa\
xNum\
Ob\
j\
e\
ctPairs
(
int
lO\
l\
lOl\
lOOOll
)
{
lOllOlOOlllO
.
lOllO\
l\
l\
OO\
Ol\
l
=
lOllOllO\
O\
Ol\
l
;
lO\
lllO\
lOOl\
Ol
(
)
;
}
int
Phys\
ic\
s\

::
GetMa\
xNumObje\
ctPairs\

(
)
{
return
lOll\
Ol\
OOl\
llO
.
lOll\
O\
l\
lOO\
Ol\
l
;
}
void
Physi\
c\
s
::
Set\
Spac\
i\
alDivis\
io\
nTy\
pe
(
Spac\
ialDivi\
si\
on\
Typ\
e
lOllOlO\
lO\
Oll
)
{
lOll\
O\
l\
OOlllO
.
lOl\
l\
OlOlOOll
=
lOllO\
lOlOO\
ll
;
lOlllOlOO\
lOl
(
)
;
}
Phy\
si\
c\
s\

::
Sp\
acialDivi\
si\
onType
Phys\
i\
cs
::
Ge\
t\
Spacia\
l\
DivisionTy\
p\
e
(
)
{
return
lOllOl\
OOll\
lO
.
lOllOlOlOOll
;
}
void\

Ph\
ysics
::
SetSp\
a\
cia\
lDivi\
s\
io\
nM\
i\
nSize
(
float
lOllOlOlOlOO\

)
{
lOll\
OlOOll\
l\
O\

.
lOllO\
lOlO\
lOO
=
lOll\
O\
lOlO\
lOO
;
lOlllO\
lOO\
lO\
l\

(
)
;
}
float\

Ph\
ysics
::
Ge\
t\
SpacialDivisi\
onMinSize\

(
)
{
ret\
ur\
n
lOllOlOOl\
l\
l\
O
.
lO\
ll\
OlOl\
Ol\
OO
;
}
vo\
id
Physic\
s
::
Se\
tSpacialDiv\
is\
ionM\
axMem\
or\
y
(
in\
t
lOl\
lO\
lOlO\
l\
Ol
)
{
lO\
ll\
OlOOlllO
.
lO\
llOlOlOlO\
l\

=
lOllOlOlOlOl
;
lOlllOlO\
OlOl
(
)
;
}
in\
t
Physics\

::
Get\
Spaci\
alDi\
v\
is\
ionMaxMe\
mory\

(
)
{
return
lOllOl\
OO\
lllO
.
lO\
ll\
O\
lOlO\
l\
Ol\

;
}
void
Ph\
ys\
ics
::
lOOl\
l\
lOOOO\
OO
(
Dy\
na\
micO\
bject
*
lOl\
l\
lOOOllO\

)
{
TA\
_A\
SSE\
RT
(
lOlllOOOllO
)
;
if
(
lOlll\
OOOll\
O
->
Adde\
dToPh\
y\
si\
cs
(
)
)
{
TA_ASS\
ERT
(
lOll\
O\
lOlO\
Ol\
O
)
;
lOllOlOlO\
O\
lO
->
lOOll\
lll\
l\
l
(
*
lOlllO\
O\
OllO
)
;
lOl\
l\
OlO\
lO\
OlO
->
lOlO\
lOOOOl
(
*
lOlll\
O\
O\
O\
llO
)
;
}
}
voi\
d
Physi\
cs
::
lOllOllOOl\
l\
O
(
fl\
o\
at\

lOOlllOOllO\
l
)
{
flo\
at\

lOlOOO\
lOllOO
=
1.0f
;
fl\
oa\
t
lOlOOOl\
OllOl
=
1.0f
-
Exp
(
-
lOOlllO\
Oll\
Ol
*
40.0f
)
;
lOlll\
Ol\
OlOlO\

lOlOOlOOlO
=
lOll\
OlOl\
l\
lO\
O
.
lO\
lOOO\
O\
l\
OO
(
)
;
whi\
le
(
!
lOlOOlOOlO\

.
AtE\
nd\

(
)
)
{
DynamicO\
b\
ject
*
&
lO\
lllOOO\
llO\

=
*
lOlO\
OlOO\
lO\

;
++
lO\
lOOl\
OOl\
O
;
if
(
lOl\
llOOOll\
O
->
lOlOOO\
Olllll
(
)
||
!
lO\
llOl\
O\
OlllO\

.
lOllOl\
OOO\
l\
ll
.
Inter\
s\
ects
(
lOll\
l\
O\
OO\
llO\

->
Ge\
t\
Wor\
l\
dAABB
(
)
.
v3\
Cent\
er
)
)
{
lOlllOO\
OllO
->
SetLi\
n\
ea\
rVe\
locity
(
k_v3Zero
)
;
lOl\
llOOO\
llO\

->
Se\
t\
Ang\
u\
lar\
Vel\
ocit\
y
(
k_v3\
Z\
ero\

)
;
lOl\
l\
lOOOll\
O
->
SetNe\
xtF\
ra\
me
(
lOll\
lO\
OOl\
l\
O\

->
Ge\
t\
F\
rame\

(
)
)
;
lOlllO\
OOll\
O
->
lOlOOl\
OOl\
Ol\
O
(
0
)
;
lOllO\
lOlllO\
O
.
lO\
Oll\
lllll
(
&
lOll\
l\
OOOllO
)
;
lO\
l\
lOlOll\
Ol\
l\

.
Free
(
&
lOlll\
OOOl\
l\
O\

)
;
lOl\
ll\
OOOllO\

->
lOl\
OO\
ll\
l\
Olll\

(
0.0f
)
;
lOlllOOOl\
lO
->
Calcu\
lateW\
or\
ldAA\
BB
(
)
;
if\

(
lOllO\
llOOOOl
)
lOllOl\
lO\
OOOl
(
*
lO\
lll\
OOOllO
,
lOllO\
l\
lOO\
OlO
)
;
lO\
lllOO\
Ol\
lO
->
lOlO\
OO\
lOOOll
(
)
;
}
el\
s\
e
{
lOlll\
OOO\
llO\

->
lO\
l\
OOOlOlOll
(
lOlOOOlOllOO
,
lO\
l\
O\
OO\
l\
O\
l\
lO\
l
)
;
if
(
!
lOlllO\
OO\
l\
lO
->
Updat\
eDisabled
(
)
)
lO\
lllOO\
Oll\
O
->
Update\

(
lOOlllOOllOl\

)
;
lOlllO\
OOllO
->
lOlOOllOlll\
l
(
0.0f
)
;
lOlllOO\
O\
llO\

->
lO\
lOOO\
lO\
OOll\

(
)
;
}
lOlllOOOllO\

->
lOOllO\
lllO\
Ol\

(
)
;
}
}
void
Phy\
sics\

::
lOllOllOlOO\
O
(
flo\
a\
t\

lOOl\
l\
lO\
Ol\
l\
Ol
,
int
lO\
llO\
llOOlll\

)
{
lO\
OlOlllOl\
l
(
lOl\
lOOlOlOOl
)
;
lOll\
lOl\
OlOlO
lOlllOl\
l\
lOOO
;
if
(
lO\
llOl\
lOO\
l\
ll
==
0
&&
(
ll\
l\
OlOlll\
O
&
(
Phys\
ics
::
FLAG_X\
Y_COL\
L\
I\
SI\
ON_\
GR\
ID\

|
Physi\
cs
::
FLAG_XZ_\
CO\
L\
LISION\
_G\
RID
|
Phys\
ic\
s
::
FL\
A\
G\
_YZ_\
COLLISI\
ON_G\
R\
ID
)
)
)
{
in\
t
lO\
l\
ll\
OlllOOl\

;
in\
t
lOlllOll\
lOlO\

;
if
(
lll\
OlOl\
llO
&
Phys\
ics
::
FLA\
G_\
X\
Y_CO\
LLISIO\
N_GRID
)
{
lOlllO\
l\
llO\
Ol
=
0
;
lOl\
ll\
O\
lll\
OlO
=
1
;
}
el\
se\

if
(
lllOlO\
l\
llO
&
Ph\
y\
sics
::
FLAG_\
XY\
_C\
OLLISION_G\
R\
ID\

)
{
lOlllOl\
llOO\
l
=
0
;
lOlll\
OlllOlO\

=
2
;
}
els\
e\

{
TA_ASSE\
RT
(
lllOlOlll\
O
&
Phy\
sics\

::
FLAG_YZ\
_\
C\
OLLI\
SION_GR\
ID
)
;
lOll\
l\
Oll\
lOO\
l
=
1
;
lO\
lllOll\
lOlO\

=
2
;
}
lOO\
l\
Ol\
l\
Olll\

(
lOll\
OOl\
Ol\
lO\
O
)
;
lOlOll\
lOO\
O\

<
DynamicObject
*
>
::
lOO\
lOO\
O\
l\
l\
l\
l
lOlllOlllO\
ll\

;
lOl\
llOl\
ll\
OO\
O
=
lOll\
Ol\
O\
lll\
OO
.
lOlOOOOlOO\

(
)
;
if
(
!
lOlllOlllOOO
.
AtEnd\

(
)
)
{
DynamicObject
*
&
lOl\
l\
lOllllO\
O
=
*
lOlllOl\
l\
l\
OOO
;
++
lOlllOlllO\
O\
O
;
lOl\
lOlO\
lllOO\

.
lO\
O\
llll\
ll\
l
(
&
lO\
lllOl\
ll\
lOO
)
;
lOl\
llOll\
lOll
.
lO\
l\
OlOOO\
Ol\

(
&
lOlllOll\
llOO
)
;
while
(
!
lOl\
l\
lOl\
llOOO
.
At\
End\

(
)
)
{
Dyna\
micO\
bj\
ect
*
&
lOll\
l\
OOO\
llO\

=
*
lOl\
l\
lOlllOOO
;
++
lO\
lllOlllOOO
;
lOll\
lO\
lOlOlO
lOll\
l\
OllllOl
=
lOll\
l\
O\
lllOll
.
lO\
lOO\
O\
O\
lOO
(
)
;
lO\
l\
l\
lOlOlO\
lO
lOlll\
Ol\
llllO
;
flo\
at
lO\
lllOll\
ll\
ll
=
lOll\
lO\
OOllO
->
GetW\
orl\
dAABB\

(
)
.
v3Exte\
nt
[
lO\
l\
ll\
Olll\
OOl
]
;
float\

lOllllOOO\
OOO
=
lOll\
lO\
OOll\
O
->
GetWorld\
A\
ABB\

(
)
.
v3Extent
[
lOlllOlll\
OlO
]
;
float
lOllllOOOOOl
=
FastMax
(
lOl\
llOlllll\
l
,
lOllllOOO\
OOO
)
;
fl\
oa\
t
lOll\
llOO\
OO\
lO
=
(
*
lOlll\
Ol\
ll\
l\
Ol
)
->
GetWor\
ld\
AAB\
B
(
)
.
v3\
E\
x\
t\
ent
[
lOlllOll\
l\
OOl
]
;
float\

lOllll\
O\
OO\
Oll\

=
(
*
lOl\
llOl\
lllOl
)
->
GetW\
o\
r\
ldAABB
(
)
.
v3Extent
[
lOll\
lO\
ll\
lO\
lO
]
;
if
(
lOllllOOOO\
Ol
>=
Fa\
stMax\

(
lOll\
llOOO\
O\
l\
O\

,
lOllllOOOOll
)
)
{
lOll\
OlO\
lllOO
.
lOO\
l\
llllll
(
&
lOlllOOO\
llO
)
;
lOl\
llOl\
l\
l\
Oll
.
lO\
lOl\
OO\
OOl
(
&
lOll\
lOOO\
llO
)
;
}
el\
s\
e\

{
lOlllOlllllO
=
lOl\
llOll\
ll\
O\
l
;
++
lOll\
lOll\
llOl
;
for\

(
;
!
lO\
lll\
Ollll\
Ol
.
AtEnd\

(
)
;
++
lOlllOllllOl\

)
{
lO\
lll\
lOO\
OOlO
=
(
*
lO\
l\
ll\
OllllOl\

)
->
Get\
W\
o\
rldAABB
(
)
.
v3Extent
[
lOlllOlllO\
O\
l
]
;
lOlll\
l\
OOOOll
=
(
*
lOlllOl\
lll\
Ol
)
->
GetW\
orld\
A\
ABB\

(
)
.
v3Extent
[
lOlll\
Olll\
OlO
]
;
if
(
lOl\
ll\
lOOOO\
Ol
>=
FastMax
(
lO\
l\
lllO\
OO\
OlO\

,
lOl\
lllOO\
OOll\

)
)
break\

;
lOll\
lOl\
lll\
lO
=
lOlllOllllOl
;
}
lOll\
OlOl\
llOO
.
lOOll\
ll\
ll\
l
(
&
lO\
ll\
l\
O\
OOl\
lO\

)
;
TA_ASSE\
R\
T
(
!
lOlllO\
lll\
llO\

.
AtEnd
(
)
)
;
lOlllOlllOll
.
lOO\
lO\
OOOOOl
(
&
lO\
lllO\
OO\
l\
lO
,
lOll\
lOlllllO
)
;
}
}
}
lO\
llOlOlllOO\

.
llOllOlOl\
O
(
lO\
lll\
Olll\
Oll
)
;
#ifdef _DEBUG
lOll\
l\
O\
ll\
lOOO
=
lOllOlO\
lll\
O\
O
.
lO\
l\
O\
O\
OOlOO
(
)
;
float
lOll\
llO\
OOl\
OO
=
k_\
fM\
a\
xF\
l\
oat
;
for
(
;
!
lOlll\
OlllOO\
O
.
AtEn\
d
(
)
;
++
lO\
l\
ll\
OlllO\
OO\

)
{
Dynam\
ic\
Ob\
j\
e\
ct\

&
lOl\
l\
O\
l\
O\
l\
lOOO
=
*
*
lOlll\
Ol\
l\
l\
OOO
;
fl\
oat\

ll\
O\
lOll\
OOO\
O
=
FastMax
(
lOllO\
l\
O\
llOO\
O
.
GetWor\
ldA\
ABB
(
)
.
v3Exte\
nt\

[
lOll\
lOl\
llO\
Ol
]
,
lOl\
lOlOllOOO
.
Get\
Wo\
rld\
AABB
(
)
.
v3Ex\
tent
[
lO\
lllOll\
l\
Ol\
O
]
)
;
TA\
_AS\
S\
ERT
(
llOl\
O\
llOOOO
<=
lOl\
lllO\
OOl\
OO
)
;
lOl\
lllOOO\
lOO
=
llOlOllOOOO
;
}
#endif //
lOO\
l\
Oll\
l\
OO\
l
(
lOl\
lO\
O\
lOllOO\

)
;
}
DynamicO\
b\
ject
*
lOllll\
OOOlOl
=
0
;
if
(
lOllOllOOl\
ll
==
0
)
{
lOll\
lOlll\
OOO
=
lOl\
l\
O\
l\
Ol\
l\
lO\
O
.
lOl\
OO\
OOlOO
(
)
;
for\

(
;
!
lOlllOl\
llO\
OO
.
AtE\
nd
(
)
;
)
{
Dynami\
cObject
*
&
lOll\
lOOOl\
lO
=
*
lOlllOlllO\
OO
;
++
lO\
ll\
lOlllO\
OO\

;
if
(
!
lOlllO\
OOllO
->
lOlOOOO\
ll\
llO
(
)
&&
!
lOlllOO\
Ol\
lO
->
Collisio\
nDisa\
bl\
ed
(
)
)
{
lOlllOO\
OllO\

->
Ca\
l\
cu\
lat\
eW\
o\
r\
ldAABB
(
)
;
lOlllOOOllO\

->
lOlOO\
llllOO\
l
(
lOll\
llOO\
Ol\
O\
l
)
;
lOllllOOOlOl\

=
lO\
l\
llOOOllO
;
lO\
l\
ll\
OO\
O\
l\
l\
O
->
lOlO\
O\
lO\
llOOl\

(
true\

)
;
}
el\
s\
e
{
}
lOlllO\
OO\
llO
->
lOlOO\
llOlOlO
(
lOllOllOOlOO\

)
;
}
TA_ASSERT
(
lOlll\
OOOlOlO\

==
0
)
;
lOlllOOO\
l\
O\
l\
O
=
0
;
}
else
{
TA\
_ASSERT
(
lOl\
l\
lOOO\
lOl\
O
==
0
)
;
lOl\
lOlOllO\
lO\

::
Ite\
rato\
r\

lO\
llOllOlOOl\

=
lOllOlOllOOl\

->
lO\
l\
O\
OOOlOO\

(
)
;
for
(
;
!
lOl\
lO\
llO\
lOO\
l
.
At\
End\

(
)
;
++
lOll\
OllO\
lOOl\

)
{
lO\
lOlllOlllO
&
lOllOllOlO\
lO\

=
*
lOll\
Oll\
OlOOl
;
lOl\
Olll\
O\
lll\
O
::
lOllll\
O\
OOl\
l\
O
lOlll\
lOO\
Ol\
ll
=
lOl\
lOllO\
lOlO
.
lOl\
l\
l\
lOO\
l\
OO\
O
(
)
;
for\

(
;
!
lOllll\
OO\
Oll\
l\

.
AtEn\
d
(
)
;
++
lOllllOOO\
l\
ll
)
{
lO\
lOOOOOOlOl
&
lO\
l\
O\
OOO\
llO\
lO\

=
*
lO\
l\
ll\
l\
OOO\
lll\

;
lOlll\
lOO\
lO\
Ol
(
lOlOO\
OOllOlO
)
;
}
}
lO\
llllOOOlOl
=
lOlll\
O\
O\
OlOl\
O
;
lOll\
lOOOlOlO\

=
0
;
}
TA_\
A\
SSER\
T
(
lOll\
lOOOlOlO
==
0
)
;
lllO\
lOlllO
|=
lOllllOOlOlO
;
for
(
int\

lO\
l\
l\
llOO\
lOll
=
0
;
lOl\
l\
llOO\
Ol\
Ol
;
lO\
ll\
ll\
O\
O\
l\
Ol\
l\

++
)
{
TA_\
A\
SS\
ERT
(
lOlllO\
OOlO\
l\
O
==
0
)
;
{
lOO\
l\
OllOlll
(
lO\
llOO\
lOlOll
)
;
Dyna\
m\
icO\
b\
j\
e\
ct
*
lOllll\
O\
O\
l\
lOO
=
0
;
Dynam\
ic\
Obj\
ect
*
lOOOOOOllll
=
0
;
for\

(
Dy\
na\
mic\
Ob\
je\
c\
t\

*
lOl\
lllOOll\
Ol\

=
lOlll\
lO\
OOlOl
;
lOllllOOllO\
l
;
lOllll\
OO\
llOl\

=
lOOOO\
OOllll\

)
{
lO\
OO\
OOOll\
ll
=
lOllllO\
OllOl\

->
lOlOOllllO\
lO
(
)
;
Dy\
n\
a\
mic\
Obje\
ct
&
lOl\
lOl\
OllO\
OO
=
*
lOlll\
lO\
OllOl
;
TA\
_ASSERT\

(
lO\
llOlOll\
OOO
.
lO\
OlO\
O\
O\
lOll\

(
)
)
;
if
(
!
lOllOlOllOOO\

.
Is\
I\
nM\
ovin\
g\
List
(
)
)
{
if
(
(
lllOlOlllO
&
lOl\
llOOlO\
lOl\

)
==
0
)
{
lOOl\
l\
l\
O\
OlOl\
l
(
lOlll\
lOOllO\
l
)
;
}
el\
s\
e
{
if\

(
lOll\
l\
lO\
OllOl\

->
lOl\
O\
Ol\
ll\
OllO
(
)
>
lOllllOOll\
Ol\

->
Get\
Mass
(
)
&&
lOllO\
lOll\
OOl
->
lOl\
lllOOl\
ll\
O
(
)
*
200
<
lOOllO\
lllOlO\

->
lOlO\
llllOOO\
l
*
100
)
{
lOO\
l\
llO\
O\
lOl\
l
(
lOllllOOl\
l\
O\
l\

)
;
if
(
lOlll\
l\
O\
O\
ll\
O\
l
->
IsInMovi\
ngL\
ist
(
)
)
{
float
lllOllllO\
O
=
0.75f
-
(
lOllllO\
OllOl
->
lOlO\
OlllO\
ll\
O
(
)
-
lOl\
l\
llOOl\
lOl
->
GetMass\

(
)
)
*
lOl\
l\
llOOllOl
->
Ge\
tI\
nvers\
eM\
ass\

(
)
;
if
(
lllO\
l\
lllOO
>
0.0f
)
{
lOll\
ll\
OOllOl
->
lOlOOl\
OO\
O\
l\
OO\

(
lllOll\
llOO
*
lO\
llOOllllOO
)
;
}
if
(
!
lOllllOOllOl
->
UpdateD\
i\
sa\
bled
(
)
)
lOl\
lll\
OOllO\
l\

->
Upd\
a\
te
(
lO\
OlllOO\
llO\
l
)
;
}
el\
s\
e
{
lO\
llllOOllO\
l
->
lO\
lO\
Oll\
l\
Oll\
l\

(
0.0f
)
;
}
}
}
}
if
(
lO\
ll\
OlOl\
lOOO\

.
IsInMo\
vi\
ng\
L\
ist
(
)
)
{
lOllO\
lO\
lOOl\
O
->
lOOll\
ll\
l\
ll
(
lOllOlOl\
l\
OOO\

)
;
lOl\
l\
ll\
OOllOl\

->
lOlOOl\
l\
ll\
O\
O\
l
(
lOllll\
OOl\
lOO
)
;
lOlll\
lOOllO\
O\

=
lOllll\
O\
O\
ll\
Ol\

;
}
el\
s\
e
{
lOll\
OlOllO\
OO
.
lO\
l\
OOl\
OllOOl
(
fa\
ls\
e
)
;
}
}
lO\
llllOO\
OlOl
=
lOll\
ll\
O\
OllOO
;
if
(
lOllllO\
OOlOl
==
0
)
break
;
for\

(
Dy\
nam\
icObjec\
t\

*
lOl\
lllOOllOl
=
lOll\
llO\
OOlOl
;
lOllllOOllOl
;
lO\
ll\
ll\
OOllOl
=
lOll\
ll\
O\
O\
llO\
l
->
lOlO\
Oll\
llOl\
O
(
)
)
{
Dy\
na\
m\
ic\
Object
&
lOllOlOl\
lO\
OO
=
*
lOllllOO\
llO\
l
;
TA_AS\
SE\
RT
(
lOllO\
lO\
l\
lOOO
.
lOOlOO\
OlOll
(
)
)
;
TA_ASSE\
R\
T
(
!
lOll\
OlOllO\
OO
.
Co\
ll\
isionDis\
abled\

(
)
)
;
#ifdef _DEBUG
AABB
lOOOOOOll\
l
;
lOO\
OOOOll\
l
.
Initial\
i\
s\
e\

(
lOllOlO\
l\
lOO\
O
.
GetCollisionObjec\
t
(
)
.
GetAA\
BB
(
)
.
v3Ce\
nte\
r
*
lO\
l\
l\
Ol\
O\
ll\
OOO
.
GetFr\
a\
me\

(
)
,
Ve\
c3\

(
0.001f
,
0.001f
,
0.001f
)
)
;
TA\
_ASS\
ERT
(
lOl\
l\
Ol\
Oll\
OOO
.
Get\
W\
or\
ldA\
AB\
B
(
)
.
Intersec\
ts\

(
lOO\
OOOOlll\

)
)
;
#endif //
static\

in\
t
lOllll\
OO\
llll
=
0
;
lOllllOO\
llll
++
;
lOllOlOll\
OOO
.
lOl\
OO\
OOl\
Ol\
lO
(
lOllll\
OO\
llll
)
;
lO\
llO\
lO\
l\
lOOO\

.
lO\
lOOOO\
lOl\
OO
(
lOllllOOllll
)
;
lO\
l\
lO\
l\
OllOOO
.
lOlOOOOl\
O\
lll
(
lOl\
lllO\
Ol\
ll\
l
)
;
lOll\
OOlllOlO
lOllllO\
l\
OO\
OO
;
lOllllOlOOO\
O
.
Init\
i\
a\
l\
ise
(
thi\
s
)
;
lOllllO\
l\
OOO\
O
.
lOlOOOOOlOll
=
&
lOll\
Ol\
O\
llOOO
;
lO\
llO\
l\
Ol\
OOlO
->
llOOO\
lOO\
lOO
(
lOl\
l\
Ol\
OllOO\
O
.
Get\
W\
orld\
A\
ABB
(
)
,
lO\
ll\
ll\
OlOO\
Ol
,
&
lO\
l\
lllO\
lOOOO
)
;
lOll\
Ol\
O\
lOOlO
->
lO\
lOlOOO\
O\
l\

(
lOl\
lOlOll\
OOO
)
;
}
}
TA_ASSERT
(
lOl\
llOO\
OlOl\
O
==
0
)
;
{
lOlO\
OO\
OOOlOl
*
lOlOOO\
OOlOlO
=
lOllOlOl\
l\
O\
Ol
->
lO\
ll\
ll\
OlOOl\
O
(
)
;
for
(
;
lOlOO\
OOOlOl\
O
;
lOlOO\
O\
OOlOlO
=
lOll\
OlOll\
OO\
l
->
lO\
lll\
l\
Ol\
OOl\
O\

(
)
)
{
lOlll\
lOOlOOl\

(
*
lOlO\
OOO\
OlOl\
O
)
;
}
}
for
(
DynamicObject
*
lOl\
lllO\
Oll\
O\
l
=
lO\
llll\
OOOlOl
;
lOl\
lllOO\
llOl
;
lOl\
lll\
OO\
ll\
O\
l
=
lOllll\
O\
OllOl
->
lOlOOlll\
lOlO\

(
)
)
{
Dyn\
ami\
cO\
b\
ject
&
lOllOlOllOO\
O
=
*
lOllllOOl\
lO\
l\

;
TA_\
AS\
SE\
RT
(
lO\
ll\
Ol\
O\
llOOO\

.
lOOlO\
OO\
l\
Oll\

(
)
)
;
lOllllOl\
OO\
ll
(
lOllOlOllO\
O\
O
)
;
lOl\
lOlOl\
lOOO\

.
lOl\
OOlOllOOl
(
false
)
;
}
lOll\
llOOO\
lOl\

=
0
;
lOlO\
OOOOOlOl
*
lO\
lOOO\
O\
O\
lO\
l\
O
=
lOl\
lO\
lO\
llOO\
l\

->
lOllll\
OlOO\
lO
(
)
;
for
(
;
lO\
lO\
OO\
OOlOl\
O
;
lOlOOO\
OOlOlO\

=
lO\
l\
lO\
l\
O\
llOOl
->
lOll\
llOl\
OOlO\

(
)
)
{
}
lOllllOO\
OlOl
=
lOlll\
O\
O\
OlO\
lO
;
lOl\
l\
lOOOlOlO
=
0
;
}
{
lO\
lO\
O\
OOOOlOl
*
lOlOOOO\
Ol\
OlO
=
lOllO\
lOl\
l\
OOl
->
lO\
llllO\
lOOl\
O
(
)
;
for
(
;
lOlOOOOOlO\
l\
O
;
lO\
lOO\
OOOlOlO\

=
lOllOlOllOOl
->
lOllllO\
lO\
OlO
(
)
)
{
}
}
lllO\
lOlllO\

&=
~
lO\
l\
l\
llO\
OlOl\
O
;
TA_\
ASS\
ERT\

(
lOl\
lOlOll\
O\
Ol
->
lO\
l\
lll\
Ol\
O\
lOO
(
)
==
0
)
;
lOlllOlll\
OOO
=
lO\
llOl\
OlllOO
.
lOlOOOOl\
OO
(
)
;
wh\
il\
e
(
!
lO\
lllO\
l\
llO\
OO
.
AtEnd
(
)
)
{
Dyna\
mi\
cObject
*
&
lOlll\
OO\
O\
llO
=
*
lOlllO\
ll\
lOOO\

;
++
lOll\
lOlllO\
OO
;
if
(
lOll\
lOOOllO
->
lOlOOOOll\
lll
(
)
)
{
lOlllO\
OO\
llO
->
SetLin\
ear\
Velocity
(
k_v\
3\
Zero\

)
;
lO\
ll\
l\
OOOl\
l\
O
->
Set\
A\
n\
g\
ula\
rVe\
lo\
cit\
y
(
k_\
v3Z\
ero
)
;
lOll\
l\
OOOllO
->
Set\
Next\
F\
rame\

(
lOl\
ll\
OOOllO
->
Ge\
tF\
rame
(
)
)
;
TA_\
ASSERT
(
lOlllOOOll\
O
->
IsI\
nM\
ov\
ingList\

(
)
)
;
lO\
lllOO\
O\
l\
lO\

->
lO\
l\
OO\
lOOlO\
lO\

(
0
)
;
lOllO\
lO\
l\
llOO
.
lO\
O\
lll\
l\
ll\
l
(
&
lOlllOOO\
ll\
O
)
;
lOllOlOl\
l\
Ol\
l
.
Fr\
ee
(
&
lOlllOO\
Oll\
O
)
;
lOlllOOO\
l\
lO
->
lOlOOlllOlll
(
0.0f
)
;
lOl\
llOOOllO
->
Ca\
lc\
ulateWorldA\
ABB
(
)
;
if\

(
lOl\
lOl\
lOOOOl
)
lOllOll\
O\
O\
OO\
l
(
*
lO\
lll\
O\
OOll\
O\

,
lO\
llOll\
OOOlO
)
;
}
}
TA_A\
S\
SERT
(
lOll\
O\
lOl\
lOOl
->
lOll\
llOlOlO\
O
(
)
==
0
)
;
lO\
llO\
lOl\
lO\
Ol\

->
lO\
l\
lllOlO\
lO\
l
(
)
;
TA\
_ASSERT\

(
lOl\
l\
Ol\
O\
l\
lO\
Ol
->
lO\
llllOlOl\
OO
(
)
==
0
)
;
lO\
llOlOl\
lO\
lO
::
Ite\
r\
ator
lOllOllOlOOl\

=
lOllOlOllO\
Ol
->
lO\
lO\
O\
OOlO\
O\

(
)
;
for\

(
;
!
lOllOllOl\
OOl\

.
AtEnd
(
)
;
++
lOll\
Ol\
lOlOOl\

)
{
lOl\
OlllOlll\
O
&
lO\
llOll\
OlOlO\

=
*
lO\
llOll\
Ol\
O\
O\
l
;
lO\
ll\
O\
llOlOl\
O
.
lOllllOlOllO
(
fals\
e\

,
lOll\
OllOO\
lll
)
;
}
lOOlOll\
lOOl
(
lOllOOlO\
lO\
ll
)
;
}
void
Physics
::
lO\
llll\
OlOO\
l\
l
(
Dy\
na\
m\
icObject
&
lOlll\
lOl\
Olll\

)
{
Dy\
n\
am\
icObject
::
Joi\
ntIterator\

lOlOOlO\
Ol\
O\

=
lOl\
lll\
O\
l\
Olll
.
GetJo\
in\
tIt\
erat\
o\
r\

(
)
;
for
(
;
!
lOlOO\
lOO\
lO
.
AtEnd
(
)
;
++
lOl\
O\
O\
lOOlO
)
{
Physi\
csJoi\
nt
&
lO\
O\
lll\
llO\
OO\
O
=
*
lOlO\
OlOOlO\

;
if
(
lOOlllllOO\
OO
.
lOllllOllOO\
O\

(
)
!=
lO\
llO\
l\
lOO\
lO\
O
)
lO\
ll\
llOllOOl
(
lOO\
ll\
lll\
O\
OOO\

)
;
}
List
<
Physics\
Join\
t
*
>
::
It\
er\
a\
tor
lOl\
l\
l\
l\
OllOlO
=
lOl\
lll\
Ol\
Oll\
l
.
lO\
lOOllO\
OllO
(
)
;
for\

(
;
!
lO\
l\
lllOl\
lOlO
.
AtEnd
(
)
;
++
lO\
ll\
llOl\
l\
O\
lO
)
{
Physics\
Joint
&
lOO\
ll\
l\
ll\
OOOO\

=
*
*
lOlll\
lOllOlO\

;
if\

(
lO\
OlllllO\
OO\
O
.
lOllllOll\
OO\
O\

(
)
!=
lO\
llOll\
OOlOO\

)
lOl\
lllOllO\
Ol
(
lO\
O\
llll\
lO\
O\
OO
)
;
}
}
void\

Physics\

::
lO\
l\
lll\
Ol\
lOO\
l
(
PhysicsJoin\
t
&
lOOl\
lll\
lOOOO\

)
{
lO\
OlllllO\
O\
OO
.
lOllllOl\
l\
Oll
(
lOllOllOO\
lOO
)
;
PhysicsJ\
oi\
nt
*
lO\
lllOOlOOO\

=
&
lOOl\
lll\
lOOOO\

;
if
(
lOO\
lllllO\
OOO
.
IsBroke\
n
(
)
)
return
;
Dyn\
a\
micO\
bject\

*
lOlOOOO\
Ol\
Oll
=
lOO\
lll\
llOO\
OO\

.
GetObjec\
tA\

(
)
;
Dynam\
icO\
bje\
ct
*
lOlOOOOOllOO
=
lOO\
llll\
l\
OOOO
.
GetOb\
jec\
tB
(
)
;
TA_ASSE\
R\
T\

(
lO\
l\
OOOO\
Ol\
Oll
)
;
if
(
lOlOOOOOllOO
)
{
if\

(
!
lOlOO\
OOOllO\
O
->
Added\
T\
oP\
hysics
(
)
)
retur\
n
;
}
else\

{
lOl\
OO\
OOOllOO\

=
lOlllOOOl\
OOl
;
}
TA\
_ASS\
ERT\

(
lO\
lO\
OOOOl\
lOO\

)
;
lO\
l\
OOOOOOlOl\

*
lOl\
OOOOO\
lOlO
=
lO\
lO\
OOO\
Ol\
Oll
->
lOlOOOO\
OOllO\

(
lOl\
OO\
OOO\
l\
lO\
O
,
true
)
;
if
(
!
lO\
l\
OOOO\
OlOlO
)
re\
turn\

;
float
lO\
OllO\
O\
OOO\
Ol\

=
Min
(
lOlOOOOOlOll
->
lOO\
l\
l\
O\
OOOOlO\

(
)
,
lO\
lOO\
O\
OO\
llOO\

->
lOO\
l\
lOOOOOlO
(
)
)
;
lOllO\
Ol\
llO\
lO\

lOlll\
lOlO\
OOO
;
lOlll\
lOlOOOO\

.
In\
iti\
alise\

(
th\
is
)
;
lOl\
lllOlOOO\
O\

.
lO\
l\
OO\
OOOlO\
l\
l\

=
lOlO\
OO\
OOlOll\

;
lO\
llllOlOOO\
O\

.
lOl\
OOOO\
Ol\
lOO\

=
lO\
lO\
OOOOllO\
O
;
lOllllOlO\
OOO
.
lOl\
OO\
OOOlOlO\

=
lOlOOOO\
Ol\
OlO
;
int
lOl\
lll\
Ol\
llOO\

=
0
;
if
(
lOOlll\
ll\
O\
O\
O\
O
.
IsObj\
ec\
tA\
Solid\

(
)
)
lOl\
l\
llOl\
l\
l\
OO
|=
Collision
::
FLAG_\
OBJECT\
A_\
SOL\
ID
;
else
if\

(
lOO\
lll\
ll\
O\
OOO
.
IsO\
bje\
ct\
BSol\
i\
d
(
)
)
lOllllOlllOO
|=
Co\
l\
lisi\
on
::
FLAG_\
OBJ\
ECT\
B_SO\
LI\
D
;
TA_ASS\
ER\
T
(
lOl\
OOO\
OOl\
Oll\

)
;
if
(
lOOl\
lll\
lOOOO\

.
GetT\
ype
(
)
==
Physi\
csJoint
::
TY\
PE_\
LINEAR_SLI\
DER
)
{
Vec3
llll\
O\
OOOOl\

=
lOOlll\
llOOO\
O
.
GetPos\
OnObje\
ctA
(
)
*
lOlO\
O\
O\
OOlOll
->
GetFr\
ame
(
)
;
Vec\
3\

lO\
lll\
lOl\
llOl
=
lO\
Olll\
llOOOO
.
Get\
Sli\
de\
rPos0
(
)
*
lOlOOOOOllOO
->
GetF\
r\
am\
e\

(
)
;
Vec3\

lOllllOl\
lllO
=
lOOllll\
lOOO\
O
.
GetSli\
de\
rP\
o\
s1
(
)
*
lOlO\
OOOO\
llOO
->
Get\
Fram\
e
(
)
;
Vec3
lOllllOlllll\

=
lOOll\
lllOO\
OO
.
Ge\
tPo\
sO\
nObje\
c\
tA
(
)
*
lOl\
O\
O\
OOOl\
Oll\

->
GetNex\
tF\
r\
ame
(
)
;
Ve\
c3\

lO\
ll\
l\
llOOO\
OO
=
lOOlll\
llOOO\
O
.
GetSliderPos\
0
(
)
*
lOl\
OOOOO\
llOO
->
GetNex\
tFram\
e
(
)
;
Vec3
lOlll\
llO\
OOO\
l
=
lOOll\
ll\
l\
OOOO
.
GetSliderPo\
s1
(
)
*
lOlO\
OOOO\
ll\
OO\

->
Get\
Next\
F\
rame
(
)
;
con\
s\
t
Ve\
c3
lO\
lll\
OllOl\
O
=
ll\
ll\
OOO\
OOl\

;
Ve\
c3
lOOOl\
OO\
OOO
=
lOlll\
lOllll\
O
-
lO\
llllO\
l\
llO\
l
;
TA\
_ASSERT\

(
lOOO\
lOOOO\
O
.
GetMagnit\
ud\
e
(
)
>
0.0f
)
;
lOO\
O\
lO\
OOOO\

.
Normali\
se
(
)
;
flo\
at\

lOl\
OllOOlO
=
lOOO\
l\
OOOOO
.
Dot
(
lO\
ll\
lOl\
l\
OlO\

-
lOllllOlllO\
l
)
;
floa\
t
lO\
lOll\
OOll\

=
lO\
O\
OlO\
OOOO
.
Dot
(
lOll\
lO\
llOlO
-
lO\
ll\
llOlll\
lO
)
;
fl\
oat
lllOll\
ll\
O\
O
=
lOlOllO\
OlO
/
(
lOlOllOO\
l\
O
-
lOlO\
llOOll\

)
;
Vec3
llOlOO\
llOOl\

=
lOl\
ll\
lOl\
l\
lO\
l
+
lOOOlOOO\
OO
*
ll\
lOll\
l\
lOO
;
Mat33
lOOOOOO\
Oll
;
Vec3
lO\
lOOOOOOll\

=
llOlOOllOOl
-
lOlll\
Ol\
lOl\
O\

;
if
(
lOlOO\
O\
OOO\
ll
.
Cros\
s
(
lOOO\
lO\
OOO\
O
)
.
Ge\
tMagnit\
udeSqrd\

(
)
>
0.0001f
)
lOOOOOOOl\
l\

.
SetTo\
LookAt
(
lOO\
OlOOOO\
O
,
lOlO\
O\
OOOOl\
l
.
GetNor\
mal
(
)
)
;
el\
se\

lOOO\
OOO\
Oll
.
Se\
tToLo\
okDo\
wnVect\
or\

(
lOOOlOOOO\
O
)
;
Co\
l\
lis\
ion
lOlllllOO\
O\
lO\

;
Collisi\
on
lOlllllO\
O\
O\
ll\

;
Co\
lli\
sion\

lOlllllOOlOO
;
lOll\
ll\
lO\
O\
OlO
.
In\
iti\
alise
(
Collis\
ion
::
lOllOOl\
ll\
l\
l
,
0.0f
,
(
llOlO\
OllOOl
-
lO\
lllOllOl\
O
)
.
Do\
t\

(
lOOOOOOOll
.
v3X
)
,
lOll\
lOll\
OlO
,
lOOOO\
OO\
Oll
.
v3X
,
lO\
lll\
OOl\
OOO
)
;
lOll\
lllOO\
OlO
.
lOlO\
llOOOl
|=
lOlll\
lOl\
l\
lOO
;
lOlllllOOOll
.
In\
it\
i\
alise\

(
Col\
lision
::
lOllO\
Olllll\

,
0.0f
,
(
ll\
O\
lOO\
ll\
OOl
-
lOlllOllOl\
O
)
.
Dot
(
lOOOOOOO\
l\
l
.
v3Y
)
,
lOll\
l\
O\
l\
lOlO\

,
lOOOOOO\
Oll
.
v3Y
,
lOll\
lOOlOOO
)
;
lO\
l\
llll\
OOO\
l\
l
.
lOlO\
llOOOl
|=
lOlll\
lOl\
llOO
;
lOl\
llllOOOlO\

.
lOll\
OlOO\
lOl
(
&
lOll\
lll\
OOO\
ll
)
;
if
(
lllOllllO\
O
<
0.0f
)
{
lOllll\
lO\
OlO\
O
.
In\
itialise
(
Co\
llisi\
on
::
lOllOl\
OOOOO
,
0.0f
,
-
lllOllll\
O\
O
,
lOll\
lO\
llOlO
,
lOO\
OOOOOll
.
v3Z
,
lOl\
llOO\
lOOO
)
;
lOl\
l\
ll\
lOOlOO
.
lOlO\
llOOOl
|=
lOlll\
l\
Oll\
lO\
O
;
lOl\
l\
lllOO\
l\
Ol
(
lOllll\
lOOl\
OO
,
&
lOll\
llOlO\
OOO
)
;
}
else
if
(
ll\
lOll\
llO\
O
>
1.0f
)
{
lOl\
llllOO\
lOO\

.
Init\
i\
alise
(
Col\
l\
i\
s\
io\
n\

::
lOll\
O\
lOOOO\
O
,
0.0f
,
lllOll\
llO\
O
-
1
,
lO\
lll\
OllO\
l\
O
,
-
lO\
OO\
OO\
O\
O\
ll
.
v3Z
,
lOl\
llOOlOOO\

)
;
lO\
ll\
ll\
l\
OOlOO\

.
lOl\
OllOO\
Ol
|=
lOl\
l\
llOlll\
O\
O
;
lO\
l\
llllO\
O\
lOl
(
lOlll\
llO\
OlO\
O\

,
&
lOllllOlOO\
OO
)
;
}
else\

{
Vec3
lOlllllOO\
l\
lO
=
lOlll\
llOOOOl
-
lO\
ll\
ll\
lOOOOO
;
TA_\
ASSERT\

(
lO\
l\
llllO\
Oll\
O
.
Ge\
tMa\
gn\
itude
(
)
>
0.0f
)
;
lO\
ll\
lllO\
O\
llO
.
Nor\
ma\
lise
(
)
;
fl\
oat
lOll\
l\
l\
l\
OOll\
l
=
lOllll\
lO\
Oll\
O
.
Dot\

(
lOlll\
lOllll\
l
-
lOlllllOOOOO
)
;
fl\
oat
lOl\
llllOl\
OO\
O
=
lO\
lllllOOll\
O
.
Dot\

(
lOll\
ll\
Ol\
ll\
ll
-
lO\
lllllOOOOl
)
;
float
lOlllll\
O\
lOO\
l
=
lO\
ll\
l\
llOOlll\

/
(
lOlllllOOlll\

-
lO\
l\
lll\
l\
OlO\
O\
O
)
;
Vec3
lOll\
lllOlOl\
O
=
lOlll\
llOOOO\
O
+
lOl\
l\
lllOOl\
lO
*
lOlllllOlO\
Ol
;
if
(
lO\
lllllOlOO\
l\

<
0.0f
)
{
lO\
llll\
lOOl\
OO
.
Initialise
(
Coll\
isi\
o\
n
::
lOll\
O\
lOOOO\
O
,
lll\
O\
l\
l\
l\
lOO
/
(
lllOlll\
lOO\

-
lOl\
llllOlOOl\

)
,
0
,
lOl\
llOllO\
l\
O
,
lO\
OOOOO\
Oll
.
v3Z
,
lOlllOO\
lOOO
)
;
lOll\
l\
ll\
OO\
lOO
.
lOlOllOO\
Ol
|=
lOll\
llOlllOO
;
lOlllllOO\
lOl\

(
lOll\
lllO\
O\
lOO
,
&
lOlll\
lOl\
OOO\
O
)
;
}
else
if\

(
lOl\
llllO\
lO\
O\
l
>
1.0f
)
{
lO\
llll\
lOOlOO
.
In\
i\
t\
ialise\

(
Coll\
ision\

::
lOl\
lOlOOOOO
,
(
1.0f
-
lllOllll\
OO
)
/
(
lO\
llll\
l\
OlOOl
-
lllOl\
lllOO
)
,
0.0f
,
lOll\
lOllOlO
,
-
lOOOOOOO\
ll\

.
v3\
Z
,
lO\
lllOOlOOO
)
;
lOlllllOO\
lOO
.
lO\
l\
OllOOOl
|=
lOl\
lll\
O\
lllOO
;
lO\
lll\
llOO\
lOl\

(
lO\
ll\
l\
l\
lOOlO\
O
,
&
lOllllOlOOO\
O
)
;
}
}
lOll\
l\
llOOlOl
(
lOl\
lll\
lOOOlO\

,
&
lO\
lll\
lOlOO\
OO
)
;
}
el\
s\
e
{
Vec3\

lll\
l\
OOOO\
Ol
=
lOO\
lllll\
OOOO
.
Ge\
tP\
osOnOb\
jec\
tA\

(
)
*
lOlOOOO\
Ol\
Oll\

->
GetFram\
e
(
)
;
Vec3
llll\
OOOOlO
;
if
(
lOOlllllOO\
O\
O
.
GetTy\
pe
(
)
==
Ph\
ys\
icsJoint
::
TY\
PE_V\
ECTO\
R_\
CONSTRA\
I\
N\
T
)
llllOOO\
OlO\

=
ll\
llOO\
OOOl\

;
els\
e
llllOOOO\
lO
=
lO\
Ollll\
l\
OOOO\

.
GetP\
osOnObjectB\

(
)
*
lOlO\
OOOOllO\
O\

->
GetFra\
me\

(
)
;
Vec3
lO\
lllOllOl\
O
=
lll\
lO\
OOOOl
;
Co\
llis\
ion\

lOl\
llllOOOlO
;
Col\
lisi\
on
lOl\
l\
ll\
lOOOll
;
Collision
lOl\
l\
ll\
lOOlOO
;
Col\
li\
s\
io\
n\

*
lO\
l\
llllO\
lO\
ll
;
Mat33
lOll\
lllOllOO
;
lOlll\
ll\
Oll\
OO
.
SetToIdent\
it\
y
(
)
;
lOll\
ll\
lOOOlO
.
Initialise
(
Co\
llision\

::
lO\
llOOlllll\

,
0.0f
,
(
lll\
l\
OOO\
OlO\

-
lll\
lOO\
O\
O\
Ol
)
.
Do\
t\

(
lOlllllOl\
lOO
.
v3X
)
,
lOlllOllOl\
O
,
lOll\
lllOllOO
.
v3X
,
lOl\
l\
l\
OOl\
O\
OO
)
;
lOlll\
llO\
OO\
lO
.
lOlOl\
lOO\
O\
l
|=
lO\
llllO\
lllOO
;
lOllll\
lOO\
O\
l\
l
.
Init\
ialise\

(
Collis\
ion
::
lOllOOlll\
l\
l
,
0.0f
,
(
llllOO\
OO\
lO\

-
llllOOOOOl
)
.
Do\
t
(
lOl\
ll\
ll\
OllOO
.
v3Y
)
,
lOlllOl\
lOlO
,
lOllll\
lOllOO
.
v3Y
,
lO\
ll\
lO\
OlOOO
)
;
lO\
lllll\
OOOll
.
lOlO\
l\
lOOOl\

|=
lOll\
llOl\
l\
lOO
;
lO\
llll\
lOOlOO
.
Initial\
ise\

(
Col\
lision
::
lOl\
lO\
O\
ll\
ll\
l\

,
0.0f
,
(
llllOOOOl\
O
-
lll\
l\
O\
O\
OOOl
)
.
Dot
(
lOlllll\
OllOO\

.
v3Z
)
,
lO\
l\
l\
lOllOl\
O
,
lOll\
lll\
OllOO
.
v3Z
,
lO\
lllOO\
lOOO
)
;
lOllll\
l\
OO\
lOO\

.
lOlOllOOOl\

|=
lOl\
l\
l\
lOll\
l\
OO
;
lO\
lll\
l\
lOOO\
lO
.
lO\
llO\
lOOlOl
(
&
lOlll\
l\
lOOO\
ll
)
;
lOlllllOOOll
.
lOll\
O\
lOOlOl
(
&
lOlllllO\
O\
l\
OO\

)
;
lOlll\
l\
l\
OlOll
=
&
lO\
l\
ll\
ll\
OOlOO\

;
Collision
lO\
llll\
lOl\
lOl
;
Collision\

lO\
l\
lll\
lOlllO
;
Co\
lli\
si\
o\
n\

lOll\
ll\
lO\
ll\
ll
;
Co\
ll\
ision
lO\
ll\
OllOlO\
l\

;
Co\
lli\
sion
::
Typ\
e
lOllllllOO\
O\
O\

=
Colli\
s\
io\
n
::
lOllOlOOO\
O\
O\

;
flo\
at
lOll\
llllOOOl
=
lO\
Ol\
lOOO\
OOO\
l
*
20.0f
;
#ifdef lOllllllOOlO
if\

(
!
lOlOOOOOll\
OO
->
IsW\
orl\
dObject
(
)
)
{
Phys\
i\
csRender\

::
RenderLi\
ne
(
lOlllOl\
lOlO
,
lOl\
O\
OOOOlOll
->
Ge\
tPosit\
i\
on\

(
)
,
0xff0000ff
)
;
Physi\
csRende\
r\

::
RenderLin\
e
(
lOlllOllOlO
,
lO\
lOOOO\
Oll\
OO
->
Get\
Po\
sit\
ion\

(
)
,
0xff8080ff
)
;
}
#endif //
swi\
tch
(
lOOllll\
l\
OO\
OO
.
GetType
(
)
)
{
ca\
se
PhysicsJoint
::
TYP\
E\
_V\
EC\
TO\
R_\
C\
O\
N\
ST\
RAI\
NT
:
if
(
lOO\
llll\
lO\
OOO\

.
Get\
MaxAngle\

(
)
==
0.0f
)
lO\
lllll\
lO\
OO\
O
=
Col\
lisi\
on\

::
lOll\
Ol\
OO\
OO\
l
;
el\
se
lOllllllOOOO
=
Col\
l\
ision
::
TY\
PE_ROT\
ATION_\
CONST\
R\
AIN\
T\

;
cas\
e
Phy\
s\
icsJ\
oint
::
TYPE\
_B\
ALL_AND_\
SO\
C\
KE\
T
:
if
(
lOO\
lllll\
OO\
O\
O\

.
GetM\
axAng\
le
(
)
!=
JO\
INT\
_\
LI\
MIT_D\
ISA\
B\
LED
)
{
Vec3
lOll\
llllO\
Oll
=
lO\
O\
llll\
lOOOO\

.
Get\
LimitNormal\
OnObj\
ec\
tA
(
)
*
lOlOOOO\
OlOl\
l
->
GetFr\
a\
me
(
)
.
m33Rotatio\
n\

;
Ve\
c\
3
lOllll\
l\
lOlOO
=
lOOlllll\
OOO\
O\

.
GetLi\
mitNor\
malOnOb\
j\
e\
ctB
(
)
*
lOlO\
OOOOllOO
->
Ge\
tF\
rame\

(
)
.
m33Ro\
t\
a\
ti\
on
;
float
lO\
llll\
llOl\
Ol
=
Co\
s
(
lOOlllllOOOO
.
Get\
M\
ax\
Angle
(
)
)
;
floa\
t\

lO\
lOOO\
lOO\
l\
O
=
-
lO\
lllll\
lO\
Oll\

.
Dot
(
lOlll\
l\
l\
lOlO\
O\

)
;
if
(
Fabs
(
lOlOOO\
lOOlO
)
<
0.99f
)
{
Vec3\

lOO\
OlOOOOO
=
lOl\
l\
lll\
lOl\
O\
O\

+
lOlll\
lll\
OOl\
l\

;
lOO\
OlOOOO\
O
.
Normalise
(
)
;
Vec3
lOll\
llllOllO
=
(
lO\
l\
l\
llllOOl\
l
-
lOl\
llll\
lO\
lOO
)
;
float
lOll\
llOO\
ll
=
lOllllllOll\
O
.
GetMagnitud\
e
(
)
;
if\

(
lOll\
llOOll
>
0.00001f
)
{
lOl\
l\
ll\
l\
l\
OllO\

/=
lO\
llllOO\
ll
;
}
els\
e\

{
Mat33
lOOOOO\
O\
Oll
;
lOOOOOOOll
.
Set\
ToL\
ookDownV\
ecto\
r
(
lOOO\
lOOOO\
O
)
;
lOlll\
l\
l\
lOl\
lO
=
lOOO\
O\
OOO\
ll
.
v3\
Z
;
}
Ve\
c3
lOl\
l\
l\
OllO\
lO
=
(
llllOO\
OOOl\

+
llll\
OO\
O\
OlO\

)
*
0.5f
-
lOllllllOllO
*
2.0f
;
lOllOllOlOl\

.
Ini\
tia\
li\
se\

(
lOlllll\
lOOOO
,
0.0f
,
(
lOl\
lllllOlO\
l
-
lOlOOOl\
OOlO
)
*
lOllllllOOOl\

,
lOlllOllOlO\

,
lO\
OO\
lOOOOO
,
lO\
lllO\
OlO\
OO
)
;
lOllOllOl\
O\
l\

.
lOlOllOO\
Ol\

|=
lOlll\
lOlllO\
O\

;
lOl\
llllOOlO\
l
(
lOllO\
l\
l\
OlOl
,
&
lO\
ll\
ll\
Ol\
OOOO
)
;
if
(
lOO\
l\
llllO\
OOO
.
Ge\
t\
MaxAn\
g\
le
(
)
==
0.0f
)
{
Vec3
lOlllOllO\
l\
O
=
(
llllOO\
OOOl
+
lll\
lOOOOlO
)
*
0.5f
-
lOll\
llllOl\
l\
O
.
Cr\
oss\

(
lO\
O\
OlO\
O\
O\
OO
)
*
2.0f
;
lO\
llOllOlO\
l
.
Init\
ialise
(
lOll\
l\
lll\
OOOO\

,
0.0f
,
0.0f
,
lOl\
llO\
l\
lOlO
,
lOOO\
lOO\
OOO\

,
lOll\
l\
OOlOOO
)
;
lOllOll\
OlO\
l
.
lO\
lOl\
lOO\
Ol
|=
lOllllOlllOO
;
lOll\
lllO\
Ol\
Ol
(
lOl\
lOllOl\
O\
l\

,
&
lOlll\
lOlOO\
OO
)
;
}
}
else
if
(
lOOl\
llllOOOO\

.
Get\
M\
axAngle
(
)
==
0.0f
)
{
Vec3
lOl\
llOllOlO
=
(
ll\
l\
lOO\
O\
OOl
+
lll\
lOOOOl\
O
)
*
0.5f
-
lOl\
ll\
lllOO\
ll
*
2.0f
;
Mat\
33
lOOOOOOO\
ll
;
lOOO\
OO\
OOl\
l
.
Set\
ToLook\
Dow\
n\
V\
ector
(
lO\
l\
l\
ll\
l\
lOOll
)
;
Colli\
sio\
n
lOl\
l\
Oll\
O\
l\
O\
l
;
lOllOllOl\
Ol
.
In\
i\
tiali\
se
(
lOllll\
llOO\
OO
,
0.0f
,
0.0f
,
lO\
lllOllO\
l\
O
,
lOOO\
OOO\
O\
ll
.
v3X
,
lOl\
llO\
O\
lOOO
)
;
lOllOllO\
l\
Ol\

.
lOlOl\
l\
OOOl\

|=
lOll\
llOlllOO
;
lOlllll\
OOlOl
(
lOll\
O\
llOlO\
l
,
&
lOll\
l\
lOlOOOO
)
;
lOllOllOlOl
.
Initialise
(
lOl\
l\
lll\
lO\
OOO\

,
0.0f
,
0.0f
,
lOll\
lO\
l\
lOl\
O
,
lOOO\
OOOOl\
l
.
v3Y
,
lO\
lllO\
OlOOO
)
;
lOll\
OllOlOl
.
lOlOll\
OOOl
|=
lOllll\
Ol\
llOO
;
lO\
lllll\
OOlOl
(
lOllOllOlOl
,
&
lOllll\
OlOOOO
)
;
}
}
brea\
k
;
ca\
s\
e
Physi\
csJoi\
nt
::
TYPE\
_\
LIMI\
TE\
D\
_BA\
LL_A\
ND_SOCKE\
T
:
{
Mat3\
3\

lO\
llll\
llOl\
ll
=
lO\
Olllll\
O\
OOO
.
Get\
Jo\
i\
ntOrientatio\
nA
(
)
*
lOl\
OOO\
OO\
lOll
->
Ge\
tFram\
e\

(
)
.
m33Rota\
t\
ion
;
Mat33\

lOll\
ll\
ll\
lO\
OO
=
lO\
Ol\
llllOOO\
O
.
GetJ\
ointOr\
i\
enta\
ti\
o\
nB
(
)
*
lOl\
OOOOOllOO
->
GetFra\
me\

(
)
.
m33Ro\
tat\
ion
;
Mat33\

lO\
lllllllOOl
=
lOll\
ll\
lllOOO
*
lOllllll\
Olll
.
Ge\
t\
T\
ra\
nsposeA\
sInver\
s\
e
(
)
;
Ve\
c\
3
lO\
lllllll\
O\
lO
(
lO\
llll\
lllO\
Ol
.
v3Y
.
x
,
0.0f
,
lO\
lllll\
llOOl
.
v3\
Y\

.
z
)
;
fl\
oat
lOlll\
lOO\
ll
=
lOlllllllOlO
.
GetMagni\
tu\
de
(
)
;
Vec\
3
lOO\
OO\
llOlO\
O
;
if\

(
lOl\
ll\
l\
OOll\

>
0.001f
)
{
fl\
o\
at
lO\
ll\
l\
ll\
ll\
Oll
=
ATan2
(
lOll\
l\
lOOl\
l\

,
lOl\
lll\
lllOO\
l
.
v3Y
.
y
)
;
if
(
lO\
Olllll\
O\
OO\
O
.
Get\
MaxAngl\
es
(
)
.
x
!=
JO\
INT_LIMIT_DISABL\
E\
D
)
{
{
Vec\
3
llO\
Ol\
lllOO
=
ll\
ll\
O\
OO\
OOl
+
lOlllllllOOO
.
v3Y
*
lOlllll\
lOOO\
l\

;
Ve\
c\
3
lOOOlOO\
O\
O\
O
=
(
lOlllll\
llOOl
.
v3Y
.
Cr\
o\
ss
(
lOllll\
l\
llOlO\

.
CrossWith\
UnitY
(
)
)
*
lO\
ll\
llllOll\
l
)
;
lOO\
OlOOO\
O\
O
.
Normali\
se
(
)
;
lOll\
Oll\
OlO\
l
.
In\
itiali\
se
(
Colli\
sio\
n\

::
lOllOl\
OOOOO
,
0.0f
,
-
(
lOOlll\
llOOOO
.
GetMaxAngl\
es
(
)
.
x
-
lOl\
lllll\
l\
O\
l\
l
)
*
(
lO\
ll\
llllOOO\
l
*
2.0f
*
k_fP\
i
)
,
ll\
OOllllO\
O\

,
lOOOl\
OO\
OOO
,
lOll\
lOOlO\
OO
)
;
lOllOllO\
l\
O\
l
.
lOlOl\
lOOO\
l
|=
lOllll\
Ol\
llO\
O\

;
lOl\
l\
ll\
l\
OO\
lO\
l
(
lOllOllOlOl
,
&
lOl\
lllOl\
OOOO
)
;
}
}
lOlllll\
llO\
l\
O
=
k_\
v3\
UnitY\

.
Cross
(
lOl\
llllllOO\
l
.
v3Y\

)
;
lOlllllllO\
lO
.
Nor\
ma\
lise
(
)
;
lO\
O\
OO\
l\
lOlO\
O
=
lO\
llll\
lll\
O\
Ol
.
v3\
Z
*
Mat3\
3
(
lOllllll\
lO\
lO
,
-
lOll\
llll\
lO\
ll
)
;
}
els\
e\

{
if\

(
lOO\
lllllOOOO
.
GetM\
axAng\
le\
s
(
)
.
x
!=
JO\
INT\
_\
LIM\
IT_D\
IS\
A\
BL\
ED
)
{
Vec3
llOOllllO\
O
=
lll\
lO\
OOO\
Ol
+
lOllll\
lll\
OOO
.
v3Y
*
lO\
llllllOOOl
;
Vec\
3\

lOOOlO\
OOO\
O
=
lO\
lllll\
ll\
O\
O\
O
.
v3X
;
lOl\
lOllOl\
Ol\

.
In\
i\
tiali\
se
(
Coll\
i\
sion
::
lOll\
OlOOO\
O\
O
,
0.0f
,
-
lOOl\
llllOO\
OO\

.
GetMaxAngles\

(
)
.
x
*
(
lOl\
lll\
ll\
OO\
O\
l\

*
2.0f
*
k_fPi\

)
,
llO\
Olll\
l\
OO
,
lOOOlO\
OOOO
,
lO\
lllO\
OlO\
OO
)
;
lOll\
Ol\
l\
O\
l\
O\
l
.
lOlOl\
lOOO\
l
|=
lO\
ll\
llOll\
l\
OO
;
lOll\
lllOO\
lOl
(
lO\
llOllOlOl
,
&
lOlll\
lO\
lOOOO\

)
;
lOllOllOlOl\

.
Ini\
t\
i\
a\
lise\

(
Co\
ll\
is\
i\
on
::
lOl\
lOl\
OOO\
OO
,
0.0f
,
lOOlllll\
OOOO
.
GetMaxA\
ng\
le\
s
(
)
.
x
*
(
lOll\
ll\
llOOOl
*
2.0f
*
k_\
f\
Pi\

)
,
ll\
OOllllOO
,
lOO\
OlOOOOO
,
lOlllO\
OlO\
O\
O
)
;
lOllOllOlOl
.
lOlO\
llOOOl
|=
lOll\
l\
lOl\
llOO
;
lOlll\
llOOlOl
(
lO\
llOllO\
lOl
,
&
lOll\
l\
l\
OlOOOO
)
;
lO\
ll\
lllllO\
lO
=
lO\
l\
l\
ll\
lllOOl
.
v3\
Z
;
llOOlll\
lOO
=
ll\
llO\
OOO\
Ol
+
lO\
ll\
lllll\
OO\
O
.
v3Y
*
lOll\
ll\
llOOOl
;
lOOOlO\
OOOO
=
lO\
ll\
l\
llllO\
OO\

.
v3Z
;
lOl\
l\
OllOlOl
.
Initiali\
se
(
Coll\
ision
::
lOllOlOOOOO
,
0.0f
,
-
lOOlllllO\
OOO\

.
GetMa\
xAngles\

(
)
.
x
*
(
lO\
llllllOOOl
*
2.0f
*
k_fPi\

)
,
llOO\
llllOO
,
lOOOl\
OOOOO
,
lOll\
lOOlOOO
)
;
lOllOll\
OlOl
.
lO\
lOl\
lOOOl
|=
lOlll\
l\
OlllO\
O
;
lOll\
lllOOlO\
l\

(
lOllOll\
OlOl
,
&
lOl\
l\
llO\
lOOO\
O
)
;
lO\
llOll\
O\
lO\
l\

.
Ini\
t\
i\
alise
(
Co\
l\
lision
::
lOl\
lO\
l\
OOOOO
,
0.0f
,
lOO\
lllll\
O\
OOO
.
Get\
Ma\
xA\
ngles\

(
)
.
x
*
(
lOlll\
ll\
lOO\
Ol
*
2.0f
*
k_fP\
i
)
,
ll\
O\
Oll\
l\
l\
O\
O
,
lOOOlOO\
OOO
,
lOlllO\
OlOOO
)
;
lO\
llOl\
lOlOl
.
lO\
lOll\
OO\
Ol
|=
lO\
l\
lllOl\
llO\
O
;
lOlllll\
OOlOl
(
lOll\
O\
llOlOl
,
&
lOllllO\
lOO\
OO\

)
;
}
lOOOOllO\
lOO
=
lOllllll\
l\
OOl
.
v3Z
;
}
TA_AS\
SER\
T
(
Fabs
(
lOO\
OOl\
l\
OlO\
O
.
y
)
<
0.01f
)
;
flo\
at\

lO\
lllll\
lll\
O\
O
=
AT\
a\
n2
(
lOO\
OOllOlOO
.
z
,
lOOO\
Oll\
Ol\
OO
.
x
)
;
Vec3
ll\
OOl\
lllOO
=
lll\
lOO\
OOOl\

+
lOlllllllO\
OO\

.
v3Z
*
lOllllllOOOl
;
Ve\
c3
lOO\
OlO\
OOOO
=
lOl\
lll\
lllOOO
.
v3\
X
;
if\

(
lOOlllll\
OOOO
.
GetM\
axAng\
l\
es
(
)
.
y
!=
JOIN\
T\
_LIMIT_\
DISABLE\
D
)
{
lOllOl\
lOl\
Ol\

.
Initia\
lise\

(
Coll\
i\
sion
::
lOllOlOOOOO
,
0.0f
,
(
lOO\
ll\
l\
ll\
OO\
OO
.
Get\
Ma\
xAng\
les
(
)
.
y
-
lOl\
ll\
lllllOO\

)
*
lOllll\
l\
lOOO\
l
,
llO\
Ollll\
O\
O\

,
lO\
OO\
l\
OOOOO
,
lOlllOOl\
OOO
)
;
lOllOllOlOl
.
lOl\
OllO\
OO\
l
|=
lOlll\
lOlllOO
;
lOlllllOOlOl
(
lOllOllOlO\
l
,
&
lOllllOlOOOO\

)
;
}
if
(
lOOlll\
llOOOO
.
Ge\
tMinAngles
(
)
.
y
!=
JOIN\
T_LIM\
IT_DISABL\
ED
)
{
lOllOllOlO\
l
.
Initialise
(
Col\
l\
i\
si\
on\

::
lOllOlOOO\
OO
,
0.0f
,
-
(
lOOlll\
llOOOO
.
GetMinAngl\
es\

(
)
.
y
-
lOlllll\
lllO\
O
)
*
lOllllllOOOl
,
llOOllll\
OO\

,
-
lOOO\
lOOOO\
O\

,
lOlllOOl\
OOO
)
;
lOllOl\
lOl\
O\
l
.
lOlOllOO\
O\
l\

|=
lO\
llllO\
l\
llOO\

;
lOlllllO\
O\
l\
Ol
(
lO\
llOllO\
lO\
l
,
&
lOlll\
lOlOOOO
)
;
}
}
bre\
ak
;
ca\
se\

Physic\
sJo\
int
::
TY\
PE\
_SQUARE_SOCK\
ET
:
{
Mat\
33
lOlll\
lll\
lOO\
O
=
lO\
O\
l\
lll\
l\
OOOO
.
GetJ\
ointOr\
ien\
tatio\
nB
(
)
*
lOlO\
OOOOllOO\

->
Get\
Fram\
e\

(
)
.
m33\
R\
ot\
ation
;
Ma\
t\
3\
3\

lOll\
l\
l\
l\
lOlll
=
lO\
O\
llll\
lOOOO
.
GetJoint\
OrientationA
(
)
*
lOlOOO\
O\
Ol\
Oll
->
GetFr\
ame\

(
)
.
m3\
3\
Rota\
tion
;
Mat33
lO\
lllllll\
O\
Ol
=
lOlll\
l\
lll\
OOO\

*
lOl\
lllllOlll
.
GetTranspose\
AsInve\
rse\

(
)
;
float
lOOOOl\
lO\
OOl\

;
floa\
t
lO\
OOOll\
OOlO
;
Sin\
A\
n\
d\
Co\
s
(
lOOlllll\
O\
OOO
.
GetMinAng\
les\

(
)
.
x
,
lO\
OOOllOOO\
l
,
lOO\
O\
OllO\
O\
lO
)
;
Ve\
c\
3\

lOll\
l\
lll\
llOl
(
0.0f
,
lO\
OOOl\
lOOl\
O
,
lOOO\
Ol\
lOOOl
)
;
Si\
nA\
nd\
Cos
(
lOOl\
llllOOO\
O
.
Ge\
t\
Max\
Angles
(
)
.
x
,
lOOO\
O\
llOOOl
,
lOOOOllOOlO
)
;
Ve\
c\
3
lO\
llll\
llll\
l\
O
(
0.0f
,
lO\
OOOllOO\
lO
,
lOOOOllO\
OOl
)
;
SinAndCos\

(
lOO\
lll\
llOOOO
.
Ge\
tMinAngl\
es\

(
)
.
z
,
lOOOOllOOO\
l
,
lOOO\
OllO\
OlO
)
;
Vec3\

lOlll\
lllllll
(
lOO\
O\
O\
ll\
OOOl
,
lOOOO\
l\
lO\
OlO\

,
0.0f
)
;
SinAndCo\
s\

(
lOOl\
llllOO\
OO
.
Get\
Max\
A\
ngle\
s
(
)
.
z
,
lO\
OOOllOOOl
,
lOOO\
OllOO\
lO
)
;
Vec\
3
llOO\
O\
O\
OOO\
OOO
(
lOOOO\
l\
l\
OOOl
,
lOOOOl\
l\
OOlO
,
0.0f
)
;
const
float
llOOO\
OO\
O\
OO\
O\
l
=
1.0f
;
{
Ve\
c3
lOOOl\
OOOOO
=
lO\
lll\
llllllO
.
Cross\

(
ll\
O\
OO\
O\
OOOOOO
)
;
TA_ASS\
ER\
T
(
lOO\
OlO\
OOOO
.
Ge\
tMagnitud\
e\

(
)
>
0.0f
)
;
lOOO\
lOO\
OOO
.
Norma\
li\
se
(
)
;
floa\
t
lOOO\
lOO\
O\
Ol\
lO\

=
-
lO\
llllll\
lOO\
l
.
v3\
Y
.
Do\
t\

(
lOO\
O\
lOOOO\
O\

)
;
{
lOOOl\
OOOO\
O
=
lOll\
lll\
l\
lOOl
.
v3Y
.
Cro\
ss
(
lOOO\
l\
O\
OOOO\

.
Cro\
ss
(
lO\
l\
ll\
lll\
lO\
Ol
.
v3\
Y
)
)
;
lO\
OOlOOOO\
O\

.
No\
rma\
lise
(
)
;
lOOOlOO\
O\
OO
*=
lOlllll\
lOlll
;
Ve\
c3\

ll\
OOlll\
l\
O\
O
=
ll\
llOOOOO\
l\

+
lOlllll\
l\
l\
O\
OO\

.
v3Y\

*
lO\
l\
lllllOOO\
l\

;
lOllOl\
lOl\
Ol
.
Initia\
lise\

(
Col\
lision
::
lOllOlOOOOO
,
0.0f
,
lOOOl\
OOOOll\
O
*
(
lOllllllO\
O\
O\
l
*
llOOOOOOOOOl
)
,
llOO\
lll\
l\
OO
,
-
lOOOlO\
OOOO
,
lOlll\
O\
OlOOO
)
;
lOl\
lOllOlOl
.
lOlO\
llOOOl
|=
lOllllOl\
l\
lOO\

;
lOllll\
l\
OOl\
O\
l\

(
lOllO\
ll\
OlO\
l
,
&
lOllll\
OlOOOO
)
;
}
}
{
Vec\
3
lOOOlOOO\
O\
O\

=
llOOOOOOOOOO
.
Cro\
ss
(
lOllll\
l\
lllOl
)
;
TA_\
AS\
SERT
(
lOOOlOOO\
O\
O\

.
Get\
M\
agnit\
u\
de
(
)
>
0.0f
)
;
lO\
OOlOOOO\
O
.
Nor\
ma\
lise
(
)
;
floa\
t
lO\
OOl\
O\
OOOllO
=
-
lOl\
ll\
llllOOl
.
v3Y\

.
Do\
t
(
lOOO\
l\
O\
O\
O\
OO\

)
;
{
lOOO\
lOOOOO
=
lOl\
llll\
llOOl
.
v3Y
.
Cross
(
lO\
O\
O\
lOOOOO
.
Cross
(
lOlllll\
llOOl
.
v3Y
)
)
;
lO\
OOlOOOO\
O
.
Nor\
malise\

(
)
;
lOOOl\
OOOOO
*=
lOl\
l\
l\
ll\
lOlll
;
Vec3
llOOll\
llO\
O
=
ll\
llOOOOO\
l
+
lOll\
l\
ll\
l\
lOOO
.
v3Y\

*
lO\
llllllOOOl
;
lOll\
O\
llO\
lO\
l
.
In\
iti\
a\
li\
se
(
Co\
llisio\
n\

::
lOllOlOOOOO
,
0.0f
,
lOO\
OlOOOO\
llO
*
(
lO\
ll\
l\
lll\
OO\
Ol
*
llOOOO\
OOOOO\
l
)
,
llO\
OllllO\
O
,
-
lOOO\
lOOOOO
,
lOl\
llOOlOO\
O
)
;
lOllOllO\
lOl\

.
lO\
l\
OllOO\
Ol
|=
lOllllOlllOO
;
lOl\
llll\
OO\
l\
O\
l
(
lOllOl\
lOlOl
,
&
lO\
ll\
llOlOOOO
)
;
}
}
{
Vec3
lOOO\
lO\
OOOO
=
lOll\
l\
llll\
lOl
.
Cro\
ss
(
lOllllllll\
l\
l\

)
;
TA_ASSERT\

(
lOOOl\
O\
OO\
O\
O
.
GetMagnitude
(
)
>
0.0f
)
;
lO\
OOlOOO\
OO
.
Normal\
i\
se\

(
)
;
float
lO\
OOl\
O\
OO\
OllO
=
-
lOlllllllO\
Ol\

.
v3Y
.
Dot
(
lOOOlOOOO\
O
)
;
{
lO\
OOlOO\
O\
OO
=
lOll\
lllll\
O\
Ol
.
v3Y
.
Cro\
ss\

(
lOOOlOOOOO
.
Cros\
s
(
lOllll\
l\
ll\
O\
Ol
.
v3Y\

)
)
;
lOO\
OlO\
OO\
OO
.
Normal\
is\
e
(
)
;
lO\
O\
OlOO\
OOO\

*=
lO\
lllll\
l\
O\
lll
;
Vec\
3
ll\
OO\
ll\
llO\
O\

=
llllO\
OO\
OOl
+
lOl\
l\
l\
llll\
O\
OO
.
v3\
Y
*
lOlll\
lllOOO\
l
;
lOllO\
ll\
Ol\
Ol
.
Initial\
i\
s\
e
(
Collision
::
lOllO\
lO\
OOO\
O
,
0.0f
,
lOOOlO\
OOOllO
*
(
lOl\
l\
llll\
OOO\
l
*
ll\
OOOOOO\
OOOl\

)
,
llOOl\
l\
l\
lOO\

,
-
lO\
OOl\
OO\
OO\
O\

,
lO\
lllOOlO\
OO\

)
;
lOllO\
l\
lO\
l\
O\
l
.
lOl\
O\
llOOOl
|=
lO\
l\
lllO\
lllOO
;
lOlllllO\
OlOl
(
lO\
llO\
l\
lOlOl\

,
&
lOl\
lllOlO\
O\
OO
)
;
}
}
{
Vec3\

lOOOl\
OOOO\
O
=
lOlll\
llll\
lll
.
Cross\

(
lOllll\
lllllO
)
;
TA_\
ASSERT
(
lOOO\
l\
OO\
OOO
.
GetMa\
gn\
it\
ude
(
)
>
0.0f
)
;
lOOO\
lOO\
OOO
.
Normalise\

(
)
;
float
lO\
O\
OlOOOO\
llO
=
-
lOll\
lllllOOl
.
v3\
Y
.
Dot
(
lOOOlO\
OOOO\

)
;
{
lO\
O\
Ol\
OO\
OOO
=
lOl\
lllll\
lO\
Ol
.
v3Y\

.
Cross
(
lOO\
OlOOOOO
.
Cr\
oss
(
lOl\
l\
lll\
llOOl\

.
v3Y
)
)
;
lOOOlO\
OO\
OO
.
No\
rmalise
(
)
;
lOOO\
l\
OO\
OOO\

*=
lO\
lll\
ll\
lOlll
;
Vec\
3
llOO\
ll\
l\
l\
OO
=
llllOOOO\
Ol
+
lOl\
llllllOOO
.
v3Y
*
lO\
l\
ll\
lllOO\
Ol
;
lOllOll\
OlOl
.
Ini\
tialise
(
Co\
l\
lis\
i\
on
::
lO\
llOlOOOOO\

,
0.0f
,
lOOOlOOOOllO
*
(
lOlllll\
lOO\
O\
l
*
llOOOOOOOOO\
l
)
,
ll\
OOll\
llOO
,
-
lOOOlOOOO\
O
,
lOlllO\
Ol\
OOO\

)
;
lOllOl\
lOlO\
l
.
lO\
l\
OllOOO\
l\

|=
lOllllOlllOO\

;
lO\
llll\
lOOl\
Ol
(
lOl\
lOllOlOl
,
&
lOllllOlOOOO
)
;
}
}
Vec3
lOllllll\
lOlO
(
lOl\
llllllOOl
.
v3Y
.
x
,
0.0f
,
lO\
lll\
ll\
llOOl
.
v3Y\

.
z
)
;
float
lOll\
llO\
Ol\
l\

=
lOlllllllO\
lO
.
GetMagnit\
ude
(
)
;
if
(
lOllllOOll
>
0.01f
)
{
float\

lOlll\
llll\
Oll\

=
ATan2
(
lOll\
llO\
Oll
,
lOl\
llllllOO\
l
.
v3Y
.
y
)
;
lOll\
ll\
lllOl\
O
=
k_\
v3Un\
itY
.
Cross\

(
lOlllll\
llOOl
.
v3Y
)
;
lO\
l\
l\
ll\
l\
llOlO
.
No\
rmalise
(
)
;
Vec3\

lO\
OOOllOl\
OO
=
lOll\
ll\
lll\
O\
Ol
.
v3\
Z
*
Mat33\

(
lOll\
lll\
llOlO
,
-
lOllll\
l\
llOl\
l
)
;
TA\
_AS\
SERT\

(
Fa\
bs
(
lOOO\
OllOlOO
.
y
)
<
0.01f
)
;
floa\
t
lOl\
lllll\
l\
lOO\

=
ATan\
2
(
-
lOOOOl\
lO\
l\
O\
O\

.
x
,
lOOOO\
l\
lOlOO
.
z
)
;
Vec3
ll\
OO\
llllOO
=
lll\
lOOOOOl
+
lOll\
lllll\
OOO
.
v3Z\

*
lO\
l\
lllllO\
O\
Ol
;
Vec3
lOOO\
lOOOOO
=
lOllll\
lllO\
OO\

.
v3X
;
if
(
lOlll\
l\
llllO\
O
>
lOOl\
llllO\
O\
O\
O
.
Ge\
t\
M\
a\
xAngle\
s
(
)
.
y
)
{
lOllOllO\
lOl
.
Init\
i\
alise
(
Collision
::
lOllOlOO\
OO\
O
,
0.0f
,
-
(
lOOl\
llllOOOO
.
GetM\
axAng\
les\

(
)
.
y
-
lOlllll\
lll\
OO
)
*
lOll\
llllOOOl
,
llOO\
llll\
O\
O
,
-
lOOOlOO\
OO\
O
,
lOlll\
OOlO\
OO
)
;
lOllOl\
lOlOl\

.
lOlOllOO\
O\
l
|=
lO\
l\
lll\
O\
lllOO
;
lOl\
l\
lll\
OO\
lO\
l
(
lOl\
lOll\
OlOl
,
&
lOl\
lllOlOOO\
O\

)
;
}
el\
se
if
(
lOll\
lll\
l\
llO\
O
<
lOOlll\
llO\
O\
O\
O
.
GetMi\
nAng\
l\
e\
s
(
)
.
y
)
{
lOl\
l\
Ol\
lO\
l\
Ol\

.
Init\
ialise
(
Collis\
io\
n\

::
lO\
llOl\
OOOOO
,
0.0f
,
(
lOO\
l\
l\
l\
l\
lO\
OOO
.
Get\
MinAngle\
s
(
)
.
y
-
lO\
ll\
l\
lll\
llO\
O\

)
*
lOll\
lll\
lOOOl
,
llOOl\
l\
llOO\

,
lOOO\
lOOOOO
,
lOl\
llO\
O\
lOO\
O
)
;
lO\
ll\
OllOlOl
.
lO\
lOl\
lOO\
Ol
|=
lOll\
llOlll\
OO\

;
lOlllll\
OO\
lOl
(
lOllOllOl\
Ol
,
&
lOllllO\
l\
OOOO
)
;
}
}
else
{
}
}
bre\
ak
;
case
Phy\
si\
cs\
Jo\
i\
nt
::
TYPE_\
ROTA\
T\
I\
ON_\
CO\
NST\
RAINT\

:
lOl\
ll\
l\
l\
lOOOO\

=
Coll\
isio\
n
::
TYP\
E\
_ROTAT\
ION_CO\
NST\
RA\
INT
;
case
Phys\
icsJoi\
nt
::
TYPE_EULER\
_A\
NG\
LE_CONSTRAI\
NT
:
{
Mat33
lO\
l\
l\
ll\
l\
l\
l\
OO\
O
=
lOOl\
llllOO\
OO
.
Ge\
t\
JointOr\
ie\
nt\
ationB\

(
)
*
lO\
lOOOOO\
llO\
O
->
Ge\
tFr\
ame
(
)
.
m33Rotatio\
n\

;
Mat\
33
lOlll\
l\
llOlll
=
lOO\
lllllOOOO
.
GetJointOr\
ie\
ntatio\
n\
A
(
)
*
lOlOOOO\
OlO\
ll\

->
Ge\
tFr\
a\
me
(
)
.
m33Ro\
ta\
ti\
on
;
Ma\
t3\
3\

lO\
lllllllOOl
=
lO\
llllll\
l\
O\
O\
O
*
lOllllllO\
ll\
l\

.
Get\
T\
r\
anspose\
AsI\
n\
verse
(
)
;
Eul\
e\
rA\
ngl\
e\
s\

llOOO\
O\
OOOO\
lO
=
lOOllll\
l\
OOO\
O
.
llOOOOO\
OOOll\

(
)
;
llOOO\
OO\
OO\
OlO
.
Up\
dateTo
(
Eu\
ler\
A\
ngles\

(
lOll\
lllllOOl
)
)
;
lOOllll\
l\
OOOO\

.
lOOlllOOO\
OlO
(
llO\
OOOOOOOlO
)
;
Ve\
c3\

llOOlll\
l\
OO
=
ll\
l\
lO\
OOO\
l\
O\

+
lOll\
llll\
lO\
OO\

.
v3X
*
lOl\
lll\
llO\
OOl\

;
Vec3
lOOO\
lOOOOO
=
-
lO\
l\
llll\
llOOO\

.
v3Y
;
if
(
lO\
O\
llll\
l\
OOO\
O
.
GetMaxA\
ngles
(
)
.
z
==
JO\
INT_L\
IMIT\
_DI\
S\
ABLE\
D
)
{
}
else\

if
(
lO\
OlllllO\
OOO
.
Ge\
tM\
inA\
ngle\
s
(
)
.
z
>=
lOOll\
lllOOOO
.
GetM\
axAngles
(
)
.
z
)
{
lOll\
l\
llO\
llO\
l
.
In\
i\
ti\
a\
li\
se
(
Collisio\
n
::
lOll\
O\
Oll\
lll
,
0.0f
,
(
lO\
Ol\
ll\
llO\
OOO
.
Ge\
t\
Mi\
nAn\
g\
les
(
)
.
z
-
llOOOO\
O\
OOOlO\

.
z
)
*
(
lOll\
l\
l\
ll\
O\
OO\
l
*
(
2.0f
*
k_fPi
)
)
,
llOO\
l\
lllOO
,
lOOOlOOOOO
,
lOlllOOl\
O\
OO
)
;
lO\
l\
l\
lllO\
ll\
Ol\

.
lOl\
Ol\
lOOOl
|=
lOll\
llOl\
l\
l\
OO
;
TA\
_ASSE\
RT
(
!
lOllll\
lOlO\
ll
->
Ge\
tNext\

(
)
)
;
lO\
llll\
lOlOl\
l\

->
lO\
llO\
lO\
OlO\
l
(
&
lOlll\
llOllOl
)
;
lO\
lllllOlOll
=
lOlll\
l\
l\
O\
lOll
->
Get\
Next
(
)
;
}
el\
s\
e\

{
{
lOllOllO\
lOl
.
Ini\
t\
ial\
is\
e
(
lO\
l\
lllllOOO\
O
,
0.0f
,
(
lOOlllllO\
OOO
.
GetM\
in\
Ang\
les\

(
)
.
z
-
llO\
OOOO\
OOOlO
.
z
)
*
(
lOll\
l\
ll\
l\
OOOl\

*
(
2.0f
*
k_fP\
i\

)
)
,
ll\
OOlll\
lO\
O
,
lOOOlOOOO\
O
,
lO\
lllOO\
lOO\
O
)
;
lOllOllOlOl
.
lOlOl\
lO\
OOl
|=
lOl\
ll\
lOl\
llO\
O\

;
lOll\
lll\
O\
OlO\
l
(
lOll\
O\
llOlOl
,
&
lOlll\
lOlOOOO
)
;
}
{
lOl\
l\
Oll\
O\
lOl
.
Init\
i\
alise
(
lO\
llll\
llOO\
O\
O
,
0.0f
,
(
llOOOOOOOOlO
.
z
-
lOO\
l\
llllOOOO
.
Ge\
t\
MaxAng\
l\
es
(
)
.
z
)
*
(
lOl\
llll\
lOOOl\

*
(
2.0f
*
k_fPi
)
)
,
llO\
Oll\
llO\
O
,
-
lOO\
O\
lOOOOO
,
lOll\
lOOlO\
OO
)
;
lO\
l\
lOllOlO\
l
.
lOlO\
llO\
OOl
|=
lOllll\
O\
lllO\
O\

;
lO\
lllllO\
OlOl
(
lOl\
lO\
ll\
OlO\
l\

,
&
lOllllOlOOO\
O\

)
;
}
}
llO\
OllllOO
=
llllO\
OOO\
l\
O
+
lOl\
llllllOOO
.
v3Z
*
lOl\
lll\
l\
lOOOl
;
lOOOlO\
OOOO\

=
-
lO\
ll\
llllOlll
.
v3\
Y\

.
Cros\
s\

(
lO\
l\
llllllO\
OO\

.
v3\
Z\

)
.
Cross\

(
lOl\
ll\
l\
l\
l\
lOOO
.
v3Z\

)
;
if
(
lO\
OOl\
OO\
OO\
O
.
GetM\
a\
gni\
tudeSqrd
(
)
>
0.0000001f
)
{
lOOOlOOOO\
O
.
No\
rma\
li\
s\
e\

(
)
;
if
(
lOO\
lll\
llOOOO
.
GetMax\
Angl\
es
(
)
.
x
==
JOIN\
T_LIMIT_\
DISAB\
LED
)
{
}
else
if
(
lOOll\
lll\
O\
OOO\

.
GetMinA\
ngles
(
)
.
x
>=
lOOll\
lllOOO\
O
.
GetMa\
xAng\
les
(
)
.
x
)
{
lO\
lllllOlll\
O\

.
In\
i\
t\
ia\
li\
s\
e
(
Col\
li\
s\
io\
n\

::
lOllOOll\
lll
,
0.0f
,
(
lOOl\
llllOOOO
.
Ge\
tM\
i\
nAngles\

(
)
.
x
-
llOOOO\
O\
OOO\
lO
.
x
)
*
(
lOllllll\
OOOl
*
(
2.0f
*
k_fP\
i\

)
)
,
llOOllllO\
O
,
lOOOl\
O\
OO\
OO
,
lOl\
llO\
OlOOO
)
;
lO\
lllllOl\
l\
lO
.
lOlOllOOOl
|=
lOlll\
lOlll\
OO\

;
TA\
_\
ASSERT
(
!
lOl\
llllOlOll\

->
Ge\
tNex\
t
(
)
)
;
lOll\
lll\
Ol\
Oll
->
lOllOlOO\
l\
Ol
(
&
lOll\
lllOll\
lO
)
;
lO\
lllllO\
lOll
=
lOlllllOlOll\

->
GetN\
ext
(
)
;
}
el\
se\

{
{
lOllOllOl\
Ol\

.
In\
itia\
lise\

(
lOll\
l\
ll\
lO\
OOO
,
0.0f
,
(
lOOllll\
lO\
OOO
.
Ge\
tMin\
Angles
(
)
.
x
-
llOO\
OOOO\
OO\
lO\

.
x
)
*
(
lOll\
l\
l\
llOOO\
l\

*
(
2.0f
*
k_fPi
)
)
,
ll\
O\
O\
l\
lllOO\

,
lO\
OOlOOOOO
,
lOll\
lOO\
lOOO\

)
;
lOllOllOl\
Ol
.
lOlOllOOOl
|=
lOll\
llO\
ll\
lO\
O
;
lO\
llll\
l\
O\
OlOl
(
lO\
l\
l\
Ol\
l\
OlOl
,
&
lOll\
llO\
lOOOO
)
;
}
{
lOl\
lOl\
lOlOl\

.
In\
itial\
ise
(
lOll\
llllO\
OOO
,
0.0f
,
(
llOOOOO\
O\
OOl\
O
.
x
-
lO\
Oll\
l\
llOOOO
.
GetMa\
xA\
ngles
(
)
.
x
)
*
(
lOll\
ll\
ll\
O\
O\
O\
l
*
(
2.0f
*
k_fPi
)
)
,
llOOllllO\
O
,
-
lOO\
OlO\
OOOO\

,
lOlllOO\
l\
OO\
O
)
;
lOll\
O\
ll\
O\
lOl
.
lOlOll\
OO\
Ol
|=
lO\
llllO\
lllO\
O
;
lO\
lllllOOl\
Ol
(
lOllOll\
OlOl
,
&
lO\
l\
ll\
l\
O\
lO\
O\
O\
O\

)
;
}
}
}
llOOllllOO
=
llll\
O\
OOOlO\

+
lOllll\
llO\
ll\
l
.
v3\
X
*
lO\
llllll\
OOOl
;
lOOO\
lO\
O\
OOO\

=
-
lOlll\
lllOlll
.
v3Z\

;
{
if
(
lOOlll\
llO\
OOO\

.
GetMax\
Ang\
les
(
)
.
y
==
JOINT_LI\
MIT_DISABLED\

)
{
}
else\

if
(
lOOl\
l\
lllO\
OO\
O
.
GetM\
inAngles
(
)
.
y
>=
lOOlll\
ll\
OO\
OO\

.
Get\
Max\
Ang\
l\
e\
s\

(
)
.
y
)
{
if
(
lOOlll\
llOOOO
.
GetMi\
nAngles\

(
)
.
z
>=
lO\
O\
l\
llllO\
OOO
.
Get\
MaxAn\
g\
les
(
)
.
z
)
lOO\
O\
lOOOOO\

=
-
lOl\
llllll\
OOO
.
v3\
Z
;
lOl\
ll\
llOllll
.
In\
itialise
(
Col\
lis\
ion
::
lOllOOll\
ll\
l
,
0.0f
,
(
lO\
O\
lllllOO\
OO
.
Ge\
t\
MinAngles
(
)
.
y
-
llOOOOOOO\
O\
lO\

.
y
)
*
(
lOl\
ll\
lllO\
OOl
*
(
2.0f
*
k_fPi\

)
)
,
ll\
OOlll\
lOO\

,
lO\
OOlOO\
O\
O\
O
,
lO\
l\
l\
lOO\
lO\
O\
O
)
;
lOll\
l\
llO\
lll\
l\

.
lOlOl\
lO\
O\
O\
l
|=
lOllllOlllOO
;
TA\
_ASSERT
(
!
lOlllllOlO\
l\
l
->
GetNext
(
)
)
;
lOlll\
l\
lOlOl\
l
->
lOllO\
l\
OOlOl
(
&
lOl\
ll\
llOllll\

)
;
lOl\
ll\
ll\
OlOll
=
lO\
l\
lll\
lOlOll
->
GetNext\

(
)
;
}
el\
s\
e\

{
{
lOllOl\
lO\
l\
Ol\

.
In\
i\
t\
i\
ali\
s\
e
(
lOllll\
l\
lOOOO
,
0.0f
,
(
lOOlllllOOOO
.
GetMin\
Angles\

(
)
.
y
-
ll\
O\
OO\
OOOO\
OlO
.
y
)
*
(
lO\
llllllO\
OOl
*
(
2.0f
*
k_\
f\
P\
i\

)
)
,
llO\
O\
llllOO
,
lO\
O\
OlOOO\
OO
,
lOlllOO\
lOOO
)
;
lOl\
lO\
llOlO\
l
.
lOlOllOO\
Ol
|=
lOllllOlllOO
;
lOll\
lllO\
OlO\
l
(
lO\
llOll\
O\
lOl
,
&
lOll\
ll\
OlOOO\
O
)
;
}
{
lOll\
Ol\
lOl\
Ol
.
Initialis\
e\

(
lOl\
l\
lll\
l\
OOOO\

,
0.0f
,
(
llOOOO\
OOOO\
lO\

.
y
-
lO\
O\
lll\
ll\
OOOO
.
Ge\
tMaxAngles
(
)
.
y
)
*
(
lOlll\
lllOOOl
*
(
2.0f
*
k_fPi
)
)
,
llOOlll\
lO\
O\

,
-
lOOO\
l\
O\
OOOO\

,
lOl\
llOOl\
OOO\

)
;
lOllOl\
lOl\
O\
l
.
lOl\
OllOO\
O\
l
|=
lOlll\
l\
Oll\
lOO
;
lOlll\
ll\
OOlO\
l
(
lO\
llOllOlO\
l
,
&
lO\
lll\
lOlOOO\
O
)
;
}
}
}
}
break
;
default\

:
lllOOOlllO
;
}
if
(
lOO\
llll\
lOOOO
.
GetType
(
)
==
Phy\
si\
csJoi\
nt
::
TY\
PE_ROTA\
TION\
_C\
O\
NSTRA\
I\
N\
T
||
lO\
Ol\
ll\
llOOOO
.
GetTyp\
e
(
)
==
Phy\
sicsJ\
oint
::
TYPE\
_VEC\
TOR\
_CONSTRA\
INT\

)
{
if\

(
lOl\
llllOOl\
O\
O
.
Get\
Next
(
)
)
{
lO\
lll\
llOll\
Ol
.
lOll\
OlOO\
lll\

(
Co\
llis\
i\
on
::
lOl\
lO\
l\
O\
OOOl\

)
;
if
(
lO\
ll\
lllOllOl\

.
GetNex\
t
(
)
)
{
lO\
ll\
lll\
Oll\
lO
.
lOllOlOOlll\

(
Coll\
isi\
on
::
lOllOlOOOOl\

)
;
if
(
lO\
lll\
l\
lO\
lllO
.
GetNex\
t
(
)
)
{
lO\
l\
llll\
O\
llll
.
lOll\
OlOO\
lll
(
Collis\
ion
::
lO\
llO\
l\
O\
O\
OO\
l\

)
;
}
}
lOlll\
l\
lOO\
lO\
l
(
lOlllllOllOl
,
&
lOlll\
l\
OlOOOO
)
;
}
}
el\
se
{
lOll\
ll\
l\
O\
O\
l\
Ol
(
lO\
lllllOOO\
lO
,
&
lOllllOlO\
O\
O\
O\

)
;
}
}
ll\
OOOO\
OOOlOO
(
)
;
}
inline
fl\
o\
a\
t
llOO\
OOOOO\
lOl
(
float
ll\
OOOOOOOl\
lO
)
{
return
Log
(
llOOOOO\
OOllO\

)
;
}
inline\

float
llOO\
O\
OOOO\
ll\
l\

(
fl\
oat
llOOOOOOOllO\

)
{
re\
t\
ur\
n
Ex\
p
(
ll\
OOOOO\
OOl\
lO
)
;
}
void
Physi\
cs
::
lOllO\
ll\
OlllO\

(
lOlOlllOll\
lO
&
lO\
l\
lOllO\
l\
Ol\
O
)
{
lOllO\
lOO\
llOl
->
Clear
(
)
;
lOO\
lO\
llO\
lll
(
lOl\
l\
OOlOl\
lO\
l
)
;
TA\
_ASSERT
(
lOOllOlllOl\
O
->
lOl\
Ol\
ll\
lOlOO
==
lOl\
lOl\
O\
OllOl
->
ll\
OO\
O\
OOO\
lOOO\

(
)
)
;
TA_A\
SS\
ERT
(
lOOll\
O\
lllOlO
->
lO\
l\
OllllOl\
Ol
==
lOllO\
l\
OO\
llOl\

->
llO\
OOOOO\
lOOl
(
)
)
;
float
llO\
OOOOO\
lOlO\

=
k_fMaxFloa\
t
;
fl\
oat
llOOOO\
OO\
lOl\
l
=
0.0f
;
lOl\
Ol\
l\
lO\
lllO
::
ll\
OOO\
OOO\
l\
lOO\

llOO\
O\
O\
OOll\
Ol
=
lOll\
Ol\
lO\
lOlO
.
llOOOOOOlllO
(
)
;
fo\
r\

(
;
!
ll\
OOO\
OOOllO\
l\

.
At\
End\

(
)
;
++
llOOOOOO\
l\
l\
Ol
)
{
Dynamic\
Ob\
jec\
t
&
lOllO\
lOl\
l\
O\
OO\

=
*
*
llO\
OOOOOl\
lO\
l
;
TA_ASSE\
RT
(
lOllOlOllOOO
.
IsInMovin\
gList
(
)
)
;
TA_ASSERT
(
!
lOllOlO\
llOOO
.
Infini\
te\
Mass
(
)
)
;
TA\
_A\
SSERT
(
!
lO\
llOlOl\
lOO\
O
.
Mov\
emen\
t\
Di\
sabl\
ed
(
)
)
;
flo\
at
lOllOOO\
OlO\
O
=
lOl\
l\
O\
lOllOOO\

.
GetMa\
ss
(
)
;
Cl\
amp\
I\
fLe\
ss\
The\
n
(
llOO\
OOOO\
lO\
l\
l\

,
lOl\
lO\
O\
O\
OlO\
O
)
;
ClampIfGre\
ate\
r\
Th\
en
(
llOO\
OOOOlO\
lO
,
lO\
ll\
O\
OOOlOO\

)
;
}
const\

float
ll\
OOOOO\
Ollll
=
0.2f
;
con\
st\

flo\
a\
t
ll\
OOOOOlOOOO
=
10.0f
;
floa\
t
ll\
O\
OOO\
Ol\
O\
O\
Ol
=
llO\
O\
OO\
OO\
OlOl\

(
llOOOOOOlll\
l\

)
;
fl\
o\
at
ll\
OOOO\
OlOOlO\

=
llOOO\
OO\
O\
Ol\
Ol
(
llO\
OOOOlOOOO\

)
;
flo\
at
llOO\
OO\
O\
l\
OO\
ll
=
(
llOOOOOl\
O\
OlO
-
ll\
OOOOOlO\
OOl
)
*
0.5f
;
flo\
at\

ll\
OOOO\
OlO\
l\
OO\

=
(
llOOOOOl\
OO\
lO
+
ll\
O\
OOOOl\
O\
O\
O\
l
)
*
0.5f
;
TA_\
ASSER\
T
(
ll\
OOOOOOl\
O\
ll
>
0.0f
)
;
TA\
_ASSERT
(
ll\
OO\
OOOOlO\
l\
O
>
0.0f
)
;
floa\
t\

llOOO\
OOlOlOl
=
llO\
OOOOO\
Ol\
Ol
(
llO\
OOOOO\
lOll
)
;
float\

llOOO\
OOl\
Oll\
O
=
llO\
OO\
OOO\
O\
l\
Ol\

(
llOO\
OOOOl\
Ol\
O\

)
;
flo\
a\
t
llOO\
OllOl\
Ol
=
(
ll\
OO\
OOO\
lO\
l\
Ol
-
llOOOOOlOllO
)
*
0.5f
;
float\

llO\
OOl\
lO\
lO\
O
=
(
llO\
OOOOlOl\
Ol
+
llOOOOOlO\
ll\
O
)
*
0.5f
;
lO\
l\
l\
l\
OOOllll
=
ll\
O\
O\
O\
OOOOl\
ll
(
llOOO\
OOl\
OlO\
O
)
/
ll\
OOOOOOOl\
ll
(
llOOOl\
lOl\
OO
)
;
if\

(
llOOO\
llO\
lOl
<
ll\
O\
OOO\
Ol\
OO\
ll
)
{
const
floa\
t\

llOlOl\
Olll\
O\

=
1.0f
/
lOlllOOOll\
ll
;
llOOOO\
O\
O\
l\
lOl
=
lOll\
OllOlOl\
O\

.
llOOOOOO\
lllO\

(
)
;
fo\
r
(
int\

llOOOOOlOl\
ll
=
0
;
!
llOOOOOOll\
Ol\

.
AtE\
n\
d
(
)
;
++
ll\
O\
OOOOOllO\
l\

,
llOO\
OOOl\
Olll
++
)
{
Dy\
n\
amicObject
&
lOllOlOllO\
OO\

=
*
*
llOOOO\
OOll\
Ol
;
lOl\
lO\
l\
Ol\
lOOO
.
lO\
l\
O\
OllOl\
lOO\

(
ll\
O\
O\
O\
OOlOlll
)
;
lOllO\
l\
OOl\
lOl
->
llOOOOOll\
OOO
(
lOllOlO\
l\
lOOO
.
Get\
InverseMass
(
)
*
llOlO\
lO\
l\
ll\
O
,
lOl\
lOlO\
l\
l\
O\
OO
.
GetWorl\
dS\
paceI\
nve\
rseI\
n\
e\
r\
tia
(
)
*
llOlOl\
Olll\
O
)
;
}
}
else
{
TA\
_ASSERT
(
llO\
OO\
l\
lO\
l\
Ol
>
0.0f
)
;
TA\
_\
A\
S\
SE\
RT
(
llOOO\
OOlO\
O\
ll
>=
0.0f
)
;
float
ll\
OOOO\
O\
llOOl\

=
llO\
O\
OOOl\
OOll
/
llOOOllOlOl
;
llO\
O\
O\
OOOl\
lO\
l
=
lOllOllOlO\
lO\

.
llOOOOO\
Ol\
llO\

(
)
;
for
(
int\

ll\
OOO\
OO\
lOlll
=
0
;
!
llOOOOOOl\
l\
Ol
.
AtEn\
d
(
)
;
++
llOOOOO\
OllOl\

,
llO\
OO\
OOl\
Olll
++
)
{
Dy\
namicObj\
ect
&
lOllOl\
OllOOO\

=
*
*
llO\
OOOOO\
ll\
Ol
;
lOllOl\
O\
llO\
OO\

.
lOl\
OOllOll\
OO\

(
ll\
O\
O\
OOOlOl\
ll\

)
;
fl\
oat\

llOOOOO\
llOlO\

=
Lo\
g
(
lOllOlO\
llOOO
.
GetMass
(
)
*
lOlllOO\
Ollll\

)
;
llOOOOO\
llOlO\

-=
llOOOOOlOlO\
O
;
llOOOOOll\
Ol\
O
*=
llOOOOOll\
OOl
;
ll\
OOOOOllOlO
+=
llOOOO\
OlOl\
OO
;
float
llOlOl\
Oll\
lO
=
lOllOl\
OllO\
OO\

.
GetMass
(
)
/
Ex\
p
(
llOOO\
OOll\
OlO
)
;
lOll\
OlOOllO\
l\

->
llOOO\
OO\
l\
lOOO
(
lOll\
OlO\
ll\
OOO
.
GetInver\
se\
Ma\
ss
(
)
*
llOlO\
lOll\
lO
,
lO\
llOlOllOOO\

.
GetWorldSpaceIn\
ve\
rseIner\
tia\

(
)
*
llOlO\
lOl\
ll\
O
)
;
}
}
lO\
l\
OlllOlllO
::
Ite\
ra\
tor
lOlO\
ll\
lOOOO\
O
=
lOllOl\
lOl\
O\
lO
.
lOl\
O\
OO\
Ol\
O\
O
(
)
;
for\

(
;
!
lOlO\
l\
l\
lOOO\
OO
.
At\
End
(
)
;
++
lO\
l\
O\
lllOOOOO
)
{
Colli\
s\
ion
*
ll\
Ol\
l\
O\
lOlOl
=
&
*
lOlOl\
llOOO\
OO
;
u32
lOlOllO\
O\
Ol
=
0
;
if
(
llOllO\
lOl\
Ol
->
lOlOll\
OOO\
l\

&
Colli\
s\
ion
::
FL\
AG_C\
ONSTRA\
IN\
_IN_\
B\
OT\
H_DIR\
ECT\
I\
ON\
S
)
lOl\
OllOO\
O\
l
|=
lOllOlOl\
O\
O\
Ol\

::
llOOOOOll\
Oll\

;
if
(
(
llOllO\
lOl\
Ol\

->
lO\
l\
O\
llO\
OOl
&
Col\
lis\
io\
n
::
FLAG_J\
OIN\
T
)
&&
llOllOlOlOl
->
lOll\
OlOl\
OOl\

(
)
)
lOlO\
llOOOl
|=
lOl\
lOl\
O\
lOOOl\

::
llOOOOOl\
llOO
;
int
ll\
O\
O\
OOOl\
llOl
=
0
;
for
(
Col\
li\
si\
on
*
lOOOOOOllll
=
llO\
llOlOlOl
;
lOOOOO\
O\
l\
lll\

;
lOOOOOOllll
=
lO\
O\
OO\
OOlll\
l
->
GetNex\
t
(
)
)
ll\
O\
OOO\
Ol\
llOl\

++
;
if
(
llO\
OO\
OOlllO\
l
>
1
)
{
TA_AS\
S\
ERT
(
llO\
l\
lOlOlO\
l
->
lOlO\
llOO\
Ol
&
Collisi\
on
::
FLAG_\
JOI\
N\
T\

)
;
}
TA_ASSER\
T
(
llOllO\
l\
Ol\
Ol
->
lOl\
lOO\
O\
lOll
->
lOl\
OO\
ll\
OOlO\
l
(
)
==
&
lOll\
Ol\
lOlOlO
)
;
TA_ASS\
E\
RT
(
!
llOl\
lO\
l\
OlOl
->
lOllOlOlOOl
(
)
||
llOllOlOl\
Ol\

->
lO\
llOl\
OlOOl
(
)
->
lO\
lOOl\
lOO\
l\
Ol\

(
)
==
&
lOl\
lOllOlOl\
O\

)
;
TA_ASSERT
(
ll\
O\
llOlO\
lO\
l
->
lO\
ll\
OOOlOll
->
Is\
I\
nMo\
vingList
(
)
)
;
TA_ASS\
ERT\

(
!
llOllO\
lOl\
Ol\

->
lOl\
lOlO\
lOO\
l\

(
)
||
llOl\
lOlO\
l\
Ol
->
lOl\
lOl\
OlOOl\

(
)
->
IsInMo\
ving\
List
(
)
)
;
int
ll\
OO\
O\
OO\
ll\
l\
lO\

=
lOllOlO\
O\
ll\
Ol
->
ll\
O\
O\
OOOlll\
l\
l
(
llOOO\
OO\
ll\
lOl\

,
llOl\
lO\
l\
Ol\
Ol
->
lOl\
l\
OO\
Ol\
Oll
->
lO\
l\
OOllOlll\
O\

(
)
,
llOll\
OlOlOl
->
lO\
ll\
O\
l\
O\
lO\
Ol
(
)
?
llOllOl\
O\
l\
Ol\

->
lOllO\
l\
Ol\
O\
O\
l
(
)
->
lOlOOllO\
lllO
(
)
:
-
1
,
lOl\
Ol\
lO\
OOl
)
;
Co\
ll\
i\
sio\
n
*
lOlll\
OllllOO
=
llOllOlOlOl
;
fo\
r
(
int\

lOOOlOOOl\
l\
l
=
0
;
ll\
Ol\
lOl\
O\
lO\
l\

;
llOllOlO\
lO\
l\

=
ll\
OllO\
lO\
lOl
->
GetN\
ext
(
)
,
lO\
OOl\
OO\
Olll
++
)
{
TA_AS\
SERT
(
ll\
Ol\
lO\
lOlOl\

->
lOl\
lO\
OOlOll
)
;
if
(
lOOOlOOOlll
>
0
)
{
TA_AS\
SER\
T
(
llO\
llOlOl\
Ol
->
lO\
llOOOlOll
==
lOlllOlll\
lOO\

->
lOl\
lOOOl\
Oll
)
;
TA_ASSERT
(
llOllOlOlOl
->
lOll\
O\
OOl\
lOO
==
lO\
l\
l\
lOlll\
lOO
->
lOll\
O\
OOllOO
)
;
TA\
_\
AS\
SERT
(
ll\
OllOl\
Ol\
Ol\

->
lOllOlO\
lOOl
(
)
==
lOlllOllll\
O\
O
->
lO\
ll\
OlO\
lOOl
(
)
)
;
}
if
(
llO\
ll\
OlOlO\
l
->
lOlOllOOO\
l
&
Colli\
sion
::
FLA\
G_\
R\
OTATI\
O\
N_C\
O\
N\
STRAINT
)
{
if\

(
llO\
ll\
O\
l\
OlOl\

->
lOllOlOlOOl
(
)
)
{
lO\
llOlOOllOl
->
llO\
O\
OOl\
O\
OOO\
O
(
llOO\
OOOll\
ll\
O
,
lOOOl\
OOOlll\

,
k_v\
3Ze\
ro
,
ll\
Oll\
O\
lOlOl
->
lOOOlOOOOO
.
Cross
(
llOl\
lOlOlOl\

->
lOOOOlllll
-
llOllOlOlOl
->
lOllOOO\
lO\
l\
l
->
GetC\
ent\
erOfM\
ass\

(
)
)
,
k_\
v3Z\
ero
,
-
llO\
llOlOl\
O\
l
->
lOOOlOO\
OOO
.
Cr\
o\
ss\

(
ll\
Oll\
Ol\
OlOl\

->
lOOOOl\
l\
lll
-
llO\
ll\
O\
lOlOl
->
lOl\
lOlO\
lOOl
(
)
->
GetC\
ent\
erOfM\
ass
(
)
)
)
;
}
else
{
lOl\
l\
OlOO\
ll\
Ol\

->
llOO\
OO\
lOO\
OOO
(
llOO\
O\
O\
OllllO\

,
lOO\
OlOO\
Olll
,
k_v3Zero\

,
llOllOlOlOl
->
lO\
O\
Ol\
O\
OOOO\

.
Cross
(
llOl\
l\
O\
l\
OlO\
l\

->
lO\
OOOll\
ll\
l
-
llOl\
lOlOlO\
l
->
lOllOOOlO\
ll\

->
Ge\
tCe\
nt\
e\
rOfMa\
ss
(
)
)
)
;
}
}
el\
se\

{
if
(
llOllOlOl\
Ol
->
lOll\
OlOlOOl
(
)
)
{
lOllOlOO\
llOl\

->
llOO\
OOl\
OOOO\
O\

(
llOO\
OOOllllO
,
lOOOlOOOl\
ll
,
llO\
llOl\
OlOl
->
lO\
O\
OlOOO\
OO
,
ll\
Ol\
lOlOlOl
->
lOOOlOO\
OOO
.
Cross
(
llO\
l\
lOlOlOl
->
lOOOOlllll
-
llOllOl\
O\
lO\
l
->
lOllOOOlOl\
l
->
GetCenterOfMass
(
)
)
,
-
llOl\
lO\
lOlOl
->
lOOOlOOOOO
,
-
llOl\
l\
O\
lO\
lOl\

->
lOO\
OlOOO\
OO\

.
Cr\
oss
(
ll\
Ol\
lOl\
OlOl
->
lO\
OO\
Oll\
ll\
l
-
llOll\
O\
lOlOl\

->
lOl\
l\
Ol\
Ol\
OOl
(
)
->
GetCen\
terOfM\
ass
(
)
)
)
;
}
el\
se
{
lOl\
lOlOOllOl
->
llOOOO\
lO\
OO\
OO
(
llOO\
O\
OOlll\
lO
,
lOOOl\
OOOlll
,
llOll\
OlOl\
O\
l\

->
lOOOl\
OOOOO
,
ll\
Oll\
OlOlO\
l
->
lOOOlOOO\
OO
.
Cros\
s
(
llOllOlOlO\
l
->
lOOO\
Olllll
-
llOllO\
lOlOl\

->
lOl\
lO\
OOlOll
->
Ge\
tCe\
nterO\
fMass\

(
)
)
)
;
}
}
}
}
lOllOlO\
O\
llOl
->
llOOO\
O\
l\
OOOOl\

(
)
;
lO\
O\
lOlllO\
Ol
(
lOllOOlOllOl
)
;
}
fl\
oat
TAC_CAL\
L\

llO\
O\
O\
OlOOOl\
O
(
flo\
at\

lOO\
lllOO\
llOl
,
Collision
&
ll\
O\
llllOl\
Ol
)
{
Ve\
c3
lO\
lOlOlO\
Olll
=
llOl\
lllOl\
Ol
.
Ge\
tObjectA\

(
)
->
Ge\
tV\
eloc\
ityAtWo\
rl\
dPo\
s\
i\
t\
io\
n
(
llOllllOl\
O\
l\

.
lOOOOlllll
)
-
llOll\
l\
lOlOl
.
GetO\
b\
jec\
tB
(
)
->
Ge\
tV\
eloc\
i\
tyA\
tW\
o\
rldPosit\
ion
(
llOll\
ll\
OlOl
.
lOOOOll\
l\
ll
)
;
flo\
at
lO\
OlOll\
OllO\
l
=
lOlOlOl\
OOl\
ll
.
Do\
t
(
llOl\
l\
l\
lOlOl
.
lOOO\
lOOOO\
O
)
;
if
(
ll\
OllllOlOl
.
lOlO\
llOO\
Ol\

&
Collisi\
on\

::
FLAG\
_USE_PUSH\
_OUT_MODIFI\
ER\

)
{
if
(
(
llOllllOlOl\

.
GetObje\
ctA
(
)
->
IsI\
nMovi\
ngList
(
)
&&
ll\
Ollll\
OlOl\

.
GetObjectB\

(
)
->
IsIn\
M\
ovin\
gList\

(
)
)
||
(
llOl\
ll\
lOlO\
l
.
GetO\
b\
jectA
(
)
->
Move\
me\
nt\
Disa\
ble\
d
(
)
||
llOllllOl\
O\
l
.
Ge\
tObjectB
(
)
->
MovementD\
isabl\
ed
(
)
)
)
{
if
(
ll\
Oll\
ll\
OlOl
.
lOlOllOOOl
&
Collis\
io\
n
::
FLAG\
_US\
E_PUSH_OU\
T_MODI\
FIER
)
{
lOOlOllOll\
Ol\

-=
llOll\
llOlO\
l
.
lOllO\
OlOlOl\

*
lOlO\
lll\
llOOl
*
1.0f
;
}
el\
se
lO\
OlOl\
l\
OllOl
-=
llOlll\
lOlOl
.
lOl\
lOOlOlOl
*
1.0f
;
}
els\
e
{
if
(
llOllllO\
lOl\

.
lO\
lOllO\
OOl\

&
Coll\
ision
::
FLAG_\
JOI\
NT
)
{
lOOl\
OllOll\
Ol
-=
llOl\
l\
llO\
lO\
l
.
lOllOO\
l\
OlOl
*
0.1f
;
}
else\

{
if
(
llOlll\
lOlO\
l\

.
GetObje\
ctA
(
)
->
IsInMovingLi\
st
(
)
)
{
if
(
ll\
O\
llllO\
lOl
.
Ge\
tNormal
(
)
.
y
>
0.0f
)
{
if
(
llOlll\
lOlOl
.
lOlOll\
O\
OOl\

&
Co\
lli\
s\
io\
n
::
FL\
AG\
_US\
E\
_PU\
SH_OUT_MODIFIE\
R\

)
{
lOO\
lOllOllOl
-=
llOllllOl\
Ol
.
lO\
llOO\
l\
O\
lOl
*
lOlOlllllOOl
*
1.0f
;
}
el\
se
lOOlO\
llOllO\
l\

-=
llOllll\
O\
l\
O\
l
.
lOllOOl\
OlO\
l\

*
1.0f
;
}
}
els\
e
if\

(
llOll\
llO\
l\
O\
l
.
Ge\
t\
ObjectB
(
)
->
IsInM\
ovin\
gList
(
)
)
{
if
(
ll\
OllllOlOl
.
GetNo\
rmal
(
)
.
y
<
0.0f
)
{
if
(
ll\
OllllOlOl
.
lOlOllOOOl
&
Col\
lisi\
on
::
FL\
AG_USE\
_PUSH\
_OU\
T_MODI\
FIER
)
{
lO\
OlOll\
O\
llOl
-=
llOllllO\
lOl
.
lOllOOl\
O\
lO\
l
*
lOlOll\
lllOOl
*
1.0f
;
}
els\
e
lO\
O\
lOll\
OllOl\

-=
llO\
l\
lllO\
lOl
.
lOl\
l\
OOlOlOl\

*
1.0f
;
}
}
}
}
}
else\

{
lOO\
lOllOllO\
l
-=
ll\
O\
lll\
lOl\
Ol
.
lOllO\
OlOl\
O\
l
;
}
lOOl\
Oll\
OllOl
+=
llO\
l\
lllOlOl
.
lOllOOl\
OOll
;
TA_ASSERT\

(
Float\
IsOK
(
lO\
O\
lOl\
l\
OllOl\

)
)
;
retu\
rn\

lO\
Ol\
OllOllOl
;
}
voi\
d\

Physi\
cs
::
lOll\
OllOlll\
l
(
flo\
at\

lOOll\
lOOll\
O\
l\

,
lO\
lOll\
lOlllO
&
lOl\
l\
Ol\
lOlOlO
,
in\
t\

lOllO\
llO\
Ol\
l\
l
)
{
lO\
l\
O\
lllOlllO\

::
It\
e\
rat\
or
lO\
lOlllOO\
OO\
O
=
lOllOl\
lOlO\
l\
O
.
lOlO\
OOO\
lO\
O
(
)
;
for\

(
int
llO\
OOOl\
O\
OOll
=
0
;
!
lO\
lOlllOOOOO\

.
AtEn\
d\

(
)
;
++
lOlOlllOOOOO
,
++
ll\
OO\
OO\
l\
OOOll
)
{
Col\
lis\
ion\

*
llOl\
lOlOl\
O\
l\

=
&
*
lOlO\
ll\
lOOOO\
O
;
for
(
int
lOO\
OlOOOlll
=
0
;
llOl\
lO\
lOlOl
;
llOl\
lO\
l\
O\
lOl
=
llOl\
lOl\
Ol\
Ol
->
GetNe\
xt
(
)
,
lOO\
O\
lOOOll\
l
++
)
{
Co\
llisio\
n
&
llOlll\
lO\
l\
O\
l
=
*
llOll\
OlO\
lO\
l\

;
lOllOlO\
OllO\
l\

->
llO\
OOOl\
OOlOO
(
llOOOOl\
OOOll
,
lOO\
OlO\
O\
Olll
,
llOOOOlOOOlO
(
lOOl\
l\
lOOl\
lOl\

,
llO\
llllOl\
Ol
)
)
;
}
}
}
voi\
d
Physics\

::
llO\
OO\
OlOOlOl
(
float\

lOOlllOOll\
Ol\

,
Co\
llisi\
o\
n
&
ll\
Ol\
lllOlOl\

)
{
llOl\
lllO\
l\
Ol
.
lOllOOlOl\
Ol
=
0.0f
;
float
lOOllO\
OO\
OOOl
=
Min\

(
ll\
Ol\
l\
l\
l\
OlO\
l
.
Ge\
tOb\
je\
ctA
(
)
->
lOOll\
OOO\
O\
OlO\

(
)
,
llOl\
ll\
l\
OlO\
l
.
Ge\
tOb\
j\
e\
ct\
B
(
)
->
lOO\
llO\
OOOOlO
(
)
)
;
if
(
llOll\
llOlO\
l
.
lOlOllOOO\
l
&
Collision
::
FLA\
G_C\
ONSTRAI\
N_\
IN_\
BOTH_D\
IRECTION\
S
)
{
if
(
(
llOll\
l\
lO\
lO\
l
.
lOlO\
llOOO\
l
&
(
Collisi\
on
::
FLAG\
_F\
RIC\
T\
ION
)
)
==
0
)
{
llO\
ll\
llOlOl
.
lOllOOlOlOl
=
ll\
O\
l\
lll\
O\
lOl
.
lOll\
OOlOOOl
;
Cla\
m\
pP\
osNe\
g
(
llOllllO\
lOl
.
lO\
llO\
O\
lOlOl
,
2.0f
*
lOOll\
O\
OOOOOl
)
;
if
(
(
ll\
OllllOl\
O\
l
.
lOl\
Ol\
lO\
OO\
l\

&
Co\
l\
lis\
ion
::
FLA\
G_DISAB\
LE_PUSH\
OU\
T
)
==
0
)
{
llO\
lll\
lOlOl
.
lO\
llOOl\
OlO\
l
*=
80.0f
;
flo\
at
lOOOOOlO\
O\
l\

=
lO\
Ol\
lOO\
OOOOl
*
0.1f
;
float\

ll\
OO\
O\
Ol\
OOll\
O
=
Max
(
llOl\
ll\
lOlO\
l
.
GetO\
bj\
ectA\

(
)
->
Ge\
tLinea\
r\
V\
el\
oc\
it\
y
(
)
.
Get\
M\
a\
gnit\
ude\

(
)
,
llO\
ll\
llO\
l\
Ol
.
GetO\
b\
jectB\

(
)
->
GetLi\
near\
V\
elocity
(
)
.
Ge\
t\
Magn\
itu\
de\

(
)
)
*
2.0f
+
lOO\
llOO\
OOO\
Ol\

*
1.5f
;
if
(
ll\
Ol\
lll\
OlOl
.
lOl\
lOOlOl\
Ol\

>
lOOOOOlO\
O\
l
)
{
llOl\
lllOlO\
l
.
lOl\
l\
OOlOlOl\

-=
lOOOOOlOOl
;
llOllllOlOl
.
lOllO\
Ol\
OlOl\

*=
0.1f
;
ll\
Ollll\
O\
lOl
.
lOl\
l\
O\
Ol\
OlO\
l
+=
lOOO\
OO\
l\
OO\
l
;
if
(
llOllll\
OlOl
.
lOllOOlOlO\
l
>
ll\
OOOOlOOllO
)
llO\
llll\
Ol\
Ol
.
lOll\
O\
OlO\
lOl\

=
ll\
OOO\
OlO\
OllO
;
}
els\
e
if
(
llOl\
l\
l\
lO\
l\
Ol
.
lOl\
lOOlOlOl
<
-
lOOOO\
Ol\
OO\
l\

)
{
llOllll\
OlOl\

.
lO\
llO\
OlOlOl
+=
lOOO\
OOlOOl\

;
llOllll\
OlOl
.
lOl\
l\
OOlOlOl
*=
0.1f
;
llOlll\
l\
OlOl
.
lOllOOlOl\
Ol\

-=
lOOOOO\
lOOl
;
if\

(
llOlll\
l\
Ol\
Ol
.
lOllOOl\
O\
lO\
l\

<
-
ll\
O\
OOOlOO\
llO
)
llOl\
ll\
l\
OlOl
.
lO\
llOOl\
Ol\
O\
l\

=
-
llOOOOlOOll\
O
;
}
}
els\
e\

{
llOl\
lll\
O\
l\
O\
l
.
lOllOOlOlOl
*=
1.2f
;
}
}
}
else
{
if
(
!
(
llOllllO\
lO\
l
.
lOl\
Oll\
OOOl
&
(
Collisi\
o\
n
::
FLAG_FRI\
C\
T\
ION
|
Colli\
sion
::
FLAG_D\
IS\
ABL\
E\
_PUSH\
OU\
T
)
)
)
{
Vec3
lO\
lO\
lOlO\
Olll
=
llOlll\
l\
O\
l\
Ol
.
GetObjectA
(
)
->
Ge\
tV\
e\
lo\
c\
it\
yAtW\
orldPosition
(
llOl\
lll\
Ol\
Ol
.
lOO\
OOlllll
)
-
llO\
llllOlOl
.
Get\
Ob\
jec\
tB\

(
)
->
GetV\
elocityA\
tWorl\
dPo\
si\
tio\
n
(
llOll\
llOlO\
l\

.
lO\
OOOllll\
l
)
;
floa\
t
lOOl\
OllOll\
Ol\

=
lOlOlOlOO\
lll
.
Dot
(
llOllllO\
l\
Ol
.
lOOOlOOOOO
)
;
con\
st
floa\
t\

llOOO\
Ol\
OOlll
=
0.02f
*
lO\
O\
l\
l\
OOOOO\
Ol
;
if
(
(
llOl\
l\
ll\
Ol\
O\
l\

.
lO\
lOllOO\
O\
l
&
Col\
l\
isi\
on
::
FLA\
G_JOIN\
T_L\
IMIT
)
&&
(
llOl\
lllOlOl
.
lOl\
OllOO\
O\
l\

&
Co\
llision
::
FLAG\
_DISABLE_\
PUSH\
OUT
)
==
0
)
{
if
(
llOll\
llOlO\
l
.
lOllOO\
lOOO\
l
>
0.0f
)
{
llOllllO\
l\
Ol
.
lOll\
OOl\
O\
lOl
=
llOll\
llOlOl
.
lOll\
OOlOOOl
/
lOOlllOOllO\
l
*
0.25f
;
if
(
llO\
l\
lllO\
lOl\

.
lOllO\
Ol\
OlOl
>
lO\
Ol\
lOOOOOOl
*
0.5f
)
llO\
l\
lllOlO\
l\

.
lO\
llOOl\
OlOl\

=
lO\
O\
ll\
O\
O\
OOOO\
l
*
0.5f
;
llOl\
l\
ll\
O\
l\
Ol
.
lOlOl\
lOOO\
l
|=
Colli\
sion
::
FLAG_U\
S\
E_PUSH\
_O\
U\
T_\
MO\
D\
I\
FIE\
R
;
}
els\
e
{
ll\
Oll\
llO\
lOl\

.
lOllOOlO\
lOl
=
llOllllO\
lOl
.
lOl\
lO\
O\
lOO\
Ol
/
lOO\
lllOOllOl
*
0.7f
;
}
}
el\
se
{
if
(
llOlll\
lOlOl
.
lOllOOlOO\
Ol
>
0.0f
)
{
ll\
Olll\
lOlOl\

.
lO\
l\
l\
OOlOOll\

=
lOO\
lOllOl\
lOl
*
llOllllOlO\
l\

.
lO\
ll\
OO\
lOOll\

;
if\

(
llOllllOlOl
.
lOllOOl\
OOl\
l
>
-
0.1f
*
lOOllOO\
OOOOl
)
llOllll\
OlOl
.
lOll\
OOlOOll\

=
0.0f
;
const
float
llOOOO\
lOlOOO
=
0.1f
*
lOl\
llOO\
OlllO
;
fl\
o\
at
lOl\
lOO\
lO\
OOl
=
llOllllOl\
Ol
.
lOllOOlOOOl
-
ll\
OOOO\
lO\
O\
l\
ll
;
if
(
lOll\
OOlOOOl
>
llOOO\
OlOlOO\
O\

)
lOllOO\
lOOO\
l
=
llOOO\
O\
lO\
lO\
OO
;
if
(
lO\
ll\
OOl\
O\
OO\
l
<
0.0f
)
{
llOllllOlOl
.
lO\
llOOlOlOl
=
lO\
llOOl\
OOOl
/
lOOlllO\
OllOl
*
0.7f
;
}
else
{
llOll\
llO\
l\
Ol\

.
lOlOllOOOl
|=
Co\
llis\
i\
o\
n
::
FLAG_U\
SE_\
PUSH\
_\
O\
UT_MO\
DIFIER\

;
lOllOOlO\
OOl
*=
50.0f
;
const
floa\
t
llOOOOlO\
l\
O\
O\
l
=
0.02f
*
lO\
O\
ll\
OOOOO\
Ol\

;
if
(
lOll\
OO\
l\
OOOl
>
ll\
OOOOl\
OlOOl\

)
{
lOllOO\
l\
OO\
Ol
-=
llOO\
OOlO\
lO\
Ol
;
lOllOOlOOOl\

*=
1.0f
/
50.0f
;
lOllOOlOOOl
+=
ll\
O\
O\
O\
OlO\
lO\
Ol
;
}
llOl\
ll\
lO\
l\
Ol
.
lOllOOlOlOl
=
lOllOOlOOO\
l
;
}
}
else
{
if
(
(
ll\
Oll\
llO\
l\
Ol
.
lOlO\
l\
lOOO\
l
&
Collision
::
FL\
AG\
_JOINT_LIMIT
)
&&
(
ll\
OllllO\
lOl
.
lO\
lOllOOOl
&
Collision\

::
FL\
A\
G_DIS\
ABLE_PUSHOU\
T
)
==
0
)
{
ll\
O\
l\
ll\
lOl\
Ol\

.
lOll\
O\
OlOlOl\

=
llO\
llllOlOl
.
lO\
l\
l\
OOlO\
O\
Ol
/
lO\
Oll\
lOO\
llOl\

*
0.7f
;
}
el\
se
{
TA_ASS\
E\
RT
(
llOl\
lllO\
l\
Ol\

.
lllOllllOO
>=
0.0f
)
;
TA_ASS\
ERT
(
ll\
Ol\
l\
llOl\
Ol\

.
ll\
l\
O\
l\
l\
l\
l\
O\
O\

<=
1.0f
)
;
llO\
ll\
llOl\
O\
l
.
lO\
llO\
OlOlOl
=
lOO\
lO\
llOllOl\

*
llO\
l\
l\
ll\
OlOl\

.
lllOlll\
lOO\

+
ll\
OO\
OOlOOl\
ll\

/
lOOll\
lOOllOl\

;
if
(
llO\
llllO\
l\
Ol
.
lOllOO\
lOlOl\

>
0
)
llOll\
llOlOl
.
lO\
ll\
OOl\
OlOl
=
0
;
float
lOl\
lOO\
lOOll
=
-
(
lOOlO\
llOllO\
l
*
(
1.0f
+
ll\
Ol\
lllOlOl
.
ll\
l\
Oll\
ll\
OO
)
)
;
lOl\
lOOlOO\
ll
*=
llOl\
l\
l\
lOl\
O\
l
.
lOll\
OOlO\
Oll
;
if
(
lO\
llO\
O\
lOOll
<
2.0f
*
lO\
Ol\
lOOOO\
OOl
)
lO\
llO\
Ol\
OOl\
l
=
0.0f
;
llOll\
llOlOl
.
lOl\
l\
OOlO\
l\
O\
l
+=
lOl\
l\
OOlOOl\
l
;
}
ll\
OllllOl\
Ol
.
lO\
llOOlOOl\
l
=
0.0f
;
}
}
}
}
}
bool
Physics
::
lOl\
lO\
l\
llOO\
OO
(
)
{
lO\
OlOlllO\
ll
(
lO\
l\
l\
OOlOl\
ll\
O
)
;
retu\
rn
lOll\
Ol\
OO\
ll\
O\
l
->
ll\
OO\
OO\
lOlOlO\

(
)
;
}
voi\
d
Physi\
cs
::
ll\
OOOO\
lO\
lOll\

(
)
{
lOO\
lOllO\
lll\

(
lO\
llOOl\
OlllO
)
;
lOllOlOOl\
lOl\

->
llOOO\
Ol\
OllOO
(
)
;
lOOl\
Olll\
OOl
(
lOll\
OOlOlllO
)
;
}
bool
Ph\
ysic\
s\

::
lOl\
l\
Olll\
OOOl\

(
lOlOlllO\
lll\
O\

&
lOl\
lOllOlOlO
)
{
exte\
rn
float
lO\
O\
lO\
llll\
l\
OO
;
lOOlOlll\
l\
lOO
=
1.0f
;
#ifdef llOOOOlOllOl
float\

llOOO\
OlO\
l\
ll\
O
=
0.0f
lOl\
O\
lllOlllO\

::
llOO\
OOOOllOO
llOOOOOO\
ll\
O\
l
=
lOl\
lOllOlOl\
O
.
llOOOOO\
O\
ll\
lO
(
)
;
for\

(
;
!
llOOOOOOllO\
l
.
At\
En\
d
(
)
;
++
llOOOOOOl\
l\
O\
l\

)
{
DynamicOb\
ject
&
lO\
llllOlOll\
l
=
*
*
ll\
OO\
O\
OOO\
ll\
Ol\

;
ll\
O\
OO\
OlOlll\
O
+=
0.5f
*
lOll\
l\
lOlOlll
.
Ge\
t\
L\
in\
earVeloc\
ity
(
)
.
GetMagn\
it\
ud\
e\
Sqr\
d\

(
)
*
lOl\
ll\
lOlOll\
l\

.
Get\
Ma\
ss
(
)
;
fl\
o\
a\
t\

ll\
OOOOl\
Olll\
l
=
0.5f
*
(
lOllll\
Ol\
O\
lll
.
GetAngularVeloc\
i\
ty
(
)
*
lO\
l\
lllO\
lOlll
.
GetWo\
rl\
dSpaceInert\
ia
(
)
)
.
Dot\

(
lOllllOl\
Olll
.
Ge\
tAngular\
Velo\
cit\
y
(
)
)
;
TA_ASS\
ER\
T\

(
llOOOO\
l\
O\
llll\

>=
0.0f
)
;
llOOO\
OlOl\
llO\

+=
llO\
O\
OOlOl\
lll
;
}
#endif //
lO\
l\
Ol\
llO\
lllO
::
llOO\
OOOOllOO
ll\
O\
OOOOOl\
lOl\

;
float
llOOOOlOl\
llO
=
0.0f
;
if\

(
!
lOllOllOlO\
lO
.
llOO\
O\
OllOOOO
(
)
)
{
fo\
r\

(
llO\
OOOO\
OllOl
=
lOllOllOlOlO\

.
llOOO\
O\
OOlll\
O
(
)
;
!
llOOOO\
OOllOl\

.
AtEnd
(
)
;
++
llOOOOOOl\
l\
Ol\

)
{
Dynami\
cObj\
ect
&
lOl\
ll\
l\
ll\
llO
=
*
*
ll\
OOO\
OOOllO\
l
;
TA_\
A\
SSERT\

(
lOllO\
lO\
OllOl\

->
Ge\
tM\
a\
ss
(
lOll\
llll\
ll\
O
.
lOlOOl\
l\
OlllO\

(
)
)
>
0.0f
)
;
TA_ASSERT
(
lOll\
ll\
lll\
lO\

.
Ge\
t\
Ma\
ss
(
)
>
0.0f
)
;
float
llOOOO\
llO\
OOl\

=
lOllOlOOll\
O\
l
->
GetMas\
s
(
lOl\
lllllllO\

.
lOlO\
Ol\
lOlllO\

(
)
)
/
lOl\
lll\
l\
lllO
.
Ge\
tMass\

(
)
;
lO\
ll\
llllllO
.
lOlOOO\
lOOOll
(
)
;
flo\
at\

llO\
OO\
OllOO\
lO
=
lOlllllll\
lO\

.
lOOllOO\
OOO\
lO
(
)
*
(
0.02f
*
60.0f
)
;
ll\
OOOOl\
OlllO
+=
0.5f
*
llOOOO\
l\
lOOOl
*
(
lOll\
ll\
l\
l\
llO
.
Get\
L\
in\
earVe\
l\
o\
city
(
)
.
GetMagnitu\
d\
eSqrd
(
)
+
llOOOOllO\
Ol\
O
*
ll\
OOOOllOOlO
)
*
lO\
ll\
ll\
llll\
O
.
Ge\
tMa\
ss
(
)
;
floa\
t
llOO\
O\
OlO\
llll
=
0.5f
*
llOOOOllOOOl
*
(
lOllllllllO
.
GetAn\
g\
ular\
V\
elocity\

(
)
*
lOl\
llllll\
lO
.
Get\
WorldSp\
ace\
Inerti\
a
(
)
)
.
Dot
(
lOllllllll\
O\

.
GetAng\
ularVelocit\
y
(
)
)
;
TA_\
ASS\
ERT
(
llO\
O\
OOlO\
llll
>=
0.0f
)
;
ll\
OOOO\
lO\
lll\
O\

+=
ll\
O\
O\
O\
Ol\
Ollll
;
}
}
lOlOl\
l\
l\
Ol\
llO\

::
Iter\
ator
lOlO\
l\
llOO\
OOO
=
lOllOl\
lO\
l\
O\
lO\

.
lOlOO\
OOlO\
O
(
)
;
for
(
int
llOOO\
OlOO\
Oll
=
0
;
!
lOl\
Ol\
llOOOO\
O\

.
AtEnd
(
)
;
++
lOl\
Ol\
ll\
OO\
OO\
O
,
++
llOOOO\
lO\
OOll
)
{
Co\
ll\
is\
io\
n
*
ll\
O\
ll\
OlOlOl
=
&
*
lOlOl\
ll\
OOOOO
;
for\

(
int
lOO\
O\
lO\
OOlll\

=
0
;
llOllOlOlOl
;
ll\
O\
llOlO\
l\
Ol
=
llOllOlOlOl\

->
Ge\
tNe\
xt\

(
)
,
lO\
O\
O\
lO\
OO\
ll\
l
++
)
{
Collisio\
n
&
llO\
ll\
ll\
Ol\
Ol\

=
*
llO\
l\
l\
Ol\
O\
lOl\

;
flo\
at
lOllOOlOO\
lO
=
lO\
l\
lO\
l\
OOllOl
->
GetImp\
ulse\

(
llOOOOl\
OO\
Oll
,
lOOO\
l\
OOOlll
)
;
if
(
lO\
l\
lOOlO\
OlO\

==
0.0f
)
continue
;
Vec3
ll\
OOOOllO\
Ol\
l
=
llOllll\
OlOl
.
lOOOlOO\
OOO
*
lOllOO\
l\
OOlO
;
TA_ASSERT
(
Flo\
atIsOK\

(
lOllOlOOllO\
l
->
GetImp\
ulse
(
llOOOOlOOOll
,
lOOOlO\
OOlll
)
)
)
;
TA_ASSER\
T
(
Fl\
o\
atI\
sOK
(
lO\
llOOlOOlO
)
)
;
Dy\
nam\
i\
c\
Ob\
ject\

*
llO\
OO\
O\
lO\
l\
l\
O
=
ll\
O\
lll\
lOlO\
l\

.
Get\
O\
bj\
ectA
(
)
;
TA_AS\
S\
ERT
(
llOO\
OO\
lO\
llO\

->
Is\
In\
Movi\
ngList
(
)
)
;
TA_ASSER\
T\

(
lO\
llOl\
OOllOl
->
GetMass
(
ll\
OOOOlOl\
l\
O\

->
lOl\
O\
OllOlllO
(
)
)
>
0.0f
)
;
fl\
oat
llOOOOllOlOO
=
1.0f
/
lO\
llOlOOllOl
->
Ge\
t\
M\
ass
(
llO\
OOOlOllO
->
lOlOOllO\
ll\
lO
(
)
)
;
if
(
(
llO\
ll\
llO\
lO\
l
.
lO\
l\
OllO\
OO\
l
&
Col\
li\
s\
io\
n
::
FLAG\
_RO\
TATION_CONSTRAI\
NT
)
==
0
)
{
Vec3\

lOlO\
lOOOlOOl
=
llO\
OO\
O\
lOll\
O
->
Get\
Li\
ne\
arVelocity
(
)
;
lOlOl\
OOOlOOl
+=
ll\
OOO\
OllOOll
*
llOOOOl\
lO\
lOO
;
llOOO\
Ol\
Ol\
l\
O
->
Se\
tLine\
arVeloci\
ty
(
lOlOlOO\
Ol\
OO\
l\

)
;
}
Ve\
c3
lOlO\
lOOOlOlO
=
llOOO\
OlO\
llO
->
Ge\
tAngularV\
e\
l\
oc\
it\
y
(
)
;
lO\
lOlOOOlOlO
+=
llOO\
OOll\
OOll\

.
Cross\

(
llOOOOlOll\
O\

->
GetCent\
erO\
fMa\
ss\

(
)
-
llOllllO\
lOl
.
lOO\
OOlllll\

)
*
llOOOOlOl\
l\
O\

->
GetMass
(
)
*
llOOOO\
llOlO\
O
*
llOO\
OOlOl\
lO
->
GetWor\
l\
d\
Sp\
aceI\
nve\
rseIn\
er\
tia
(
)
;
llOOOO\
l\
O\
l\
lO\

->
Se\
tAn\
g\
ul\
arVelocit\
y
(
lO\
lOlOOOlOl\
O
)
;
if
(
llO\
ll\
llO\
lOl\

.
lOl\
lO\
lOlOOl
(
)
)
{
llOOOO\
lO\
ll\
O
=
ll\
OllllOlOl
.
lOll\
O\
l\
OlOOl
(
)
;
TA_AS\
SERT
(
lOl\
lO\
lOOl\
lOl
->
Get\
Mass
(
ll\
OOOO\
l\
OllO
->
lOlOO\
l\
l\
Ol\
llO
(
)
)
>
0.0f
)
;
fl\
o\
at
llOOOOllOl\
OO
=
1.0f
/
lOl\
lOlOOllOl
->
Get\
Ma\
ss
(
llOOOOlOl\
l\
O
->
lO\
l\
O\
Oll\
Oll\
lO
(
)
)
;
if
(
(
llOll\
ll\
OlOl\

.
lO\
lOl\
lO\
O\
O\
l\

&
Col\
lisio\
n
::
FL\
A\
G_ROTATIO\
N\
_CONSTRAIN\
T
)
==
0
)
{
Vec3
lO\
l\
O\
lOOOlOO\
l
=
llOOOOlO\
llO\

->
Ge\
tLi\
nea\
rVelocit\
y
(
)
;
lOlOlOOO\
l\
OO\
l
-=
ll\
OOOOllOOll
*
llO\
OOOl\
lOl\
OO\

;
llO\
OOOlOl\
lO
->
SetLinea\
rVel\
ocity
(
lOlOlOOOlOO\
l\

)
;
}
lOlOlO\
O\
O\
lOlO
=
ll\
OOOO\
lOllO
->
Ge\
tAngularV\
elo\
city\

(
)
;
lOlOlO\
OOlOlO
-=
llO\
O\
OOllO\
Oll
.
Cross
(
llOOOOlOl\
lO
->
Get\
CenterOf\
Mass\

(
)
-
llO\
l\
lllOlOl\

.
lOOOO\
lllll
)
*
llO\
OOOl\
Ol\
lO
->
Ge\
tM\
a\
ss
(
)
*
llO\
OOOl\
lOlO\
O\

*
llO\
OOOlOllO
->
GetWorldSpac\
eInverseIne\
r\
ti\
a
(
)
;
ll\
O\
OO\
O\
lOl\
lO
->
SetAn\
gu\
larVelo\
c\
ity
(
lOlOlOOO\
lO\
lO
)
;
}
}
}
if
(
!
lOll\
OllOlOlO\

.
llOOOOllOO\
OO
(
)
)
{
fl\
o\
at
llO\
O\
O\
OllOl\
O\
l
=
0.0f
;
for
(
llO\
OOOOO\
llOl
=
lO\
l\
l\
O\
l\
lO\
lO\
lO
.
ll\
OO\
O\
OOOll\
lO
(
)
;
!
ll\
OOO\
OOOllOl
.
AtEnd\

(
)
;
++
llOO\
OOO\
O\
l\
l\
Ol
)
{
Dyn\
ami\
c\
Object
&
lOlllll\
ll\
lO
=
*
*
llOO\
OO\
OOllO\
l
;
TA_A\
S\
SERT
(
lOllOl\
OOll\
Ol
->
Get\
Mas\
s\

(
lO\
lll\
lll\
l\
lO
.
lOlOOllOll\
lO
(
)
)
>
0.0f
)
;
TA_ASS\
ER\
T
(
lO\
l\
lllllll\
O\

.
GetMass
(
)
>
0.0f
)
;
floa\
t
llOOOOll\
OOO\
l
=
lOll\
O\
lO\
OllOl
->
Ge\
tM\
ass\

(
lOllllllll\
O
.
lOlO\
Oll\
Oll\
l\
O\

(
)
)
/
lOll\
lllll\
l\
O
.
GetM\
as\
s\

(
)
;
llOO\
OOllOlO\
l
+=
0.5f
*
llOOOOllOOO\
l
*
lO\
ll\
llllllO\

.
Get\
Li\
nearVe\
locit\
y
(
)
.
GetMagnitude\
Sq\
rd\

(
)
*
lOll\
ll\
llllO
.
Get\
Mass\

(
)
;
flo\
a\
t
llOO\
OO\
lOl\
l\
ll
=
0.5f
*
llOOO\
OllOOOl\

*
(
lOlllll\
ll\
lO
.
GetAn\
g\
u\
larVelocity
(
)
*
lOllllllllO\

.
GetWorld\
Spac\
eIn\
er\
t\
i\
a
(
)
)
.
Dot
(
lOll\
ll\
l\
lllO\

.
GetAn\
g\
ularVel\
oci\
ty
(
)
)
;
TA\
_ASSERT
(
llOO\
OO\
lO\
l\
lll
>=
0.0f
)
;
llOOO\
OllOlO\
l
+=
llO\
OOOl\
O\
lll\
l\

;
}
if
(
llO\
OOOllOl\
O\
l
*
0.5f
>
llOOO\
OlOlllO\

)
{
for\

(
ll\
OOOO\
OOllOl
=
lOllOllOlOlO
.
ll\
OOOOO\
Oll\
lO
(
)
;
!
ll\
OOOOO\
OllOl\

.
AtE\
nd
(
)
;
++
ll\
OOO\
OO\
O\
llOl\

)
{
Dyn\
am\
icObject\

&
lOllll\
ll\
llO\

=
*
*
llOO\
OOOOll\
Ol
;
lO\
lllllll\
lO\

.
lOl\
OOOlOOlOO
(
)
;
}
re\
t\
urn
fals\
e
;
}
}
lOl\
Ol\
l\
lOO\
OOO
=
lOllO\
l\
lO\
lOlO
.
lOl\
O\
OOOlO\
O
(
)
;
for
(
int
llOOOOlOOOll
=
0
;
!
lOlOll\
l\
OO\
OOO\

.
AtEnd
(
)
;
++
lOl\
Oll\
l\
OO\
OOO
,
++
llOO\
OOlOOOl\
l
)
{
Coll\
ision
*
llOl\
lO\
lO\
lO\
l\

=
&
*
lOl\
Oll\
lOOOO\
O
;
for
(
int
lOOOlO\
OOl\
ll
=
0
;
llOl\
lOlO\
lOl
;
ll\
OllOlOlOl
=
llO\
llOl\
OlOl
->
Ge\
tNext
(
)
,
lOOOlOOOlll
++
)
{
Co\
llis\
i\
on
&
llO\
ll\
llOl\
Ol\

=
*
llOll\
O\
lOlO\
l
;
float\

lOllOOlOOlO\

=
lOll\
OlOO\
llO\
l\

->
GetImpulse
(
llO\
OO\
OlOO\
Ol\
l
,
lOOOl\
O\
O\
Ol\
ll
)
;
if
(
lOl\
lO\
OlOOlO
==
0.0f
)
contin\
ue
;
llO\
lll\
l\
Ol\
O\
l
.
lOl\
lO\
Ol\
O\
OlO
+=
lOllOOlO\
O\
lO
/
lO\
ll\
lOOO\
lll\
l
;
TA_A\
SSERT
(
Float\
IsO\
K\

(
lOllOlOOllOl\

->
GetImpul\
se
(
ll\
O\
OO\
O\
l\
OOO\
ll
,
lO\
O\
OlO\
OOlll
)
)
)
;
TA\
_\
ASSERT
(
Floa\
tIsOK\

(
lOll\
OOlO\
OlO
)
)
;
Dyna\
m\
icObject
*
llOOOO\
lO\
llO
=
llOllllO\
lOl
.
GetObjec\
tA
(
)
;
TA\
_ASSERT
(
llOO\
OOlOllO
->
IsI\
nMovingList\

(
)
)
;
TA_A\
SSER\
T
(
lOll\
OlOO\
llO\
l
->
Get\
M\
as\
s
(
ll\
O\
OOOlO\
llO
->
lOlOOll\
O\
ll\
lO
(
)
)
>
0.0f
)
;
fl\
o\
at
llO\
OOOllOlOO
=
1.0f
/
lO\
l\
lO\
lOOl\
l\
Ol
->
Get\
Mass
(
llOOO\
OlOl\
lO
->
lOlOOllOll\
l\
O
(
)
)
;
if
(
(
ll\
Ol\
lll\
OlOl
.
lOlOl\
lO\
OOl\

&
Collision\

::
FLAG_ROTA\
T\
ION_CO\
N\
STRAIN\
T\

)
==
0
)
ll\
OO\
OO\
lOl\
lO
->
lOO\
lOl\
lll\
lOl
(
Fabs
(
lOllO\
OlOOlO
*
(
llO\
O\
O\
OlOll\
O
->
Ge\
tMass
(
)
*
llOOOOllOl\
OO
)
)
)
;
if
(
llOllllOl\
Ol
.
lOllO\
lOlO\
Ol\

(
)
)
{
llO\
OOO\
l\
O\
llO
=
llOlll\
lO\
lOl
.
lOl\
lOlOlOO\
l\

(
)
;
TA_A\
SS\
E\
RT
(
lOl\
l\
Ol\
OOllOl
->
GetMass
(
llO\
OOOl\
OllO
->
lOlO\
O\
llOlllO\

(
)
)
>
0.0f
)
;
float
llO\
OO\
Oll\
Ol\
OO
=
1.0f
/
lOll\
OlOOllOl\

->
Ge\
t\
M\
ass\

(
llOOOO\
lO\
ll\
O
->
lOlOOllOlllO
(
)
)
;
if\

(
(
llOllll\
OlO\
l\

.
lOl\
O\
llOOOl
&
Colli\
s\
ion
::
FL\
AG_\
R\
O\
TAT\
ION_CO\
NSTRAI\
NT\

)
==
0
)
llO\
OO\
Ol\
Oll\
O
->
lOO\
lOl\
llllOl\

(
Fab\
s
(
lOl\
lO\
O\
l\
O\
O\
l\
O
*
(
ll\
OOOOlOllO\

->
Get\
M\
a\
ss
(
)
*
llOOOOllO\
lOO
)
)
)
;
}
}
}
#ifdef llOOOOlOllOl
flo\
at
llOOOOllOlOl
=
0.0f
;
llOOOOO\
O\
l\
lO\
l
=
lOllOl\
l\
O\
lOlO
.
llOO\
OOOOlllO\

(
)
;
for
(
;
!
ll\
OOO\
OOOllOl
.
AtEnd
(
)
;
++
llOOO\
O\
OOllOl
)
{
Dyn\
amicOb\
ject
&
lOllll\
OlOlll\

=
*
*
llOOOO\
OOllOl
;
llOOOOllOlOl\

+=
0.5f
*
lO\
ll\
llOl\
Olll
.
Get\
Lin\
ear\
Ve\
l\
o\
cit\
y
(
)
.
GetMagnitude\
Sqrd
(
)
*
lO\
l\
lllO\
lO\
ll\
l\

.
GetMa\
s\
s\

(
)
;
float
llOO\
OOlOl\
ll\
l
=
0.5f
*
(
lO\
l\
ll\
lOlOlll
.
GetA\
n\
gularV\
elocity\

(
)
*
lOllll\
OlO\
lll
.
GetWorl\
dSpaceIne\
rt\
ia
(
)
)
.
Dot
(
lOllllOlOlll
.
Get\
An\
gularVelocit\
y
(
)
)
;
TA_\
AS\
SERT
(
ll\
OOOO\
lOllll
>=
0.0f
)
;
llOOO\
OllO\
l\
O\
l
+=
llOOOOlOlll\
l
;
}
TA_A\
SS\
ERT
(
llOOO\
OllO\
lOl
>=
0.0f
)
;
TA_\
ASSER\
T
(
llOOOO\
l\
O\
l\
ll\
O
>=
0.0f
)
;
llO\
OOOlOlllO\

*=
1.05f
;
if
(
llOOOO\
llOl\
Ol
>
llOOOO\
lO\
lllO
)
{
floa\
t\

llOlOlOlllO
=
Sqrt
(
llO\
OOO\
lOl\
llO
/
llOO\
OO\
llOlOl\

)
;
llOOOOOOl\
l\
Ol
=
lOl\
l\
OllOlOlO
.
llOOOOOOlllO
(
)
;
for
(
;
!
llO\
OOOOOl\
l\
Ol
.
AtEnd
(
)
;
++
ll\
O\
OOOOOllOl
)
{
Dy\
nam\
ic\
Object\

&
lO\
llllOl\
O\
lll
=
*
*
llO\
OO\
OO\
Oll\
Ol
;
lOllllOl\
Oll\
l
.
SetLinea\
rVelocity
(
lOllll\
Ol\
Olll
.
Get\
Li\
nearV\
elo\
c\
ity\

(
)
*
ll\
OlOlOl\
llO
)
;
lOllllO\
lO\
lll
.
SetAngul\
arV\
e\
locity
(
lOll\
llOl\
Olll
.
GetA\
n\
gula\
rVeloc\
i\
ty
(
)
*
llOlOlOlll\
O
)
;
}
fl\
o\
at\

llOOOOllOllO
=
0.0f
;
llOOO\
OOOllOl
=
lO\
l\
lOllOlOlO
.
ll\
OOO\
OOOl\
llO\

(
)
;
for
(
;
!
ll\
OOO\
OOOllOl
.
At\
End
(
)
;
++
llOOOO\
OOllO\
l
)
{
Dynam\
i\
c\
Object
&
lOl\
l\
llOlOl\
ll\

=
*
*
llO\
OOO\
OOll\
Ol
;
llO\
O\
O\
OllO\
ll\
O
+=
0.5f
*
lOllllOl\
O\
lll\

.
GetLi\
nearVe\
locity
(
)
.
Ge\
t\
Ma\
gnitudeSqrd
(
)
*
lOll\
l\
lO\
l\
Olll
.
GetMa\
ss
(
)
;
flo\
a\
t\

llO\
OOOl\
Olll\
l
=
0.5f
*
(
lOl\
lllOlOlll\

.
Ge\
tAngularV\
el\
ocity
(
)
*
lOl\
l\
llOl\
Olll\

.
GetW\
o\
rl\
dSp\
ac\
eInerti\
a
(
)
)
.
Dot
(
lOll\
llOlOl\
ll\

.
Get\
Angu\
lar\
Ve\
locity\

(
)
)
;
TA_\
AS\
SERT
(
llOOOOl\
Ollll
>=
0.0f
)
;
ll\
O\
O\
O\
Oll\
OllO
+=
llO\
OOO\
lOllll
;
}
TA_\
AS\
SERT\

(
Fa\
bs
(
llO\
OOOl\
lOl\
lO
-
llOOOOlOlllO
)
<
0.001f
)
;
}
#endif //
return
tr\
ue\

;
}
vo\
id
Physics
::
lOllO\
lll\
O\
OlO\

(
lO\
lOlllOlll\
O
&
lOllO\
llOlOl\
O
)
{
int
llOOO\
O\
lOOO\
ll
=
-
1
;
lO\
lOll\
lO\
ll\
lO
::
lOllllOOOll\
O
lOl\
ll\
lOOOll\
l
=
lOl\
l\
OllO\
lOlO
.
lO\
l\
lllOOlOOO
(
)
;
for
(
;
!
lO\
ll\
llOOOlll\

.
AtE\
nd
(
)
;
++
lOllllOOO\
lll\

)
{
lO\
l\
OOOOOOl\
Ol
&
lOl\
OOOOll\
O\
lO\

=
*
lO\
llll\
OO\
Ol\
l\
l
;
lOl\
OOOO\
OOlOl
::
Co\
l\
li\
sio\
n\
I\
ter\
a\
to\
r\

lOl\
OlllOO\
O\
OO\

=
lOl\
OOO\
OllO\
l\
O
.
lOlOlllOOOll
.
lOlOOOO\
l\
OO
(
)
;
Col\
lision
*
ll\
OOOOllO\
lll
=
0
;
int
ll\
OO\
OOlllO\
OO\

=
0
;
for
(
;
!
lOlOlllOOOOO
.
AtEn\
d
(
)
;
++
lO\
lOlllO\
OOOO\

)
{
Colli\
s\
ion\

&
llO\
l\
lllOlOl
=
*
lOlO\
lllOOOOO
;
if\

(
llOl\
lllOl\
Ol
.
lOl\
Ol\
lO\
OO\
l
&
Co\
llisi\
on
::
FL\
AG_FRIC\
T\
ION
)
cont\
inue
;
llOOOOlOO\
O\
ll\

++
;
if\

(
llO\
l\
ll\
lOlOl
.
lOlOllOO\
Ol\

&
Col\
li\
sio\
n
::
FL\
AG\
_\
N\
O_FRICT\
IO\
N\

)
co\
ntinue\

;
Dyn\
am\
icObje\
ct
*
llOOOOlO\
ll\
O
=
llO\
ll\
ll\
OlOl
.
GetObj\
ect\
A\

(
)
;
if
(
llOlll\
lOlO\
l
.
lOllOlO\
lOOl
(
)
&&
llOll\
llOlOl
.
lOl\
lOlOl\
OOl\

(
)
->
Ge\
tMa\
ss
(
)
>
llOllllO\
l\
Ol
.
Get\
O\
b\
jectA\

(
)
->
GetMass
(
)
)
ll\
O\
OOO\
lOllO\

=
llO\
llllOlOl
.
lO\
llOlO\
lOO\
l
(
)
;
flo\
a\
t\

llOOOOlll\
O\
Ol
=
ll\
OO\
OOl\
OllO\

->
Get\
M\
ass
(
)
/
lO\
ll\
OlO\
OllOl
->
GetM\
ass
(
ll\
OOOOlOl\
lO
->
lO\
lOOllOlllO
(
)
)
;
bool
lOl\
l\
OOOl\
OOOl
=
lOl\
OO\
Ollll\
l\
O
(
lO\
llOl\
OOllOl
->
GetI\
mpul\
s\
e
(
ll\
OOOOlOOOll
,
0
)
*
llOOOOlll\
OOl
,
ll\
Ol\
lllO\
lOl
)
;
if\

(
lOll\
O\
OOlOOOl
&&
!
llOllllOl\
Ol
.
lO\
llOOOlOll
->
RigidFric\
t\
io\
n\
D\
isable\
d
(
)
&&
(
!
llOllll\
OlOl
.
lOllOl\
O\
lOO\
l
(
)
||
!
ll\
OllllO\
lOl
.
lOl\
lOlOlO\
Ol
(
)
->
Rigid\
Fri\
ction\
Disabled
(
)
)
)
{
int
lO\
l\
Ol\
lOOOl\

=
llOl\
lllO\
lOl
.
lOlO\
ll\
OOOl\

&
(
llOlll\
lOlOl\

.
FLAG_\
OB\
JECTB_SO\
LID_IN\
TE\
RNAL\

|
llO\
lll\
lO\
lOl
.
FL\
AG_OBJ\
ECT\
A_SOL\
ID_\
IN\
T\
ER\
NAL
|
llOll\
llO\
lOl
.
FL\
AG_OB\
J\
E\
C\
TB_INFINIT\
E_MAS\
S\

)
;
lO\
l\
OllOOOl
|=
Col\
li\
sio\
n
::
FLAG\
_CONSTRAI\
N_\
IN_\
BOTH\
_DIR\
ECTIONS\

|
Colli\
sio\
n\

::
FLAG_\
FR\
ICTI\
ON\

;
Collision
lOll\
OOll\
lOOl
=
ll\
Oll\
l\
lOlOl
;
lOllO\
O\
lllOOl
.
lOlO\
ll\
OOO\
l
=
lOlOllOOOl
;
lOl\
l\
OOl\
llOO\
l\

.
lOl\
lOO\
lOOOl
=
0.0f
;
lO\
llO\
Ol\
llOO\
l
.
lllOlll\
lO\
O
=
0.0f
;
lOllOOll\
lOOl
.
lO\
ll\
O\
Ol\
OlOl\

=
0.0f
;
lOllOO\
lllOOl
.
lO\
llOOlOllO
.
Cl\
ear
(
)
;
lOllOOl\
llOOl\

.
lO\
llO\
O\
lO\
lll
.
Cl\
ea\
r
(
)
;
lOllO\
O\
l\
llOOl
.
lOl\
lOlOO\
lOl
(
0
)
;
if
(
llOOOOlllOO\
O
==
0
)
{
llOllllOlOl\

.
lO\
lOll\
OO\
Ol
|=
Collisi\
o\
n\

::
FL\
A\
G_FR\
ICTION_\
GENER\
ATING_IMP\
U\
LSE
;
Ma\
t33\

lOOOOOOO\
l\
l
;
TA\
_ASS\
ER\
T
(
llO\
llllOlOl
.
lOO\
OlOO\
OOO\

.
IsNo\
r\
malised
(
)
)
;
lOOOOOOOll
.
SetToL\
o\
o\
kD\
ownV\
ec\
to\
r\

(
llOllllOlO\
l\

.
lOOO\
lOOOOO
)
;
lOllOOll\
lO\
Ol
.
lOOOlO\
OOOO
=
lO\
OOOOOOl\
l
.
v3\
X
;
Collision
*
llOOOOlllOlO\

=
lO\
llOlOll\
OOl
->
llOOOOl\
llOl\
l
(
lOlOO\
OO\
ll\
OlO
,
lOll\
O\
Oll\
lO\
Ol\

)
;
if
(
ll\
O\
OOO\
ll\
lO\
lO\

)
{
llOOOOlOO\
lO\
l
(
lO\
O\
ll\
Olll\
O\
lO
->
lO\
lOl\
lllOllO
,
*
llO\
OOO\
lllOl\
O\

)
;
#ifdef lOllOOlOOlOl
if
(
ll\
lOlOlllO
&
llOOOOlll\
lOO
)
PhysicsRender
::
Ren\
de\
rA\
rrow\

(
ll\
O\
OO\
OlllOlO
->
lOO\
O\
O\
lllll\

,
llO\
OOOl\
llO\
lO
->
lOOOlOO\
OOO
,
0xff00ff00
)
;
#endif //
}
lO\
llO\
Olll\
OOl
.
lO\
OOlOOOO\
O
=
lOOOOOO\
O\
ll
.
v3Y\

;
Collision\

*
llOO\
OOllll\
Ol\

=
lOllOlO\
llOOl
->
ll\
OOO\
OlllOll
(
lOlOOOOllOlO
,
lOll\
OOll\
lOOl
)
;
if
(
llOOOOllllOl
)
{
llOOOOlOOlO\
l\

(
lO\
Ol\
lOl\
ll\
OlO
->
lOl\
Ol\
lll\
O\
llO\

,
*
ll\
OO\
OOll\
llOl
)
;
#ifdef lOllOOlOOlOl
if
(
ll\
lOl\
Oll\
lO\

&
llOO\
OOllllOO
)
PhysicsRe\
nder
::
Ren\
derArr\
ow\

(
llOOOOllllOl
->
lOO\
OOlll\
ll
,
llOO\
OO\
lll\
lO\
l
->
lOOOlOOOOO\

,
0xff00ff00
)
;
#endif //
}
}
else
if\

(
llOOOO\
lllO\
OO
==
1
)
{
TA_ASS\
ERT
(
llO\
O\
OOllO\
lll
!=
0
)
;
Vec3
lO\
OOlOOO\
OO
=
llOl\
lllOlO\
l\

.
lOOOlOOOOO
.
Cross
(
llOllllOlOl\

.
lOOO\
Olll\
ll\

-
ll\
OOOOll\
Oll\
l
->
lO\
OOOlllll\

)
;
fl\
oat
lOllllO\
Ol\
l\

=
lOO\
Ol\
OOOO\
O\

.
GetMa\
gnitude
(
)
;
if\

(
lOll\
llOO\
l\
l\

>
0.000001f
)
{
ll\
Oll\
llO\
lOl
.
lO\
lOll\
O\
OOl
|=
Co\
l\
li\
s\
ion
::
FLA\
G_FRI\
CT\
ION_\
GEN\
ERA\
T\
ING_\
IMP\
ULSE\

;
lOOOlOO\
OO\
O\

.
No\
rma\
lis\
e
(
)
;
lOllOOlllO\
Ol
.
lO\
O\
OlOOOOO
=
lOOOlOO\
OOO
;
Co\
l\
l\
isio\
n\

*
llOO\
OOlllOlO
=
lOl\
lOlOllO\
Ol
->
llOOOOlllO\
ll
(
lO\
l\
OOOOllOl\
O
,
lOl\
lOO\
l\
llO\
Ol
)
;
if
(
llOOOOlll\
O\
lO
)
{
llOO\
OOl\
OOlOl
(
lOOl\
lOlllOl\
O\

->
lOl\
O\
llllO\
ll\
O
,
*
llOOOOll\
l\
O\
lO
)
;
#ifdef lOllOOlOOlOl
if
(
lll\
O\
lOlll\
O
&
ll\
OOOO\
llll\
O\
O
)
Physi\
cs\
R\
ender
::
Render\
Arr\
ow
(
llOOOO\
lllOl\
O
->
lOOOOll\
lll
,
ll\
OOOOlllOlO
->
lO\
OOl\
OOOOO
,
0xff00ff00
)
;
#endif //
}
}
}
el\
se\

if
(
llOOOOlllOOO
==
2
)
{
ll\
Ol\
lllOl\
O\
l
.
lOlOl\
lOO\
O\
l
|=
Collision
::
FLAG_FRICTION_G\
EN\
E\
R\
ATING\
_\
IMP\
ULSE
;
}
llOO\
OOl\
lOl\
ll
=
&
ll\
Oll\
llOlO\
l
;
llO\
O\
OOlllO\
O\
O\

++
;
}
}
}
}
void
Physics
::
lOllOl\
ll\
l\
lOl\

(
fl\
oat
lO\
OlllO\
OllOl
,
lOl\
O\
lll\
Oll\
lO
&
lOllOllOlOl\
O
)
{
lOlOlll\
OlllO
::
ll\
OOO\
OO\
OllOO
llOOO\
O\
OO\
llOl\

=
lO\
ll\
OllOlOlO\

.
llOOO\
OOOlllO\

(
)
;
for\

(
;
!
llO\
OOOOOllO\
l
.
AtEnd\

(
)
;
++
llO\
OOOOOl\
lO\
l
)
{
Dynami\
cObj\
e\
ct\

&
lOlll\
lOlOlll\

=
*
*
llOOOO\
OO\
ll\
Ol
;
lOll\
llOl\
Olll\

.
lO\
lO\
OlO\
O\
lOOl
(
)
;
}
bool
ll\
O\
OO\
Ol\
l\
ll\
lO
=
true
;
lOlO\
l\
ll\
O\
lllO
::
It\
erat\
or
lOlOlll\
OOOO\
O\

=
lO\
llO\
ll\
OlO\
lO
.
lOl\
OOOOl\
O\
O\

(
)
;
for
(
;
!
lOlOll\
lO\
OO\
OO
.
At\
End
(
)
;
++
lOlO\
l\
l\
lOOOOO
)
{
Colli\
sion
&
ll\
Ol\
l\
l\
lOlOl
=
*
lOl\
O\
lllOOOOO
;
if
(
!
llO\
llll\
OlOl
.
Ge\
tObj\
e\
c\
tA
(
)
->
lOlO\
OO\
O\
ll\
l\
l\
O
(
)
||
!
ll\
OllllOl\
Ol\

.
Ge\
tObjectB
(
)
->
lOl\
OOOO\
llllO
(
)
)
llO\
OOOlllllO
=
fal\
s\
e
;
if
(
!
(
ll\
OllllO\
lOl
.
lO\
lOll\
OOOl\

&
(
Collis\
io\
n\

::
FLAG_FRICT\
I\
ON_GENERATI\
NG_I\
M\
PUL\
SE
|
Co\
l\
lision
::
FL\
AG_FR\
IC\
TION\
_GEN\
ERATING_\
IMPULSE2\

)
)
)
co\
nt\
in\
ue
;
if
(
!
(
llO\
ll\
llOlOl\

.
GetObj\
e\
ctB
(
)
->
lO\
l\
OOOOl\
l\
llO
(
)
||
llOl\
lll\
Ol\
Ol
.
GetObj\
ectA
(
)
->
lOlOOOOlll\
lO\

(
)
)
)
con\
tinue
;
TA_A\
S\
S\
ERT
(
llOl\
lllO\
l\
Ol
.
GetObj\
ectA
(
)
)
;
TA_ASS\
ER\
T
(
llOlll\
lOlOl
.
Ge\
tObj\
ec\
tB
(
)
)
;
if
(
llOllllOlOl
.
lO\
OOl\
OOOOO\

.
Dot\

(
Get\
Gr\
avity
(
)
)
<
lOll\
l\
OOOll\
lO\

*
0.8f
)
llOllllOl\
Ol
.
Ge\
tObj\
ec\
tA\

(
)
->
lO\
lO\
OlOOlOOO\

(
)
;
if
(
ll\
O\
l\
ll\
l\
Ol\
Ol
.
lOOOlOOOOO
.
Do\
t
(
Ge\
tGra\
vity
(
)
)
>
-
lO\
lllOOOll\
lO
*
0.8f
)
ll\
OllllOlOl
.
Ge\
t\
O\
bj\
ectB\

(
)
->
lO\
lO\
O\
lOO\
lOOO\

(
)
;
}
llOOOOOOllOl
=
lOllOllO\
lOlO\

.
llO\
OOOOO\
ll\
lO
(
)
;
con\
st\

flo\
at\

llOOOO\
llllll
=
lOlllOOO\
lll\
O
*
lOll\
lO\
OO\
lllO
*
(
1.0f
/
9.81f
/
9.81f
)
*
lO\
Ol\
ll\
OOll\
Ol
*
60.0f
;
boo\
l\

llOOOl\
OOOOOO
=
tr\
u\
e
;
fl\
oat
llOOO\
l\
O\
O\
OO\
Ol
=
lOl\
lOlOO\
Ol\
OO
(
lO\
Ol\
l\
l\
OOl\
l\
Ol\

)
;
fl\
oat\

llOOOlOOO\
Ol\
O
=
Exp\

(
lOOlll\
OOllOl
*
-
3.0f
)
;
for
(
;
!
llOOOOOOl\
l\
Ol
.
AtEnd
(
)
;
++
llOO\
O\
O\
O\
Ol\
l\
Ol
)
{
Dy\
namicObject
&
lOl\
lOl\
Ol\
l\
OOO
=
*
*
llOOO\
O\
OOllO\
l\

;
lOllOl\
O\
l\
lOO\
O
.
lOl\
OOO\
lOOlO\
l
(
lO\
O\
lllOOll\
Ol\

,
llOOO\
lOOOOOl
)
;
flo\
at\

llOl\
O\
l\
Oll\
lO
=
lO\
llOlOll\
OOO\

.
Ge\
tRe\
stTimeMul\
tiplier\

(
)
;
ll\
O\
lOlOl\
llO\

=
llOlOlOlllO
*
llOlOlOlllO
;
if\

(
lOllOl\
O\
l\
lOOO
.
lOl\
O\
O\
lOOOll\
l
(
)
>=
3
)
ll\
OlO\
lOlllO
*=
3.0f
;
float
llO\
OOlO\
OOO\
ll
=
ll\
OlOlOlllO
;
llOlOlOll\
l\
O\

*=
llOOO\
Olll\
l\
ll
*
lO\
ll\
O\
lO\
ll\
O\
OO
.
lO\
Ol\
lOOO\
OOlO
(
)
*
lOllOlOll\
O\
OO
.
lO\
O\
ll\
OO\
O\
OO\
lO\

(
)
;
if
(
(
lOl\
lOlOllOOO
.
Ge\
tL\
inearVel\
oci\
t\
y\

(
)
.
GetMagn\
itude\
Sqrd\

(
)
<
lOllOOll\
llOl\

*
llOl\
Ol\
O\
l\
l\
l\
O
&&
lOllOl\
OllOOO
.
Ge\
t\
A\
ng\
ularVel\
oc\
i\
ty
(
)
.
Ge\
tM\
agn\
i\
t\
udeS\
q\
rd
(
)
<
lOll\
OOl\
llllO
*
llOOOlO\
OOOll
)
||
(
lOllOlOllOOO
.
lO\
lOOlll\
OlO\
O\

(
)
.
GetM\
a\
gni\
tudeS\
qrd
(
)
<
lOllO\
OllllOl
*
0.001f
*
llOlOlOlllO\

&&
lOll\
OlOllOOO
.
lOlOOl\
l\
lOlO\
l\

(
)
.
GetMagnitudeSqrd\

(
)
<
lOllOO\
l\
llllO
*
0.001f
*
llO\
O\
OlO\
O\
OOl\
l\

)
)
{
if
(
lOll\
OlOll\
OO\
O
.
lO\
l\
O\
Ol\
OOOll\
l\

(
)
>=
3
)
lO\
llO\
lOllO\
O\
O
.
lO\
lO\
Ol\
O\
O\
OlO\
l
(
lOOl\
llOO\
llO\
l\

*
5.0f
)
;
els\
e
lO\
ll\
O\
l\
Ol\
lOOO\

.
lOlOOlOOOl\
Ol
(
lO\
Ol\
l\
lOOllOl
)
;
}
els\
e\

{
lOllO\
l\
O\
l\
lOOO
.
lOOlllO\
OllO\
O
(
)
;
}
if
(
lOllOlOllOOO
.
lOl\
O\
OlOOOOll
(
)
>
lOllOO\
llllOO
)
{
if
(
(
lOll\
Ol\
Oll\
OOO
.
GetLinear\
Ve\
locity
(
)
.
Ge\
tMagnitu\
deS\
qrd
(
)
<
lO\
llOOl\
lllO\
l\

*
llO\
l\
O\
l\
OlllO\

*
0.2f
&&
lOllO\
lO\
llOOO
.
GetAng\
ul\
a\
r\
Velocity\

(
)
.
GetMagni\
tudeSq\
rd
(
)
<
lOllO\
Ol\
llll\
O
*
llO\
OO\
lOOO\
Ol\
l
*
0.2f
)
||
(
lOllOlOllOOO\

.
lO\
lOO\
lll\
OlOO
(
)
.
Ge\
tM\
agnitudeSq\
rd
(
)
<
lOllO\
Olll\
lO\
l
*
0.00025f
*
llOlOlOl\
ll\
O\

&&
lOllOlOl\
l\
OOO
.
lOlOOlllOlOl
(
)
.
Get\
M\
a\
gnitud\
eSqrd\

(
)
<
lOl\
l\
OO\
lll\
llO\

*
0.00025f
*
ll\
OO\
Ol\
O\
O\
OOll
)
)
{
lOl\
lOl\
Ol\
lOO\
O
.
SetLinear\
Velocity\

(
k_\
v\
3Z\
e\
ro
)
;
lOl\
lO\
lOllOO\
O\

.
Se\
tA\
ngul\
arVe\
l\
oc\
ity\

(
k_\
v3\
Zer\
o\

)
;
lO\
l\
l\
O\
lOllOOO\

.
lOOl\
llOOlOO\
O\

(
tru\
e\

)
;
if
(
(
lllOl\
O\
lllO
&
lOl\
ll\
OOlOl\
Ol
)
&&
lOl\
lO\
lOllO\
OO
.
lOlOOlllO\
l\
lO
(
)
<
lOl\
lOlOll\
OOO
.
GetM\
a\
s\
s
(
)
*
0.5f
)
lOll\
OlOllO\
OO
.
SetToRestin\
g
(
)
;
}
else\

{
lOllOlOllOOO
.
lOOl\
l\
lO\
Ol\
OO\
O
(
fa\
l\
s\
e
)
;
if
(
!
lOllOlOl\
lOO\
O
.
IsAllDampingDi\
sabled
(
)
)
{
lO\
llOlOl\
l\
O\
O\
O
.
SetLinear\
Ve\
lo\
city\

(
lOllOlO\
llOO\
O
.
GetLi\
n\
earVelo\
ci\
ty
(
)
*
llOOOlOOOO\
lO
)
;
lOllOlOllOOO
.
Se\
tA\
n\
gularV\
elocit\
y\

(
lOllOl\
Ol\
lOOO
.
Get\
AngularVe\
lo\
city\

(
)
*
llOO\
OlO\
O\
OOlO
)
;
}
}
}
else\

{
lOl\
lOlOll\
O\
OO
.
lOO\
lllOOl\
OO\
O
(
fa\
lse
)
;
llOO\
OlOOOOOO
=
false
;
}
}
if
(
llOOOl\
O\
OOOOO
&&
llOOOOlllllO
)
{
llOOOOOOllOl\

=
lOl\
lOllOlOlO
.
llO\
O\
O\
OOO\
l\
llO\

(
)
;
for
(
;
!
ll\
OO\
OOO\
O\
llOl
.
AtEnd
(
)
;
++
llO\
O\
OOOO\
llOl
)
{
Dyna\
micObject\

&
lOll\
OlOllO\
OO
=
*
*
llOOOOOOllO\
l
;
lO\
llOl\
O\
llO\
O\
O
.
lO\
lO\
OlOOll\
ll\

(
true
)
;
}
}
}
void\

Ph\
y\
sics
::
lOl\
llOOOOllO
(
fl\
oat
lOOlllOO\
l\
l\
Ol
,
bool
llOO\
OlOOO\
lOO\

,
lO\
l\
OlllO\
l\
ll\
O\

&
lO\
llO\
llO\
lOl\
O\

)
{
fl\
o\
at
llOO\
Ol\
OO\
OlOl\

=
lOl\
llOOO\
l\
l\
l\
O
*
lOOlllOOllOl
;
lO\
l\
Ol\
l\
lO\
l\
ll\
O
::
llOOOOOOl\
lOO
llOOOOOOllOl\

=
lOllOllOlOlO
.
llOOO\
O\
OOlll\
O
(
)
;
for
(
;
!
llOOOO\
O\
Oll\
Ol
.
AtE\
nd
(
)
;
++
llOO\
OOOOllOl\

)
{
DynamicOb\
j\
e\
ct
&
lOllO\
l\
Ol\
l\
OOO
=
*
*
llOO\
OOOOllOl
;
lO\
llOlOl\
l\
OO\
O
.
ApplyVe\
l\
o\
city\
To\
NextFram\
e
(
lOOll\
lO\
OllOl
)
;
if
(
llOOOlOOO\
l\
O\
O\

)
{
if
(
!
lOllOlOl\
lOOO
.
lOlO\
OO\
Oll\
l\
lO
(
)
)
lO\
l\
l\
OlOll\
OO\
O
.
Ap\
pl\
yNex\
tFra\
me
(
)
;
if
(
!
lOll\
O\
lOllO\
OO\

.
IsAl\
lDamp\
i\
ngDi\
sa\
ble\
d
(
)
&&
lOl\
lOllOlO\
l\
O\

.
llOOOlO\
O\
O\
llO\

(
)
)
{
TA\
_AS\
S\
E\
RT
(
lOl\
lO\
lOllOOO
.
lOOl\
lO\
OOO\
O\
lO
(
)
>
0.0f
)
;
fl\
oa\
t
lOOllllO\
OOOl
=
lO\
llOl\
OllOOO
.
GetLinearVel\
ocity
(
)
.
GetM\
agn\
it\
ude
(
)
/
lO\
l\
lOlOllO\
OO
.
lOO\
llOO\
O\
OOl\
O
(
)
;
lOOll\
ll\
O\
O\
O\
Ol\

+=
lOll\
OlOllOOO
.
GetA\
ngu\
larVel\
ocity
(
)
.
GetM\
agnit\
ud\
e
(
)
*
0.5f
;
lOOll\
llO\
O\
OOl\

+=
lO\
llOlO\
l\
lOO\
O
.
lOOllOOOO\
Ol\
O\

(
)
*
0.02f
;
{
TA_ASSERT
(
lOllOlOll\
OO\
O
.
GetMa\
ss
(
)
>
0.0f
)
;
flo\
at\

ll\
OO\
OlOOOl\
ll
=
(
lOllOlOl\
lO\
OO\

.
lOlO\
O\
lllOOO\
l\

(
)
-
lOl\
lOlOl\
lO\
OO
.
GetMass
(
)
*
llOO\
OlOOO\
lOl\

)
/
(
lOOlll\
lOOO\
Ol
*
lOll\
Ol\
OllOOO
.
GetM\
a\
ss\

(
)
)
;
llO\
OOlOOOlll\

-=
0.5f
;
if\

(
llO\
OOlO\
OOll\
l
>
0.0f
)
{
if\

(
llO\
OOlO\
OOlll
>
10.0f
)
llOO\
O\
lO\
OO\
ll\
l
=
10.0f
;
floa\
t
llO\
OOlOO\
l\
OO\
O
=
Exp\

(
-
llOOO\
lOOOl\
l\
l
*
lOOl\
llOO\
llO\
l
*
1.5f
)
;
lO\
l\
l\
O\
lOllOOO\

.
SetLine\
arVel\
oci\
t\
y\

(
lO\
l\
lOlOllOOO\

.
GetLin\
ea\
rV\
eloc\
ity
(
)
*
llOOO\
lO\
O\
lOOO\

)
;
llOOOlOOlOO\
O
=
Ex\
p
(
-
llOOO\
l\
OO\
Oll\
l\

*
lOO\
lll\
O\
Oll\
Ol
*
1.75f
)
;
lOl\
lOlO\
llOOO
.
Se\
tAng\
ul\
arVelocity
(
lOl\
lOlOllOOO\

.
GetAngula\
rVeloci\
ty
(
)
*
llOOOlOOlO\
OO
)
;
}
}
}
}
}
if
(
llOO\
Ol\
OO\
OlOO
)
{
int
ll\
OOOlOOlO\
Ol
=
0
;
const
int
llO\
O\
OlOOlO\
lO
=
lOOl\
lOl\
l\
l\
O\
lO\

->
lOl\
Oll\
l\
lOOOl
;
lO\
Olll\
OOOOl
(
Physic\
sJ\
oint
*
,
llO\
OOlOOl\
Oll
,
ll\
O\
OOl\
OOlO\
lO
)
;
boo\
l
llO\
OOlO\
OllOO
=
fals\
e
;
llO\
O\
OOOOllOl\

=
lO\
l\
lOllOlOlO
.
llOO\
OOOOlll\
O
(
)
;
fo\
r
(
;
!
llOOOOOOllOl
.
AtEnd
(
)
;
++
ll\
O\
OO\
O\
OO\
llOl
)
{
Dyn\
amic\
Ob\
ject
&
lOllllO\
l\
Olll
=
*
*
llOOOOOOll\
Ol
;
Dynam\
i\
cO\
bject\

::
Join\
tItera\
t\
or\

llOOOlO\
O\
llOl
=
lO\
l\
lllOlOll\
l\

.
Get\
JointIter\
a\
t\
or
(
)
;
for
(
;
!
llOOOlOO\
llOl
.
AtEn\
d
(
)
;
++
ll\
OO\
O\
lOO\
llOl
)
{
Ph\
ysicsJo\
int
&
lOOl\
llllO\
OOO
=
*
llOOOlOO\
l\
lOl
;
if
(
lOO\
l\
llllO\
OOO
.
Is\
Brok\
en\

(
)
)
cont\
i\
nue
;
llOOOl\
OOl\
lOO
=
tru\
e\

;
lOOl\
ll\
llOOO\
O
.
llOOO\
lO\
Olll\
O
(
fa\
l\
se
)
;
TA_A\
SSERT
(
lOOll\
l\
llOO\
O\
O
.
Ge\
tOb\
jec\
tA\

(
)
)
;
if\

(
!
lOO\
l\
llllOOOO\

.
GetO\
bje\
c\
t\
B
(
)
||
lOO\
llll\
lOOOO
.
GetObje\
ctB
(
)
->
Mo\
veme\
ntDis\
a\
bled
(
)
||
lOOlll\
l\
lOOOO
.
Ge\
tObjec\
t\
B
(
)
->
In\
finiteMa\
ss
(
)
||
!
lO\
OlllllO\
O\
O\
O
.
Ge\
t\
Objec\
tB
(
)
->
Is\
InMovi\
ngLis\
t
(
)
||
lOOllll\
lOOOO\

.
Ge\
t\
O\
b\
jectA
(
)
->
Infi\
niteMass
(
)
||
!
lOOll\
lllOO\
OO\

.
GetObj\
ectA
(
)
->
IsIn\
Mo\
v\
ingList
(
)
||
lOOll\
lllOOO\
O\

.
IsObj\
ec\
tASo\
li\
d
(
)
||
lOOl\
llllO\
OOO\

.
Is\
Obj\
ectBSol\
id
(
)
)
{
if
(
llO\
O\
OlOOlO\
O\
l\

<
llOOOlO\
OlOlO
)
{
llOO\
O\
lOOlOll
[
ll\
O\
OOlOO\
lOOl\

++
]
=
&
lOOl\
llllOOOO
;
lOOlll\
ll\
OOOO
.
llOOO\
lOOlllO\

(
true
)
;
bo\
ol
ll\
O\
OO\
lOO\
lll\
l
=
(
lOOl\
ll\
ll\
OOOO
.
Ge\
t\
O\
bjec\
tA\

(
)
->
InfiniteM\
ass
(
)
||
lOOlllllOO\
OO
.
IsObj\
ectASolid\

(
)
)
;
lOOl\
l\
lll\
OO\
O\
O\

.
ll\
O\
OOlOlOOOO
(
llO\
O\
O\
lOOllll
)
;
}
}
}
Li\
st
<
PhysicsJ\
oin\
t
*
>
::
It\
erato\
r
lOl\
lll\
Ol\
l\
Ol\
O\

=
lO\
llllOlOlll
.
lOlO\
OllOO\
llO
(
)
;
for
(
;
!
lO\
llllOllOlO
.
AtEnd\

(
)
;
++
lOl\
l\
llOl\
lOl\
O
)
{
Physics\
J\
oi\
nt
&
lOOlllllOOOO
=
*
*
lOllll\
OllOlO
;
TA_A\
S\
SERT
(
lO\
O\
lllllO\
O\
OO
.
Ge\
t\
Ob\
ject\
B
(
)
==
&
lO\
lll\
lOlOlll
)
;
TA_AS\
SERT
(
lOO\
l\
ll\
l\
lO\
OOO
.
GetO\
bj\
ect\
B\

(
)
->
lOl\
OOllOOlOl
(
)
==
(
voi\
d\

*
)
&
lOl\
lOl\
lOlOlO
)
;
if
(
lO\
OlllllO\
OOO
.
GetObjec\
t\
A\

(
)
->
lOlOOllOOlO\
l\

(
)
!=
(
void\

*
)
&
lOl\
lOllOlOlO
)
{
llOOOlOO\
l\
lO\
O\

=
true
;
lOOlllllOOOO
.
llOO\
OlOO\
lll\
O
(
fal\
se
)
;
if
(
llO\
OOlOOl\
OOl
<
llOO\
Ol\
OO\
lOl\
O
)
{
llO\
OOlOO\
lOll
[
llOOOlOOlOO\
l\

++
]
=
&
lOOlllllOOOO
;
lOO\
lllll\
OOOO
.
llO\
OO\
lOOlllO
(
tr\
ue
)
;
lO\
Ollll\
lOOOO\

.
llO\
OOl\
O\
lO\
OOO\

(
false
)
;
}
}
}
}
if\

(
llOOOlOOll\
OO
)
{
for\

(
;
;
)
{
int
llOO\
OlOlO\
O\
O\
l
=
llOO\
Ol\
OOlOOl\

;
for
(
in\
t
llO\
OO\
lOl\
OOlO
=
0
;
llOOO\
lOlOOlO\

<
ll\
OO\
Ol\
OlO\
OO\
l
;
ll\
O\
OO\
lO\
lOOl\
O
++
)
{
Phy\
si\
cs\
Joint\

&
lOOll\
l\
ll\
OOOO
=
*
llOOOlOOl\
Oll
[
llOOO\
lO\
lO\
O\
lO
]
;
if
(
lOOlll\
l\
lOOOO\

.
Is\
Broke\
n\

(
)
)
cont\
in\
ue
;
Dy\
n\
am\
icO\
bjec\
t
::
Joint\
Itera\
tor
llO\
OOlOOllOl\

=
lOOll\
l\
ll\
OO\
OO\

.
GetObject\
A
(
)
->
GetJ\
oint\
Ite\
r\
ator
(
)
;
for
(
;
!
llOOOlOOllO\
l
.
AtEn\
d
(
)
;
++
llO\
O\
OlO\
O\
ll\
Ol\

)
{
Phy\
sicsJ\
o\
int\

&
llOOOlOlOO\
l\
l\

=
*
llOOOlOOl\
l\
O\
l
;
if\

(
!
(
llOO\
O\
lO\
l\
OOll\

.
ll\
OOO\
l\
OlOlOO
(
)
||
llOOOlOl\
OOll\

.
IsBr\
oken
(
)
)
)
{
if\

(
llOOOlOOlOOl\

<
llOOOlOO\
lOlO
)
{
llO\
OOlO\
O\
lOll
[
llOOOlOOlOOl
++
]
=
&
ll\
O\
OOlO\
lOO\
ll
;
llOOO\
l\
OlO\
Oll
.
ll\
O\
OOlOOll\
l\
O
(
true\

)
;
lO\
O\
ll\
lllO\
O\
OO
.
ll\
OO\
OlOl\
O\
OO\
O
(
fa\
lse\

)
;
}
}
}
List
<
Physi\
csJoint
*
>
::
Iterator\

lOllllOl\
l\
OlO
=
lOO\
lllllOO\
OO
.
GetO\
b\
je\
ct\
A
(
)
->
lOlOO\
llO\
OllO
(
)
;
fo\
r
(
;
!
lOllll\
OllOlO
.
AtEnd
(
)
;
++
lOllllO\
ll\
Ol\
O\

)
{
PhysicsJo\
i\
nt
&
llOO\
Ol\
O\
l\
OOl\
l
=
*
*
lOllllOll\
OlO
;
if\

(
llOOO\
lOlOOl\
l
.
IsBroken
(
)
)
co\
n\
tinue
;
if
(
!
(
llOOO\
lOlOO\
l\
l
.
llO\
OO\
lOlOlO\
O
(
)
||
llOOO\
l\
Ol\
OO\
ll
.
IsBr\
oken\

(
)
)
)
{
if\

(
ll\
OOOlO\
OlOO\
l
<
ll\
OOOl\
O\
OlOl\
O
)
{
llOO\
O\
lOOlOl\
l\

[
llOO\
OlOOlOO\
l\

++
]
=
&
ll\
OOOlOlOOll
;
llOOOlOlOO\
ll
.
ll\
O\
O\
Ol\
OOlllO
(
true
)
;
lOOll\
l\
l\
l\
OO\
OO
.
llO\
OOlOlOOOO\

(
true\

)
;
}
}
}
if
(
lO\
Olllll\
O\
OO\
O
.
Ge\
tO\
bjec\
tB
(
)
)
{
llOO\
Ol\
OO\
llOl
=
lOOll\
l\
llO\
OO\
O
.
Ge\
tO\
bjectB
(
)
->
Get\
Joi\
ntIt\
e\
r\
a\
to\
r\

(
)
;
for
(
;
!
ll\
OOOlOOllO\
l\

.
AtEn\
d
(
)
;
++
llOOOl\
O\
O\
llOl\

)
{
Ph\
ysi\
csJ\
oint
&
llOOOlOl\
O\
Ol\
l
=
*
llOOOlOOllO\
l\

;
if
(
!
(
llOOOl\
OlOOll\

.
llOOOl\
OlOl\
OO
(
)
||
llOOO\
l\
OlOO\
ll
.
Is\
B\
r\
oken
(
)
)
)
{
if\

(
llOOOlOO\
l\
O\
Ol\

<
ll\
OOOl\
OOl\
OlO
)
{
llO\
OOlOOlOl\
l
[
ll\
OOOlOO\
lOOl
++
]
=
&
llOOOlO\
lOOll
;
llO\
OOl\
O\
lOOll
.
llO\
OO\
lOOlllO
(
tr\
u\
e
)
;
lO\
Olllll\
OOOO
.
llO\
OOlOlOOO\
O\

(
true
)
;
}
}
}
lO\
llllOllOlO
=
lOOlll\
l\
lOOOO
.
GetOb\
jec\
tB\

(
)
->
lO\
lO\
Ol\
lOOllO
(
)
;
fo\
r\

(
;
!
lOl\
lllOl\
l\
OlO
.
AtEnd
(
)
;
++
lOll\
l\
lOll\
OlO
)
{
Ph\
y\
sic\
sJ\
oint
&
llOO\
O\
l\
O\
lO\
Oll\

=
*
*
lO\
llllOllO\
lO\

;
if
(
!
(
llOOOlOl\
OOll
.
llOOOlO\
lO\
lO\
O
(
)
||
llOOOlO\
lOO\
l\
l
.
IsBroken
(
)
)
)
{
if
(
llOOOlO\
Ol\
OOl\

<
ll\
OO\
OlOOl\
Ol\
O\

)
{
llOOOlOO\
l\
O\
l\
l\

[
ll\
OOOl\
OOlOOl\

++
]
=
&
ll\
O\
O\
O\
lOlO\
Oll
;
ll\
OOO\
lOl\
OOll
.
ll\
OO\
OlOOl\
l\
lO
(
tru\
e
)
;
lOOl\
lll\
lOO\
OO
.
llOOO\
l\
OlOOOO\

(
false
)
;
}
}
}
}
}
if\

(
llOO\
OlOlOOOl
==
llOOOlOOlOOl
)
break
;
}
llOOOOOOl\
lOl\

=
lOllO\
l\
lO\
l\
OlO
.
llOOOOOOll\
lO
(
)
;
fo\
r
(
;
!
llO\
OO\
OOOllOl
.
At\
End
(
)
;
++
llOOOOOOll\
O\
l
)
{
Dy\
namicObje\
ct
&
lO\
l\
lllOlOl\
ll
=
*
*
llO\
OOOOOl\
l\
Ol
;
Dynami\
cO\
b\
ject
::
JointIt\
e\
rator
lO\
lOOlO\
O\
lO
=
lOl\
ll\
lO\
lOl\
ll
.
GetJoint\
Iterator
(
)
;
for
(
;
!
lOlOOl\
OOlO
.
AtEnd
(
)
;
++
lOlO\
Ol\
OOlO
)
{
Ph\
ys\
ic\
sJoi\
nt
&
lOO\
l\
llllO\
OOO
=
*
lOlOO\
lO\
O\
lO
;
if
(
!
(
lO\
Olll\
llOOOO\

.
ll\
O\
OOl\
OlOlOO
(
)
||
lOOlllll\
OOOO
.
IsBroken\

(
)
)
)
{
if
(
llOOOlOOl\
O\
Ol\

<
llOO\
O\
l\
OOlO\
lO\

)
{
int\

ll\
OOO\
l\
O\
lOl\
Ol
=
llOOOlOOlOO\
l\

;
llOOOlO\
OlOll
[
llO\
OO\
lOOl\
OO\
l
++
]
=
&
lOO\
ll\
l\
llOOO\
O
;
lOOlllllO\
OOO
.
llOOOl\
O\
O\
lllO
(
true\

)
;
whil\
e\

(
ll\
OOOlOlOlOl
!=
ll\
OOOl\
OOlOOl\

)
{
int\

llO\
OOl\
O\
lOO\
lO
=
llOOOlOl\
Ol\
Ol
;
llOOOl\
OlOlO\
l
=
ll\
O\
O\
OlOOlOOl\

;
for
(
;
llOOO\
lOlOOlO
<
llOOOlOl\
O\
lOl
;
llOO\
Ol\
Ol\
OO\
lO
++
)
{
Physic\
sJoint\

&
lOOll\
ll\
l\
OOOO
=
*
llOOO\
lOO\
l\
Oll
[
llO\
O\
Ol\
Ol\
O\
O\
l\
O
]
;
Dyn\
amicObject\

::
Jo\
int\
Iterator
llO\
OOl\
OO\
llO\
l
=
lOO\
l\
llllOOOO
.
GetObjec\
tA
(
)
->
GetJ\
oi\
ntIt\
era\
t\
or
(
)
;
for
(
;
!
llOOOl\
OOllO\
l
.
AtEnd
(
)
;
++
llOO\
O\
lO\
Ol\
lO\
l
)
{
Phys\
i\
cs\
Joint\

&
llOOOlOl\
OO\
l\
l\

=
*
llOOOl\
OOllO\
l
;
if\

(
!
(
llOOOlO\
lOO\
ll\

.
llO\
O\
OlOlO\
l\
OO
(
)
||
ll\
OOOlO\
lOOll\

.
Is\
Br\
o\
ken\

(
)
)
)
{
if\

(
llOOOl\
O\
O\
l\
O\
Ol
<
llOOOl\
OOlOlO
)
{
llOO\
OlO\
OlOll
[
llOOOlO\
O\
lOO\
l
++
]
=
&
llOOOlO\
l\
OO\
l\
l\

;
ll\
OOOl\
Ol\
OOll
.
llOOO\
lOOl\
l\
l\
O
(
true
)
;
lO\
OlllllOOOO
.
llOO\
Ol\
O\
l\
OOOO\

(
fals\
e
)
;
}
}
}
Li\
st
<
Physic\
sJo\
int\

*
>
::
Iter\
at\
or
lOllll\
O\
llOlO
=
lOOlll\
ll\
OO\
O\
O
.
GetObje\
ctA
(
)
->
lOlOO\
l\
lOOllO
(
)
;
for
(
;
!
lOll\
llOllOlO\

.
AtEnd
(
)
;
++
lOllllO\
llOlO\

)
{
Phy\
sics\
Joint
&
ll\
OOOlOl\
OOll\

=
*
*
lOlll\
l\
OllOl\
O
;
if
(
!
(
ll\
OO\
Ol\
OlO\
O\
ll
.
llOOO\
l\
OlO\
l\
OO
(
)
||
ll\
OO\
OlOl\
O\
Oll\

.
IsB\
rok\
en
(
)
)
)
{
if
(
llOOOlOOlOO\
l
<
llOOO\
lO\
O\
l\
OlO
)
{
llOOOl\
O\
O\
lOll
[
llOOO\
l\
OOlOOl
++
]
=
&
llO\
OOlOl\
O\
O\
ll
;
llO\
O\
Ol\
OlOOll
.
llOOOl\
OOl\
llO
(
tru\
e
)
;
lO\
O\
llll\
lOOOO
.
llO\
O\
Ol\
OlOOOO\

(
tru\
e\

)
;
}
}
}
if
(
lO\
Ol\
llllO\
OOO
.
Ge\
tObjec\
t\
B\

(
)
)
{
llOOOlO\
OllOl
=
lOOll\
lllOOO\
O\

.
Ge\
tO\
bjectB\

(
)
->
Ge\
tJointIterat\
o\
r
(
)
;
for
(
;
!
ll\
OOOlO\
O\
llOl\

.
At\
En\
d
(
)
;
++
llOOOl\
OO\
ll\
Ol\

)
{
Ph\
ysicsJoi\
nt
&
ll\
OOOl\
Ol\
OOll
=
*
llOOO\
lO\
O\
ll\
Ol
;
if\

(
!
(
llOOOlOl\
OOll
.
llOO\
O\
lOlO\
lOO
(
)
||
ll\
OOOl\
O\
l\
OOll\

.
IsB\
rok\
en
(
)
)
)
{
if\

(
llOOOlOOlO\
Ol
<
llOOOlOOlO\
lO\

)
{
llOOO\
lOOlOll
[
llOOOlOOlOOl
++
]
=
&
llOOO\
l\
OlOOll
;
ll\
OOOlOl\
O\
Oll
.
llOOOlOO\
l\
ll\
O
(
true
)
;
lOOll\
lll\
OOO\
O
.
llOOOl\
OlOOOO
(
tru\
e
)
;
}
}
}
lOllllO\
ll\
OlO
=
lOOllll\
lOOO\
O
.
Ge\
tObje\
ctB
(
)
->
lOl\
OOllOOl\
lO
(
)
;
for\

(
;
!
lOll\
llOl\
l\
O\
lO
.
AtE\
n\
d
(
)
;
++
lO\
l\
ll\
lO\
ll\
OlO
)
{
Ph\
ys\
i\
cs\
Jo\
i\
n\
t
&
llO\
OOlO\
l\
OOll
=
*
*
lOlll\
lO\
ll\
Ol\
O
;
if
(
!
(
llOOO\
lOlOOll
.
ll\
OO\
OlOlOlOO
(
)
||
llOOOlO\
lOOl\
l
.
Is\
Br\
o\
ken
(
)
)
)
{
if
(
llOOOl\
OO\
l\
OOl
<
llOO\
OlO\
OlOlO\

)
{
llOO\
OlO\
OlOl\
l
[
llOO\
OlOO\
lOO\
l
++
]
=
&
llOOOl\
OlOOll
;
llOO\
OlOl\
O\
Oll
.
llOO\
OlOO\
lllO
(
true
)
;
lOOlllllOOOO
.
llOO\
OlOl\
OO\
O\
O
(
fals\
e
)
;
}
}
}
}
}
}
}
}
}
}
const
in\
t\

llOO\
OlO\
lOl\
l\
O
=
5
;
for\

(
int
lOOO\
llO\
OOl
=
0
;
lOOOl\
lO\
O\
Ol
<
llO\
OOlO\
l\
Oll\
O\

;
lOOO\
l\
lOO\
Ol\

++
)
{
float
llOOOlOl\
Ol\
ll
=
(
fl\
oat
)
lOOOllOOOl\

/
(
float
)
(
llO\
OOlO\
lO\
llO\

-
1
)
;
int
llOOO\
l\
OlO\
O\
lO
;
if
(
lOOOll\
OO\
Ol
!=
0
)
{
for
(
llOOOlOl\
OO\
lO
=
ll\
OO\
OlOO\
lOOl
-
1
;
ll\
O\
OOl\
OlOOlO
>=
0
;
llOOOl\
OlOO\
l\
O
--
)
{
Ph\
ysi\
cs\
Joi\
n\
t
&
lO\
Olll\
llOO\
O\
O\

=
*
llOO\
Ol\
OOl\
O\
ll
[
llOOOlOlOOl\
O\

]
;
llOOOlO\
llO\
OO\

(
lO\
O\
lllllOO\
OO\

,
false
,
ll\
OOOlOlOlll\

)
;
}
}
fo\
r
(
llO\
OOlOlO\
OlO\

=
0
;
ll\
O\
OO\
l\
Ol\
O\
OlO
<
llOOOl\
O\
OlO\
Ol
;
llO\
OOlOlOO\
l\
O
++
)
{
Phys\
ic\
s\
Joint
&
lOOlllll\
OOO\
O\

=
*
llOOOlOO\
l\
O\
ll
[
llOOOl\
OlO\
OlO\

]
;
llOO\
OlOllOOO
(
lOOlll\
llOOOO
,
true\

,
llOO\
OlOlOlll
)
;
}
}
}
}
}
void
Physics\

::
llOO\
OlOllO\
OO
(
Physi\
c\
sJoint
&
lOOllll\
l\
O\
OOO
,
boo\
l
llO\
OO\
lOOl\
lll
,
float
llOOOlOlOlll
)
{
float\

llO\
O\
O\
l\
OllOOl
=
0.0f
;
fl\
oa\
t
ll\
OOOl\
OllO\
lO
=
ll\
O\
OOlOlO\
lll\

;
TA_\
A\
SSERT
(
!
lOO\
llll\
lO\
O\
O\
O
.
Is\
B\
roken
(
)
)
;
if\

(
lO\
O\
lllllO\
OOO\

.
Is\
Bro\
ke\
n\

(
)
)
retu\
r\
n
;
if
(
lOOlllllOOOO
.
GetTy\
pe
(
)
==
PhysicsJoin\
t\

::
TYPE\
_VECT\
OR\
_\
CONSTRAINT
)
{
}
else
if
(
lOOlllll\
O\
O\
OO
.
Ge\
tT\
ype\

(
)
==
Phys\
ic\
sJoint
::
TYPE_\
L\
I\
N\
EA\
R_SLIDER
)
{
}
els\
e\

{
TA_A\
SSE\
RT\

(
lOO\
l\
ll\
ll\
OOOO
.
Get\
Ob\
jectA
(
)
)
;
{
Dyna\
micO\
bject
*
lOll\
OOOl\
O\
l\
l
=
lOOl\
l\
lll\
OOOO
.
Get\
Ob\
jec\
tA
(
)
;
Dyna\
m\
icObjec\
t
*
lO\
l\
l\
OOOllOO
=
lOOllll\
lOOOO\

.
Ge\
t\
Obj\
e\
c\
t\
B\

(
)
;
Vec3
lll\
lOOOOOl
=
lOOlllllO\
O\
OO\

.
GetPosOnOb\
j\
e\
ctA
(
)
*
lOl\
lOOO\
lOll
->
Ge\
tFrame
(
)
;
Vec3
llllO\
O\
OO\
lO\

=
lOO\
ll\
lll\
OOOO\

.
Get\
Po\
sOnObjectB
(
)
;
if
(
lO\
l\
l\
OOOllOO
)
llllOO\
O\
OlO
*=
lOllO\
OO\
l\
l\
OO\

->
Get\
Frame
(
)
;
MFram\
e
llO\
O\
O\
lOl\
lO\
ll\

;
Vec3\

lOlOOOOOO\
l\
l
=
llllOOO\
O\
Ol\

-
lll\
lOOOOlO\

;
floa\
t
llOOO\
lOlll\
O\
O
=
0.15f
;
if\

(
lOll\
OO\
OllOO
)
llO\
OOl\
OlllOO
*=
Min
(
lOllOOOllOO
->
lOO\
llOO\
O\
OOlO
(
)
,
lOllOOOlO\
l\
l
->
lO\
Ol\
lOOOO\
OlO
(
)
)
;
else
llOOO\
l\
Oll\
lOO
*=
lOllOOOlOll
->
lOOl\
lOOO\
OO\
lO
(
)
;
float\

lll\
OO\
lOl\
O\
l
=
lOlOOOO\
O\
Oll
.
GetMagnitu\
deS\
qrd\

(
)
;
if
(
lllO\
O\
lOlOl
>
llO\
OOl\
Olll\
OO
*
llOOOlOl\
l\
lOO
)
{
lOlO\
OOO\
OOl\
l\

-=
lO\
lOOOOOOll
*
(
llO\
OOlOl\
llOO\

/
Sq\
rt\

(
lllOOl\
OlOl\

)
)
;
lOlOOOO\
OO\
l\
l
*=
ll\
O\
OOlO\
llOlO
;
if
(
(
lO\
Oll\
lllO\
O\
O\
O
.
llOO\
O\
lOlllOl
(
)
&&
llOOOlO\
Ol\
lll
)
||
(
!
lOOl\
l\
lllOOOO
.
ll\
OOO\
lO\
lll\
Ol
(
)
&&
!
llOOOl\
OO\
llll
)
)
{
if
(
lOl\
lOO\
Ol\
lO\
O
&&
(
!
lOll\
OOOllOO
->
In\
fin\
ite\
Ma\
ss
(
)
&&
!
lOllO\
OOllOO\

->
Movem\
entDisabl\
ed
(
)
&&
lOl\
l\
O\
OOllOO
->
IsInMo\
v\
i\
n\
gLis\
t
(
)
&&
!
lOOll\
ll\
lO\
OOO\

.
IsOb\
ject\
BS\
ol\
i\
d
(
)
)
)
{
llO\
OO\
lOl\
lOll
=
lOllOOOllOO
->
Get\
Frame
(
)
;
ll\
O\
O\
O\
lOl\
lOl\
l
.
v3Tr\
anslation
+=
lOl\
OO\
OOOOll
;
lO\
llOOO\
llOO
->
SetF\
ram\
eDir\
ec\
t
(
llO\
OOlOllO\
ll
)
;
}
}
else
{
if
(
!
lOllO\
OO\
l\
Ol\
l
->
Infinit\
eM\
ass
(
)
&&
!
lOllO\
OOl\
Oll
->
Movem\
entDi\
sabl\
ed
(
)
&&
lO\
llO\
O\
O\
lOl\
l
->
Is\
In\
Mo\
vingList
(
)
&&
!
lOO\
llll\
lOO\
OO
.
IsObjectASolid
(
)
)
{
llOO\
OlO\
llO\
ll
=
lOllO\
OOlOll\

->
GetF\
rame
(
)
;
llOO\
OlOll\
Oll
.
v3Tran\
s\
lat\
ion
-=
lOlO\
OOOOOll
;
lO\
llOO\
OlOl\
l\

->
Se\
t\
F\
r\
ame\
D\
irect
(
llOO\
OlOl\
lOll\

)
;
}
}
}
}
}
}
void
Ph\
ysi\
cs
::
lOl\
llO\
OOOll\
l
(
float
lOOll\
lOOll\
O\
l
,
boo\
l
llOOO\
lOOOl\
OO\

)
{
float
llOO\
OlO\
O\
OOO\
l
=
lOllOlOOOl\
OO\

(
lOO\
l\
ll\
OO\
llOl
)
;
lOlllOl\
OlOl\
O
lO\
lOOlOOlO
=
lOl\
lO\
l\
Ol\
l\
lO\
O
.
lOlOOO\
OlOO
(
)
;
for\

(
;
!
lOlO\
OlO\
OlO\

.
AtE\
nd\

(
)
;
++
lO\
lOO\
lOOlO
)
{
Dynam\
icObjec\
t\

&
lO\
llOl\
Ol\
lOOO
=
*
*
lO\
lO\
OlOO\
l\
O\

;
if
(
lOl\
lOlOll\
OO\
O
.
lOlOOll\
OOlOl
(
)
)
contin\
ue
;
lOllOlOl\
lO\
O\
O
.
ApplyVelo\
cityT\
oNextFrame
(
lOOlllOO\
llOl
)
;
if
(
ll\
OO\
OlOOOlOO
)
{
lOl\
lO\
lO\
llOOO\

.
ApplyN\
ex\
tFra\
me
(
)
;
lO\
llOl\
OllO\
O\
O
.
lOlO\
O\
OlOO\
lO\
l
(
lOOlllOOllOl\

,
llOO\
O\
l\
O\
OOOOl
)
;
float
llO\
lOlOlllO
=
lOll\
OlO\
ll\
OO\
O
.
GetRe\
s\
tTimeM\
ultiplie\
r
(
)
;
llOlOlOlllO
=
llO\
l\
OlO\
l\
l\
lO
*
llOl\
Ol\
OlllO
;
float
ll\
OOO\
lO\
O\
O\
Oll
=
llO\
lOl\
Ol\
llO
;
llOlO\
l\
OlllO\

*=
lOlllOOOl\
llO
*
(
1.0f
/
9.81f
/
9.81f
)
;
float\

llOOOlOllllO
=
(
lOOll\
lOOl\
lOl\

*
lOO\
l\
llOOllOl\

)
;
if\

(
(
lOllOlO\
llOO\
O
.
GetLine\
arVelocity
(
)
.
Get\
Mag\
nitudeSqrd
(
)
<
lOl\
lO\
OllllO\
l\

*
llOl\
OlOlllO
&&
lOllOlO\
llOOO
.
GetAngu\
la\
rVeloc\
ity
(
)
.
Get\
Magn\
itudeS\
qrd
(
)
<
lO\
l\
lOOlll\
l\
lO
*
llOOOl\
OOO\
Oll
)
||
(
lOllOlOllOOO
.
lOlO\
O\
lllOlOO\

(
)
.
Ge\
t\
M\
agnitudeSq\
rd
(
)
<
lOllO\
Olll\
lOl
*
0.2f
*
llOOOlO\
ll\
llO
*
ll\
O\
lO\
lOl\
llO
&&
lOllOlO\
ll\
O\
O\
O
.
lOlO\
O\
lllOlOl\

(
)
.
Ge\
t\
M\
a\
gni\
t\
ud\
eS\
qrd
(
)
<
lOllOO\
l\
ll\
llO
*
0.2f
*
llO\
O\
O\
lOll\
l\
lO
*
llOO\
O\
lOOO\
Oll\

)
)
{
lO\
l\
l\
OlO\
l\
l\
OOO
.
lOlOOl\
OOOlO\
l
(
lO\
OlllOOll\
O\
l\

)
;
}
else
{
lOllOlOllO\
OO
.
lO\
Olll\
OOllOO\

(
)
;
}
if
(
lOllO\
lOl\
lOOO
.
lOlOOl\
OOOOll
(
)
>
lOllOOl\
ll\
lOO
)
lO\
l\
lOlOllOO\
O
.
lO\
lO\
OlO\
Ollll
(
true\

)
;
}
}
}
void
Physics
::
lO\
lllOOOO\
O\
l\
l
(
lOlO\
lllOlllO\

&
lO\
llOll\
O\
lOlO
,
lOllOl\
OOOl\
O\
l
*
lO\
lll\
OO\
OOOlO
,
in\
t
llOOOlO\
ll\
lll
)
{
Vec\
3\

ll\
OO\
O\
l\
l\
OO\
OOO\

=
Get\
G\
rav\
ity
(
)
;
float
llO\
OO\
llOOOOl\

=
lOlllOOO\
lll\
O
;
llOOOl\
l\
O\
O\
O\
Ol\

*=
0.2f
;
llOO\
Oll\
OOO\
O\
O\

.
x
+=
Ra\
n\
dFu\
nc
::
Ta\
Ra\
n\
d\
Betwee\
nPosN\
eg
(
llOO\
O\
llO\
O\
OOl\

)
;
ll\
OOO\
l\
lOOO\
OO
.
y
+=
Ra\
n\
dFunc\

::
TaRandBetwee\
n\
P\
o\
s\
Neg\

(
llOOOllOO\
OOl
)
;
llOOOll\
OOO\
OO\

.
z
+=
Ran\
dF\
u\
nc
::
TaR\
an\
dBetwe\
enPo\
sNe\
g\

(
ll\
OOO\
llOOOOl
)
;
in\
t
lO\
l\
llOOOOOOl
=
0
;
lO\
lO\
ll\
lOll\
l\
O
::
Iterat\
or\

lOl\
O\
l\
llO\
OO\
OO
=
lOllOll\
OlOlO
.
lOlOOO\
Ol\
OO
(
)
;
fo\
r
(
;
!
lOlOlll\
OO\
OOO
.
AtEn\
d
(
)
;
++
lO\
lO\
ll\
lO\
OOOO
)
{
Coll\
isi\
on
*
llOll\
OlO\
lOl\

=
&
*
lOlOlllOOO\
OO\

;
for
(
;
llOll\
O\
lO\
lOl
;
llOll\
O\
lOlO\
l\

=
llOllOlO\
l\
Ol
->
Get\
Nex\
t
(
)
)
{
TA_\
A\
SSERT
(
lOll\
lOOO\
OOOl
<
ll\
OOO\
lOlll\
ll\

)
;
Collision
&
llOllllOlOl
=
*
llOllOlO\
lOl
;
lOllOlOOOl\
Ol
&
lO\
Ol\
OOlll\
OO
=
lO\
ll\
lOOOO\
OlO\

[
lOlllOO\
OOOOl
++
]
;
lOOlOOlll\
OO
.
llOl\
l\
Ol\
O\
lO\
l\

=
llOll\
Ol\
OlOl
;
lOOlOO\
l\
l\
lO\
O
.
lOOO\
l\
OOllO
=
-
llOO\
Oll\
OOOOO
.
Dot\

(
llOl\
lllOl\
Ol
.
lOOOOlllll
)
;
}
}
TA_ASS\
ERT
(
lO\
l\
llOOOOOOl
==
llOOO\
lOlll\
l\
l
)
;
}
vo\
i\
d
Phy\
si\
cs
::
lOllOllll\
Ol\
l
(
lOlOlllO\
l\
llO
&
lO\
l\
lOllO\
lO\
lO
,
Dynami\
cObject
*
*
lO\
l\
lO\
llllOO\
l\

,
int
&
lOl\
lOlllOllO
,
int\

lOllOlllO\
lll
,
Co\
l\
li\
sion
*
*
lOll\
Olll\
lOlO\

,
int
&
lOl\
lO\
lll\
O\
Oll
,
int\

lOl\
l\
Olll\
OlOO\

)
{
lOOlllOO\
OOl
(
lOlO\
OOOOOlO\
l\

*
,
ll\
OOOllOOOl\
O
,
lOOll\
Ol\
ll\
O\
lO
->
lOlOllllO\
O\
ll
)
;
in\
t
llOOOll\
O\
OOll
=
0
;
lOl\
OlllOlllO\

::
lO\
llllOO\
O\
l\
lO\

lOllllOOOlll
=
lOll\
O\
l\
lOlOlO
.
lOllllOOl\
OOO
(
)
;
for
(
;
!
lOllll\
OOOlll\

.
AtEnd
(
)
;
++
lO\
lll\
l\
OOO\
l\
ll
)
{
TA_\
A\
S\
SERT
(
llOOO\
l\
l\
OO\
O\
l\
l
<
lOOllO\
l\
llOlO
->
lOl\
Olll\
lOOl\
l
)
;
lOl\
OO\
O\
OOOlO\
l
&
lOlO\
OOOllO\
l\
O
=
*
lOlll\
lOOO\
lll
;
TA_ASSE\
RT\

(
lOlOOOOllOlO
.
lOlOO\
O\
OOlOll\

)
;
TA\
_A\
SS\
ER\
T
(
lOlOO\
OOll\
Ol\
O
.
lO\
lOO\
OO\
O\
l\
lOO
)
;
co\
nst
u32\

llOOO\
llOO\
lOO
=
~
(
Dyn\
amicObj\
e\
ct
::
lO\
l\
OOlOl\
O\
OO\
l
|
Dynami\
cOb\
je\
ct\

::
lOl\
OO\
lOlO\
l\
O\
O
|
Dy\
nam\
i\
cObj\
ect\

::
lOlOOlOl\
Olll
)
;
if
(
lO\
l\
OOOOllOlO\

.
lOlOOOOOlOll
->
lOlOOl\
l\
OOlOl\

(
)
==
&
lOllOl\
lO\
l\
OlO
)
lO\
lOOOO\
llOl\
O
.
lOlOOOO\
O\
lOll\

->
lOlO\
O\
lO\
llllO
(
)
&=
ll\
OO\
O\
llOOlO\
O
;
if\

(
lOlOOO\
Ol\
lOlO\

.
lO\
lOOOO\
OllOO\

->
lOl\
OO\
ll\
OOlO\
l
(
)
==
&
lOl\
l\
OllOlO\
l\
O
)
lO\
l\
OOOOl\
lOlO
.
lOlO\
OOO\
O\
l\
lO\
O
->
lOlOOlOlll\
lO
(
)
&=
ll\
OOOl\
lOOlOO
;
llOOOllOOOl\
O
[
ll\
OOOll\
OOO\
ll
++
]
=
&
lOlO\
OOOl\
l\
OlO
;
}
#ifdef _DEBUG
if\

(
lOOl\
O\
OOllO
)
{
lOlOlll\
Ol\
l\
lO
::
lOll\
llO\
OOllO
llOO\
OllO\
OlOl
=
lOl\
lOllO\
lOlO
.
lOl\
lllOOl\
OOO
(
)
;
fo\
r
(
;
!
llOOO\
ll\
OOlO\
l
.
AtEn\
d\

(
)
;
++
llOOOllO\
Ol\
Ol
)
{
lO\
l\
OOOOOO\
lOl
&
ll\
OOOllOOllO\

=
*
llO\
OOllO\
O\
l\
O\
l\

;
lOlOlllO\
lllO\

::
lO\
l\
lllO\
OO\
llO
llOO\
Ol\
lO\
Ol\
ll
=
lO\
llO\
llOlOlO
.
lO\
llllO\
O\
l\
O\
OO
(
)
;
for
(
;
!
llOOOll\
O\
Olll
.
AtE\
nd
(
)
;
++
llOOO\
ll\
OOlll
)
{
lOlO\
OOOO\
O\
l\
O\
l
&
ll\
O\
OOllOlOOO\

=
*
llOOO\
l\
lO\
O\
l\
l\
l
;
if\

(
&
llO\
O\
OllOOllO\

==
&
llO\
OOl\
lOlOOO
)
con\
tinue
;
TA_ASSERT\

(
(
llOO\
O\
l\
lOOllO\

.
lOl\
OO\
OOOlOll
!=
llO\
OOllOlO\
O\
O\

.
lOl\
OOO\
O\
O\
l\
O\
ll
||
llOOOllOO\
llO
.
lOlOOOOOllOO
!=
ll\
OOOllOl\
OO\
O
.
lOlOOOO\
O\
l\
lOO\

)
&&
(
llO\
OOll\
OOl\
lO
.
lOl\
OOOOOlOll
!=
llOOOllO\
lOOO
.
lOlOOO\
OOllOO
||
llOOO\
l\
lOOll\
O\

.
lOlOOOOOll\
OO
!=
llOOOllO\
lOOO
.
lOlOOOOOlOll
)
)
;
}
}
}
#endif //
fo\
r
(
;
;
)
{
bool
llOlOOl\
OOl
=
fal\
s\
e\

;
int
llOOO\
llOlOOl
=
lOllOlllOll\
O\

;
int
llOOOll\
OlO\
lO
;
fo\
r
(
ll\
OOOll\
OlOl\
O\

=
0
;
llO\
OO\
ll\
OlO\
lO\

<
llOO\
Oll\
O\
OOll\

;
llOOOll\
Ol\
OlO\

++
)
{
if
(
ll\
OOO\
llOO\
Ol\
O
[
llOO\
Ol\
lO\
lO\
lO\

]
==
0
)
continue
;
lOlO\
OO\
OOO\
lO\
l
&
lO\
lOOO\
Ol\
l\
O\
l\
O\

=
*
llOOOllOOOl\
O
[
llOOO\
llOl\
Ol\
O
]
;
TA_A\
SS\
ER\
T
(
lOl\
OO\
OOllOl\
O\

.
lO\
lOOOOOlOll
)
;
u32
llO\
OO\
llOl\
Oll
=
Dynami\
cO\
bject
::
lOlOOlO\
lOl\
l\
l\

|
Dyn\
ami\
cO\
bj\
e\
ct
::
lOOlllOOlOOl
|
Dyna\
mi\
cObj\
ect
::
lO\
Oll\
l\
OOOlll\

|
Dyna\
m\
icObje\
ct
::
lOl\
OOlOOllOO
;
if
(
(
lOl\
OOOO\
llOlO\

.
lOlOOOOOl\
O\
ll
->
GetF\
lags\

(
)
&
llOO\
O\
llOlO\
l\
l\

)
==
Dyn\
a\
micO\
b\
j\
ect\

::
lOl\
O\
OlOOllOO
||
(
lOlOOOOllOlO
.
lO\
l\
OOOOOl\
lOO\

->
Ge\
tFlags\

(
)
&
llO\
OOllOlOll
)
==
Dy\
na\
mi\
cObj\
ect
::
lOlOOlOOllOO
)
{
if
(
(
lOlOO\
OOllOl\
O
.
lOl\
OOOOOlOl\
l
->
Ge\
t\
Fl\
ag\
s
(
)
&
llOOOl\
lO\
lOll
)
==
Dyn\
amic\
Obj\
e\
c\
t
::
lO\
lOOlO\
Ol\
lOO
&&
(
lOl\
OOOOllOlO
.
lOlOOOOO\
llOO
->
GetFlags
(
)
&
llO\
OO\
llOlOll
)
==
Dy\
nam\
i\
cObjec\
t
::
lO\
l\
OO\
l\
O\
O\
llOO
)
conti\
nue\

;
ll\
O\
O\
Ol\
lO\
OOlO
[
llOOO\
llOl\
OlO
]
=
0
;
lOl\
OOOO\
OOlOl
::
Col\
lisi\
o\
nI\
t\
erator\

lOl\
Ol\
ll\
OOOOO\

=
lO\
lOOOO\
llOlO
.
lOlO\
l\
ll\
OOOll
.
lOlOOO\
OlOO
(
)
;
if
(
!
lOlOl\
llO\
OOOO
.
At\
En\
d
(
)
)
{
llOl\
OOlO\
Ol
=
true\

;
if
(
(
lOlOOO\
O\
llOl\
O
.
lOlO\
OOOO\
lOll\

->
Ge\
tF\
lags
(
)
&
(
DynamicOb\
j\
ect
::
lO\
lOO\
lOl\
O\
l\
OO
|
Dynami\
cObj\
ect
::
lOlOOlO\
lOl\
ll\

)
)
==
0
)
{
if\

(
lO\
lOO\
OO\
llOlO
.
lOlOOOO\
O\
lOll
->
lOlO\
Oll\
OO\
lOl\

(
)
==
(
voi\
d\

*
)
&
lOllOllO\
l\
OlO
)
{
TA\
_ASSERT
(
lO\
llOlllO\
ll\
O
<
lOll\
O\
lllOlll
)
;
lO\
llO\
llll\
OO\
l\

[
lOllO\
l\
llO\
ll\
O\

++
]
=
lO\
lO\
OOOl\
lOl\
O
.
lO\
lOOOOOl\
O\
ll\

;
lOl\
OO\
OOllO\
lO\

.
lO\
lO\
OOO\
OlOll
->
lOlOO\
l\
OlOOll
(
tru\
e
)
;
}
}
if
(
(
lO\
lOOOO\
l\
lOlO\

.
lOl\
OO\
OO\
OllOO
->
GetFl\
a\
gs\

(
)
&
(
Dyn\
ami\
c\
Obje\
ct\

::
lOl\
O\
OlOl\
OlOO
|
Dyna\
micObjec\
t
::
lOlOO\
lOlOlll
)
)
==
0
)
{
if
(
lOl\
O\
OOOl\
l\
OlO
.
lOlO\
OOOOl\
l\
OO
->
lOl\
OOl\
lOO\
lOl
(
)
==
(
voi\
d
*
)
&
lO\
l\
lOll\
O\
lOlO\

)
{
TA_\
AS\
SER\
T\

(
lOllO\
lll\
OllO
<
lOllO\
ll\
l\
Olll
)
;
lOllOllll\
O\
Ol
[
lOllOl\
llO\
l\
l\
O
++
]
=
lO\
lOOOOllO\
lO
.
lOlOOOOOl\
lOO\

;
lO\
lO\
O\
OO\
l\
lOl\
O
.
lOlOO\
OO\
OllO\
O\

->
lOlOOl\
OlOOll
(
tru\
e\

)
;
}
}
}
fo\
r
(
;
!
lOl\
O\
ll\
lOOOOO
.
At\
End
(
)
;
++
lOlOll\
lOO\
OO\
O
)
{
TA_ASS\
E\
RT
(
lOllOlll\
O\
Oll
<
lOl\
lOll\
l\
Ol\
OO
)
;
Co\
l\
l\
ision
&
llOl\
lllOlOl
=
*
lOlO\
lllO\
OO\
OO
;
lOllOl\
ll\
lO\
lO
[
lOllOll\
lOO\
l\
l
++
]
=
&
llOlll\
l\
OlOl
;
TA_\
ASSER\
T
(
llOllll\
Ol\
Ol
.
Get\
Ob\
j\
ectA
(
)
!=
ll\
OllllOlO\
l\

.
Ge\
t\
Obj\
ectB
(
)
)
;
TA_AS\
S\
ERT
(
llOllllOlOl
.
GetO\
bjec\
tA
(
)
==
lOlOO\
OO\
llOlO
.
lOlOOOO\
OlO\
ll\

||
llO\
lll\
l\
Ol\
Ol
.
GetOb\
j\
ec\
tB
(
)
==
lOlOOOOllOlO\

.
lOlOOOOOl\
Ol\
l
)
;
TA_ASSERT
(
llO\
l\
l\
ll\
O\
lO\
l\

.
GetOb\
j\
ectA
(
)
==
lOlOO\
OO\
l\
lOl\
O\

.
lO\
l\
OO\
O\
OO\
l\
lOO
||
llOll\
l\
l\
O\
lOl\

.
GetObjectB
(
)
==
lOlO\
OOOllOlO
.
lOlOOO\
OOll\
O\
O
)
;
}
}
}
for
(
ll\
OOO\
llOlOlO\

=
0
;
llO\
O\
OllOlO\
lO
<
ll\
OO\
Oll\
OOOl\
l
;
llOOOll\
Ol\
O\
lO\

++
)
{
if
(
llO\
OOllOO\
OlO\

[
llOO\
Oll\
OlOlO
]
==
0
)
conti\
nue
;
lOlOOOO\
OOlO\
l
&
lOlO\
O\
OOllO\
lO
=
*
llO\
OOll\
OOOlO
[
ll\
OO\
O\
l\
lO\
lOlO
]
;
u32
llO\
OOl\
lOlOll
=
Dynami\
cO\
bject
::
lOlO\
O\
l\
OlO\
lO\
O
;
if
(
(
(
lOl\
OO\
O\
OllOlO
.
lOlO\
OO\
OOlOl\
l
->
GetFl\
a\
gs\

(
)
&
llO\
OOllOlOll
)
||
lOlOOOO\
llOlO
.
lOlO\
OOOOlOll
->
lOlOOllO\
O\
l\
Ol
(
)
!=
(
void
*
)
&
lOl\
lO\
llOlOlO
)
&&
(
(
lOlOOO\
O\
llOlO
.
lOl\
OOO\
OOllOO
->
GetFl\
ags\

(
)
&
llOO\
Oll\
O\
lOll
)
||
lO\
lOOO\
Ol\
lOlO
.
lOl\
O\
OOOO\
l\
lOO
->
lOlOO\
llOOlOl
(
)
!=
(
void
*
)
&
lOllOllOlOlO
)
)
{
lOlOO\
O\
OOO\
l\
Ol
::
Coll\
isi\
onIterator
lOlOl\
llO\
OOOO
=
lO\
l\
OOOOllOlO
.
lO\
lOll\
lOOOll
.
lOlOOO\
OlOO
(
)
;
for
(
;
!
lO\
lOlllOOOOO
.
AtEnd
(
)
;
++
lOl\
OlllOOOO\
O
)
{
TA_\
AS\
SERT
(
lOl\
lO\
l\
llO\
Oll
<
lO\
l\
l\
O\
lllO\
lO\
O
)
;
Colli\
sion
&
llO\
lll\
l\
OlO\
l\

=
*
lOl\
O\
lllOO\
OOO
;
lOllO\
lll\
lOl\
O
[
lOll\
OlllO\
O\
ll
++
]
=
&
llO\
llll\
OlOl
;
TA_A\
S\
SE\
RT
(
llOlll\
lOlOl\

.
GetObje\
ctA
(
)
!=
llOl\
lllOlOl
.
Ge\
tOb\
je\
ctB\

(
)
)
;
TA_\
A\
S\
S\
ERT
(
llOl\
lllOlOl\

.
GetObj\
ectA
(
)
==
lOl\
OOO\
OllOl\
O
.
lO\
l\
O\
OO\
OO\
lO\
ll
||
llOll\
llOlOl
.
Ge\
tO\
bje\
c\
tB
(
)
==
lOlOOOOllO\
lO\

.
lOlOOOOOl\
Oll
)
;
TA\
_ASSERT
(
llOllllOlO\
l\

.
Get\
Ob\
jectA
(
)
==
lOlOO\
OOllOlO
.
lOlOO\
OOOllOO\

||
llOl\
lllOl\
Ol\

.
Get\
Ob\
jec\
t\
B\

(
)
==
lOl\
OOOOll\
OlO\

.
lOlOO\
OOO\
l\
lO\
O
)
;
}
}
}
for
(
int
lOO\
OllO\
O\
Ol
=
llOOOll\
OlOOl
;
lOOOllOOOl
<
lOllOl\
l\
lOl\
lO\

;
lOOO\
llOO\
Ol
++
)
{
TA_ASSER\
T
(
lOllOllll\
OOl\

[
lOO\
Ol\
lOOOl
]
)
;
TA_ASSE\
RT\

(
lOl\
l\
O\
llllO\
O\
l
[
lO\
OO\
l\
lO\
OOl
]
->
lOl\
OOlOlOl\
Ol\

(
)
)
;
lOll\
Ol\
lllOO\
l
[
lOO\
Ol\
lO\
O\
Ol
]
->
lOlO\
OlOlO\
l\
lO
(
true
)
;
lOllOllllO\
Ol
[
lOOO\
ll\
OO\
O\
l\

]
->
lOl\
O\
Ol\
OlOO\
ll\

(
fals\
e
)
;
}
llOOOllOlOO\
l\

=
lOl\
lOll\
l\
OllO
;
TA\
_\
ASSERT
(
lOllOll\
lOllO
<
lOllO\
lllOl\
l\
l
)
;
lO\
llO\
llll\
OOl\

[
lOllOl\
ll\
Ol\
lO
++
]
=
0
;
TA\
_\
ASSER\
T
(
lOl\
lOlll\
OOl\
l
<
lOllOl\
l\
lOlOO\

)
;
lO\
l\
lOllllO\
l\
O\

[
lOll\
OlllOOll\

++
]
=
0
;
if
(
!
llOl\
OO\
l\
OOl
)
break
;
}
}
voi\
d\

Physics\

::
lOllO\
l\
llllll
(
Dynam\
i\
cOb\
j\
ect\

*
*
lOllOllll\
OOl
,
int
lOl\
lO\
lllOllO
,
Collision
*
*
lOllO\
llll\
OlO
,
int\

lOllOlllOO\
ll\

)
{
fl\
oat
lOOl\
l\
l\
OOl\
lOl
=
lOO\
ll\
Ol\
l\
lOl\
O
->
lOlOllll\
O\
llO
;
int
llO\
OO\
lOlOllO
=
4
;
lO\
OlOlllllO\
O\

=
1.0f
;
for
(
in\
t
lOO\
lOOlO\
lO\

=
0
;
lOOlOOlO\
lO\

<
llOOO\
lOlOllO
;
lOOlOOlOl\
O\

++
)
{
if
(
lO\
OlO\
Ol\
O\
lO\

<
llO\
O\
OlO\
lO\
llO
>>
1
)
{
fo\
r
(
in\
t
lO\
OOl\
l\
O\
OOl
=
lOllOll\
lOOll
-
1
;
lOOOl\
lOO\
O\
l
>=
0
;
lO\
O\
OllOOOl
--
)
{
#ifdef lOllOOOllllO
if
(
lOOOllOOOl
>=
3
)
{
con\
st
Coll\
i\
sion\

*
llOOOll\
Ol\
lOO
=
lOl\
lOlll\
lOlO
[
lOOOllOOOl\

-
3
]
;
if
(
llOOO\
ll\
OllO\
O\

)
{
lO\
llOOl\
OOOl\
l
(
&
ll\
OOOllOll\
OO
->
lO\
OOOlllll\

)
;
}
const
Collision
*
llOOOl\
lO\
llO\
l
=
lO\
l\
lOllllOlO
[
lO\
OOllOO\
Ol
-
2
]
;
if
(
llO\
OOllOl\
lOl
)
{
lOllOO\
lOOOll
(
&
llOO\
OllOllOl\

->
lOllOOO\
lOll
)
;
lO\
l\
l\
OOlOOO\
l\
l\

(
&
llOOOl\
lOllO\
l
->
lOllO\
OOllOO
)
;
}
co\
nst
Collisi\
on
*
llOOOl\
l\
Ol\
llO
=
lO\
llOll\
l\
lOl\
O
[
lOOO\
llOOOl\

-
1
]
;
if
(
llOO\
Ol\
lOlll\
O
)
{
lOllOO\
O\
lllll
(
&
llO\
O\
O\
llOll\
lO
->
lOll\
OO\
O\
lO\
ll\

->
GetCente\
r\
Of\
fse\
t\

(
)
)
;
lOl\
lOOO\
llll\
l
(
&
ll\
OOOllO\
lll\
O
->
lOl\
lOO\
O\
llOO
->
Ge\
tCen\
terOffset
(
)
)
;
}
}
#endif //
if
(
!
lOl\
lOlll\
lOlO
[
lOOO\
llOO\
Ol
]
==
0
)
{
Co\
llisi\
o\
n
*
llOllO\
lOlOl
=
lOllOllllOlO\

[
lOOOllO\
OOl\

]
;
int
llOllOOlO\
l
=
(
llOllO\
lOlO\
l
->
lOl\
O\
l\
lO\
OOl
&
Collis\
ion\

::
FL\
AG_JOINT
)
?
lOllOOllll\
l\
l
:
1
;
fo\
r
(
int
lOOlOOlOl\
O
=
0
;
lOOlOO\
lOlO\

<
ll\
Ol\
lOOlOl\

;
lO\
Ol\
O\
OlOl\
O
++
)
{
Collisio\
n\

*
ll\
O\
llOl\
OlO\
l
=
lOll\
Olll\
l\
OlO
[
lOOOllOOOl
]
;
for
(
;
llO\
l\
lOlOlO\
l
;
llOllO\
l\
Ol\
Ol\

=
llO\
llOl\
OlOl\

->
Ge\
t\
Ne\
xt
(
)
)
lOlOOOll\
lO\
ll\

(
lOl\
O\
OlOO\
O\
OOO\

(
lOOlllO\
OllOl\

,
*
llOl\
lOlOl\
Ol
)
,
*
llOl\
l\
OlO\
lOl
)
;
}
}
}
}
fo\
r\

(
int
lOOOl\
l\
O\
OOl
=
0
;
lOO\
OllOOOl
<
lO\
llOl\
llOOll
;
lOOOllOOOl
++
)
{
#ifdef lOllOOOllllO
if\

(
lOOOl\
lO\
OO\
l
<
lOllOl\
llOOll
-
3
)
{
const\

Coll\
ision\

*
llO\
OOllOllOO
=
lO\
l\
lOllllO\
lO
[
lOOOllOOO\
l
+
3
]
;
if
(
llOO\
OllOl\
l\
O\
O\

)
{
lOllOO\
lOOOll
(
&
ll\
O\
OOl\
l\
Oll\
OO\

->
lOOOOlllll
)
;
}
const
Collis\
ion\

*
llO\
OO\
llOllOl
=
lOllOllll\
OlO
[
lOOO\
llOOOl\

+
2
]
;
if
(
ll\
OOOllO\
ll\
Ol\

)
{
lOll\
OO\
lO\
O\
Ol\
l\

(
&
llO\
O\
OllO\
llOl
->
lOllOOOlO\
ll
)
;
lO\
llOO\
l\
O\
OO\
ll
(
&
llOOOl\
lOllOl
->
lOllOOO\
llOO
)
;
}
con\
st
Collis\
i\
o\
n
*
ll\
O\
OOllOll\
l\
O
=
lO\
llOllll\
OlO
[
lOOO\
llOOOl\

+
1
]
;
if\

(
llO\
O\
Ol\
lOlllO\

)
{
lOll\
OO\
Olllll
(
&
ll\
OOO\
ll\
Oll\
lO\

->
lOll\
OOOlOll
->
GetCenter\
O\
ff\
set\

(
)
)
;
lO\
l\
l\
O\
OO\
l\
l\
ll\
l
(
&
llO\
OOl\
l\
O\
l\
ll\
O
->
lOll\
OOOl\
l\
O\
O
->
GetC\
e\
nterOf\
fset\

(
)
)
;
}
}
#endif //
if
(
!
lOllOllllOlO\

[
lOOOllOOOl\

]
==
0
)
{
Co\
llis\
ion\

*
llOll\
OlOlOl
=
lOllOll\
llOl\
O\

[
lOOOll\
OO\
Ol\

]
;
int
llO\
llOOlOl\

=
(
ll\
OllO\
l\
O\
l\
O\
l
->
lO\
l\
Oll\
OOO\
l
&
Col\
li\
s\
io\
n
::
FLA\
G\
_\
JOINT\

)
?
lOl\
l\
OOl\
ll\
lll
:
1
;
fo\
r
(
in\
t
lOO\
lO\
OlOlO\

=
0
;
lOOlO\
OlOlO
<
llO\
llOOlOl
;
lO\
O\
lOOlOlO
++
)
{
Col\
lision
*
llOllOl\
OlOl
=
lOllO\
l\
lllOlO\

[
lOOO\
l\
lOO\
Ol
]
;
for
(
;
llOll\
O\
lOlO\
l
;
llOllOlOlOl
=
llOllOl\
O\
lOl
->
GetNex\
t
(
)
)
lOlOOOlllOll
(
lOlOOlO\
OOOO\
O
(
lOOlllOOll\
O\
l\

,
*
llOllOlO\
lOl
)
,
*
llOllO\
lOlOl\

)
;
}
}
}
}
}
voi\
d
Phys\
i\
cs\

::
lOlllOOOO\
OOO\

(
lOlOlllOl\
llO
&
lOllOllO\
lOlO\

,
Dyna\
micOb\
ject\

*
*
lO\
llOll\
llOO\
l\

,
int
lO\
l\
lOl\
llOllO
,
Colli\
sion
*
*
lOll\
OllllOl\
O
,
int
lOll\
Ol\
l\
lOOll\

)
{
const
float
llO\
OOl\
lOl\
lll
=
1.0f
;
floa\
t\

lOOlllOOllOl\

=
lOOllOll\
l\
OlO
->
lOlOllllOl\
lO
;
int
llOOO\
lllOOOO\

=
0
;
co\
nst
float
ll\
OllOl\
ll\
l
=
0.4f
;
int\

llOOOll\
l\
OO\
O\
l
=
0
;
co\
nst
int
llOOOl\
Ol\
OllO\

=
1
;
int
lO\
Ol\
O\
OlOOO\

=
0
;
int
lO\
lOOOll\
Ol\

=
0
;
for\

(
int
lOO\
OllOOO\
l
=
0
;
lOOOll\
O\
OOl
<
lO\
llOl\
llOOl\
l\

;
lO\
OOl\
l\
OOO\
l
++
)
{
if
(
lOll\
Ol\
l\
l\
lO\
lO
[
lOOOllOOOl
]
==
0
)
{
llOOOl\
llOOOl
++
;
if
(
llOOOl\
llOO\
Ol
<
llOO\
OlOl\
Ol\
lO
)
{
lOOO\
llOOO\
l\

=
lOOl\
OO\
lO\
OO
;
}
else
{
llOOOlllOOOl
=
0
;
for
(
;
llOOOl\
l\
lOOOO\

<
lOllOll\
lO\
ll\
O
&&
lOllO\
llllOOl
[
ll\
OOO\
l\
llOOO\
O
]
;
ll\
O\
OOlllOOOO
++
)
{
TA\
_ASSERT
(
!
lOll\
Oll\
l\
lO\
O\
l
[
ll\
OOOll\
lO\
OOO
]
->
lO\
lOOlOl\
O\
Ol\
O
(
)
)
;
lO\
l\
lOllllOOl
[
llOOOl\
l\
l\
O\
O\
OO
]
->
lOl\
OOl\
OlOOO\
O
(
true
)
;
}
lOl\
OOOllOl
++
;
llOOO\
lllOOOO
++
;
lOO\
lO\
O\
lOOO
=
lOOOllOO\
Ol
+
1
;
}
}
else
{
Col\
l\
ision
&
llOl\
lllOlO\
l\

=
*
lO\
ll\
Ol\
lllO\
l\
O
[
lO\
OOllOOOl
]
;
if\

(
!
llOllllOl\
O\
l
.
GetO\
b\
j\
e\
c\
tA
(
)
->
lO\
lOO\
lO\
l\
O\
OlO
(
)
||
!
llO\
ll\
llOlO\
l
.
GetOb\
j\
ectB\

(
)
->
lOlOO\
lOlO\
OlO
(
)
)
{
int
ll\
OllO\
OlO\
l
=
(
llOll\
llO\
l\
Ol
.
lOlOllOOOl\

&
Collisi\
on
::
FLAG\
_JOIN\
T
)
?
lO\
llOOllllll
:
1
;
for
(
int
lO\
OlOO\
lOlO
=
0
;
lOO\
lOOlOlO
<
llOl\
lOOlO\
l
;
lO\
O\
lOOlO\
lO
++
)
{
Co\
llision\

*
llOllOlOlOl
=
&
llO\
llll\
O\
lOl\

;
for\

(
;
llO\
llO\
lOlOl
;
llO\
llO\
lOlOl\

=
llO\
ll\
O\
lO\
lOl
->
GetNex\
t
(
)
)
{
lOlOOOlll\
lOO
(
lOlOOlO\
O\
OOOO
(
lO\
OlllO\
O\
l\
l\
Ol
,
*
llO\
ll\
OlOlO\
l
)
,
llOllO\
llll
,
1.0f
,
*
llOl\
lOlOl\
O\
l
)
;
}
}
}
else\

{
#ifdef _DEBUG
if\

(
lOO\
lOOOllO
)
{
bool
llOOOlll\
OOlO
=
fal\
s\
e
;
bool\

llOOOll\
lOOll
=
!
llOllllOlO\
l\

.
lO\
llOl\
OlOOl
(
)
;
for
(
in\
t
lOOl\
OOlO\
lO
=
0
;
lOOlO\
OlO\
lO
<
llOOOlllOOO\
O
;
lOOlOOlOlO
++
)
{
if
(
llO\
lll\
lOl\
Ol
.
lOl\
l\
OOOlO\
ll
==
lOl\
l\
O\
ll\
l\
l\
OOl
[
lOO\
lOOlOlO
]
)
llOOOl\
llOOl\
O
=
true\

;
if
(
llOllllOlOl\

.
GetO\
bjectB
(
)
==
lOl\
lOlll\
lOOl\

[
lOOlOO\
lO\
lO
]
)
llOOO\
lllOOll
=
true
;
}
TA\
_AS\
SERT
(
llO\
OOlllOOlO
)
;
TA_\
AS\
SERT
(
ll\
OOOlllO\
Oll
)
;
}
if\

(
lOO\
lOO\
O\
ll\
O
)
{
bool
llOOOl\
llOOlO
=
fals\
e
;
bo\
ol
ll\
OOOll\
lO\
Oll\

=
!
llOll\
ll\
OlO\
l
.
lOllO\
l\
OlOO\
l
(
)
;
fo\
r
(
int
lOOlOO\
lOlO\

=
ll\
OOOlll\
O\
OOO
;
lOOlOOlO\
l\
O
<
lO\
ll\
Ol\
llO\
ll\
O
&&
lO\
ll\
OllllOOl
[
lOOl\
OOlO\
lO
]
;
lOOl\
O\
Ol\
OlO
++
)
{
if
(
llO\
llll\
OlOl
.
lO\
llO\
OOlOl\
l\

==
lO\
llOllllO\
Ol
[
lOOl\
OOlOlO\

]
)
llOOOlllOOlO
=
true
;
if
(
ll\
OllllOl\
Ol
.
Get\
O\
bjectB\

(
)
==
lOllO\
llllO\
O\
l
[
lOO\
l\
OO\
lO\
lO
]
)
llO\
OOlll\
OOll
=
tr\
ue
;
}
TA_ASS\
ERT
(
llO\
OOlllOOlO
)
;
TA\
_AS\
SERT
(
llOOOlllOOll\

)
;
}
#endif //
TA_A\
SSE\
RT
(
0
)
;
}
}
}
}
vo\
id\

Physi\
cs\

::
lOlllOOOOlOO
(
lOl\
lOlO\
O\
OlOl
*
lOlllOOO\
OO\
lO
,
int
lOlllO\
OO\
O\
OO\
l\

,
int\

llO\
ll\
OllOl
,
const
Vec\
3
&
ll\
OO\
O\
l\
llOlOO\

)
{
float
lOOl\
llOO\
llOl
=
lO\
OllOl\
l\
lO\
lO
->
lOlOll\
ll\
Oll\
O\

;
lOO\
lOlllll\
O\
O
=
1.0f
;
for\

(
int\

lOOO\
llOOOl
=
0
;
lOOOllOOOl
<
llOllOll\
Ol\

;
lOOOllOOO\
l
++
)
{
int
llOOO\
O\
lOO\
Ol\
l
;
for
(
ll\
OO\
O\
OlOO\
O\
ll\

=
lOll\
lOOO\
O\
O\
Ol
-
1
;
llO\
O\
O\
OlOO\
O\
ll
>=
0
;
llOOOO\
lOOOll
--
)
{
#ifdef lOllOOOllllO
if
(
llO\
O\
O\
OlO\
OOll
>=
3
)
{
const
Collisio\
n
*
llOO\
OllOl\
lOO
=
lO\
lll\
OOOOO\
l\
O
[
llOOOO\
lOOOl\
l
-
3
]
.
ll\
Oll\
OlOlOl
;
lOllOOlO\
OOl\
l
(
&
llOOOll\
O\
ll\
OO
->
lO\
O\
O\
Olllll
)
;
co\
nst\

Collisi\
on
*
ll\
OOOllOll\
O\
l
=
lOlllOOOOOlO
[
llOOO\
Ol\
OOOl\
l
-
2
]
.
llO\
ll\
OlOlO\
l\

;
lO\
llO\
OlOOO\
l\
l\

(
&
llO\
OOll\
Oll\
O\
l
->
lO\
llOOO\
lOll
)
;
lOllO\
OlOOOl\
l
(
&
llOOO\
ll\
OllOl
->
lOllOOOllO\
O
)
;
con\
s\
t
Colli\
s\
i\
on
*
llOOOl\
lOll\
lO
=
lOlllOOOOOl\
O\

[
llOO\
OOl\
OO\
Oll
-
1
]
.
llOl\
l\
OlOl\
Ol
;
lOllOO\
Ol\
llll\

(
&
llOO\
Ol\
lOl\
llO\

->
lOllOOO\
lOll
->
GetCenterOffset
(
)
)
;
lOllOO\
Ollll\
l
(
&
ll\
OOOllOlll\
O
->
lO\
llOO\
O\
llOO
->
Ge\
t\
Ce\
nterOf\
fs\
et\

(
)
)
;
}
#endif //
Colli\
s\
ion
&
llO\
l\
l\
l\
lOlOl
=
*
lOl\
llOOO\
O\
Ol\
O\

[
llOOOOlOOOll\

]
.
llOllOlOlOl
;
lOlOO\
Olll\
Oll
(
lOlOOlOOOOOO
(
lOOll\
l\
OOl\
lOl
,
llOll\
ll\
OlOl
)
,
llOl\
lllOlOl\

)
;
}
for
(
llOOOOl\
OOOll
=
0
;
llOOOOl\
OOOl\
l
<
lO\
lllOO\
OO\
OOl\

;
llOOOOlO\
OOll
++
)
{
#ifdef lOllOOOllllO
if
(
llOOOOlO\
OOl\
l
<
lOlllOOOOOOl
-
3
)
{
cons\
t\

Co\
lli\
sion
*
llOOOllO\
llOO
=
lOll\
lOO\
OOOl\
O
[
llOOOOl\
OO\
Oll
+
3
]
.
llOll\
O\
lOlOl
;
lOl\
lOOlOOOll
(
&
llOO\
O\
l\
lO\
llOO\

->
lOOOOlllll
)
;
cons\
t
Collision
*
llOOOl\
lOllO\
l\

=
lO\
l\
l\
lOOO\
O\
Ol\
O
[
llOO\
OO\
lOOOl\
l
+
2
]
.
llOl\
lO\
lOlO\
l\

;
lO\
l\
lOOl\
OOOll
(
&
llOOOll\
Ol\
lOl
->
lOl\
lOO\
OlOll
)
;
lOll\
OOlOO\
Oll
(
&
llO\
OO\
l\
lOllO\
l
->
lOllO\
OOl\
lOO\

)
;
co\
ns\
t
Co\
llision
*
ll\
OOO\
ll\
OlllO\

=
lOl\
llO\
O\
O\
OO\
lO
[
llOO\
OOlO\
OOl\
l
+
1
]
.
ll\
O\
ll\
OlOlO\
l
;
lO\
llOOOl\
llll
(
&
llOO\
Oll\
Oll\
lO
->
lOll\
OOO\
lOll
->
GetCen\
te\
r\
Of\
fs\
et
(
)
)
;
lOllO\
OOlll\
l\
l
(
&
llO\
OOll\
OlllO
->
lOllOOOll\
O\
O
->
Get\
Cent\
erOffset\

(
)
)
;
}
#endif //
Col\
lision
&
llOl\
lllOlOl
=
*
lOlll\
OO\
OOO\
lO\

[
ll\
OOOOl\
OOO\
ll\

]
.
llOl\
lOl\
Ol\
Ol
;
lOlOO\
Olll\
Oll
(
lO\
l\
O\
O\
lOOO\
OOO
(
lO\
Ol\
llO\
O\
llOl
,
llOlll\
lOlOl\

)
,
llO\
l\
l\
llOlOl\

)
;
}
}
lOOl\
Ollll\
lO\
O
=
1.0f
;
}
void
Ph\
ysic\
s\

::
lOlllO\
OOOlOl
(
lO\
llOlO\
OOlOl
*
lOlllOOOO\
OlO
,
in\
t
lOlllOOOOOOl
,
int
llOl\
lOll\
O\
l
,
co\
nst
Vec3
&
llOOO\
l\
l\
lOlOO
)
{
flo\
at
lOOlll\
OOl\
lOl
=
lOO\
l\
lOll\
lOlO
->
lOlO\
llllOll\
O
;
float
llOOOl\
llOlOl\

=
llO\
OOlllO\
lO\
O
.
GetMagnitude\

(
)
*
0.2f
;
for
(
int\

lOOOllOOO\
l
=
0
;
lOOOl\
l\
O\
OO\
l
<
llOllOllO\
l
;
lOOOllOOOl
++
)
{
lOlOlllllOOl
=
3.5f
;
float
llO\
OOll\
lOllO
=
0.25f
;
float\

lO\
lOOOl\
l\
llOl
=
1.0f
;
float
ll\
OOO\
lllOl\
ll
=
0.65f
;
float
llOOO\
llll\
OOO
=
0.65f
;
if
(
lO\
OOllO\
OOl
==
0
)
{
llOOOlll\
Ol\
ll
=
1.05f
;
llOO\
O\
llllO\
OO
=
1.05f
;
}
else\

if\

(
lOOO\
llO\
O\
Ol
==
llOllOll\
Ol\

-
1
)
{
lO\
lOlll\
ll\
OOl
=
0.05f
;
llOOO\
l\
l\
lOllO
=
0.65f
;
llOOOlll\
lOOO
=
0.05f
;
llOOOll\
lO\
lll
=
0.05f
;
lO\
lOOOllllOl\

=
1.0f
;
}
lOlOOOl\
lllOl\

=
0.4f
;
for
(
in\
t
llOOOOlOOOll
=
0
;
llOOO\
OlOO\
Ol\
l
<
lOlllO\
O\
OOOOl
;
llOOOOlOOO\
l\
l
++
)
{
#ifdef lOllOOOllllO
if\

(
ll\
OO\
OOl\
O\
OOll
<
lOl\
llOOOOOOl
-
3
)
{
const
Coll\
i\
sion
*
llO\
OOll\
O\
llOO\

=
lOlllOOOOOl\
O
[
llO\
O\
OOlOOOll\

+
3
]
.
ll\
O\
llOlOlOl
;
lOllOOl\
OOO\
ll\

(
&
llOOOl\
lOl\
lOO
->
lO\
OOOl\
l\
ll\
l\

)
;
const
Colli\
s\
io\
n\

*
ll\
OOOllO\
llO\
l\

=
lOlllOO\
O\
OOlO
[
llOOOO\
lO\
O\
Oll\

+
2
]
.
llOll\
O\
lOlOl
;
lOl\
lO\
OlO\
OO\
l\
l
(
&
llOOOl\
l\
O\
llOl
->
lO\
llOOO\
lO\
ll
)
;
lOllOO\
lOOOll\

(
&
llOOOllOllO\
l
->
lOllOOO\
ll\
OO
)
;
cons\
t
Collisi\
o\
n
*
ll\
OOOll\
Oll\
lO
=
lO\
lllOOOOO\
lO\

[
llOOOOlOOO\
l\
l\

+
1
]
.
llOllO\
lOlO\
l
;
lOllOOOlllll
(
&
llOOOllOll\
lO
->
lOllOO\
OlO\
ll\

->
Get\
Center\
O\
ff\
set
(
)
)
;
lOllOOOl\
lll\
l
(
&
llOOO\
llOlllO\

->
lO\
ll\
O\
OOllOO
->
GetC\
ente\
rOf\
f\
set
(
)
)
;
}
#endif //
float
llOllOl\
l\
ll
=
llOO\
Oll\
lO\
ll\
O
;
Collis\
ion
&
ll\
Oll\
llOl\
O\
l
=
*
lO\
l\
l\
lO\
OO\
OO\
lO
[
ll\
OO\
OOlOO\
O\
l\
l
]
.
llOllOlOlOl
;
fl\
oat\

llOO\
Ollll\
O\
O\
l\

=
ll\
OOOl\
llOlOl
;
bool
llOOOllll\
Ol\
O
=
fa\
lse
;
bo\
ol\

llO\
OOll\
ll\
O\
ll
=
fa\
l\
se
;
if\

(
(
llO\
lll\
l\
OlOl
.
lOlO\
ll\
OOOl
&
Coll\
i\
sion
::
FLAG_CONST\
RAIN_I\
N_BOTH_\
DIRECTION\
S
)
!=
0
)
{
if\

(
llOOOll\
lOlOO\

.
Dot
(
ll\
OllllOlO\
l
.
lOllOO\
OlO\
l\
l
->
GetP\
ositi\
o\
n
(
)
-
ll\
Olll\
lOl\
Ol
.
lOOOOlllll
)
<
0.0f
)
llOOOllllOlO\

=
tru\
e
;
if\

(
llOl\
l\
llOlOl
.
lOllOlOl\
O\
Ol
(
)
&&
llOOO\
lll\
OlOO
.
Dot
(
llOl\
l\
llOl\
Ol\

.
lOll\
Ol\
O\
l\
OO\
l
(
)
->
Get\
Pos\
ition
(
)
-
llO\
llll\
O\
l\
Ol
.
lOOOOlllll
)
<
0.0f
)
ll\
OOOllllOll\

=
tru\
e
;
llOl\
lOllll\

*=
0.5f
;
}
else\

{
float
lOlOOOlOOl\
O\

=
llOll\
llOlO\
l
.
lO\
OOlOOOOO
.
Dot\

(
llO\
OOl\
ll\
OlOO
)
;
if
(
lOlOOOlOO\
lO
<
-
llOOOllllO\
Ol\

)
llOO\
OllllO\
l\
O
=
true
;
els\
e
if
(
llO\
llllOlOl\

.
lOllO\
lOlO\
Ol
(
)
&&
lO\
l\
OO\
OlO\
OlO
>
ll\
O\
OO\
llllOOl
)
ll\
OOOlll\
lOll
=
true\

;
}
floa\
t\

lOOllll\
OO\
OOl
=
0.0f
;
if\

(
llOO\
Oll\
l\
l\
OlO
|
llOO\
Ollll\
O\
ll\

)
{
lOOll\
llOOOOl\

=
lO\
l\
OO\
lO\
OOOOO
(
lOO\
ll\
lOO\
llOl
,
llO\
ll\
llOlOl\

)
;
#ifndef llOOOlllllOO
#endif //
floa\
t
lOO\
llO\
OOOOOl
=
Min
(
llOll\
llOlOl
.
GetObjectA
(
)
->
lOO\
ll\
OOOO\
OlO
(
)
,
ll\
Ol\
ll\
l\
OlOl
.
GetO\
bj\
ec\
tB
(
)
->
lOOllOO\
OOOlO
(
)
)
;
const
fl\
oat
ll\
OOOll\
lllOl\

=
10.0f
;
flo\
at
ll\
OOOll\
lll\
lO
=
Fabs
(
lOOl\
lllOO\
OO\
l
/
lO\
OllOO\
OOOOl\

)
-
0.5f
;
if
(
ll\
OOOlll\
lllO
<
0.0f
)
llO\
O\
Ollll\
llO
=
0.0f
;
ll\
O\
O\
OllllllO
*=
llOOOll\
llllO\

;
ll\
OOOl\
ll\
l\
llO
*=
llO\
OOl\
lllll\
O
;
llOllO\
l\
lll
*=
(
0.9f
*
llO\
OOll\
l\
llOl
/
(
llO\
OOllll\
lOl
+
llOOOll\
llllO
)
)
+
0.1f
;
}
lOO\
l\
O\
l\
lll\
lOO
=
llO\
OOllll\
O\
O\
O
;
llOlll\
l\
OlO\
l
.
GetO\
bjec\
tA
(
)
->
lOlOOlOl\
O\
O\
OO
(
fals\
e\

)
;
if
(
llOOOll\
llO\
lO
)
{
llOl\
ll\
l\
OlOl
.
Ge\
tO\
bject\
B
(
)
->
lOlOO\
l\
O\
l\
OOOO
(
true
)
;
lOlOOOllll\
OO
(
lOOll\
ll\
O\
OOOl
,
llOl\
lOllll
,
llOl\
l\
Oll\
l\
l
*
lOlOOO\
lll\
lOl
,
llOllllOlOl
)
;
}
ll\
OllllOlOl
.
Get\
ObjectB
(
)
->
lO\
lOO\
lO\
lOOOO
(
fa\
lse
)
;
if
(
llO\
OO\
llllOll
)
{
llO\
llllOl\
Ol\

.
Get\
Ob\
ject\
A
(
)
->
lOlOOl\
OlOOOO
(
true
)
;
lOlOO\
OllllOO
(
lOOl\
lllOOOO\
l
,
llOllOll\
ll
,
llOl\
l\
Ollll
*
lOlOO\
Oll\
llOl\

,
ll\
Oll\
l\
l\
Ol\
O\
l
)
;
ll\
Olll\
lO\
lOl
.
Get\
ObjectA
(
)
->
lOlOO\
lOlOO\
OO
(
false\

)
;
}
}
if
(
lOOOllOOOl
<
llOllOllO\
l
-
1
)
{
lOlOlllllOOl
=
0.05f
;
llOOOlllOllO\

=
0.2f
;
for\

(
int
llOO\
OOlOOOll
=
lOlllOOOO\
OO\
l
-
1
;
ll\
OOOO\
lOOOll
>=
0
;
llOOOOlOOOll
--
)
{
#ifdef lOllOOOllllO
if
(
llOOOOlOOOl\
l
>=
3
)
{
cons\
t\

Co\
llisi\
on
*
llOO\
OllOllOO\

=
lO\
lllOOOOOlO\

[
llO\
OOO\
lOOOl\
l
-
3
]
.
llO\
llOl\
OlOl\

;
lOllOO\
lOOOl\
l\

(
&
ll\
OOOllOllOO
->
lOO\
O\
Ollll\
l
)
;
co\
n\
s\
t\

Col\
lis\
ion
*
llOO\
O\
llOl\
l\
O\
l
=
lOl\
llOO\
OOOlO
[
llOO\
O\
OlOO\
Oll\

-
2
]
.
ll\
Oll\
O\
l\
O\
lOl\

;
lOllOOlOOO\
l\
l
(
&
llOOOl\
lOllOl
->
lOllOOOlOl\
l
)
;
lOllOOlOO\
Ol\
l
(
&
ll\
OOOllOll\
Ol
->
lOllO\
OOl\
lOO
)
;
co\
nst\

Collision\

*
ll\
O\
OOl\
lOlllO\

=
lOl\
ll\
O\
O\
O\
OOl\
O
[
llO\
O\
OOlOO\
Oll
-
1
]
.
llOl\
l\
O\
l\
Ol\
Ol
;
lOll\
O\
O\
O\
lll\
ll
(
&
llOOOl\
lOlllO
->
lOllOOOlO\
ll
->
Ge\
t\
Ce\
nter\
Off\
se\
t
(
)
)
;
lO\
llOOO\
l\
l\
ll\
l
(
&
ll\
O\
OOl\
l\
O\
ll\
lO\

->
lOll\
OOOllOO
->
GetCe\
nterOf\
fse\
t
(
)
)
;
}
#endif //
floa\
t
llOll\
Ol\
lll
=
llOOOll\
l\
Oll\
O
+
0.1f
;
Coll\
i\
sion
&
llOl\
ll\
lOlOl\

=
*
lOlllOOOOO\
lO\

[
llO\
OOO\
l\
OOOl\
l
]
.
ll\
Ol\
lOlOlOl
;
float
llOOOll\
llO\
O\
l
=
llOOOlllOlO\
l
;
bool
llOOO\
l\
lllOl\
O
=
fals\
e
;
bo\
o\
l
llO\
O\
Ol\
lllOll
=
fa\
l\
s\
e
;
if
(
(
llOll\
llOlOl
.
lOl\
O\
l\
lOOOl
&
Colli\
s\
i\
on
::
FLA\
G_C\
O\
NS\
TRAI\
N_IN_B\
OTH_\
DIR\
ECTIONS
)
!=
0
)
{
if\

(
llOOO\
l\
l\
lOlOO
.
Dot
(
ll\
O\
l\
lll\
Ol\
Ol
.
lOllOOO\
l\
Oll
->
GetP\
o\
si\
tio\
n
(
)
-
llO\
llllOlO\
l\

.
lOOO\
Olll\
l\
l
)
>
0.0f
)
llOOOllllOlO
=
tru\
e
;
if
(
llOll\
ll\
O\
lOl
.
lOllO\
lOlOOl
(
)
&&
llOOOl\
llOlOO\

.
Dot
(
llOll\
llO\
lOl\

.
lO\
llO\
lO\
lOOl\

(
)
->
Ge\
tPositi\
on
(
)
-
ll\
Oll\
llOl\
Ol
.
lOOOOl\
lll\
l
)
>
0.0f
)
ll\
OOO\
llllO\
ll
=
tr\
u\
e
;
llOllO\
llll
*=
0.5f
;
}
el\
s\
e
{
float
lOlO\
OOlOO\
l\
O
=
llOlll\
l\
OlO\
l
.
lO\
O\
OlOOOOO
.
Dot
(
llOO\
Ol\
l\
lOlOO
)
;
if
(
lOl\
OOOlO\
OlO
>
llOOOll\
l\
lOO\
l\

)
llO\
OOl\
ll\
lOlO
=
tr\
ue\

;
els\
e
if\

(
ll\
O\
llll\
OlOl\

.
lOl\
lOlOlOO\
l\

(
)
&&
lOl\
OOOlOOlO
<
-
ll\
O\
OO\
lll\
lOOl
)
llOOOlll\
lOll
=
tru\
e\

;
}
lOOlOllll\
l\
OO
=
llOOOllllOOO
;
llOlll\
l\
OlOl
.
GetObjec\
tB\

(
)
->
lO\
lOOlOlOOOO
(
fal\
se\

)
;
if
(
ll\
OOOlll\
lOlO\

)
{
llOl\
l\
l\
lOlOl
.
Ge\
tO\
b\
j\
ect\
A
(
)
->
lOl\
O\
OlOlOO\
OO
(
true
)
;
lOlOOOlll\
lOO
(
lO\
lOOlO\
OOO\
OO
(
lO\
O\
ll\
l\
OOll\
Ol
,
ll\
Oll\
llOl\
Ol
)
,
ll\
OllO\
llll
,
0.0f
,
llOllllO\
l\
Ol
)
;
}
ll\
O\
ll\
llOlOl
.
GetO\
bjectA
(
)
->
lO\
lOOl\
OlOOOO
(
fa\
lse\

)
;
if
(
llOO\
OllllO\
ll
)
{
llOlll\
lOl\
Ol
.
GetO\
bject\
B
(
)
->
lOlOO\
lOl\
O\
O\
OO
(
tru\
e
)
;
lOlOOOl\
lllOO
(
lO\
lO\
O\
l\
OOOO\
OO\

(
lO\
Ol\
l\
lO\
O\
llOl
,
llO\
llllO\
lOl
)
,
llOllOl\
lll
,
0.0f
,
ll\
Ol\
ll\
l\
OlOl
)
;
llOllllO\
lOl
.
GetO\
bj\
e\
c\
tB
(
)
->
lOlOOl\
Ol\
OOO\
O
(
false
)
;
}
}
}
}
lOO\
lOl\
ll\
llOO
=
1.0f
;
lO\
lOlll\
ll\
O\
Ol\

=
1.0f
;
}
void\

Ph\
y\
sics
::
lO\
llO\
l\
l\
lllO\
O
(
lOlOlll\
OlllO
&
lOll\
OllO\
l\
O\
lO
,
Dynami\
cObject
*
*
lOllO\
ll\
ll\
O\
Ol
,
in\
t\

lOll\
Olll\
OllO
,
Collisi\
on\

*
*
lOl\
l\
O\
l\
l\
llO\
l\
O
,
in\
t
lO\
llOlll\
OOll\

)
{
float
lOO\
l\
llOO\
llO\
l\

=
lOOllOl\
l\
lOl\
O
->
lO\
lO\
llll\
O\
llO
;
#ifdef _DEBUG
for
(
int\

lO\
OlO\
lO\
OO\
l
=
0
;
lOO\
lO\
lO\
OOl\

<
lOllOl\
l\
lO\
llO
;
lO\
OlOlO\
OOl\

++
)
{
if
(
lOl\
lOllll\
OO\
l
[
lOOlO\
lOOOl\

]
)
{
TA_AS\
SERT
(
!
lO\
llOllll\
OOl\

[
lOOlOlOOOl
]
->
lOlOO\
lO\
l\
OOlO\

(
)
)
;
}
}
#endif //
int\

ll\
OOOl\
l\
lOOO\
O
=
0
;
co\
ns\
t\

float
llOllOl\
lll
=
0.5f
;
int\

ll\
OOOlllOO\
Ol\

=
0
;
const
int
llO\
OO\
lO\
lO\
ll\
O
=
2
;
int\

lOOlOOlO\
OO
=
0
;
for
(
int\

lOO\
OllOOOl
=
0
;
lOOO\
llO\
OOl
<
lO\
llOl\
l\
lOOll\

;
lOOOllOOOl\

++
)
{
if
(
lO\
ll\
Ollll\
OlO\

[
lO\
OOllOOOl\

]
==
0
)
{
llO\
OOlllO\
OOl\

++
;
if
(
ll\
O\
OO\
l\
llOOO\
l\

<
llOO\
O\
lO\
lOllO
)
{
lOO\
OllOOOl
=
lO\
O\
lOOlOO\
O
;
}
el\
s\
e
{
ll\
OOOll\
l\
OO\
Ol
=
0
;
fo\
r
(
;
llO\
O\
Olll\
O\
OOO
<
lOll\
Oll\
lOllO
&&
lO\
l\
lOlll\
lOO\
l
[
llO\
O\
Ol\
llOOOO\

]
;
llOOOll\
lOOOO
++
)
{
TA_AS\
SERT
(
!
lOllO\
llllOOl
[
llO\
OOlllOO\
OO
]
->
lO\
lOO\
lOlOOlO\

(
)
)
;
lO\
llOl\
ll\
l\
OOl
[
llOOOll\
lO\
OOO\

]
->
lOlOOlOlOO\
OO
(
tru\
e
)
;
}
ll\
O\
OOlll\
OO\
OO
++
;
lO\
OlO\
Ol\
OOO
=
lO\
OOll\
OOOl
+
1
;
}
}
else
{
Col\
lision
&
llOl\
l\
llOlO\
l
=
*
lOllOll\
ll\
OlO
[
lO\
O\
OllOOO\
l
]
;
if\

(
(
llOllllO\
l\
Ol
.
lO\
lOl\
lOOO\
l\

&
Coll\
ision
::
FLAG_JOIN\
T
)
)
{
fo\
r
(
int
lOOlOlOO\
O\
l\

=
0
;
lO\
OlOl\
OOOl\

<
4
;
lO\
Ol\
O\
l\
OOOl
++
)
{
lO\
OlOlllllOO\

=
(
1.33f
-
(
float
)
lO\
OlOlO\
O\
Ol\

*
0.33f
)
*
0.5f
;
for\

(
Collis\
i\
on\

*
lOOOO\
OOllll
=
&
llOlll\
l\
OlOl
;
lOOOOOOl\
lll
;
lOOOOO\
O\
llll
=
lO\
OOOOOllll
->
GetNext\

(
)
)
{
lOlO\
OO\
l\
lllOO
(
lOlOOlO\
O\
OOOO\

(
lOOlll\
O\
O\
llO\
l
,
*
lOOOOOOl\
ll\
l
)
,
1.0f
,
0.0f
,
*
lO\
OO\
OO\
Ol\
l\
l\
l\

)
;
}
}
lOO\
lO\
llll\
lOO\

=
1.0f
;
}
else
if
(
(
llO\
ll\
l\
lOlOl
.
lOl\
OllOOOl
&
Collisio\
n\

::
FLAG\
_JOIN\
T_\
LIMIT
)
)
{
lO\
lOOOllllOO
(
lOl\
O\
OlOOOOOO
(
lOOll\
lOOllO\
l
,
llOllllOl\
Ol
)
,
ll\
OllO\
l\
l\
ll
,
0.0f
,
llOllllOlOl
)
;
}
else
{
if
(
!
(
llO\
llll\
O\
lO\
l
.
lOlOllOO\
O\
l\

&
Colli\
si\
o\
n
::
FLAG_F\
RIC\
T\
I\
ON\
_GENERATING_\
IMPULSE
)
)
continue
;
lOl\
OO\
O\
llll\
ll
(
lOlOO\
lO\
OOOO\
O
(
lOOlll\
OO\
l\
l\
O\
l\

,
llOll\
l\
l\
Ol\
Ol
)
,
llOllOllll
,
ll\
OllllOlOl\

)
;
}
}
}
}
void\

Phy\
sics
::
llOOOll\
l\
l\
lll
(
lOllOlO\
OO\
l\
Ol\

*
lO\
ll\
lOO\
OOOlO\

,
int\

lO\
l\
llO\
O\
OO\
O\
Ol
,
int
llOllOl\
lOl\

,
con\
st\

Vec\
3
&
llOO\
OlllO\
lOO
)
{
}
vo\
id
Phy\
s\
i\
c\
s
::
lO\
l\
llOOO\
lO\
OO
(
)
{
lllOlOll\
l\
O
|=
lOlll\
Ol\
O\
lOOl
;
TA_\
A\
SSERT
(
lO\
ll\
lOO\
OlOll
==
0
)
;
lOllOlO\
llOlO
::
Iterator
lO\
llO\
llOl\
OOl
=
lO\
l\
l\
OlO\
llO\
O\
l
->
lO\
lOOOO\
lO\
O\

(
)
;
fo\
r
(
;
!
lOllOllO\
lO\
Ol
.
AtEn\
d
(
)
;
++
lOllOllOlOOl\

)
{
lOlOlllOlllO
&
lOllOllOl\
O\
lO
=
(
*
lOllOl\
lOlO\
Ol\

)
;
lOl\
OlllOlllO
::
It\
era\
tor
lOl\
OlllOO\
OO\
O
=
lOllOll\
Ol\
O\
lO\

.
lOlOO\
OOl\
O\
O
(
)
;
for\

(
;
!
lO\
lO\
l\
llOO\
OO\
O
.
AtEnd\

(
)
;
++
lOlOlllOOOOO\

)
{
Co\
l\
l\
ision
&
llOl\
ll\
lO\
lOl\

=
*
lOlOl\
llO\
OOOO
;
if
(
lO\
lllOOl\
lOlO
)
lOlllO\
O\
l\
lOlO
(
(
Post\
Col\
li\
sio\
n\

&
)
ll\
OllllOlOl
)
;
Phy\
si\
cs\
Joi\
n\
t
*
lOlllOOlOOO
=
llOllllOlOl\

.
GetJ\
oint
(
)
;
if\

(
lO\
ll\
lOOlO\
O\
O
&&
lOlllOOl\
OOO
->
IsBrea\
ka\
b\
l\
e
(
)
&&
llOllllO\
lOl
.
lOll\
OO\
l\
OOlO
>
lOll\
lOOlOO\
O
->
Ge\
tBreakFor\
ce
(
)
&&
!
lOl\
llOO\
lOO\
O\

->
IsBro\
k\
en
(
)
)
{
lO\
lllOOlOOO
->
SetBroken
(
true
)
;
if
(
lOlllOOll\
Oll
)
lOll\
lOOl\
lOll
(
*
lOll\
lO\
Ol\
OOO
)
;
}
}
}
if
(
lOlllOOllOlO\

)
{
lO\
llOlOl\
lOl\
O
::
lO\
ll\
l\
lOOOllO
llOOlOOOOO\
OO\

=
lO\
ll\
O\
lOl\
lOOl\

->
ll\
OO\
l\
OOOOOO\
l\

(
)
;
for
(
;
!
llO\
OlOOO\
OOOO
.
At\
En\
d
(
)
;
++
llOO\
lO\
OOO\
OOO
)
{
lOl\
OOOOOOlOl\

&
lO\
l\
OOOO\
ll\
O\
lO
=
*
ll\
O\
OlO\
OOOO\
OO
;
lOlOOOO\
O\
Ol\
O\
l
::
Col\
l\
is\
ionIterat\
or
lOl\
O\
lll\
OOO\
OO\

=
lOlOOO\
OllOlO
.
lOlOll\
lOOOl\
l
.
lOlO\
OOOlO\
O\

(
)
;
fo\
r
(
;
!
lOlOlllOO\
O\
OO
.
AtEnd\

(
)
;
++
lOlO\
lllOOOOO
)
{
Collisio\
n
&
llO\
llllO\
lOl\

=
*
lOlOlll\
OO\
OOO
;
TA\
_ASSE\
RT
(
lOlllOOllOl\
O\

)
;
lOlll\
OOllOlO\

(
(
Pos\
tCollisio\
n
&
)
llOllllOlO\
l
)
;
}
}
}
lllOlOlllO
&=
~
lO\
lllOlOlOOl
;
for
(
DynamicObj\
ect
*
lO\
OOOOOll\
ll
=
lOlllO\
OO\
lOll
;
lOOOOOOl\
lll
;
)
{
Dynam\
icOb\
j\
ect
*
lOlllOOO\
l\
lO
=
lOOOOOO\
l\
lll
;
lOOOOOOlll\
l
=
lO\
OOOOOlll\
l\

->
lOlOO\
llll\
OlO
(
)
;
TA_ASS\
ER\
T
(
lOlllOOOllO
->
lOOlOO\
O\
lO\
ll\

(
)
)
;
lOl\
llO\
O\
OllO
->
lO\
lOO\
l\
l\
l\
lOOl\

(
0
)
;
lOlllOOOllO
->
lOlOO\
lO\
llOOl
(
fal\
se
)
;
RemoveDyn\
am\
i\
cObjec\
t
(
lOll\
lOOOllO\

)
;
lOlllO\
OOll\
O
->
Release
(
)
;
}
lOlllOO\
OlO\
ll
=
0
;
}
bool\

Physic\
s
::
llOOl\
OOO\
OOl\
O\

(
Dyn\
amicOb\
ject
*
lOlll\
OOOllO
)
{
if
(
lO\
lllOOOllO
->
Mov\
ement\
Disa\
bled
(
)
)
return
fa\
ls\
e\

;
re\
t\
urn
lOll\
O\
lO\
l\
lOll
.
lOOlOOl\
OOll
(
)
;
}
void\

Phy\
sics\

::
lOl\
lO\
l\
lOOlOl
(
)
{
}
voi\
d\

Physics\

::
lOOlll\
O\
O\
lO\
ll
(
Dyn\
a\
micOb\
ject
*
lOll\
lOO\
Oll\
O
,
int
lOO\
l\
l\
lOOlO\
lO
)
{
if
(
lO\
l\
llO\
OOllO
->
Move\
ment\
Di\
sa\
b\
led
(
)
)
retu\
rn
;
TA_ASS\
ERT
(
!
lOl\
llOOOllO
->
IsInMovin\
g\
List
(
)
)
;
if
(
lOOlllOO\
l\
O\
lO
!=
SET_MOV\
ING_P\
R\
IORITY\
_L\
OW
)
{
if
(
!
lOllO\
lOllOl\
l
.
lOO\
l\
OOlOOll\

(
)
)
{
floa\
t\

llO\
O\
l\
OOOO\
Ol\
l
=
-
k_f\
MaxF\
loat
;
Dy\
namicObje\
c\
t
*
llOOlOOOOlO\
O
=
0
;
lOll\
lOl\
OlO\
lO\

lO\
l\
llOlll\
OOO\

=
lOl\
lOl\
O\
lll\
OO
.
lOlOO\
OOl\
O\
O\

(
)
;
for\

(
;
!
lO\
lllO\
l\
llOOO
.
AtE\
nd
(
)
;
++
lOl\
l\
lOll\
lO\
O\
O
)
{
Dy\
namicO\
bje\
ct
&
lOll\
O\
lOllOOO
=
*
*
lO\
l\
llOll\
lOOO
;
if\

(
lOllOlO\
l\
lOOO
.
lO\
lOOO\
OllllO
(
)
)
{
flo\
at
llOOlOOOO\
lOl
=
lOllOlOll\
OOO\

.
lOlO\
Ol\
llOOO\
l
(
)
;
if
(
ll\
OOlOOOOO\
l\
l\

<
ll\
OOlO\
OOOlOl
)
{
llO\
OlO\
OO\
OOl\
l
=
llOOl\
OOO\
OlOl
;
ll\
OOlOOO\
OlOO
=
&
lOllO\
lOllO\
OO
;
}
}
}
if
(
llOOl\
OO\
OO\
lOO
)
{
llO\
Ol\
OOOOlO\
O
->
Se\
tTo\
Re\
stin\
g
(
)
;
}
el\
se\

{
floa\
t
ll\
OO\
lO\
OOOll\
O
=
k_f\
Max\
Flo\
at\

;
lOlllOlllO\
O\
O
=
lOllOlO\
l\
llOO
.
lOlOOOOl\
OO
(
)
;
fo\
r
(
;
!
lOlllOlllO\
O\
O
.
AtEnd\

(
)
;
++
lO\
ll\
lOlll\
OOO
)
{
Dy\
namicO\
bj\
ect
&
lOl\
l\
OlO\
ll\
O\
OO
=
*
*
lOlllOlllOOO
;
if
(
!
lOl\
lOlOllO\
OO
.
Get\
C\
ollision\
I\
tera\
tor
(
)
.
AtEnd
(
)
)
{
float
ll\
OOlOOOOlll
=
lOl\
lOlOl\
l\
O\
O\
O
.
GetL\
inearVelocity\

(
)
.
GetMag\
n\
it\
udeSqrd
(
)
+
lOllOlOllOOO
.
Get\
Angula\
r\
Veloc\
ity
(
)
.
Get\
M\
agnitud\
eSqr\
d\

(
)
;
if
(
ll\
OOlO\
OOOllO
>
ll\
O\
OlO\
OO\
Oll\
l\

)
{
ll\
OOlO\
OO\
Ol\
lO\

=
llOOlOO\
O\
O\
ll\
l
;
llOOlOOO\
OlOO\

=
&
lOll\
OlOllOO\
O
;
}
}
}
if
(
llOOlOO\
OOlOO
)
llOOlOOOOl\
O\
O\

->
SetToRes\
ti\
ng
(
)
;
}
}
}
if
(
lO\
llOlOl\
lO\
ll
.
lOO\
lOO\
l\
OOll
(
)
)
{
TA\
_ASSERT
(
llO\
Ol\
OOOOOlO
(
lO\
lllO\
OOllO
)
)
;
Dyn\
amicOb\
je\
ct
*
*
lOllOllOO\
OOO
=
lOllOlO\
llOll\

.
All\
oc
(
)
;
TA_\
ASSER\
T
(
lOll\
O\
llO\
OOO\
O
)
;
*
lOllOl\
l\
OOOOO
=
lOll\
lO\
OO\
llO\

;
TA_\
AS\
SE\
RT
(
!
lOlllO\
O\
OllO
->
IsI\
nMoving\
Lis\
t
(
)
)
;
{
lOllOlOlllOO\

.
lOOl\
OO\
OOlOO
(
lOllOl\
lOOOOO
)
;
lOlllOOOl\
lO
->
lO\
lO\
Ol\
OOlOlO
(
lOllOl\
OlllO\
O\

.
lOO\
lOOlOOOO
(
)
)
;
}
if
(
lO\
lll\
O\
OlllOO
)
lO\
lllOOll\
l\
OO
(
*
lOlllOOOllO\

,
lOlll\
OO\
lllO\
l
)
;
if
(
lOOllOlllOlO
->
lOlOll\
llOlll
>=
0
)
{
for
(
lO\
lOOOOOlOOO
*
lOlOOOOOlOlO
=
lOl\
llOO\
OllO\

->
lOlOOllOOlll
(
)
;
lO\
l\
OO\
OO\
OlOl\
O\

;
lO\
lOOOO\
Ol\
OlO
=
lOlO\
OOOOlOlO
->
llO\
OO\
Olllll
)
{
TA_ASS\
ERT
(
lO\
lOOOOOlOlO\

->
lOlOOO\
OOlOl\
O
)
;
lOlO\
OOOO\
OlOl
&
lOlOOO\
O\
l\
lOlO
=
*
lOlO\
O\
OO\
OlO\
lO
->
lOlO\
OOOOlO\
l\
O
;
if
(
lOl\
O\
OOOllOlO\

.
lOlO\
OOOl\
OO\
OO\

)
lO\
llOl\
OllOOl
->
llOOl\
OOO\
lOOO
(
lOlOOOOllO\
lO
)
;
}
}
lOlllOOO\
llO
->
lOl\
OOlOlOOOO
(
fa\
lse
)
;
lOl\
llOO\
Ol\
lO\

->
lOlOOl\
OO\
ll\
ll\

(
false
)
;
lOlllOOOllO
->
lO\
OlllOOl\
lOO
(
)
;
}
}
bo\
ol\

Phys\
ics\

::
llO\
Ol\
O\
OOl\
OOl
(
)
{
if
(
!
lOll\
OlOOll\
Ol
)
return
fa\
ls\
e
;
if\

(
lOllOlOOl\
lOl\

->
llOOO\
OOOlOOl\

(
)
!=
lOll\
OlOOlllO\

.
lOl\
Oll\
llOlOl
)
return\

fal\
se
;
if
(
lOllOlO\
OllO\
l\

->
llO\
OOO\
OOlOO\
O\

(
)
!=
lOllOl\
OOlllO
.
lO\
llOlOO\
ll\
ll
)
re\
turn
false\

;
if\

(
!
lOOl\
lOlllOlO
)
retu\
rn
false
;
if\

(
lOOllOlllOlO\

->
lO\
lOl\
lllOO\
Ol
!=
lOllOlOOlllO\

.
lO\
lO\
llllOO\
Ol
)
ret\
urn
fa\
lse
;
if
(
lOOllO\
lllOlO
->
lOlOlll\
l\
OOlO
!=
lOllOl\
OOll\
l\
O
.
lOlOllllOOlO
)
retu\
rn
false
;
if
(
lO\
Oll\
Olll\
Ol\
O
->
lO\
lOl\
lllOlOO
!=
lOll\
OlOO\
l\
llO
.
lOl\
l\
O\
l\
OOlll\
l
)
ret\
urn\

false
;
if
(
lOOll\
OlllOlO
->
lOlO\
ll\
llOlO\
l
!=
lO\
l\
lOlOOlllO
.
lOl\
O\
lll\
lOlO\
l
)
ret\
urn
fals\
e\

;
if
(
lOll\
O\
lOl\
l\
Oll
.
lOOOl\
llOO\
l\

(
)
!=
lOllO\
lOOlllO
.
lO\
lOll\
l\
l\
OO\
l\
O
)
retur\
n
fals\
e
;
retur\
n\

tr\
ue
;
}
void
Phys\
ics
::
llOOlO\
O\
OlOlO
(
DynamicObject
*
lO\
llO\
OOlO\
ll\

,
DynamicOb\
ject
*
lOllOOO\
l\
lOO
,
con\
st
MFrame
&
lO\
Ol\
l\
l\
Ol\
l\
OlO
,
co\
n\
st\

MFrame\

&
lO\
OlllOllO\
ll
,
fl\
oat
lOOll\
lOOllOl
)
{
TA_AS\
SE\
RT
(
lOllOO\
O\
lOl\
l
)
;
TA\
_ASSER\
T
(
lOl\
l\
O\
OOllOO
)
;
Dyn\
ami\
c\
Objec\
t
&
lllO\
llOllOO\

=
*
lOllOO\
O\
lO\
ll
;
DynamicObject\

&
lllOllO\
ll\
Ol
=
*
lOl\
l\
OOOllOO
;
MF\
rame
ll\
OOlOOO\
l\
O\
ll
=
lll\
OllO\
llOl\

.
GetFrame\

(
)
;
MFra\
me\

llOO\
l\
OOOllO\
O
=
(
lOO\
l\
l\
lOllOll\

*
lOOlllO\
llOlO\

.
GetIn\
verse\

(
)
)
*
lll\
O\
llOllO\
O
.
GetFra\
me
(
)
;
Vec3
llOOl\
O\
OOl\
lOl
=
(
(
lllOl\
lOllOl
.
GetC\
ente\
r\
O\
ffset\

(
)
*
llOOl\
OOO\
llOO
)
-
(
lllOllOllOl
.
Get\
Cen\
t\
er\
Of\
fset
(
)
*
llOO\
lOOOlOl\
l\

)
)
/
lOOlllOOllOl
;
Mat33
lOOlll\
OOl\
llO
=
llOO\
lOOO\
l\
Oll\

.
m33Rot\
at\
i\
on\

.
GetT\
r\
ansp\
oseAsInve\
r\
se\

(
)
*
ll\
O\
O\
lOOOll\
O\
O
.
m33\
Rot\
a\
tion\

;
Vec3
lOOOO\
OlllOl
;
float
lOO\
OOOllll\
O
;
lO\
Ol\
l\
lOOl\
llO
.
Ge\
tRo\
t\
ati\
o\
nAx\
isAn\
d\
Magnitud\
e\

(
lOO\
OOO\
l\
llOl
,
lOOO\
OOlll\
lO
)
;
Vec\
3\

llO\
OlO\
OOlll\
O
=
lOOOOOlllOl\

*
lO\
OOOOlll\
lO
/
lOOll\
lOOl\
l\
Ol
;
Vec3
lOlO\
OO\
OO\
O\
l\
l
=
lllO\
llOllOl
.
GetCe\
nterOfMass
(
)
-
lllO\
llO\
ll\
OO
.
GetCente\
rOfMass
(
)
;
lO\
lOOOOOOll\

.
Nor\
m\
alis\
e\

(
)
;
Mat33
ll\
O\
Ol\
OOOllll\

;
ll\
OOlOO\
Ol\
lll
.
SetToLookDo\
w\
nV\
ecto\
r\

(
lOlOOOOOOll
)
;
cons\
t
int
llOO\
lOOlOOO\
O\

=
6
;
Vec3
llOOl\
OO\
l\
OOO\
l
[
llOOlOOlO\
OOO
]
;
Vec3
llOO\
lOOlOO\
lO
[
llOOlOOlOOOO\

]
;
flo\
at
llO\
OlOOlOOll
[
ll\
OO\
lO\
OlOOO\
O
]
;
llOOlOOlOOO\
l
[
0
]
=
lll\
O\
llOll\
O\
l\

.
Ge\
tCente\
rOfMas\
s
(
)
;
llOOlOO\
lOO\
lO
[
0
]
=
llOO\
lOOOl\
l\
ll
.
v3X
;
llOO\
lOOl\
OO\
Ol\

[
1
]
=
ll\
lOllOllOl\

.
Ge\
tCenter\
Of\
Ma\
s\
s\

(
)
-
llOOlOO\
Ol\
ll\
l
.
v3\
X\

;
llO\
OlOOl\
OOl\
O\

[
1
]
=
llOOl\
OOO\
llll
.
v3Y\

;
llO\
O\
lO\
OlOO\
Ol
[
2
]
=
lllOllOll\
Ol\

.
Ge\
tC\
enterO\
fMass
(
)
;
llOOlOOlOO\
l\
O\

[
2
]
=
-
llOO\
lOO\
Ollll
.
v3\
Y
;
llOOlOO\
lOOOl\

[
3
]
=
ll\
l\
Oll\
OllO\
l\

.
Ge\
t\
Ce\
n\
terOfMass
(
)
;
ll\
OOlOOlOOlO
[
3
]
=
ll\
OOl\
OO\
Ol\
l\
ll
.
v3\
Z
;
ll\
OO\
lOOl\
OOO\
l\

[
4
]
=
lllOl\
lOll\
O\
O
.
Ge\
t\
C\
e\
nterOf\
Ma\
ss
(
)
;
llOO\
lOOl\
OOlO
[
4
]
=
llO\
OlOO\
Ol\
ll\
l
.
v3X
;
llOOlOO\
lOOOl
[
5
]
=
lllOll\
OllO\
O
.
Ge\
tCente\
r\
OfMass
(
)
;
llO\
OlO\
Ol\
OO\
lO
[
5
]
=
llOOlOOOll\
ll
.
v3Y
;
in\
t
lOOOl\
l\
OOOl
;
for
(
lOOOll\
OO\
Ol
=
0
;
lOOOllOOO\
l
<
llOO\
lOO\
lOO\
OO
;
lO\
OOl\
lO\
OOl\

++
)
{
Ve\
c3
llOOlOOlOl\
OO\

=
llO\
OlOOO\
llO\
l\

+
llO\
O\
lOOO\
l\
l\
l\
O\

.
Cross
(
llO\
OlOOlOO\
Ol
[
lOOOl\
lOOOl
]
-
ll\
lO\
llOllOl
.
GetC\
enter\
OfM\
a\
ss
(
)
)
;
llOOlO\
O\
lOl\
OO
+=
ll\
l\
Ol\
l\
OllOO
.
GetVelo\
c\
i\
tyAtW\
orl\
dPos\
itio\
n
(
llOO\
lOOlOOOl
[
lOOOl\
lOOOl\

]
)
;
ll\
OOlOOlO\
lOO\

-=
lllO\
llOll\
Ol
.
Ge\
tV\
e\
locityAt\
WorldP\
o\
siti\
on
(
llO\
OlO\
Ol\
O\
OOl
[
lOO\
Ol\
lO\
OO\
l
]
)
;
llOOl\
OOlOOl\
l
[
lOOOl\
lOO\
O\
l
]
=
ll\
OOlO\
OlOlOO
.
Dot
(
llOOlOO\
l\
OOlO
[
lOO\
Ol\
l\
O\
OOl\

]
)
;
}
lO\
ll\
O\
lOO\
ll\
Ol
->
Clear
(
)
;
lOllOlOOl\
lO\
l
->
llOOOOOl\
lOOO\

(
ll\
lOl\
lOl\
lO\
O
.
GetIn\
v\
erseM\
as\
s
(
)
,
lll\
Oll\
O\
llOO\

.
GetW\
o\
rldSpaceI\
nv\
er\
seInertia
(
)
)
;
lOllOl\
OOl\
lOl\

->
ll\
OO\
OOOl\
l\
OOO
(
ll\
lOllOll\
Ol
.
GetInve\
rs\
e\
Mass
(
)
,
lll\
OllOl\
lOl
.
GetWo\
rld\
Sp\
ace\
Inve\
rseInertia
(
)
)
;
int\

llO\
OOOO\
llllO
=
lO\
ll\
Ol\
OOllOl\

->
ll\
O\
OO\
OOl\
llll
(
llOOl\
OOl\
OOOO\

,
0
,
1
,
lOllOlOlOOOl
::
llOOO\
OOlllO\
O\

|
lOllOlOl\
OOOl
::
llOOOOOllOll
)
;
fo\
r\

(
lO\
OO\
l\
lOOO\
l\

=
0
;
lOOOllOO\
Ol
<
llOOlOOl\
OO\
OO
;
lOOOl\
lOOOl
++
)
{
lOl\
lO\
l\
OOl\
lOl
->
ll\
OO\
OO\
lOOOO\
O
(
llO\
O\
OOO\
llllO
,
lOOO\
llOOOl
,
llOOlOO\
lO\
OlO
[
lO\
O\
OllO\
OOl\

]
,
llO\
OlOOlOO\
lO
[
lOOO\
ll\
OO\
Ol
]
.
Cros\
s
(
llO\
OlOOlOOOl\

[
lOOO\
ll\
O\
OOl\

]
-
ll\
lOllOllOO
.
GetC\
enterO\
f\
Mass
(
)
)
,
-
llOOlOO\
lO\
O\
l\
O
[
lOOOllOOOl
]
,
-
llO\
Ol\
OOlOOl\
O\

[
lO\
OOl\
lOOOl
]
.
Cr\
o\
s\
s
(
ll\
OO\
l\
OOlOOOl
[
lOOO\
l\
lOOOl
]
-
lllOl\
l\
OllO\
l
.
GetCe\
n\
te\
r\
O\
fMass\

(
)
)
)
;
}
lOllOlOOl\
lO\
l
->
ll\
O\
OOOlO\
O\
OOl
(
)
;
for
(
lOOOllOOOl
=
0
;
lO\
OOll\
OO\
Ol\

<
llO\
OlOOl\
O\
OOO
;
lOO\
Ol\
lOOO\
l
++
)
{
lOl\
lOl\
OOllOl\

->
llOO\
OO\
l\
OO\
l\
OO
(
llOO\
OOO\
l\
l\
llO
,
lOOO\
llOOO\
l\

,
ll\
OOlO\
O\
lO\
Ol\
l\

[
lOOO\
llOOO\
l\

]
)
;
}
if
(
lOl\
lOlOOllO\
l
->
llOOO\
OlO\
lO\
l\
O
(
)
)
{
fo\
r\

(
lOO\
O\
llOO\
Ol
=
0
;
lO\
OO\
llOOOl
<
llOOlOOlOOOO
;
lOOOl\
l\
OOOl
++
)
{
floa\
t
lO\
llOO\
lO\
OlO
=
lO\
l\
lOlOO\
l\
lOl
->
GetI\
m\
pul\
se
(
llOOOOOll\
llO\

,
lOOOllOO\
O\
l
)
;
lllOl\
l\
OllOO\

.
Appl\
y\
Imp\
ul\
s\
e
(
1.0f
*
lOllO\
OlO\
O\
lO
*
ll\
OOlOO\
lOOlO
[
lO\
OOllOOOl
]
,
ll\
OOl\
OOlOO\
Ol
[
lOOOll\
OOOl
]
)
;
ll\
l\
Ol\
lOllOl
.
Ap\
plyImpulse
(
-
1.0f
*
lO\
llO\
Ol\
O\
OlO\

*
llOO\
lO\
OlOOlO
[
lO\
OOl\
lOO\
Ol
]
,
llOOl\
OOl\
OOOl
[
lOOO\
llOOOl
]
)
;
}
}
}
voi\
d\

Phy\
si\
cs
::
ll\
O\
OOOOOOlO\
O
(
)
{
if
(
(
lll\
OlO\
l\
llO
&
lOl\
llOO\
lOl\
Ol
)
==
0
)
re\
turn
;
fo\
r
(
int
lOOOllOO\
Ol\

=
0
;
lOO\
O\
llOO\
Ol
<
lO\
OllOl\
l\
l\
OlO
->
lO\
lOl\
l\
llOO\
lO
&&
lOl\
lOlOl\
lOOl
->
lOllllOOlllO
(
)
+
64
>
lOOll\
Oll\
lOlO
->
lO\
lOllllOO\
O\
l
;
lOO\
OllO\
OOl
++
)
{
float
llOO\
lOOOOOll
=
-
k_fM\
axFloat
;
Dyna\
micObje\
ct\

*
llOOlOOOOl\
O\
O
=
0
;
lO\
lllOlOl\
OlO\

lOlll\
Olll\
O\
O\
O
=
lOl\
l\
O\
lOll\
lOO
.
lOl\
OOO\
OlOO
(
)
;
for
(
;
!
lOlllO\
l\
llOOO
.
AtEnd
(
)
;
++
lOlllOlllO\
OO
)
{
DynamicObject
&
lO\
llOlOllOOO
=
*
*
lO\
lllOl\
llOO\
O
;
if
(
lOl\
lOlOllOOO
.
lOlOOOOllllO
(
)
&&
!
lOllOl\
OllOOO
.
Ge\
tC\
o\
lli\
s\
ionIt\
era\
t\
or
(
)
.
At\
End
(
)
)
{
floa\
t
llOOlO\
OOOl\
Ol
=
lOll\
O\
lOll\
OOO\

.
lOlO\
OlllO\
O\
O\
l
(
)
;
if\

(
llOOl\
OO\
OOOll
<
ll\
OOlOO\
O\
OlOl
&&
!
lO\
llOlOllOOO\

.
lOlOOOOll\
lll\

(
)
)
{
ll\
OOlO\
OO\
OOll
=
llOOlOOO\
O\
lOl\

;
llOO\
lOO\
O\
OlOO
=
&
lOllOlOllO\
OO
;
}
}
}
if\

(
llOOlOOOOlOO
)
{
ll\
OOlOOOOl\
OO
->
lOOlllOOlOO\
O
(
tru\
e\

)
;
llOO\
lOOOOlOO\

->
lOlOOlOO\
ll\
ll\

(
true
)
;
llOOl\
OOOOl\
O\
O
->
lO\
lOOO\
Ol\
llOl
(
)
;
}
else
{
float\

ll\
OOlOO\
OOllO
=
k_f\
MaxF\
l\
oa\
t
;
lOlllO\
lllOOO
=
lOllOl\
O\
ll\
lOO
.
lO\
lO\
OOOlO\
O
(
)
;
for
(
;
!
lOlllOlllOOO\

.
At\
End
(
)
;
++
lO\
lllOlllO\
OO
)
{
Dynam\
icObject\

&
lOllOlO\
l\
l\
OOO
=
*
*
lOlllO\
l\
llO\
O\
O
;
if
(
!
lO\
l\
l\
Ol\
O\
llO\
O\
O
.
GetCo\
llis\
ionIterator
(
)
.
AtEnd\

(
)
&&
!
lOl\
lO\
lOll\
OOO
.
lOlOOOOlllll
(
)
)
{
flo\
at
llO\
OlO\
OOO\
lll
=
lOllO\
lO\
l\
lOOO
.
lOl\
O\
Ol\
llOlOO
(
)
.
GetMa\
gn\
it\
udeSq\
rd
(
)
+
lOl\
l\
OlOllOOO
.
lO\
lO\
Ol\
llOlOl\

(
)
.
Ge\
tM\
agni\
t\
u\
deSqrd\

(
)
;
if
(
ll\
O\
Ol\
OOO\
Oll\
O
>
ll\
O\
OlOOOOl\
ll
)
{
llOOlOOOOllO
=
llOOlO\
O\
OOlll
;
ll\
OO\
lOOO\
OlOO
=
&
lOllOl\
O\
ll\
OOO
;
}
}
}
if
(
llOOl\
O\
O\
OOl\
O\
O
)
{
llOOlOOOOl\
OO
->
lOOll\
lOOlOOO
(
true\

)
;
llOOlOOOOl\
OO\

->
lOlO\
Ol\
OO\
ll\
ll
(
true
)
;
llO\
OlOOO\
OlOO
->
lOlO\
OOOl\
llOl
(
)
;
}
else
{
bre\
ak
;
}
}
}
}
bool
Ph\
ysics\

::
lOlllll\
O\
OlOl
(
Coll\
isi\
on\

&
lOl\
lOllO\
lOl
,
void\

*
ll\
OO\
lOOl\
Ol\
Ol
)
{
TA_A\
SS\
ERT
(
ll\
O\
O\
lOOlOlOl
)
;
lOllO\
Ol\
llOlO
&
lOOO\
OOlOO\
OO
=
*
(
(
lO\
llOO\
ll\
lOlO
*
)
ll\
OOlO\
OlOlO\
l\

)
;
Physi\
cs\

*
lO\
llO\
lOl\
lll\

=
lO\
OO\
OOl\
O\
OOO
.
lOlOllllOOOO
;
lO\
ll\
Oll\
Ol\
Ol
.
Se\
tOb\
jectA
(
lOOO\
OOlOOO\
O
.
lOl\
O\
O\
OOO\
lOll
)
;
lOll\
Ol\
lO\
lOl
.
Se\
t\
Obj\
ect\
B\

(
lOO\
O\
O\
OlOO\
OO\

.
lOlO\
OO\
OO\
l\
lOO
)
;
fo\
r
(
Col\
l\
isi\
on
*
lO\
O\
O\
OOOlll\
l
=
lOll\
Ol\
lO\
lOl
.
GetNext\

(
)
;
lOOOO\
OOllll
;
lOOOO\
OO\
l\
ll\
l
=
lO\
O\
OOOOllll
->
GetNe\
xt
(
)
)
{
lOO\
O\
OO\
Ollll\

->
SetObjectA
(
lOOOOOlOOOO\

.
lOlOOOOOlOll
)
;
lOOO\
OOOllll
->
SetO\
bjectB
(
lOO\
OOOlO\
O\
OO
.
lOlOOOOOllO\
O\

)
;
}
TA\
_ASSER\
T
(
lO\
l\
lO\
l\
Ol\
l\
ll
)
;
TA\
_\
ASS\
ERT
(
lOll\
Ol\
lOl\
Ol
.
lll\
Olll\
lOO\

>=
0.0f
)
;
TA_AS\
SE\
RT
(
lO\
ll\
Oll\
O\
lOl
.
lllOllllO\
O
<=
1.0f
)
;
TA\
_ASS\
ERT
(
Floa\
tIs\
OK
(
lO\
ll\
O\
l\
lO\
lO\
l
.
lOllOOlO\
OOl
)
)
;
TA_AS\
SER\
T\

(
Float\
Is\
OK
(
lO\
llOl\
l\
O\
l\
O\
l
.
lOO\
Ol\
OOOO\
O
.
x
)
)
;
TA_AS\
SERT
(
Fl\
oatI\
s\
OK\

(
lO\
llO\
l\
lOlO\
l
.
lOOO\
lOOO\
OO
.
y
)
)
;
TA_A\
SS\
ERT
(
Floa\
t\
IsO\
K\

(
lO\
llOll\
OlO\
l\

.
lOO\
OlO\
O\
O\
O\
O
.
z
)
)
;
TA_ASSE\
RT
(
lO\
l\
l\
Ol\
lOlOl
.
lOOOlOOO\
OO
.
IsNormalised
(
)
)
;
fl\
o\
a\
t
lOl\
lOO\
lOOl\
l
=
0.0f
;
Dyn\
amic\
O\
bje\
ct\

*
ll\
OOlOOlO\
l\
l\
O
=
0
;
in\
t
ll\
OOl\
OOlOl\
ll
=
0
;
if
(
lOl\
l\
Ol\
lOlOl
.
GetTy\
pe\

(
)
==
Collisio\
n
::
lOll\
Ol\
O\
OO\
l\
O
)
{
TA_\
ASSER\
T
(
lO\
llOllO\
lOl
.
lOll\
O\
OOllOl\

)
;
TA_\
ASSERT
(
lOll\
OllO\
lOl
.
lO\
llOO\
Ol\
l\
lO
)
;
TA_ASSE\
RT
(
lOll\
OllOlOl
.
lOllOOOllOl
->
Ge\
tC\
ollis\
io\
nO\
b\
jectType
(
)
==
Collisio\
nO\
bje\
ct
::
TYPE_\
LINE_LI\
ST\

||
lOllOl\
l\
O\
l\
Ol
.
lOl\
lOOO\
lllO
->
GetC\
ollisio\
nObjec\
t\
Type
(
)
==
Co\
l\
li\
sionObj\
e\
ct
::
TYPE_\
LINE\
_LIST
)
;
TA_ASS\
ERT\

(
lOllOllO\
lO\
l
.
lOllOOO\
ll\
O\
l
->
Ge\
t\
C\
ollisio\
nO\
bj\
ectT\
yp\
e
(
)
!=
Coll\
isi\
onObje\
ct
::
TYPE_LINE\
_LIS\
T\

||
lO\
llOllOlOl
.
lOl\
lOOOl\
llO
->
Ge\
tC\
o\
llisi\
onObject\
Type
(
)
!=
Collisi\
o\
nO\
b\
je\
ct\

::
TYP\
E_LINE_\
LI\
S\
T
)
;
if\

(
lOl\
lOllOlO\
l
.
lOllOOO\
l\
llO
->
Ge\
tC\
ol\
li\
si\
onObje\
c\
tType\

(
)
==
Col\
l\
i\
si\
onObject
::
TYP\
E_LI\
NE_LIST
)
{
lOllO\
l\
lOlOl
.
lOll\
OlOl\
OlO
(
)
;
lOllO\
llOlOl
.
lOOO\
lO\
O\
O\
OO\

*=
lO\
llOl\
l\
Ol\
Ol
.
Ge\
tObjectA\

(
)
->
Ge\
t\
Fra\
me\

(
)
.
m3\
3R\
otat\
ion\

;
lO\
ll\
OllOlOl
.
lOOOlOOOOO
=
-
lOll\
O\
l\
lOlOl
.
lO\
OO\
lOO\
OOO\

;
}
else
{
lOllOllO\
l\
Ol
.
lO\
OOO\
lll\
l\
l
*=
lOl\
lOll\
OlOl
.
GetObjectB
(
)
->
Get\
Fra\
me
(
)
;
lO\
llOllO\
lO\
l
.
lOOOOlllll
/=
lOll\
OllOlOl\

.
Ge\
tOb\
jec\
t\
A
(
)
->
Ge\
tFram\
e\

(
)
;
lOllOllOlOl
.
lOOOlOOOOO
*=
lOllOllOlOl
.
Get\
ObjectB
(
)
->
GetFra\
me
(
)
.
m33Rot\
at\
ion\

;
lOllOllOl\
O\
l
.
lO\
OOlOO\
O\
O\
O\

=
-
lOllOll\
O\
l\
O\
l\

.
lOOOl\
OOOOO
;
}
TA_ASSE\
RT
(
lOll\
Oll\
Ol\
Ol
.
lOl\
lO\
OO\
llOl
->
Get\
Collisi\
on\
O\
b\
ject\
Ty\
pe
(
)
==
Co\
l\
l\
i\
s\
ion\
O\
b\
je\
ct
::
TYPE_\
LI\
NE_\
LI\
ST
)
;
if\

(
lO\
llOlOlll\
l
->
lOlll\
OO\
llOOl\

&&
!
lOllOlOllll
->
lO\
lllOO\
ll\
OOl
(
(
Pr\
eC\
ollis\
ion
&
)
lO\
ll\
O\
llOlOl
)
)
return
tr\
ue
;
if
(
lOl\
l\
O\
l\
l\
OlOl
.
Ge\
tObjectA\

(
)
->
Gh\
ost
(
)
||
lOl\
lOll\
O\
l\
Ol
.
GetObjectB\

(
)
->
Ghost
(
)
)
return
fal\
se\

;
lOll\
Ol\
lOlOl
.
GetObject\
A
(
)
->
lOOllllOl\
lOO
(
lOllO\
llOlOl
.
lO\
llOO\
Ol\
lll\

,
lOll\
Ol\
lOlOl
.
GetObjectB
(
)
,
lOll\
OllO\
lO\
l
.
lOllO\
OOl\
llO
,
lO\
llOl\
l\
Ol\
Ol
.
lO\
ll\
OOlOOOO\

,
lO\
ll\
OllOlO\
l
.
lOll\
OO\
l\
O\
O\
Ol
,
lOllOl\
lO\
lOl
.
lOO\
OOll\
lll
,
lOllOllOlOl\

.
lOOOl\
OOOOO
)
;
return
true
;
}
if
(
lOllOll\
O\
l\
Ol\

.
Ge\
t\
O\
bj\
ectA
(
)
->
MovementD\
i\
s\
abled
(
)
||
lO\
llO\
llOlOl
.
GetObjec\
tA\

(
)
->
Infinit\
e\
Ma\
ss
(
)
)
lOllOllOlOl
.
lO\
l\
OllO\
OOl\

|=
Collis\
ion
::
FL\
A\
G_OBJECT\
A_SOLID\

;
if
(
lOllOl\
lOl\
O\
l
.
GetO\
bj\
ectB\

(
)
->
Mov\
em\
entDisabled
(
)
||
lOllOll\
OlOl\

.
GetObjectB\

(
)
->
Infinite\
Mas\
s
(
)
)
lOl\
lOllOl\
Ol
.
lO\
lOllOO\
Ol\

|=
Coll\
isio\
n
::
FLAG_OBJE\
C\
TB\
_SOL\
I\
D
;
if
(
(
lOllOllOlOl
.
lOlOl\
l\
O\
OOl
&
(
Collis\
ion\

::
FLA\
G_OBJECTA\
_SOL\
ID
|
Col\
lision
::
FLAG_OB\
JECTB_SOLI\
D
)
)
==
(
Colli\
s\
io\
n
::
FLAG_OB\
JE\
CTA_S\
OLI\
D
|
Coll\
ision
::
FLAG_O\
BJECTB\
_SO\
LID
)
)
retu\
rn\

false
;
Dyna\
mi\
cO\
bj\
ec\
t
*
const\

lOlOO\
O\
OOlOll\

=
lOllO\
ll\
O\
lOl\

.
GetObj\
ectA\

(
)
;
Dyna\
micO\
bject
*
const\

lOl\
OOOOO\
ll\
OO
=
lOllOllOlO\
l
.
GetObje\
ctB
(
)
;
u3\
2\

llOOlOO\
llOOO\

=
0
;
#ifdef lOllOOlOOllO
{
co\
nst\

float
llOOlOOll\
OO\
l
=
0.2f
;
if
(
(
lO\
lO\
OOO\
OlOl\
l\

->
ExtraStability
(
)
||
lOlOOOOOllO\
O\

->
ExtraStabili\
ty\

(
)
)
&&
lOl\
O\
O\
OOO\
l\
Oll
->
GetLine\
arVe\
locity
(
)
.
Ge\
tMa\
g\
nitudeS\
qrd
(
)
<
llOOlOOllO\
Ol
&&
lOlO\
OOOOlOl\
l\

->
Get\
Angul\
arVeloc\
ity\

(
)
.
GetMag\
nitudeSqr\
d
(
)
<
llOOlOOll\
OOl
&&
lOlOO\
OOOllOO\

->
Ge\
tLine\
ar\
Veloc\
it\
y
(
)
.
GetMagnitudeSqrd
(
)
<
llOOlO\
O\
l\
l\
O\
Ol
&&
lOl\
O\
OOOO\
l\
lO\
O
->
GetA\
ngul\
ar\
Veloc\
ity\

(
)
.
GetM\
agni\
tud\
eSqrd\

(
)
<
llOOlOO\
llOOl
)
{
ll\
OOlOOllO\
OO
|=
Collision
::
FLA\
G_DI\
SABLE_PUSHOU\
T
;
}
}
#endif //
switch
(
lOllOllOlOl\

.
GetType
(
)
)
{
ca\
se
Coll\
i\
sion\

::
lOllO\
Ol\
l\
ll\
l
:
llO\
OlOOl\
lOOO
|=
Co\
llision
::
FLA\
G_CONS\
TRAIN_\
I\
N_BOTH_DI\
R\
E\
C\
TIONS
|
Coll\
ision
::
FLAG_JO\
INT\

|
Colli\
sion\

::
FLAG\
_NO_FRICTION
;
case
Colli\
sio\
n
::
TYPE_\
ROTATIO\
N_CONST\
RAIN\
T
:
cas\
e\

Collisio\
n
::
lOllOlOO\
OOl\

:
cas\
e
Collisi\
o\
n\

::
lO\
l\
l\
OlO\
OOOO
:
if\

(
lO\
ll\
OllOl\
O\
l
.
GetType
(
)
==
Coll\
ision
::
TYP\
E_ROTA\
TION_\
CONS\
T\
RA\
IN\
T
)
llOOlO\
OllOOO
|=
Collision\

::
FL\
AG_RO\
TA\
T\
I\
ON\
_CO\
NST\
RA\
I\
N\
T
|
Collis\
ion\

::
FLA\
G_N\
O_\
FRICTION\

;
else\

if
(
lOllOl\
l\
OlOl
.
GetType\

(
)
==
Collisi\
on
::
lOllO\
l\
O\
OOOl
)
llOOlO\
Oll\
OOO
|=
Colli\
sion
::
FL\
AG\
_R\
OTAT\
I\
O\
N_\
CO\
NSTRA\
I\
NT
|
Co\
llisi\
on\

::
FLA\
G_\
NO_F\
R\
IC\
TI\
ON
;
else
if
(
lOll\
OllOlOl
.
Get\
Typ\
e
(
)
!=
Coll\
ision
::
lOll\
OOlllll
)
ll\
OO\
lO\
OllOOO
|=
Co\
llis\
i\
on
::
FLA\
G_J\
OINT_LI\
MI\
T
|
Co\
ll\
is\
i\
on
::
FLAG\
_NO_FRIC\
TI\
O\
N\

;
br\
eak
;
de\
f\
ault
:
TA\
_ASS\
ERT
(
lOl\
lOllOlOl
.
Get\
Nex\
t
(
)
==
0
)
;
lOl\
l\
OOlO\
Oll
=
lO\
lOOOOO\
l\
Oll
->
GetR\
e\
stitut\
ion
(
)
;
if
(
lO\
l\
O\
OOO\
Oll\
OO
->
Ge\
t\
Coll\
isio\
n\
O\
bjectCo\
mple\
x
(
)
)
lOl\
lOOl\
O\
Oll
+=
lO\
llOlOlll\
l\

->
GetSur\
f\
aceA\
t\
t\
ri\
bute\

(
lOllO\
llOl\
Ol\

.
lO\
ll\
OOlOOOO
)
.
Ge\
tRest\
it\
u\
tio\
n
(
)
;
else
lOl\
lOOlOOl\
l
+=
lOl\
OOOOOllOO
->
Ge\
tRest\
it\
ution
(
)
;
lOllOllOl\
Ol
.
lOO\
OOll\
l\
l\
l
*=
lOOOO\
OlOOOO
.
lOlOOOO\
Oll\
OO
->
GetF\
ram\
e
(
)
;
lO\
l\
lOllOlOl
.
lOO\
OlO\
O\
OO\
O
*=
lOO\
OOOl\
O\
OO\
O\

.
lO\
lOOOOOllOO
->
Get\
F\
rame
(
)
.
m3\
3\
Rotatio\
n
;
if
(
lOlOO\
OOOlOl\
l
->
Ghost
(
)
||
lOlOOO\
OOll\
OO\

->
Ghost\

(
)
)
{
if
(
!
lO\
llOl\
Ol\
ll\
l
->
lOl\
llOO\
llOOl
||
lOl\
lOlO\
lll\
l\

->
lOlllOOl\
lO\
Ol
(
(
Pr\
eCollision
&
)
lOllO\
llOlO\
l
)
)
{
lO\
ll\
O\
lOl\
lll
->
lOl\
lOlOllO\
Ol
->
llOO\
lOO\
l\
lO\
lO
(
*
lOOOOOl\
OO\
OO
.
lOl\
OO\
OOOl\
Ol\
O
,
lOllO\
ll\
OlOl
)
;
}
ret\
urn\

true
;
}
break
;
}
float
lOllOOlOlOO\

=
FastMi\
n
(
lO\
lO\
OOO\
Ol\
Oll
->
Get\
Friction\

(
)
*
lOllOl\
Ol\
ll\
l\

->
GetSurfaceAttribute
(
lOllOl\
l\
O\
lOl
.
lOl\
lOO\
O\
ll\
ll\

)
.
GetCol\
l\
isi\
o\
n\
F\
riction
(
)
,
lOl\
OOO\
OOlOll
->
Get\
F\
riction
(
)
*
lOllOlOllll\

->
GetSu\
rfaceAttr\
i\
bute
(
lO\
llOllO\
lOl
.
lOllO\
OlOOOO\

)
.
GetC\
ollis\
ionFri\
ctio\
n
(
)
)
;
lOl\
lOOlOl\
OO
*=
0.4f
;
#ifdef TA_DYNAMIC_OBJECT_GROUP_ENABLED
if
(
lOlOOO\
OOlOl\
l
->
GetDy\
namicObj\
e\
ct\
G\
roup
(
)
)
lOlO\
OOOOlO\
l\
l
=
lOlOO\
OOOl\
Oll
->
Ge\
tDynamicObjectGro\
up
(
)
;
if\

(
lOl\
O\
OO\
OOl\
lOO
->
GetDyn\
amicOb\
je\
c\
tGroup
(
)
)
lOlOOOOOllOO
=
lOlO\
OO\
OOll\
OO\

->
GetDyn\
amic\
ObjectGro\
up
(
)
;
#endif //
lOllOllOlOl\

.
lOl\
lOO\
lOOll
=
lOllO\
O\
lO\
Oll
*
0.5f
;
Cl\
am\
p
(
lOllOl\
lOl\
Ol
.
lOllO\
OlOOll\

,
0.0f
,
1.0f
)
;
lO\
l\
lOllOlO\
l
.
lOllOOlO\
lOO\

=
lOll\
OOlOlOO
;
lOll\
Oll\
OlO\
l\

.
lOlO\
ll\
O\
O\
Ol
|=
llOO\
lOOl\
lOO\
O
;
fo\
r
(
Collisi\
on
*
lO\
OOOOOl\
lll\

=
lOllO\
ll\
OlOl\

.
GetN\
ex\
t
(
)
;
lOO\
OOOOl\
lll
;
lOOOOO\
Ol\
l\
l\
l
=
lO\
O\
OOOOll\
ll\

->
GetNext
(
)
)
{
lOOOOOOllll
->
lO\
ll\
OOlO\
Oll
=
lO\
llO\
llOlOl
.
lOllO\
OlOOll
;
lO\
OO\
OOO\
llll
->
lO\
l\
lOOlOlOO
=
lO\
llO\
llOl\
Ol\

.
lOllOO\
l\
OlO\
O
;
lO\
OOOOOll\
ll\

->
lOlOll\
OOO\
l\

|=
ll\
O\
OlOOllOOO
;
}
if\

(
lOllO\
l\
O\
l\
lll\

->
lOlllOOllOO\
l
&&
!
lOll\
OlO\
llll
->
lOl\
llOOl\
lOOl
(
(
PreCollisio\
n\

&
)
lOllO\
llO\
lO\
l
)
)
return\

tru\
e
;
if
(
(
lO\
l\
l\
O\
llOlOl
.
lO\
lOllOOOl
&
(
Co\
l\
lisio\
n
::
FLAG_\
OBJECT\
A_SO\
LID\

|
Col\
lis\
i\
on\

::
FL\
A\
G_OBJE\
CTB\
_SOL\
I\
D
)
)
==
(
Collisio\
n
::
FLA\
G_O\
BJECTA_\
S\
OLID
|
Co\
llis\
ion
::
FLAG\
_OBJ\
EC\
TB_SOL\
ID\

)
)
retur\
n
tr\
ue
;
if
(
lOl\
lOlOllll
->
ll\
lOlOlllO
&
lOllllOOlOlO
)
{
if
(
!
lOllO\
ll\
O\
l\
Ol\

.
Ge\
tObjectA\

(
)
->
Inf\
ini\
teM\
ass\

(
)
&&
!
lO\
llOl\
lOlOl
.
GetObje\
c\
tA\

(
)
->
Movemen\
tD\
isable\
d
(
)
)
{
lOllOllOlO\
l
.
Get\
O\
bj\
ec\
tB
(
)
->
lO\
lOOOlO\
lOOl
(
lOllOl\
lOlOl
.
GetO\
bje\
ctA
(
)
)
;
if
(
!
lO\
llOllOl\
O\
l
.
Get\
Obje\
ctA
(
)
->
lOOlOOOlOl\
l
(
)
&&
!
lO\
llOll\
O\
l\
Ol
.
GetObje\
ct\
A\

(
)
->
IsInM\
ovingLi\
st
(
)
&&
lOl\
lO\
l\
lOl\
Ol\

.
Ge\
tO\
bje\
ctA\

(
)
->
lOlOO\
ll\
OlO\
O\
l
(
)
!=
lOllO\
lO\
l\
lll\

->
lOll\
OllOOlOO\

)
{
lOl\
lO\
llOlOl
.
GetObj\
ec\
tA
(
)
->
lO\
lOOllllO\
O\
l
(
lOll\
OlO\
l\
l\
ll
->
lO\
ll\
lOOO\
lO\
lO
)
;
lOl\
lOlOllll
->
lOll\
l\
O\
O\
O\
lOl\
O\

=
lO\
l\
lOllO\
l\
O\
l
.
GetO\
bj\
ec\
t\
A\

(
)
;
lOll\
Oll\
OlOl\

.
GetObject\
A
(
)
->
lO\
lOOlOl\
lOOl
(
tru\
e
)
;
lOllOllOlOl\

.
GetObjectA
(
)
->
lOlOO\
llOlO\
lO
(
lOllOlOllll\

->
lOllOllOOlOO
)
;
}
}
if
(
!
lOll\
OllOlO\
l
.
GetO\
bjectB\

(
)
->
Inf\
initeMas\
s\

(
)
&&
!
lOl\
l\
OllOlOl\

.
GetObjectB
(
)
->
MovementD\
isabl\
ed
(
)
)
{
lOl\
lOll\
OlO\
l
.
GetOb\
j\
ectA
(
)
->
lOlO\
OOlOl\
OOl
(
lOllOllOlOl
.
GetOb\
ject\
B
(
)
)
;
if
(
!
lOl\
l\
OllO\
lOl
.
Get\
Obje\
ctB
(
)
->
lOOlOOO\
lO\
ll
(
)
&&
!
lOllOll\
O\
l\
Ol
.
Ge\
tObjectB\

(
)
->
IsIn\
Movi\
ngL\
is\
t
(
)
&&
lOl\
lOl\
lOlO\
l
.
GetOb\
jec\
tB
(
)
->
lO\
lOO\
ll\
Ol\
OO\
l\

(
)
!=
lOllOl\
Oll\
ll\

->
lOllOll\
OOlOO\

)
{
lOll\
Ol\
lO\
lOl
.
Ge\
tObjectB
(
)
->
lOlOOll\
l\
l\
OOl
(
lOl\
lOlO\
llll
->
lOlllOOOl\
O\
l\
O
)
;
lOllOlOllll
->
lOlll\
OO\
OlOl\
O
=
lO\
llO\
llOlOl\

.
GetOb\
j\
e\
ctB\

(
)
;
lO\
llO\
l\
lOl\
O\
l
.
GetObjectB
(
)
->
lOl\
O\
O\
lOl\
lOOl\

(
true
)
;
lOll\
OllOlOl
.
GetObjectB
(
)
->
lOlOO\
llO\
lO\
lO
(
lOllOlOlll\
l
->
lOllOllOOlOO
)
;
}
}
}
TA_\
ASSERT
(
lO\
OO\
OOlOO\
OO
.
lOlOOO\
O\
O\
lOlO
)
;
Co\
llisi\
o\
n\

*
llOl\
lOl\
Ol\
Ol\

=
lOl\
l\
OlOl\
lll
->
lO\
ll\
OlOllOOl
->
llOOOOlllO\
l\
l
(
*
lOOO\
O\
Ol\
OO\
O\
O
.
lOlOOOOOl\
O\
lO
,
lOllOll\
O\
lOl
)
;
if
(
ll\
Ol\
lOlOlOl
)
{
lOl\
lOl\
Ollll
->
ll\
O\
OOOlOOl\
Ol
(
lOllOl\
Ol\
l\
ll
->
lOOl\
l\
OlllO\
lO
->
lOlOllllO\
llO\

,
*
llOll\
OlO\
lOl\

)
;
for
(
Co\
lli\
si\
o\
n
*
lO\
OOOOOllll
=
lOll\
OllO\
lO\
l
.
Ge\
tNext
(
)
;
lOO\
OOOOllll
;
lOOOOOOll\
ll
=
lOOOOOOll\
ll\

->
Get\
Next
(
)
)
{
TA_A\
SS\
ER\
T
(
lOOO\
OOOll\
ll
->
lllOllllOO\

>=
0.0f
)
;
TA_ASSE\
RT
(
lO\
OO\
OO\
Ollll
->
lllO\
llllOO
<=
1.0f
)
;
TA_ASS\
ERT
(
Fl\
oa\
t\
IsO\
K\

(
lO\
ll\
Ol\
lOlO\
l\

.
lOllOOlO\
OOl
)
)
;
lO\
ll\
O\
lOlll\
l
->
lO\
l\
lO\
lOll\
OO\
l
->
llOO\
lO\
Ol\
lO\
ll\

(
*
llOllOl\
OlO\
l
,
*
lOOOO\
OOll\
ll\

)
;
lOllOl\
O\
l\
lll
->
ll\
OO\
OOlOO\
lOl
(
lO\
llOlOllll
->
lOOllO\
l\
l\
l\
OlO
->
lOl\
Ol\
lll\
OllO\

,
*
ll\
O\
ll\
O\
l\
Ol\
Ol
->
GetNext
(
)
)
;
}
}
els\
e
{
retu\
rn
tr\
ue\

;
}
#ifdef lOllOOlOOlOl	
if
(
lOl\
lO\
lOllll\

->
ll\
lOl\
O\
lllO
&
ll\
O\
OOO\
llll\
OO
)
{
fo\
r
(
Collisi\
on
*
lOOOOOOl\
l\
ll
=
llOllOlO\
lOl
;
lO\
OOOOOllll
;
lOO\
OO\
OO\
lll\
l
=
lOOOOOOlll\
l
->
GetNext
(
)
)
{
Phy\
sicsRender
::
RenderArrow
(
lOOOOO\
Oll\
l\
l
->
lOOO\
Olllll\

,
lO\
OOOOOlll\
l
->
lOOO\
lOOOO\
O
*
2.0f
,
0xffff0000
)
;
}
}
#endif //
retu\
rn
tr\
u\
e\

;
}
void
Physics
::
lOll\
llOlOOO\
l
(
Spac\
eDivi\
sionObje\
ct
&
lOlll\
lllllO\

,
voi\
d
*
llOOlOO\
lOl\
O\
l
)
{
TA_\
A\
S\
SE\
R\
T
(
llO\
OlOOlO\
l\
Ol
)
;
lOllOOlllO\
lO
&
lOO\
OOO\
lO\
OOO
=
*
(
(
lOllO\
O\
ll\
lOl\
O\

*
)
llO\
O\
lOOlOlOl
)
;
TA\
_\
ASSERT
(
lOOO\
OO\
l\
OOOO
.
lOlOO\
OOOl\
Oll
)
;
TA_ASSER\
T
(
lOOOOOl\
O\
OOO
.
lO\
lOOOO\
O\
llOO
==
0
)
;
Dyna\
m\
ic\
Obj\
e\
ct
*
lO\
l\
OOOOOlOll\

=
lO\
OOOO\
lOO\
OO
.
lOlO\
OO\
OOlOl\
l
;
Dyn\
a\
mic\
O\
bj\
e\
c\
t\

*
lO\
lO\
O\
OOOl\
lOO\

=
(
Dynamic\
O\
bj\
e\
c\
t
*
)
&
lOllll\
llll\
O
;
#ifdef llOOlOOlllOO
Phy\
sicsRen\
der
::
Re\
n\
derLin\
e
(
lOlllOllOOOO
->
GetPositio\
n\

(
)
,
lOl\
ll\
OllO\
OOl
->
GetP\
o\
sit\
ion
(
)
,
0xFF00FF00
)
;
#endif //
if
(
lOlOOOOO\
lOll
->
Ge\
tWorldA\
ABB\

(
)
.
Int\
ersect\
s
(
lOl\
O\
O\
OOOllOO
->
GetWorldAABB
(
)
)
&&
lO\
lOOOOO\
l\
Ol\
l
->
lOlOOllOlOOO
(
)
!=
lO\
lOO\
O\
OOl\
lOO
->
lO\
lOOllOlOOO
(
)
&&
lO\
l\
OOOOOlOll
->
IsAllowedToCol\
lid\
e\
W\
ith\

(
*
lO\
lOOOOO\
llOO
)
&&
!
lO\
lOO\
OOOllOO\

->
Coll\
i\
s\
i\
onD\
is\
a\
bled
(
)
)
{
#ifdef TA_DYNAMIC_OBJECT_GROUP_ENABLED
if
(
lOlOOOOOl\
Oll
->
Ge\
t\
Dyn\
am\
ic\
ObjectGrou\
p\

(
)
&&
lOlOO\
OO\
Ol\
O\
ll\

->
GetDy\
nami\
c\
Obje\
ctGroup
(
)
==
lOlOOOO\
OllOO
->
Ge\
tDyn\
amicObj\
ectG\
roup\

(
)
)
{
lOlO\
OOOOllO\
O
=
0
;
ret\
urn\

;
}
#endif //
TA_\
AS\
SER\
T\

(
lOlOOOOOlOll
->
lOlOOO\
O\
OOllO
(
lO\
lOOOO\
Ol\
l\
OO
,
false
)
==
0
)
;
whi\
le
(
!
lOlOO\
OO\
OlOll
->
lO\
lO\
OOO\
Oll\
Ol
(
lOl\
OOOOOll\
O\
O
)
)
{
TA_ASSERT
(
lOOOOOl\
OOOO
.
lO\
l\
O\
llllOOOO
)
;
lO\
lOOOOOOlO\
l
*
lO\
l\
O\
OOO\
OlO\
lO\

=
lOO\
O\
OOlOOOO
.
lOlOl\
lllOO\
OO\

->
lOllOl\
Ol\
l\
OOl\

->
lOll\
l\
lOlO\
Ol\
O
(
)
;
if\

(
lOl\
O\
OO\
OOlO\
lO
==
0
)
br\
eak\

;
lOOOOOlOOOO\

.
lOlOll\
ll\
O\
O\
OO
->
lO\
llllOOlO\
Ol
(
*
lOlO\
OOOOlOl\
O
)
;
if
(
lOlOOOOOlOlO
->
lOl\
OlllOOOl\
l
.
lOOOOOlOO\
lO
(
)
)
lO\
OOOOlOOOO\

.
lOlOllllOOO\
O
->
lOllOl\
OllOO\
l
->
lOlOO\
OO\
ll\
lOO
(
*
lOlOOOOOl\
Ol\
O
)
;
}
}
}
void\

Phy\
sic\
s
::
lOl\
l\
l\
l\
O\
Ol\
OOl
(
lO\
lOOOO\
OO\
lOl\

&
lOl\
O\
OOOl\
lOlO\

)
{
TA\
_\
AS\
SE\
RT
(
lO\
lOOOOll\
Ol\
O
.
lO\
lOOOOOlOll
)
;
TA_\
ASS\
ERT
(
lO\
l\
OO\
OOl\
lOl\
O
.
lO\
lO\
OO\
OOl\
lOO
)
;
if
(
(
lO\
lOOO\
O\
llOlO
.
lO\
lO\
OOOO\
lOll
->
lOlOO\
O\
Oll\
llO
(
)
||
lOlO\
OOOllOlO
.
lOlOOOOOl\
Oll\

->
lOl\
O\
OOOlllll\

(
)
)
&&
(
lOlO\
OOOllOlO
.
lOl\
OO\
OO\
O\
ll\
OO
->
lOlOOO\
OllllO\

(
)
||
lO\
l\
OOOOllO\
lO
.
lOl\
O\
OO\
OOllOO
->
lO\
lO\
OOOl\
llll
(
)
)
)
re\
t\
urn
;
Dy\
n\
ami\
cObject
*
lOlOOOOO\
lOl\
l
=
lO\
lOOOO\
llOlO
.
lOlOOOOO\
l\
Oll
;
Dy\
nam\
ic\
Object
*
lOl\
OOOOOllO\
O\

=
lO\
l\
O\
OOOllOlO\

.
lOlOOOOOllO\
O
;
#ifdef llOOlOOlllOO
Phy\
sics\
Render\

::
Re\
nderLine
(
lO\
lO\
OOOOlO\
ll
->
Get\
Pos\
ition
(
)
,
lOl\
OOO\
O\
O\
l\
lOO
->
Get\
Pos\
it\
ion
(
)
,
lOOOOOOOlOO\
l
(
255
,
0
,
255
,
0
)
)
;
#endif //
const
int
lOllO\
l\
lOO\
lll
=
lOOl\
l\
OlllO\
lO
->
lO\
lO\
llllOlll\

;
if\

(
(
lO\
ll\
Ol\
lOOll\
l
==
0
)
||
(
lOlOOOOO\
lO\
l\
l\

->
Get\
WorldA\
A\
BB
(
)
.
Inte\
rsects
(
lOlOO\
O\
OOllO\
O
->
GetWorldAAB\
B
(
)
)
&&
lO\
l\
OO\
OOOl\
Oll
->
IsA\
l\
lo\
w\
e\
dT\
oC\
ollide\
Wi\
th
(
*
lO\
lOO\
OO\
Oll\
OO\

)
&&
!
lOlOOOOOllOO
->
Col\
li\
si\
on\
Disa\
bled
(
)
)
)
{
llOO\
ll\
OOOO\
l
=
Min
(
lOlOOOOOlOll
->
lOO\
l\
lOO\
O\
O\
OlO
(
)
,
lOlOOOOO\
ll\
OO\

->
lOOll\
OO\
OOO\
lO\

(
)
)
;
if\

(
lOllOl\
lOOlll\

>
0
)
{
Vec3\

llOO\
lOOlllOl
=
lOlOOOOO\
lOll
->
Get\
L\
i\
nearV\
elo\
city
(
)
-
lOlO\
OOOO\
l\
lO\
O\

->
Get\
Linea\
rVelocity
(
)
;
const\

Vec3
ll\
OOlOOl\
lllO
=
ll\
O\
OlOOlll\
Ol
-
lOlO\
O\
OOOlOl\
l
->
lOlOOll\
lO\
Ol\
O
(
)
+
lOlOO\
O\
O\
OllOO
->
lOl\
OOl\
llOOl\
O
(
)
;
Vec3
ll\
OOlOOlllll
=
lOlO\
OOOOlOll
->
GetAng\
ul\
arVe\
locit\
y\

(
)
-
lOlO\
OOOO\
ll\
OO
->
GetAngularVelo\
cit\
y
(
)
;
co\
nst
Vec3
ll\
OOlOl\
OOOOO
=
llOOl\
OO\
ll\
l\
ll
-
lOlO\
OOOOlOll\

->
lOlOOlllOOll
(
)
+
lOlO\
OOOOllOO
->
lOlOOll\
lOO\
l\
l\

(
)
;
float\

lOOl\
l\
OO\
OOOOl\

=
Min\

(
lOlOOOOO\
l\
Oll
->
lOO\
l\
lO\
O\
OOOl\
O
(
)
,
lO\
lO\
OO\
OOllOO
->
lOO\
llOOOOO\
lO\

(
)
)
;
flo\
a\
t
llOOlO\
l\
O\
OO\
Ol
=
1.0f
/
(
lOOl\
l\
Ol\
llO\
lO
->
lOl\
OllllOllO
*
lO\
O\
llOll\
l\
OlO
->
lO\
lO\
lll\
l\
OllO
)
;
float
lll\
OOl\
O\
ll\
l
=
llOOlOlOO\
OOl
*
llOOllOOO\
Ol\

*
llO\
O\
llO\
O\
OO\
l\

;
if
(
(
llOOlOOlll\
lO
.
GetMagn\
itudeS\
qrd
(
)
<
(
0.01f
*
lll\
OOlOlll\

)
||
llOOl\
OOlllO\
l\

.
GetMagnit\
ude\
Sqrd\

(
)
<
(
(
0.02f
*
0.02f
)
*
ll\
l\
OOlO\
l\
ll
)
)
&&
(
ll\
OOlO\
lOOOOO
.
Ge\
tMagni\
tu\
de\
S\
qrd
(
)
<
(
0.01f
*
ll\
O\
O\
l\
OlOOO\
Ol
)
||
llOOlO\
Olllll\

.
GetMagn\
it\
udeSqrd
(
)
<
(
0.01f
*
llOO\
lO\
l\
OO\
OO\
l
)
)
)
{
re\
tu\
rn
;
}
}
if\

(
lO\
lOOOOOlOl\
l
->
Ge\
tID
(
)
<
lO\
lO\
OOOOll\
OO
->
GetID
(
)
)
{
Swap
(
lOl\
OOOOOl\
O\
ll
,
lOlOOO\
OOll\
OO\

)
;
}
if\

(
lOll\
lOO\
l\
lOOO
)
{
TA_\
ASSE\
RT\

(
lOlOOO\
OO\
l\
Ol\
l
)
;
TA_\
AS\
S\
ERT\

(
lOlO\
OOOOllOO\

)
;
if\

(
!
lOl\
ll\
OOl\
lOOO
(
*
lOlOO\
OOOlOll
,
*
lOl\
OOOO\
OllOO
)
)
{
retur\
n
;
}
}
MF\
rame
lOlll\
Ol\
lOl\
lO
=
lO\
lOOOOOlOll\

->
Ge\
tFrame
(
)
/
lOlO\
OOO\
Ol\
lOO\

->
GetFram\
e\

(
)
;
MFr\
ame\

lOl\
ll\
Oll\
Oll\
l
=
lOlOOOO\
OlOll
->
Get\
Next\
Frame
(
)
/
lOlOOOOOllOO
->
Get\
Next\
Fr\
ame
(
)
;
if\

(
!
lOlOOOOOlOll
->
IsInMovingL\
ist
(
)
&&
!
lOl\
OOOOOlO\
ll
->
Movemen\
t\
D\
isabled
(
)
)
lOl\
llOl\
lOll\
l
.
v3T\
r\
a\
nslat\
ion
+=
(
GetGravity\

(
)
*
lOOl\
lOlllOlO\

->
lOlO\
ll\
l\
lOllO
)
/
lOlO\
OOO\
OllO\
O
->
GetNe\
x\
tFrame
(
)
.
m33Ro\
tat\
ion
;
if\

(
!
lOlOOOOO\
llOO
->
IsInMov\
ingL\
i\
st
(
)
&&
!
lOlOO\
OOOl\
l\
OO\

->
Mov\
eme\
n\
tDis\
abl\
ed\

(
)
)
lOlllOll\
Olll
.
v3Tra\
n\
slat\
ion\

-=
(
Get\
Gra\
vit\
y\

(
)
*
lOO\
l\
l\
Olll\
O\
lO
->
lOl\
O\
ll\
llOllO
)
/
lO\
lOOOOOllOO
->
GetNextFra\
me\

(
)
.
m33\
Rota\
t\
i\
on
;
ll\
llOll\
OllO
*
ll\
llOllOll\
l
=
0
;
lOllOOl\
llO\
lO\

lOO\
O\
OOlOOOO\

;
lOO\
OO\
Ol\
OOOO
.
Initi\
al\
ise
(
this
)
;
lOO\
O\
O\
O\
lO\
OOO\

.
lO\
lOOOOO\
l\
O\
ll
=
lOlOO\
OOOlOll\

;
lOO\
OOOlOO\
OO\

.
lOlOO\
OOO\
l\
l\
OO
=
lOlOOO\
OO\
ll\
OO\

;
lOO\
OOOlOOOO
.
lOl\
OOOOO\
lOl\
O\

=
&
lOlO\
OOOllO\
lO
;
TA_ASSE\
R\
T
(
lOlll\
Ol\
l\
OllO
.
m33Rotati\
on
.
IsOr\
th\
ogonal
(
)
)
;
TA_\
ASSERT\

(
!
lOlO\
O\
OOOlOll
->
IsWorldOb\
ject
(
)
)
;
TA\
_ASSERT
(
!
lOlOOO\
OOllOO
->
IsWo\
rldObje\
ct
(
)
)
;
llllOllOOll
(
*
lOOllOlllOlO
,
lO\
l\
OOOO\
Ol\
O\
l\
l
->
GetC\
oll\
is\
io\
nObject
(
)
,
lO\
lll\
O\
llOllO\

,
lO\
l\
llOllOlll
,
lOlO\
OO\
O\
OllOO
->
Get\
Co\
lli\
s\
ionObjec\
t
(
)
,
llllO\
llOll\
l\

,
lOlllllO\
Ol\
O\
l
,
&
lOOOOOl\
O\
O\
OO
)
;
lOOOOO\
lOO\
OO
.
lOl\
OO\
OOOlOll
=
0
;
lOOOO\
O\
lO\
OOO\

.
lOlOOO\
OO\
ll\
O\
O\

=
0
;
llOO\
O\
O\
OOO\
l\
O\
O
(
)
;
}
}
void
TAC\
_CALL\

Physi\
c\
s
::
lOlllOlOlOll
(
Spac\
eDivisionObject
&
lOll\
llllllO
,
vo\
id
*
lOOll\
lOO\
OO
)
{
lOllO\
O\
lll\
OOO
&
lO\
OO\
OO\
lOOOO
=
*
(
lOl\
lOOll\
l\
O\
O\
O\

*
)
lOO\
l\
l\
lOOOO\

;
Dynam\
i\
cObj\
ect
*
lOll\
lO\
OO\
l\
lO
=
(
Dy\
na\
mic\
Ob\
ject
*
)
&
lO\
llll\
llllO\

;
if\

(
lOll\
lO\
O\
OllO
->
Ghost
(
)
)
int\

lOlO\
OOl\
lO\
l
=
0
;
if
(
!
lOlllOOO\
ll\
O
->
Collisi\
onD\
i\
sabled
(
)
&&
!
(
!
(
lOOOO\
OlOOOO\

.
lO\
lOllOOOl
&
FL\
AG_GHOST_OBJ\
ECTS
)
&&
lOlllO\
O\
Oll\
O\

->
Ghos\
t\

(
)
)
&&
!
(
!
(
lOOOOOlOOOO
.
lOl\
OllOOOl
&
FL\
AG\
_\
STA\
TIC\
_OB\
JECT\
S
)
&&
lOlll\
OOOllO
->
GetCo\
llis\
ionO\
b\
jectCompl\
ex
(
)
)
&&
!
(
!
(
lOOOOO\
l\
OO\
OO
.
lOlOllOOO\
l
&
FLAG\
_\
DYN\
AMI\
C\
_\
OBJEC\
TS\

)
&&
lOll\
lOOOllO\

->
Get\
Co\
llisio\
n\
Ob\
jectComb\
o
(
)
)
)
{
lO\
lllOOO\
llO
->
Tes\
t\
L\
i\
neFor\
Collisi\
on
(
lO\
O\
O\
OO\
lOOO\
O
.
lOOlOl\
Oll\
l\

,
lOOOOO\
lO\
OO\
O
.
lOOOlOO\
O\
OO
,
lOOOOOlOOOO
.
lOOlOllO\
OO
,
lOO\
OOOlOOO\
O
.
llOllllO\
lOl
)
;
}
}
vo\
id
TAC\
_C\
AL\
L
Physi\
cs
::
lO\
l\
l\
l\
Ol\
OllOO\

(
Spac\
eDivisionOb\
jec\
t
&
lOl\
llll\
ll\
lO
,
vo\
id\

*
lOOlllOOO\
O\

)
{
Dynamic\
Ob\
j\
ec\
t\

*
*
llOlOllOO\
Ol\

=
(
Dynamic\
Objec\
t
*
*
)
lOO\
ll\
lOOO\
O
;
TA_A\
SSER\
T
(
llOlOllO\
OO\
l
)
;
Dy\
nami\
cObject
*
lOl\
llOOO\
llO
=
(
Dyn\
amicO\
bject
*
)
&
lOl\
lll\
l\
lll\
O
;
lOlllOOOllO\

->
lOlO\
O\
llllOO\
l
(
*
llOlO\
llOOOl
)
;
*
ll\
Ol\
OllOOOl\

=
lOlllO\
OO\
llO
;
lOlllOOOllO
->
AddRef
(
)
;
}
}
