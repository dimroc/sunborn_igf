//---------------------------------------------------------------------------------
// File Name: zpta009.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#define TA_PHYSICS_INTERNAL
#include "CollisionObjectCombo.h"
#ifndef llOllOOOllO
#include "../Physics/zpta013.h"
#endif //
#ifndef TA_PHYSICS_H
#include "Physics.h"
#endif //
#ifndef TA_COLLISIONOBJECTCONVEX_H
#include "CollisionObjectConvex.h"
#endif //
#ifndef TA_COLLISIONOBJECTCACHEDPOLYDATA_H
#include "CollisionObjectCachedPolyData.h"
#endif //
#ifndef TA_COLLISIONOBJECTLINELIST_H
#include "CollisionObjectLineList.h"
#endif //
#ifndef TA_COLLISIONOBJECTCAPSULE_H
#include "CollisionObjectCapsule.h"
#endif //
#ifndef TA_COLLISIONOBJECTSPHERE_H
#include "CollisionObjectSphere.h"
#endif //
#ifndef TA_COLLISIONOBJECTCYLINDER_H
#include "CollisionObjectCylinder.h"
#endif //
#ifndef TA_COLLISIONOBJECTCOMPLEX_H
#include "CollisionObjectComplex.h"
#endif //
#ifndef llllOOOOlOO
#endif //
#ifndef lllOOOlOllO
#include "../Physics/zpta007.h"
#endif //
#ifndef llllOOOOlOl
#include "../Physics/zpta010.h"
#endif //
#define llllOOOOllO()
namespace
TA
{
struc\
t
Co\
llis\
i\
onO\
bjectCom\
bo
::
Dat\
a\

{
#ifdef _DEBUG
int\

llllOO\
OOlll
;
#endif
lO\
OO\
O\
lOl\
lO
<
Coll\
isionObjec\
tS\
imple\

*
>
lll\
l\
OOOlOOO
;
}
;
#ifndef DOXYGEN
co\
nst
in\
t
llll\
OOOl\
OOl
=
5
;
con\
st
int
llllO\
OOlOlO
=
llllO\
OOl\
OOl
*
llllOOOlOOl
;
typedef
voi\
d
(
TA\
C_CALL\

*
ll\
llO\
OO\
lO\
ll
)
(
const
MFrame
&
lOl\
l\
Ollllll\

,
cons\
t
MFrame\

&
lOlll\
O\
OOOO\
O\

,
lOl\
lOl\
lO\
ll\
O
*
lO\
ll\
lO\
OOO\
Ol
)
;
st\
ruct
llllOO\
O\
llOO
{
ll\
l\
lOOOlOll
llllOO\
Oll\
O\
l
;
u32
lOl\
O\
l\
lOOO\
l
;
}
;
enu\
m
llllOOOlllO
{
ll\
llO\
OO\
llll
=
0x1
,
llllOOl\
O\
OOO
=
0x2
,
}
;
static\

ll\
l\
l\
OO\
O\
ll\
O\
O
llllOO\
lOOOl\

[
lll\
l\
OOOlO\
l\
O
]
=
{
{
llllOOlOOlO\

,
0
}
,
{
llllO\
Ol\
OOll
,
ll\
ll\
OOlOOOO
}
,
{
lll\
lOOOOOlO
,
lll\
lO\
O\
lOO\
OO
}
,
{
lll\
lO\
O\
lOlOO
,
ll\
llOOlOOOO
}
,
{
ll\
l\
lOOl\
OlO\
l
,
llllOOlO\
OOO\

}
,
{
llll\
OOlOO\
ll\

,
0
}
,
{
0
,
0
}
,
{
lllOll\
llllO\

,
lll\
lO\
OlOOOO
}
,
{
llllO\
O\
lOl\
lO
,
llll\
OOlOOOO
}
,
{
llllOOlO\
lll
,
llll\
OOlOOOO
}
,
{
llllOOO\
OOlO
,
0
}
,
{
lll\
Ol\
ll\
ll\
lO
,
0
}
,
{
lll\
OllO\
lO\
ll
,
0
}
,
{
lllOl\
ll\
Olll
,
ll\
llOOlOOOO\

}
,
{
lll\
lOOOOOl\
l
,
0
}
,
{
ll\
l\
lO\
O\
l\
O\
lO\
O\

,
0
}
,
{
ll\
llOOl\
OllO
,
0
}
,
{
lll\
Ol\
l\
lOlll
,
0
}
,
{
ll\
l\
l\
OOllOOO\

,
0
}
,
{
llllOO\
llO\
Ol
,
0
}
,
{
ll\
llOOl\
OlOl
,
0
}
,
{
ll\
l\
lOOlOlll
,
0
}
,
{
llllOO\
OO\
Oll
,
lll\
l\
O\
OlOO\
O\
O
}
,
{
ll\
ll\
OOl\
lOO\
l
,
lll\
lOOlO\
OOO
}
,
{
lll\
lOOllOlO
,
0
}
,
}
;
ty\
pedef
void
(
TAC_CA\
LL\

*
llllOOll\
Oll
)
(
co\
ns\
t
MF\
rame\

&
lOl\
l\
Ollll\
ll
,
con\
s\
t
MFr\
ame\

&
lOlllOOOOOO
,
lOllOllOllO
*
lO\
ll\
lOOOOOl\

)
;
static
ll\
llOOl\
lO\
ll
lll\
lOO\
l\
l\
lOO\

[
ll\
llO\
O\
OlO\
O\
l
]
=
{
lllOlO\
Ol\
lOO\

,
llllO\
Ol\
ll\
Ol\

,
ll\
l\
Oll\
llO\
l\
l\

,
llllOOllllO
,
llll\
OO\
l\
llll
,
}
;
#endif //
vo\
i\
d
Collisi\
on\
Ob\
j\
ectC\
ombo\

::
Initialise
(
)
{
if
(
lO\
lOOl\
Oll\
O
!=
0
)
{
lOOO\
lllOl\
O
(
0
,
"CollisionObjectCombo::Initialise. Already initialised.")
;
Finalise
(
)
;
}
;
llllOlOO\
OO\
O\

.
v3Cen\
t\
er
.
Cl\
ear
(
)
;
lll\
lOl\
OO\
OOO
.
v3\
Ext\
en\
t\

.
Cle\
ar\

(
)
;
lOOOOOl\
lO\
OO
(
lOl\
O\
OlOllO
,
Da\
ta
)
;
lOlOO\
l\
O\
l\
lO
->
llll\
OO\
OlO\
O\
O
.
Initia\
l\
ise\

(
0
,
1
)
;
llllOlOOO\
Ol
=
0
;
}
voi\
d
Collis\
ion\
O\
b\
je\
ctCom\
bo\

::
Ini\
tia\
l\
iseAsABox
(
flo\
a\
t
llllOlO\
OOlO
,
float
llllOlOOOll
,
fl\
oat
lll\
lO\
l\
OOlO\
O
)
{
if
(
lOlOO\
lOl\
l\
O
!=
0
)
{
lOOOl\
llOlO
(
0
,
"CollisionObjectConvex::InitialiseAsABox. Already initialised.")
;
Fin\
a\
lis\
e\

(
)
;
}
;
lO\
OOO\
O\
llOO\
O
(
lOl\
OOlOllO
,
Data\

)
;
lOlO\
Ol\
O\
llO
->
llllOOO\
lOO\
O
.
Initialise
(
1
,
1
)
;
llll\
Ol\
O\
O\
OO\
l\

=
0
;
Collisio\
nObjectConv\
ex
*
lll\
lOl\
OOlO\
l
=
Collisio\
nObject\
Co\
nvex
::
Creat\
eNe\
w
(
)
;
llllO\
lO\
O\
l\
O\
l
->
Initia\
li\
se\
AsABox
(
llllO\
lO\
OOl\
O\

,
llllOlO\
O\
Oll\

,
ll\
ll\
OlOOlO\
O
)
;
lO\
lOOlOl\
lO\

->
llllOO\
OlOOO\

[
0
]
=
llll\
Ol\
OOlO\
l
;
llllOlOO\
O\
OO\

=
lOlOOlOllO
->
llllO\
O\
OlOOO
[
0
]
->
Calculat\
eBound\
ing\
Box
(
)
;
lll\
lOlOOOOO
.
v3Extent
.
x
+=
llOO\
l\
lO\
OOOO
;
llllOlOO\
O\
O\
O
.
v3Extent
.
y
+=
llOOllOOOOO
;
ll\
ll\
OlOO\
OOO
.
v3Ext\
ent
.
z
+=
llOOllOOOO\
O
;
}
void\

CollisionObj\
ect\
C\
omb\
o
::
Ini\
t\
ialiseAsABox
(
const\

AABB
&
lOOOOO\
Olll\

)
{
if
(
lOl\
OO\
l\
OllO
!=
0
)
{
lOO\
OlllO\
lO
(
0
,
"CollisionObjectCombo::Initialise. Already initialised.")
;
Fina\
lise
(
)
;
}
;
lO\
O\
O\
OOl\
lOO\
O\

(
lOlOOlOllO
,
Data
)
;
lOlOO\
lOllO
->
ll\
ll\
OOOlO\
OO
.
Initia\
li\
se
(
1
,
1
)
;
llll\
O\
l\
O\
OO\
Ol\

=
0
;
Collision\
Ob\
ject\
C\
o\
nvex
*
llllOl\
O\
OlOl
=
Collisio\
n\
ObjectConv\
e\
x
::
Crea\
teNew
(
)
;
llll\
O\
l\
OOlO\
l
->
Ini\
ti\
aliseA\
s\
ABox
(
lOOO\
O\
OOlll
)
;
lOl\
OO\
lOllO
->
llllOOOlOOO\

[
0
]
=
ll\
l\
lO\
lOOlOl
;
ll\
l\
lOl\
OOOOO
=
lOlOOl\
Ol\
lO
->
llll\
OOOlOO\
O
[
0
]
->
Calcu\
late\
Bounding\
Box\

(
)
;
lll\
l\
O\
lO\
OO\
O\
O
.
v3\
E\
xt\
en\
t\

.
x
+=
llOOllOOO\
OO
;
llllO\
lOOOO\
O
.
v3E\
xt\
en\
t\

.
y
+=
llO\
OllOOO\
OO
;
llllOlOOO\
O\
O
.
v3Extent
.
z
+=
llO\
OllOOOOO\

;
}
vo\
id
Collisi\
onObject\
C\
o\
mbo
::
Ini\
ti\
alise\
AsA\
nOriente\
d\
Bo\
x
(
co\
nst
AABB
&
lO\
O\
O\
OOOlll
,
const
MFra\
me
&
lO\
O\
OOOOOOl
)
{
if
(
lOlOOlOll\
O\

!=
0
)
{
lO\
OOlllO\
lO
(
0
,
"CollisionObjectConvex::InitialiseAsABox. Already initialised.")
;
Final\
ise\

(
)
;
}
;
lOOOOO\
llOOO
(
lOlO\
O\
lOl\
l\
O\

,
Dat\
a\

)
;
lO\
lO\
OlOll\
O
->
llllOOOlOOO
.
Initialise
(
1
,
1
)
;
llllOlOOOOl\

=
0
;
Collis\
ionO\
bject\
Co\
nve\
x
*
llllOlOOlO\
l
=
CollisionO\
bjectCon\
ve\
x
::
Create\
New
(
)
;
lll\
lO\
lOOlOl\

->
Initial\
is\
eA\
sAnOri\
ente\
dBox\

(
lOO\
OOOOlll
,
lOOOOOOO\
O\
l
)
;
lOlO\
OlO\
ll\
O
->
llll\
OOOlO\
OO
[
0
]
=
ll\
llOlOOlOl\

;
ll\
llOlOOOO\
O\

=
lOl\
O\
OlOllO
->
ll\
llOOOlO\
OO
[
0
]
->
CalculateBoun\
din\
gBo\
x
(
)
;
llllOlOOOOO\

.
v3Ex\
ten\
t\

.
x
+=
llOOllO\
OOOO
;
llllOlO\
OO\
OO
.
v3Ex\
tent
.
y
+=
llOOll\
OO\
OOO\

;
ll\
l\
l\
O\
lOOO\
OO
.
v3E\
xte\
nt
.
z
+=
llOOllOOOOO\

;
}
void
Coll\
is\
ion\
ObjectC\
o\
mbo
::
Initi\
al\
is\
eAsA\
C\
a\
psul\
e
(
co\
ns\
t
Vec3\

&
lO\
O\
lOlOlll
,
cons\
t
Vec\
3
&
lOOlOllOO\
l
,
float\

ll\
l\
lO\
lllll\

)
{
if
(
lO\
lO\
Ol\
OllO\

!=
0
)
{
lOOO\
l\
l\
lOlO
(
0
,
"CollisionObjectCombo::Initialise. Already initialised.")
;
Fi\
nalise
(
)
;
}
;
lOOOOOllO\
OO\

(
lOl\
OOlO\
l\
lO
,
Data
)
;
lOl\
O\
OlOll\
O
->
lll\
lOOO\
l\
OOO
.
In\
itia\
li\
se
(
1
,
1
)
;
llll\
OlOOOOl\

=
0
;
Collision\
ObjectCapsule
*
ll\
llOlOOll\
O
=
Collisi\
o\
nObjec\
t\
Capsu\
le
::
Cre\
ateNe\
w\

(
)
;
llllOl\
O\
O\
l\
lO\

->
Initial\
ise
(
lO\
OlOlOl\
ll\

,
lOOlOll\
OO\
l
,
llllOlllll
)
;
lO\
l\
O\
O\
l\
Ol\
lO
->
llll\
OOO\
lOOO
[
0
]
=
llllO\
l\
OOll\
O
;
llllO\
lOOO\
OO
=
lOlOOlOll\
O
->
llll\
O\
OO\
l\
OOO
[
0
]
->
Ca\
l\
cul\
ate\
Bo\
und\
ingB\
ox
(
)
;
lll\
lOlOOOOO
.
v3Ex\
t\
e\
nt
.
x
+=
ll\
O\
Ol\
lOOOOO
;
llllOlO\
OOOO
.
v3Exte\
n\
t
.
y
+=
ll\
OOllOO\
OOO
;
ll\
l\
lOlOOOOO\

.
v3Ex\
t\
ent
.
z
+=
llO\
O\
llOOOO\
O
;
}
vo\
id
Coll\
i\
sionObject\
C\
o\
mbo\

::
InitialiseAs\
ASphere
(
con\
st
Vec3
&
v3\
Ce\
nt\
e\
r
,
fl\
o\
at
lll\
l\
O\
ll\
lll
)
{
if
(
lOl\
OOlOllO\

!=
0
)
{
lOOOll\
lOlO
(
0
,
"CollisionObjectCombo::Initialise. Already initialised.")
;
Finalis\
e
(
)
;
}
;
lO\
OOOOllOOO
(
lOl\
OOlO\
llO
,
Data
)
;
lOlOOl\
Oll\
O
->
llllOOO\
lO\
OO
.
Ini\
tialise
(
1
,
1
)
;
llllOlOOOOl\

=
0
;
Co\
l\
l\
isi\
on\
ObjectSpher\
e\

*
llllOlO\
O\
lll
=
Co\
llisionObjectSphere
::
Create\
New\

(
)
;
llll\
Ol\
OOlll
->
Ini\
tiali\
se
(
v3\
Center
,
llllOlllll\

)
;
lOlOOlOl\
lO
->
llllOO\
OlOOO
[
0
]
=
lll\
lOlOOlll
;
llllO\
lOO\
OOO\

=
lOlOOlOllO\

->
ll\
llOOOl\
OOO
[
0
]
->
Calc\
u\
la\
teBo\
un\
din\
g\
Box
(
)
;
ll\
ll\
O\
l\
O\
O\
OOO\

.
v3Extent\

.
x
+=
ll\
O\
Oll\
OOOOO
;
ll\
llOlOOOO\
O\

.
v3Ex\
t\
ent
.
y
+=
llOOll\
OO\
OOO
;
lll\
lO\
lOOOOO
.
v3Exten\
t
.
z
+=
llOOllOOOOO
;
}
voi\
d
Collision\
O\
bject\
Co\
m\
bo\

::
Ini\
t\
ialiseAsACyl\
ind\
er
(
co\
n\
st\

Vec\
3
&
lOO\
lOlOlll\

,
const
Vec\
3
&
lO\
OlOl\
lOOl
,
fl\
o\
at
llllOl\
ll\
ll
)
{
if\

(
lOlOOlO\
llO
!=
0
)
{
lO\
OO\
lllOlO
(
0
,
"CollisionObjectCombo::Initialise. Already initialised.")
;
Fi\
nalis\
e\

(
)
;
}
;
lOOOO\
OllOOO
(
lOlOOlOl\
lO
,
Da\
ta
)
;
lOl\
OOlOll\
O\

->
llll\
OOOlOO\
O
.
Initialise
(
1
,
1
)
;
lll\
lOl\
OO\
O\
Ol\

=
0
;
Co\
ll\
ision\
Objec\
tCylind\
er
*
ll\
llOlOlOOO\

=
Collis\
i\
o\
n\
Ob\
je\
ct\
Cylind\
er
::
Cr\
eate\
Ne\
w\

(
)
;
llllOl\
O\
lOOO\

->
Initialise\

(
lOOl\
OlOlll
,
lOO\
lO\
l\
l\
OOl
,
lll\
lOl\
llll
)
;
lOl\
OO\
l\
OllO
->
llllOOO\
lOOO\

[
0
]
=
ll\
ll\
OlOlOOO
;
ll\
l\
lO\
lO\
OOOO\

=
lOlOO\
lOl\
lO
->
llll\
OOO\
lO\
OO
[
0
]
->
Calc\
ula\
teBou\
nd\
ingB\
ox\

(
)
;
llll\
O\
lO\
OOO\
O\

.
v3Extent
.
x
+=
llOOllO\
O\
OOO
;
llll\
OlOOOOO\

.
v3Ext\
ent
.
y
+=
llOOllOOOOO
;
lll\
lO\
lOOOOO\

.
v3Ext\
ent\

.
z
+=
ll\
OOl\
l\
OOOOO
;
}
bool
Col\
li\
si\
onObjectCombo
::
In\
itiali\
s\
eF\
r\
omP\
o\
i\
ntL\
i\
st\

(
const
Vec3
*
llll\
OlOlOOl\

,
int
ll\
llOl\
OlOlO\

)
{
if
(
lOlOOlOllO
!=
0
)
{
lO\
OO\
lllO\
lO
(
0
,
"CollisionObjectCombo::Initialise. Already initialised.")
;
Finalis\
e
(
)
;
}
;
lOOOOO\
l\
lOO\
O
(
lOlOO\
lOl\
lO
,
Data\

)
;
lO\
lOOlOllO
->
lll\
l\
O\
OOl\
O\
O\
O\

.
Ini\
tialise\

(
1
,
1
)
;
ll\
l\
lO\
l\
OO\
OOl\

=
0
;
Coll\
is\
io\
nObje\
ctConv\
e\
x
*
lll\
lO\
lOOlOl
=
Collisi\
o\
nObjec\
t\
Conve\
x
::
Cre\
at\
eN\
ew\

(
)
;
boo\
l\

llllOlOl\
Oll
=
lll\
l\
Ol\
O\
OlO\
l
->
Initi\
aliseF\
romP\
oi\
ntL\
ist
(
lll\
l\
Ol\
OlO\
Ol
,
llllOlOlO\
lO
)
;
lOl\
OO\
l\
Oll\
O
->
lll\
lOOOl\
O\
OO
[
0
]
=
ll\
llOlOOlOl
;
lll\
lOl\
OOOOO\

=
lOl\
OO\
lOll\
O
->
llllOOOlOO\
O
[
0
]
->
Calcu\
lateBoundingB\
ox
(
)
;
llllOlOO\
OOO
.
v3Ext\
ent\

.
x
+=
llOOl\
l\
OO\
OOO\

;
llllO\
lOOOOO
.
v3Extent
.
y
+=
llOOllOOOOO
;
llllOlOOOO\
O
.
v3Extent\

.
z
+=
llO\
O\
ll\
OOOOO
;
retu\
rn\

lll\
lOlO\
lOll
;
}
vo\
id\

Colli\
sionObject\
C\
ombo
::
Fin\
alis\
e
(
)
{
if
(
!
lOlOOlOllO
)
re\
turn
;
lll\
lO\
l\
O\
OOOO
.
In\
iti\
ali\
se
(
k_v3Z\
e\
r\
o
,
k_v3\
Ze\
ro
)
;
for
(
int
llllOlOllOO
=
0
;
llllO\
l\
Ol\
lO\
O
<
lOlOOlOllO
->
ll\
ll\
O\
OO\
l\
O\
O\
O
.
lOO\
O\
l\
llOOl\

(
)
;
llllOlO\
l\
lOO\

++
)
lOlO\
OlO\
l\
lO\

->
ll\
ll\
OOO\
lOOO
[
llll\
O\
lO\
ll\
OO\

]
->
Release
(
)
;
lO\
Ol\
O\
O\
O\
OOO
(
lOlOO\
lO\
ll\
O
,
Data\

)
;
lOlO\
Ol\
Oll\
O
=
0
;
}
void
Collisi\
onObje\
ctComb\
o
::
Seria\
lise\

(
Seria\
lise\
r
&
lOOOlO\
llOl\

,
con\
st
Version
&
lllOl\
O\
OOlO
)
{
lOOOOOOllO\

(
lllOl\
OOO\
lO
<=
llOllOOl\
OlO
,
"CollisionObjectCombo::Serialise. Version is too new.")
;
if
(
lO\
OOl\
OllOl
.
lOOOllO\
OOO\

(
)
)
{
if
(
lOl\
OOlOll\
O\

!=
0
)
{
lO\
OOlllOlO
(
0
,
"CollisionObjectCombo::Serialise. Already initialised")
;
Finali\
s\
e
(
)
;
}
;
lOOOOO\
ll\
O\
OO
(
lOl\
O\
O\
lOllO
,
Data
)
;
llll\
Ol\
OOOO\
l\

=
0
;
}
lOOO\
lOl\
l\
Ol
.
Ser\
ia\
lise
(
lll\
lOlO\
O\
OOO\

)
;
int\

lOOl\
llOl\
lO
=
lO\
lO\
O\
l\
Oll\
O\

->
lll\
l\
OOOlOO\
O
.
lOO\
Oll\
l\
OOl\

(
)
;
lO\
O\
O\
lOllOl
.
Ser\
i\
a\
l\
ise\

(
lOOlllOll\
O
)
;
if
(
lO\
OOlOl\
lOl
.
lO\
OOllO\
O\
O\
O\

(
)
)
{
lOlOOl\
OllO\

->
ll\
l\
l\
OOO\
lO\
OO
.
In\
it\
i\
alise
(
lOOlll\
O\
l\
lO
,
lOOl\
llOll\
O
)
;
for\

(
in\
t
ll\
llOlO\
llOO
=
0
;
llllO\
lOllO\
O
<
lOlOO\
lOllO
->
lll\
lO\
O\
O\
lOOO
.
lO\
OOlll\
OOl
(
)
;
llllOlOllOO
++
)
{
int
lOllOlOlO\
O\
O
;
lO\
OO\
l\
OllOl
.
Se\
ri\
alise\

(
lOllOlOlO\
OO
)
;
Co\
ll\
isio\
n\
Obje\
ct\
Si\
m\
ple\

*
lOlOllOOO\
Ol
;
switch
(
lOllOlO\
l\
O\
OO
)
{
case
Co\
llisionO\
bject
::
TYPE_CONVEX\

:
lOlOll\
OOOOl
=
CollisionO\
b\
jec\
tConvex\

::
Cre\
ate\
Ne\
w
(
)
;
break
;
case
Colli\
sio\
n\
O\
b\
ject
::
TY\
P\
E_LINE_\
LIS\
T
:
ll\
ll\
O\
lOOO\
O\
l
=
Collisi\
onObj\
ectL\
ine\
List
::
Cre\
ateNew\

(
)
;
lOlOllOOO\
Ol\

=
ll\
l\
lOlO\
OO\
Ol
;
br\
e\
ak
;
case\

Co\
l\
lisio\
n\
Obj\
ect
::
TYP\
E_S\
P\
HERE
:
lO\
lOllOOOO\
l
=
Col\
lisionOb\
j\
ectSph\
e\
re
::
Cre\
a\
teNe\
w
(
)
;
break\

;
case\

Coll\
isio\
nO\
b\
ject
::
TYPE\
_CAPSUL\
E
:
lOlO\
ll\
OOOOl
=
Collisi\
onO\
bje\
c\
tC\
aps\
ule
::
Cr\
eat\
eNew
(
)
;
break
;
cas\
e
Co\
ll\
isionOb\
ject
::
TYPE\
_CY\
L\
INDER\

:
lOlOllOOO\
Ol\

=
Colli\
sionOb\
jec\
t\
C\
ylinder\

::
CreateNe\
w
(
)
;
bre\
ak\

;
defa\
ult\

:
ll\
lOOOlll\
O
;
}
lO\
lOll\
OOO\
Ol
->
Se\
r\
i\
ali\
se
(
lOOOlOl\
lOl
,
ll\
lOl\
OOOl\
O
)
;
lOlOOl\
OllO
->
llllOOOlOO\
O
[
lll\
l\
OlOllOO\

]
=
lOl\
OllOOOOl
;
}
}
else
{
for
(
in\
t
llllO\
lO\
llOO
=
0
;
llllO\
lOll\
OO
<
lO\
lOO\
lO\
llO\

->
llllOOOl\
OOO
.
lO\
OOlll\
OOl
(
)
;
ll\
llOlOl\
lOO
++
)
{
Co\
lli\
sionObj\
ec\
t\
S\
impl\
e
*
lO\
l\
O\
llOOO\
O\
l
=
lO\
l\
OOlOll\
O\

->
llll\
O\
OOlOO\
O
[
llll\
OlOl\
lOO
]
;
int
lOl\
lOlOl\
OOO
=
lOlOl\
lOOOOl
->
Get\
Co\
llis\
i\
onObje\
ctTy\
pe
(
)
;
lOOOlOll\
O\
l
.
Ser\
i\
alise\

(
lOl\
lOl\
OlOOO\

)
;
TA_\
A\
SSERT
(
lOl\
lO\
l\
OlOOO
==
Co\
ll\
is\
ion\
Obj\
e\
ct
::
TYPE_CON\
VEX\

||
lO\
l\
lOl\
O\
lOOO
==
Co\
ll\
ision\
O\
bject
::
TY\
PE\
_LINE_LIST
||
lOl\
lOlO\
lO\
OO
==
Colli\
sion\
Object
::
TY\
PE_S\
PHERE
||
lO\
llOlO\
lOOO
==
Co\
l\
lision\
Ob\
ject
::
TYP\
E_CAPSULE
||
lOllOl\
OlOOO
==
CollisionObjec\
t
::
TY\
PE_CYLINDER\

)
;
lOl\
OllOO\
OOl
->
Seri\
al\
ise
(
lOOOl\
Ol\
lOl
,
lllOlOOOlO
)
;
}
}
}
void
Col\
lisionObject\
C\
o\
m\
bo\

::
AddCo\
ll\
i\
s\
i\
onO\
bject
(
CollisionObje\
ctS\
im\
ple
*
lOlOllOOO\
Ol
)
{
llll\
OOOO\
llO
(
)
;
lOOOOOOll\
O
(
lOl\
O\
Ol\
O\
l\
l\
O
,
"CollisionObjectCombo::AddCollisionObject. Initialise not called on CollisionObjectCombo yet.")
;
TA_A\
SSER\
T\

(
lO\
l\
Oll\
O\
OOOl
)
;
TA_ASS\
E\
RT
(
lOl\
OllOOOO\
l
->
GetColli\
sionObjectTyp\
e
(
)
==
Co\
l\
l\
i\
si\
on\
Object
::
TY\
PE\
_CON\
VE\
X
||
lOlOllOOOO\
l\

->
GetC\
ollisionObjec\
tType\

(
)
==
Co\
llisi\
on\
Obj\
e\
ct
::
TYPE_L\
IN\
E_\
LI\
ST\

||
lOlOll\
OOOOl
->
Ge\
tCollisi\
onObject\
T\
y\
p\
e
(
)
==
Colli\
s\
ionObject
::
TY\
PE_CA\
PSULE
||
lOlOllOOO\
Ol\

->
Ge\
tCo\
ll\
i\
s\
ionObject\
Ty\
pe
(
)
==
Co\
l\
lisi\
o\
nOb\
ject
::
TYPE\
_\
SPH\
ER\
E
||
lOlOllOOOOl
->
Ge\
tC\
o\
llis\
io\
nObject\
Type
(
)
==
Co\
l\
lisionO\
b\
ject\

::
TYPE_CYLI\
NDER
)
;
lOlO\
Ol\
O\
l\
lO
->
lll\
lOO\
OlOO\
O
.
lOO\
OlllOO\
O
(
lOlO\
llOO\
OOl
)
;
lO\
l\
OllO\
OOOl
->
AddR\
e\
f
(
)
;
llllOl\
OllOl
(
)
;
if\

(
lOlO\
l\
l\
OO\
OOl
->
GetC\
o\
llis\
i\
on\
O\
b\
ject\
Typ\
e
(
)
==
Collisio\
nObjec\
t\

::
TYPE_LI\
NE_LI\
ST
)
{
lO\
OOOO\
Oll\
O
(
llll\
OlOOOOl
==
0
,
"CollisionObjectCombo::AddCollisionObject, Only allowed on CollisionObjectLineList per CollisionObjectCombo")
;
ll\
llOlOOOO\
l
=
(
Coll\
i\
s\
ionObj\
ect\
LineLi\
s\
t
*
)
lOlO\
llOO\
OOl
;
}
}
void
Coll\
i\
si\
o\
n\
O\
b\
j\
ectCom\
b\
o\

::
Rem\
oveColl\
is\
ionObject\

(
Collisi\
onO\
bj\
e\
ctSim\
ple
*
lOl\
OllO\
O\
OOl\

)
{
lll\
l\
OO\
OOllO
(
)
;
fo\
r
(
int
lOOOllOO\
O\
l
=
0
;
lOOOllO\
OOl
<
lO\
lOOlOll\
O\

->
lll\
lOO\
Ol\
OOO
.
lOOOlllOOl
(
)
;
lOO\
O\
llOOOl
++
)
{
if
(
lOlOOlOllO
->
ll\
llOOOl\
OOO
[
lOOO\
llOOOl
]
==
lOlOllO\
O\
OOl
)
{
llllO\
OOOll\
O\

(
)
;
lOlOOlOllO
->
llllO\
OOlOOO\

.
lOOl\
lll\
lll
(
lO\
OOllO\
OOl
)
;
return\

;
}
}
lOOO\
l\
l\
lO\
lO
(
0
,
"CollisionObjectCombo::RemoveCollisionObject. pCollisionObject not found.")
;
}
void
Colli\
si\
o\
nObjectCo\
mbo
::
Remov\
eCo\
llisio\
nObj\
ec\
t
(
in\
t
lO\
O\
Ol\
O\
Olll
)
{
lll\
lOOO\
Oll\
O
(
)
;
if
(
lOOOlO\
O\
lll\

<
0
||
lOO\
O\
lOOll\
l
>=
lOlOOlO\
ll\
O
->
ll\
l\
l\
OOOl\
OOO\

.
lOOOlll\
OO\
l
(
)
)
{
lOOO\
lllOlO\

(
0
,
"CollisionObjectCombo::RemoveCollisionObject. nIndex is out of bounds.")
;
retu\
rn\

;
}
llllOOOOll\
O
(
)
;
lOlOOl\
OllO\

->
lll\
l\
OOOlOO\
O\

.
lOOl\
llllll
(
lOOO\
lO\
Ol\
ll
)
;
}
int
Col\
lisio\
nObject\
Com\
bo
::
Get\
NumCollis\
i\
onO\
bject\
s\

(
)
const
{
retur\
n
lO\
lO\
O\
lOl\
lO
->
lll\
lOOOlOOO
.
lO\
O\
OlllOOl
(
)
;
}
CollisionObjec\
tSimpl\
e
*
Col\
lision\
Ob\
jec\
t\
Combo
::
GetC\
ol\
lisi\
o\
nObje\
ct
(
int
lOO\
Ol\
O\
Olll
)
{
if
(
lO\
OOlOOll\
l\

<
0
||
lO\
OOlO\
Ol\
ll
>=
lO\
lOO\
lO\
llO
->
llllOOOlO\
OO\

.
lOOOlll\
OOl\

(
)
)
{
lOOOlllOl\
O
(
0
,
"CollisionObjectCombo::RemoveCollisionObject. nIndex is out of bounds.")
;
re\
tu\
r\
n
0
;
}
retur\
n
lOlOO\
lO\
llO
->
llllOOOlOOO
[
lOO\
OlOOlll
]
;
}
void\

Col\
lisionObj\
e\
ct\
Combo
::
Re\
n\
de\
r
(
con\
st
MFr\
a\
me
&
lOOO\
O\
OOOOl
)
{
fo\
r
(
int\

llllOlO\
llOO
=
0
;
llllO\
lOllO\
O
<
lOlO\
O\
l\
OllO\

->
llllOOOlOOO
.
lOOO\
lllOOl
(
)
;
llll\
Ol\
OllOO
++
)
lOl\
OO\
lOl\
lO
->
llllO\
OOlO\
OO
[
ll\
llOlOllOO
]
->
Render\

(
lOO\
O\
OOOOOl
)
;
}
void\

Collisio\
nObjectCom\
b\
o
::
Calc\
ulateMa\
s\
s
(
float\

lllOl\
Olll\
ll
,
float
&
lO\
l\
lO\
O\
OO\
lOO
,
Vec3
&
lll\
Ol\
lO\
OOOO
,
Mat3\
3
&
ll\
lOll\
OOOOl
)
co\
nst
{
lllO\
llOOOOO\

.
Clear
(
)
;
lOl\
lOOOOlOO
=
0
;
int
llllO\
lOllO\
O
;
ll\
lO\
l\
lOOO\
Ol
.
v3X
.
Cl\
ea\
r\

(
)
;
lllOll\
OOO\
Ol
.
v3\
Y\

.
Cl\
ear
(
)
;
lllOllO\
OOOl
.
v3Z
.
Clear
(
)
;
for
(
llllOlOllO\
O
=
0
;
lll\
l\
O\
lOllOO
<
lOlOOlOllO
->
ll\
llO\
OOlOOO
.
lO\
OOlllOOl
(
)
;
llllO\
lOllO\
O
++
)
{
fl\
oat
lll\
l\
OlOlllO
;
Ve\
c\
3
ll\
l\
lOlO\
llll
;
Mat33
llllO\
llOOO\
O
;
lOlO\
O\
lOl\
lO\

->
ll\
llOOOlOOO
[
llllOl\
Oll\
OO\

]
->
Ca\
lcul\
ateM\
ass
(
ll\
l\
OlOlll\
l\
l
,
ll\
llOlO\
l\
l\
lO
,
ll\
l\
lOl\
Ollll\

,
ll\
llOllOOOO
)
;
lOl\
lOOOOlOO
+=
lll\
l\
OlO\
l\
ll\
O
;
lllOll\
OOOOO
+=
llllOlOllll
*
lll\
lO\
l\
O\
l\
l\
lO
;
}
if
(
lOl\
l\
OOOOlOO\

>
0.0f
)
lllO\
l\
lOOOOO\

/=
lO\
l\
lOOOOl\
OO\

;
fo\
r
(
llll\
Ol\
O\
llO\
O
=
0
;
llllO\
lO\
llOO
<
lOlOO\
lOllO
->
ll\
llO\
OOlOOO
.
lOOOlll\
OOl
(
)
;
ll\
llOlOllOO
++
)
{
flo\
a\
t
llllOlOl\
ll\
O
;
Ve\
c3\

llllOlOllll\

;
Mat\
33\

llllOll\
O\
OO\
O
;
lOl\
OOlOll\
O
->
llll\
O\
OO\
l\
O\
OO
[
llllOlOllOO\

]
->
Calc\
ulat\
eM\
ass
(
lll\
O\
lOl\
llll
,
lll\
lOlOlllO
,
lll\
lOlOllll
,
llll\
OllOOOO
)
;
Ve\
c3\

ll\
lOlO\
l\
OllO
=
llllOlOlll\
l\

-
lllO\
llOOOOO\

;
llllOllOOOO
.
M11
(
)
+=
ll\
l\
lOlO\
lllO
*
(
lllOlO\
lOllO
.
y
*
lllO\
lOlOl\
lO
.
y
+
lll\
OlOlOllO
.
z
*
ll\
l\
Ol\
O\
l\
Ol\
lO
.
z
)
;
llllOl\
lO\
OOO
.
M22\

(
)
+=
lll\
lOlOlllO
*
(
lll\
Ol\
Ol\
OllO
.
z
*
lll\
Ol\
OlOllO
.
z
+
lllOlOlOllO
.
x
*
lll\
O\
lO\
l\
OllO\

.
x
)
;
lll\
lOllO\
O\
OO
.
M33
(
)
+=
lll\
l\
OlOlllO\

*
(
ll\
lOlOlOl\
lO\

.
x
*
ll\
l\
Ol\
Ol\
O\
l\
l\
O
.
x
+
lllOl\
O\
lO\
llO
.
y
*
ll\
lOlOl\
O\
l\
lO
.
y
)
;
llllOllOOO\
O
.
M1\
2
(
)
=
llll\
OllOO\
OO
.
M2\
1
(
)
-=
ll\
ll\
OlOlllO
*
ll\
l\
O\
lOlOllO
.
x
*
lllOlO\
lOllO
.
y
;
llllO\
llO\
OOO\

.
M23
(
)
=
llllO\
llOOOO
.
M32
(
)
-=
ll\
llOl\
Olll\
O
*
ll\
lOlO\
lOllO
.
y
*
lllO\
lO\
lOllO
.
z
;
llllOl\
lO\
OOO\

.
M13
(
)
=
llllO\
llO\
OO\
O
.
M3\
1
(
)
-=
lll\
l\
Ol\
OlllO\

*
ll\
lOl\
O\
lO\
llO
.
z
*
lllOlOlOllO
.
x
;
ll\
lO\
llOO\
OOl
+=
llllOllO\
OO\
O
;
}
}
bo\
ol
Colli\
s\
i\
o\
nO\
bje\
ctCom\
bo
::
Test\
LineFor\
Coll\
isio\
n
(
con\
st
Ve\
c3
&
lOOlOlO\
lll
,
const
Vec3
&
lOOOlOOOO\
O
,
flo\
at\

lOOlOllO\
OO
,
Col\
lisi\
on
&
ll\
Ol\
lll\
O\
lOl
)
const
{
bool\

llllO\
l\
OlOll
=
fals\
e
;
for
(
int
ll\
llO\
lOllO\
O
=
0
;
lll\
l\
OlOllO\
O
<
lOlOO\
lOl\
l\
O
->
lll\
lO\
OOlOO\
O
.
lOOO\
l\
ll\
OOl
(
)
;
lll\
l\
OlOllOO
++
)
{
Vec\
3\

llllOllOOOl\

;
Vec3
lll\
lOl\
lOOl\
O\

;
if
(
lOlOOlOl\
lO
->
llll\
OOOlOOO
[
llllOlOllO\
O
]
->
Tes\
tLi\
neFo\
rCollision
(
lOO\
lOlOll\
l
,
lO\
OOlOOOOO\

,
lOOlOll\
O\
OO
,
ll\
Oll\
ll\
O\
l\
O\
l
)
)
{
llllOlO\
l\
Oll\

=
tr\
u\
e\

;
TA\
_\
A\
SSER\
T
(
ll\
O\
llllOl\
Ol
.
GetCollision\
Obj\
ect\
A
(
)
)
;
}
}
retu\
r\
n
ll\
llOlOlO\
l\
l
;
}
Col\
lis\
ionObject\
Combo
*
TAC_CALL
Collis\
ionObje\
ct\
Comb\
o
::
Crea\
teNew\

(
)
{
Co\
ll\
is\
ionOb\
ject\
Com\
bo\

*
lOl\
Oll\
OO\
l\
ll\

;
lOOOO\
OllOOO
(
lOl\
Oll\
OOl\
l\
l\

,
Coll\
isionObje\
c\
t\
Combo
)
;
ret\
urn\

lO\
l\
OllOOlll
;
}
Collis\
ionOb\
je\
ct\
Comb\
o
::
CollisionObjectCo\
mbo
(
)
:
Col\
lis\
ion\
O\
bj\
ect
(
TYP\
E_COMBO
)
{
ll\
l\
lO\
lO\
OOO\
O
.
In\
itiali\
se\

(
k_v3Ze\
ro
,
k_v3Z\
e\
ro
)
;
lOlOOlOllO
=
0
;
}
Colli\
s\
i\
o\
nObj\
ectC\
ombo
::
~
Col\
lis\
ionObjectComb\
o
(
)
{
Fina\
lise
(
)
;
}
voi\
d
Collisi\
onOb\
jec\
tCombo
::
llllOlO\
l\
lOl\

(
)
{
if\

(
lOl\
OOlO\
llO\

->
llllOOOlOOO
.
lO\
O\
Ol\
ll\
OO\
l
(
)
>
0
)
{
ll\
ll\
OlOOOOO
=
lOlO\
Ol\
Oll\
O
->
lll\
lOOOlOOO\

[
0
]
->
Ca\
lc\
u\
lateBoundi\
ngBox
(
)
;
for\

(
in\
t\

lll\
l\
OlOllOO
=
1
;
llllOlOllO\
O\

<
lO\
l\
OO\
lOl\
lO
->
llllOOOlOOO
.
lOOOl\
llOOl\

(
)
;
ll\
llOlOllOO
++
)
{
llllO\
lO\
O\
OO\
O
+=
lOlOOl\
Ol\
lO
->
ll\
ll\
OOO\
lOOO
[
ll\
llOlOllOO
]
->
CalculateBo\
undi\
ngBox
(
)
;
}
lll\
lO\
lOOO\
OO
.
v3Ex\
tent\

.
x
+=
llOOl\
l\
O\
OOOO
;
lll\
lOlOOOOO\

.
v3Exten\
t\

.
y
+=
ll\
OOl\
lOO\
O\
O\
O
;
llllOlO\
OOOO
.
v3\
Extent
.
z
+=
llO\
O\
llOO\
O\
O\
O
;
}
else
{
ll\
llO\
lO\
OOOO
.
v3C\
enter
.
Clea\
r
(
)
;
llllOlOOOOO
.
v3Ext\
ent\

.
Cl\
ear
(
)
;
}
}
#ifndef DOXYGEN
void
TAC_CALL
llllOl\
l\
OOll
(
llllOllOlOO
&
llllO\
llOl\
Ol
,
Col\
li\
sion\
Obj\
ect
&
ll\
lO\
llOllO\
O
,
const
MFrame\

&
lOllOll\
ll\
ll
,
const\

MFram\
e\

&
lOlllO\
O\
OOOO\

,
CollisionObje\
ct\

&
ll\
lOllO\
ll\
Ol
,
llll\
OllOllO\

*
llllO\
ll\
Olll\

,
lOl\
lOllOlOO
ll\
lOOO\
O\
Olll
,
void
*
lllO\
l\
lOl\
OlO
)
{
if\

(
lllOllOl\
lOO\

.
Get\
Collis\
i\
onObjectType
(
)
==
Colli\
sion\
O\
b\
ject
::
TYPE_\
CO\
MBO
)
{
if
(
lll\
OllO\
l\
lOl
.
Ge\
tC\
ollis\
i\
onObject\
Type
(
)
==
CollisionObj\
e\
ct\

::
TYPE_COMBO
)
{
llll\
OllOOll
(
llllOllOl\
Ol
,
*
(
Collisi\
onObj\
ect\
Co\
m\
bo
*
)
&
lllOl\
lOllO\
O\

,
lOllO\
llllll
,
lOl\
l\
lOOO\
OO\
O
,
*
(
Collisi\
on\
Objec\
tC\
om\
bo\

*
)
&
ll\
lOllO\
llO\
l
,
llllOllOl\
l\
l
,
lllOOO\
OOlll
,
lll\
OllO\
lO\
lO\

)
;
}
else
if
(
lllOllOl\
lOl
.
GetCol\
lisio\
nOb\
jectType
(
)
==
Co\
llis\
i\
o\
nObje\
ct\

::
TY\
PE\
_COMPLE\
X\

)
{
ll\
llOllOOll
(
llll\
O\
llOlOl
,
*
(
Col\
l\
isionObj\
ectCombo\

*
)
&
lllOll\
Ol\
lO\
O
,
lO\
l\
lOl\
lllll
,
lOl\
ll\
OOO\
O\
OO
,
*
(
Coll\
isionObjec\
tC\
om\
plex
*
)
&
lllOllOl\
lOl
,
lll\
OOOO\
Olll
,
lllOll\
OlOl\
O\

,
0
,
false
)
;
}
el\
se
{
ll\
lOOOll\
ll
(
0
)
;
}
}
el\
se
{
if
(
lllO\
llOll\
Ol
.
GetColli\
si\
on\
Obj\
ec\
t\
Type
(
)
==
Colli\
sio\
n\
Obj\
ect
::
TY\
PE_COM\
BO
)
{
llllOl\
lO\
O\
ll
(
llllO\
llOlOl
,
*
(
Co\
l\
lis\
ionO\
bjectCom\
b\
o
*
)
&
lll\
Ol\
lOll\
O\
l
,
lOll\
Olll\
l\
ll\

.
Ge\
tInverse
(
)
,
lOl\
llOO\
OOOO
.
Get\
Inve\
rse\

(
)
,
*
(
Colli\
si\
onOb\
je\
c\
tComplex
*
)
&
ll\
l\
OllOll\
O\
O
,
ll\
l\
O\
OOOOll\
l\

,
ll\
lOll\
OlO\
lO\

,
0
,
true
)
;
}
else
{
lllOOO\
l\
l\
l\
l
(
0
)
;
}
}
}
voi\
d
TAC_\
CA\
LL\

llllO\
llO\
Oll
(
llll\
Oll\
Ol\
OO\

&
lll\
lO\
llOlOl
,
CollisionObjectC\
omb\
o
&
ll\
lOl\
lOll\
O\
O\

,
con\
st
MF\
ra\
m\
e\

&
lOll\
Oll\
ll\
l\
l
,
const
MF\
r\
am\
e
&
lOlllOOOO\
OO
,
Coll\
i\
sionObje\
ctComb\
o
&
lllOllOllO\
l
,
lll\
lOllOllO
*
llllO\
l\
lOll\
l
,
lOll\
OllOlOO
ll\
lOO\
OO\
Olll
,
void
*
lllOll\
OlOlO
)
{
TA_A\
SSE\
RT
(
lll\
O\
llOll\
O\
O\

.
lOlOOl\
OllO
)
;
TA\
_ASS\
E\
R\
T
(
lllO\
llOllOl
.
lOlOOlO\
l\
lO
)
;
int
llllOlllOO\
O\

;
in\
t\

ll\
llOlllOOl
;
bo\
ol
lOllOlllOOl
=
fal\
s\
e
;
con\
st
floa\
t
lll\
l\
OlllO\
l\
O
=
0.02f
;
co\
nst
fl\
oat\

llllOll\
l\
Oll
=
0.95f
;
co\
nst
flo\
a\
t
lll\
lOllllOO\

=
ll\
ll\
Olll\
O\
l\
O\

*
ll\
ll\
Oll\
lOlO\

;
if
(
(
lOllOll\
l\
lll\

.
v3T\
ra\
nslatio\
n
-
lOlllOOO\
OOO\

.
v3Tr\
ans\
lation
)
.
Ge\
tMag\
nitude\
Sqrd
(
)
>
ll\
llO\
l\
lllOO\

*
ll\
O\
OllOOOO\
l
*
llOOllOOOO\
l
||
lOl\
lOl\
lllll
.
m33Rotation\

.
v3X
.
Dot\

(
lOlllOO\
OOOO
.
m3\
3R\
ota\
tion
.
v3\
X\

)
<
llllOll\
l\
Oll
||
lOll\
Ollll\
ll
.
m33R\
otati\
on
.
v3Y
.
Dot
(
lOlllOOOOOO
.
m33Rotati\
on
.
v3Y
)
<
llll\
OlllO\
l\
l
||
lOllOlll\
lll\

.
m33R\
o\
tat\
io\
n
.
v3Z\

.
Dot
(
lOl\
l\
lOOO\
OOO
.
m33Rotation
.
v3Z
)
<
ll\
llO\
l\
llO\
ll
)
{
lOllOl\
llOOl
=
tr\
ue
;
}
#ifdef llllOllllOl
ll\
ll\
O\
lllllO
llllOlll\
lll
;
if
(
ll\
llO\
l\
lOlll
)
ll\
llOllllll
=
ll\
llOl\
lOlll\

->
lllllOOO\
O\
O\
O
.
lOlOOOO\
lO\
O
(
)
;
#endif //
lO\
llOllO\
l\
lO
lllllO\
OOOO\
l
;
ll\
l\
llOO\
OO\
O\
l\

.
lO\
llOll\
l\
Oll
=
0
;
lll\
llO\
OOOOl\

.
lOl\
lOllOl\
ll
=
lll\
O\
OO\
OOlll
;
llll\
lOO\
OO\
O\
l
.
lOll\
Oll\
lOOO
=
lll\
O\
l\
lOlO\
lO
;
llll\
lOOO\
OOl
.
lOllO\
lllOOl
=
lOl\
lOlllO\
Ol\

;
lllllO\
OOO\
O\
l\

.
lOl\
lO\
lllOlO\

=
fa\
lse
;
for
(
ll\
llOlllOOO
=
0
;
lll\
lOlllOOO\

<
lll\
Ol\
lOllOO
.
lOlOOlOl\
lO\

->
lll\
l\
O\
OO\
l\
O\
OO
.
lO\
OOlllO\
Ol
(
)
;
llllOlllOOO
++
)
{
lllllO\
O\
O\
OOl
.
lO\
l\
lO\
O\
Ol\
lOl
=
lll\
O\
llO\
llOO
.
lOl\
OO\
lOllO\

->
llllO\
OOlOOO
[
ll\
l\
lOll\
l\
O\
OO
]
;
TA_ASSE\
RT
(
ll\
lllOOO\
O\
Ol
.
lOllOOO\
l\
lOl
)
;
for
(
ll\
llOlllOOl\

=
0
;
llllOlllO\
O\
l
<
lll\
Oll\
Oll\
O\
l
.
lO\
lOO\
lO\
llO
->
llllOO\
OlO\
OO
.
lOOOll\
l\
O\
Ol\

(
)
;
llllOl\
llOOl\

++
)
{
llll\
l\
OOOOOl
.
lOllOOOll\
lO
=
lllOll\
Ol\
lOl
.
lOlOO\
l\
Oll\
O
->
lll\
lO\
OOl\
OOO\

[
ll\
ll\
Oll\
lOOl
]
;
TA\
_ASS\
ERT
(
ll\
lllOOOOOl
.
lOllOOOlllO
)
;
int
llll\
lOO\
OOl\
O\

=
(
lllllOO\
OOOl
.
lOllOOO\
llO\
l\

->
Ge\
tCollision\
Obje\
c\
tT\
ype
(
)
*
ll\
llO\
OOl\
OOl
)
+
lllllOOO\
OO\
l\

.
lOllOO\
OlllO
->
GetCo\
ll\
is\
ionObj\
e\
c\
tType
(
)
;
lllO\
O\
O\
lll\
l
(
lllll\
O\
OOOlO\

>=
0
)
;
lll\
OOO\
l\
l\
l\
l
(
llll\
lOO\
OOlO
<
lll\
lOOO\
lOlO
)
;
if\

(
lll\
l\
OOlO\
OOl
[
lll\
llOOOO\
l\
O
]
.
ll\
llO\
O\
OllO\
l\

)
{
llll\
l\
O\
O\
O\
O\
Ol
.
lOll\
Ol\
llOl\
l\

=
0
;
if
(
ll\
llO\
OlOOOl
[
lllllO\
O\
OOlO
]
.
lOlOllOO\
Ol
&
lll\
lOOlOOOO
)
{
lllll\
OO\
O\
OOl
.
lO\
llOll\
llO\
O
=
lOllOlll\
l\
ll
;
llll\
l\
OOOOOl
.
lOll\
OlllOl\
O
=
true
;
Swap\

(
llll\
lOOOOO\
l
.
lOll\
O\
O\
O\
llO\
l\

,
ll\
ll\
lOOOOOl
.
lOll\
OOOlll\
O
)
;
llllOO\
lOOO\
l
[
lllllOOOOlO
]
.
llllO\
OO\
l\
lOl
(
lOll\
Ollll\
ll
.
GetInv\
e\
rse
(
)
,
lOl\
llOOOOOO\

.
Ge\
tInvers\
e\

(
)
,
&
ll\
lllOOOO\
Ol\

)
;
Swap
(
ll\
lll\
OO\
OOOl\

.
lOl\
l\
OOOllO\
l\

,
lll\
llOOO\
O\
Ol
.
lOllOOO\
lllO\

)
;
ll\
lll\
O\
OOOOl\

.
lOllO\
lll\
O\
lO
=
fa\
ls\
e
;
}
els\
e
{
TA_ASS\
ERT
(
!
ll\
lll\
OOOO\
Ol
.
lO\
llO\
lllO\
lO
)
;
ll\
llOOlOOO\
l
[
lllll\
OOOOlO
]
.
lll\
lOOOll\
Ol\

(
lO\
ll\
Oll\
l\
ll\
l
,
lO\
lllOO\
OOOO
,
&
llll\
l\
OOOO\
Ol
)
;
}
}
}
}
}
void\

TAC_CAL\
L
llll\
O\
llOOl\
l\

(
ll\
llOllOlOO
&
lll\
lOll\
Ol\
O\
l
,
Co\
llisionObjectCo\
mbo
&
ll\
l\
ll\
O\
O\
OOl\
l
,
co\
nst
MFra\
me
&
lOll\
Ollllll
,
const
MF\
rame
&
lOlllO\
OO\
OOO
,
Collis\
io\
nObjectComplex
&
ll\
lllOO\
OlOO
,
lOllOll\
OlOO
lll\
OOOOOlll
,
void\

*
lll\
OllOlOl\
O
,
void
*
ll\
Ollll\
llOO
,
bo\
ol
lOllO\
l\
llOlO
)
{
TA_ASSER\
T
(
lllll\
O\
O\
OOl\
l
.
lOlOOl\
OllO
)
;
Colli\
sio\
nO\
b\
jectC\
ac\
h\
edPolyData
&
llOllllO\
lll
=
llllOllO\
lOl
.
Ge\
tPhy\
s\
ics
(
)
.
lllllO\
OOl\
Ol
(
)
;
AA\
BB
lOO\
OOOOll\
l\

;
bool
lOl\
l\
Oll\
lO\
Ol\

=
false
;
con\
st
float
llll\
O\
lll\
OlO
=
0.02f
;
const
floa\
t
ll\
ll\
Oll\
l\
Ol\
l
=
0.95f
;
const
float
llllOllll\
O\
O\

=
llllOll\
lOl\
O
*
ll\
l\
lOlllOl\
O
;
if
(
(
lOllO\
ll\
llll\

.
v3Tra\
nsl\
a\
tion\

-
lOll\
lOOO\
OOO
.
v3\
Trans\
lation\

)
.
Get\
M\
a\
g\
n\
itudeSqrd
(
)
>
lll\
lO\
llllOO
*
llOO\
l\
l\
O\
OO\
O\
l\

*
llOOllOOOOl
||
lOl\
lO\
ll\
llll
.
m33Rota\
ti\
on
.
v3X
.
Do\
t\

(
lOlllOOOOO\
O
.
m33Rotati\
on\

.
v3X
)
<
ll\
l\
lOlllO\
ll\

||
lOllOl\
l\
ll\
l\
l\

.
m33\
R\
otation
.
v3\
Y
.
Dot
(
lOlll\
OOO\
OOO
.
m33Rota\
t\
ion
.
v3Y
)
<
ll\
llOlllOl\
l
||
lOll\
Ollllll
.
m33Rota\
ti\
on
.
v3Z
.
Dot\

(
lOl\
llOOOOOO\

.
m33R\
o\
ta\
t\
io\
n
.
v3Z
)
<
llll\
O\
lll\
O\
l\
l\

)
{
lO\
llOl\
llOO\
l
=
true
;
lOO\
OO\
OO\
lll
=
llll\
l\
OOOOl\
l
.
ll\
l\
lO\
lOOOOO\

*
lOllO\
llllll\

+
lll\
llOO\
O\
O\
ll
.
llllOl\
OOOOO
*
lOlllOOO\
OOO
;
}
else
{
lOO\
O\
OOO\
lll
=
ll\
ll\
lO\
O\
OOl\
l\

.
lll\
lOlOO\
OOO
*
lOllO\
lll\
lll
;
}
ll\
l\
ll\
OOOl\
OO
.
Cac\
hedL\
o\
calPol\
y\
gons
(
llOllllOll\
l
,
lO\
OOO\
OOlll
,
ll\
Ollllll\
OO
)
;
if
(
llOlll\
lOl\
ll\

.
lllOlOOlOOO\

(
)
==
0
)
re\
turn
;
lO\
llOllO\
l\
lO
llll\
lOOOO\
O\
l
;
lllllO\
OOOOl\

.
lO\
llOll\
lO\
ll
=
0
;
lll\
ll\
OOOO\
O\
l
.
lO\
l\
l\
O\
llOl\
ll
=
lll\
OOOOO\
lll
;
lllllOOOO\
Ol
.
lOllOll\
lOOO
=
lll\
O\
l\
lOl\
Ol\
O\

;
lll\
l\
lO\
OOO\
O\
l
.
lOllOl\
ll\
OO\
l
=
lO\
ll\
OlllOO\
l
;
ll\
lllOO\
OOOl\

.
lO\
l\
l\
OOO\
lllO
=
&
ll\
Ol\
ll\
lOlll
;
llO\
ll\
ll\
Ol\
ll
.
ll\
l\
OlOOlOlO
(
&
lllllOOOlOO
)
;
llll\
l\
OOOOOl
.
lOllOlllOlO
=
lOl\
lO\
lllO\
lO\

;
if
(
lO\
llOll\
lOl\
O
)
ll\
l\
l\
l\
O\
O\
OOOl
.
lOl\
l\
Oll\
llOO
=
lOllOl\
ll\
l\
ll\

.
GetIn\
verse
(
)
;
for
(
in\
t
ll\
l\
lOlOllOO
=
0
;
lll\
lOlOl\
lOO
<
llll\
lOOOO\
ll
.
lOlOO\
lOllO\

->
llllO\
OO\
lO\
OO\

.
lO\
OO\
lllOO\
l
(
)
;
ll\
ll\
O\
lO\
l\
lOO
++
)
{
ll\
l\
llOO\
OOOl
.
lOllO\
OOl\
lOl
=
lllllO\
OOOll
.
lOlOOlOllO\

->
llllOOOlOOO
[
llllOlO\
l\
lO\
O
]
;
int\

lll\
llOOOOlO\

=
lllll\
O\
OOO\
O\
l
.
lOllOOO\
l\
lOl
->
GetCol\
lis\
ionO\
b\
jectTy\
p\
e\

(
)
;
ll\
lOOO\
lll\
l
(
lllllOOOOlO
>=
0
)
;
ll\
lOOO\
l\
lll\

(
lll\
ll\
OOO\
OlO
<
ll\
llOOOlOl\
O
)
;
if\

(
llllO\
O\
l\
llOO
[
ll\
lllOOO\
OlO\

]
)
llllOOll\
lOO\

[
lllllOOO\
OlO\

]
(
lOll\
Ollllll
,
lOlll\
OOOOOO
,
&
ll\
l\
llO\
O\
OOO\
l\

)
;
}
llllOl\
l\
O\
lO\
l
.
Get\
Physi\
c\
s\

(
)
.
lllllO\
OOlOl
(
)
.
Clear
(
)
;
}
#endif //
}
