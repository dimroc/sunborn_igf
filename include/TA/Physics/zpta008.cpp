//---------------------------------------------------------------------------------
// File Name: zpta008.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#define llOllOlOOOl
#define lOllOllOOOO
#include "CollisionObjectCapsule.h"
#ifndef TA_MFRAME_H
#include "../Common/MFrame.h"
#endif //
#ifndef TA_GEOMETRY_H
#include "../Common/Geometry.h"
#endif //
#ifndef llOllOOOllO
#include "../Physics/zpta013.h"
#endif //
#ifndef TA_COLLISIONOBJECTSPHERE_H
#include "CollisionObjectSphere.h"
#endif //
#ifndef TA_COLLISIONOBJECTLINELIST_H
#include "CollisionObjectLineList.h"
#endif //
#ifndef TA_COLLISIONOBJECTCACHEDPOLYDATA_H
#include "CollisionObjectCachedPolyData.h"
#endif //
#ifndef TA_PHYSICSRENDER_H
#include "PhysicsRender.h"
#endif //
#ifndef TA_COLLISION_H
#include "Collision.h"
#endif //
#ifndef lllOOOlOllO
#include "../Physics/zpta007.h"
#endif //
na\
m\
e\
s\
p\
ace\

TA
{
void
CollisionObjec\
tCap\
s\
ule
::
Ini\
tia\
li\
s\
e
(
const
Vec\
3
&
lllO\
l\
OOlllO\

,
const
Ve\
c\
3\

&
lllOlO\
Ollll
,
float
ll\
ll\
O\
l\
llll
)
{
ll\
lO\
lOl\
O\
OOO
=
lll\
Ol\
O\
OlllO
;
ll\
lOlOl\
OOOl\

=
lllOlOOllll\

;
lOl\
Ol\
OOlOOO
=
lll\
lO\
lllll\

;
lO\
OOOOOll\
O\

(
ll\
llOlll\
ll\

>=
0.0f
,
"CollisionObjectCapsule::Initialise. fRadius is < 0.")
;
lOO\
OOOO\
llO
(
(
ll\
lOlOlOOOl
-
lllOl\
Ol\
OOOO
)
.
GetM\
a\
gni\
tud\
e
(
)
>
k_\
fMinF\
l\
o\
a\
t
,
"CollisionObjectCapsule::Initialise. The capsule length is equal to zero")
;
}
void
Co\
llision\
Obj\
e\
ctCa\
psul\
e
::
Fina\
lis\
e
(
)
{
lll\
Ol\
O\
lO\
OOO
.
Clear
(
)
;
lllOlOlOOO\
l
.
Clea\
r
(
)
;
lOlOlOOlOO\
O
=
0.0f
;
}
vo\
i\
d\

Co\
l\
lision\
Ob\
j\
ec\
tCa\
psul\
e
::
Serial\
is\
e
(
Seria\
li\
ser\

&
lOOO\
lOl\
l\
Ol\

,
const\

Ve\
rsi\
on\

&
lllO\
lOO\
O\
lO\

)
{
lOOOO\
O\
Ol\
lO\

(
lll\
OlOO\
O\
l\
O
<=
llOllOOlOl\
O
,
"CollisionObjectCapsule::Serialise. The version number is too new.")
;
lOOO\
lOllOl
.
Serialise
(
lllO\
l\
Ol\
OO\
OO
)
;
lOOOlO\
ll\
Ol
.
Ser\
ialise
(
lllOlOlOO\
O\
l
)
;
lOOOlOllO\
l\

.
Seri\
al\
ise
(
lO\
lOlO\
Ol\
OOO
)
;
}
voi\
d
Coll\
isionObje\
ctCa\
p\
sule
::
Rende\
r
(
const
MFr\
ame
&
lOOOOOOOO\
l
)
{
const
in\
t
lllOlO\
lOO\
lO
=
6
;
const
int\

lll\
O\
lOlOOll
=
4
;
Ma\
t33\

lll\
Ol\
Ol\
OlOO\

;
ll\
lOlOlO\
l\
O\
O
.
Set\
ToLookDownV\
ect\
or\

(
(
lllO\
lO\
l\
OOOl
-
lllOlOlOOOO\

)
.
GetNo\
r\
ma\
l
(
)
)
;
for
(
int
lll\
Ol\
OlOl\
O\
l
=
0
;
lllO\
l\
OlOlOl\

<
lllO\
lOlOO\
l\
O
;
lll\
OlOlO\
lOl
++
)
{
float
lOO\
O\
O\
llOOOl\

;
flo\
at
lOO\
O\
OllOOlO
;
Sin\
AndCos
(
(
float
)
lllOlOlOlOl
/
(
fl\
oa\
t
)
ll\
lOlOlO\
OlO
*
(
k_fPi
*
2.0f
)
,
lOOOOllOOOl
,
lOOOOllOOlO
)
;
Ve\
c3\

ll\
lOlO\
lOllO\

=
(
lllOlOlO\
l\
O\
O
.
v3\
X
*
lOOOO\
ll\
OOlO
+
lllOl\
Ol\
OlOO\

.
v3Y
*
lOOO\
Ol\
lOOO\
l
)
;
SinA\
ndC\
os
(
(
fl\
o\
a\
t
)
(
lllO\
lOlOlOl\

+
1
)
/
(
float\

)
lll\
OlO\
lOOlO
*
(
k_fPi
*
2.0f
)
,
lOOO\
Ol\
lOOOl
,
lOOOO\
llOOl\
O
)
;
Ve\
c3
lllOlOlO\
l\
ll
=
(
lll\
OlOl\
OlOO\

.
v3X
*
lOOO\
OllOO\
l\
O
+
lll\
O\
lOlOlOO
.
v3Y
*
lOO\
O\
O\
llOOOl
)
;
{
cons\
t
Ve\
c3
lllO\
lOllOO\
O
[
4
]
=
{
(
ll\
lO\
lO\
lOOOO
+
lllO\
l\
OlOllO
*
lOlO\
lOOl\
OOO
)
*
lO\
O\
O\
OOOOOl\

,
(
lllOlOlOOOO\

+
ll\
l\
OlO\
l\
Olll
*
lOlOlO\
OlO\
OO
)
*
lO\
OO\
OOOOOl
,
(
ll\
l\
OlO\
lOOOl
+
lllOlOlOll\
l
*
lOlOlOO\
l\
OOO
)
*
lO\
OO\
OO\
O\
OO\
l
,
(
lllOlO\
l\
OOOl\

+
lllO\
lOlOl\
l\
O\

*
lOlOlO\
O\
l\
O\
O\
O
)
*
lO\
OO\
O\
O\
OOO\
l
,
}
;
co\
nst
Vec\
3
ll\
lO\
lO\
llOOl
[
4
]
=
{
lll\
O\
lOl\
Oll\
O
*
lOOOO\
OOOO\
l
.
m33\
Ro\
tation\

,
lllO\
lO\
lO\
lll\

*
lOO\
OOO\
O\
OO\
l
.
m33Rot\
ati\
o\
n
,
lllOlOlOl\
ll
*
lOOOOOOOO\
l
.
m3\
3Rotation
,
lll\
OlOl\
O\
llO
*
lO\
OOO\
OOOOl
.
m33Rot\
ation\

,
}
;
Phys\
i\
csRender
::
Re\
nde\
rPoly\
gon
(
4
,
lll\
Ol\
OllOO\
O
,
lllOlOllOOl
)
;
}
for
(
int
lll\
OlO\
llOl\
O
=
0
;
lll\
OlOllO\
lO\

<
ll\
l\
O\
lOlOOll
;
lllO\
l\
O\
llOlO\

++
)
{
SinAnd\
Cos
(
(
floa\
t
)
ll\
lOlOllOlO
/
(
float
)
lll\
OlOlOO\
ll\

*
(
k_f\
Pi\

)
,
lOOOOll\
O\
OOl
,
lOOO\
OllO\
O\
l\
O
)
;
Ve\
c3
lll\
OlO\
ll\
Oll
=
lllO\
lOl\
Ol\
lO
*
lOOOOllOOlO
+
lllOl\
OlOlOO\

.
v3\
Z
*
lOO\
O\
OllOOOl
;
Vec\
3\

lllOl\
O\
ll\
lO\
O
=
ll\
lOlOl\
Olll
*
lO\
OOOllOOlO
+
lllO\
lO\
l\
OlOO
.
v3Z
*
lO\
O\
OOllO\
OOl\

;
SinAndCos
(
(
float
)
(
lll\
OlOl\
lOl\
O
+
1
)
/
(
float
)
lllOlOl\
OOll
*
(
k_f\
P\
i
)
,
lOOOO\
llOOO\
l
,
lO\
O\
OOl\
lOOlO\

)
;
Vec\
3\

lllOlO\
lllOl
=
lllOlO\
lOllO
*
lOOO\
O\
llO\
OlO
+
ll\
lO\
l\
Ol\
OlO\
O
.
v3\
Z
*
lOOO\
Oll\
OOOl\

;
Vec3\

lllOlOllllO
=
lllOlOlOlll
*
lOO\
OOll\
OOlO
+
lll\
O\
lOlOlOO
.
v3Z
*
lOO\
OOllO\
O\
O\
l
;
{
const
Vec\
3\

lll\
O\
l\
OllO\
OO
[
4
]
=
{
(
ll\
lOlO\
l\
O\
OOO
-
lllOlOllOll
*
lOlOlO\
O\
l\
OO\
O\

)
*
lOO\
OOOOOOl
,
(
ll\
lOlO\
lOOOO
-
lllOl\
Ol\
llOl
*
lO\
lOlOOlOO\
O
)
*
lOOO\
OO\
O\
OOl\

,
(
lll\
Ol\
O\
l\
OO\
O\
O\

-
lll\
OlOl\
ll\
lO
*
lOl\
OlO\
OlOO\
O\

)
*
lO\
OO\
OOOOOl\

,
(
ll\
lOlOlO\
OOO\

-
ll\
lOlOl\
ll\
OO
*
lOlO\
l\
O\
Ol\
OOO
)
*
lO\
OOO\
O\
O\
OOl
,
}
;
con\
st
Vec3
ll\
lOlOllOOl
[
4
]
=
{
-
lllOlOllOl\
l
*
lOOOO\
OOOO\
l\

.
m33R\
o\
tati\
on
,
-
lllOlOlllOl
*
lOOOOOOOOl
.
m3\
3R\
otation
,
-
lllOlO\
l\
l\
llO\

*
lOOOOOOO\
O\
l\

.
m3\
3\
R\
ota\
ti\
on
,
-
ll\
l\
OlOlll\
OO
*
lOOOOOOOOl
.
m33R\
o\
tation
,
}
;
Physi\
csRend\
er
::
RenderP\
ol\
y\
gon
(
4
,
ll\
lO\
lO\
l\
lOOO
,
lll\
OlO\
ll\
O\
Ol
)
;
}
{
con\
s\
t
Vec3
lllOlOllOOO
[
4
]
=
{
(
lll\
O\
lOlOOOl
+
lllOlOllO\
ll
*
lOl\
OlOO\
l\
OOO\

)
*
lOO\
OOOOOOl
,
(
ll\
lOl\
OlOOOl
+
lll\
OlOl\
llOl
*
lOlO\
lOOl\
OOO
)
*
lO\
O\
OO\
OOOOl\

,
(
lllO\
lOlOOOl
+
lllOl\
OllllO
*
lO\
lOlOOlOOO
)
*
lO\
OO\
OOOOOl\

,
(
lllOlOlOO\
Ol
+
ll\
lOlOlllO\
O
*
lO\
lOlOOlOOO
)
*
lOOO\
O\
OO\
O\
O\
l
,
}
;
const
Vec3
lllOlOl\
lOOl
[
4
]
=
{
lll\
OlOllOl\
l
*
lO\
O\
OOOOOO\
l
.
m33Rota\
tion
,
lllOlOlllOl
*
lOOO\
OOO\
OOl
.
m3\
3Ro\
tat\
io\
n\

,
lll\
Ol\
O\
ll\
ll\
O
*
lOO\
OO\
OOOOl
.
m3\
3Rota\
tion
,
lll\
OlOlllOO
*
lOO\
OOOOOOl\

.
m33Rot\
a\
tio\
n
,
}
;
Phys\
ic\
sR\
en\
der
::
Re\
nd\
erP\
olygon
(
4
,
lllOlO\
l\
l\
OOO
,
lll\
OlOll\
OO\
l
)
;
}
}
}
}
AABB
Co\
llisi\
onOb\
jectC\
aps\
u\
l\
e
::
Calc\
ulateBo\
undin\
gB\
ox
(
)
const
{
AA\
BB
lOOOO\
O\
O\
ll\
l
;
lO\
OOOO\
Olll
.
Initia\
lise\
ToFit\
2P\
oints
(
lll\
OlOlOOOO\

,
lllOlOlOOO\
l
)
;
lOO\
OO\
OOlll\

.
v3Ex\
t\
e\
n\
t\

.
x
+=
lOlOlOOlO\
OO
;
lOO\
OOOOll\
l\

.
v3\
Extent
.
y
+=
lOlOlO\
Ol\
O\
OO
;
lO\
OOO\
OOl\
ll\

.
v3\
Exten\
t
.
z
+=
lOlOlO\
OlOO\
O\

;
return
lOO\
OOOO\
ll\
l
;
}
void
Co\
l\
lisionOb\
j\
e\
c\
tC\
aps\
ul\
e
::
Calcula\
teMass
(
fl\
o\
a\
t\

ll\
lO\
lO\
lllll\

,
floa\
t
&
lO\
l\
lO\
OOO\
lO\
O
,
Vec\
3\

&
ll\
lOllO\
OOOO
,
Ma\
t33
&
lllO\
llOO\
OOl
)
co\
ns\
t
{
fl\
o\
at
lO\
OlOl\
lOOO
=
(
lllO\
lOlOOOO
-
lllOl\
Ol\
OOO\
l\

)
.
GetM\
agn\
itude
(
)
;
fl\
oa\
t\

lllOl\
l\
O\
O\
OlO
=
lOO\
l\
Ol\
lOOO
*
k_f\
Pi
*
lO\
lO\
lOOlOOO\

*
lOlOlOOlOOO
*
ll\
l\
OlOl\
llll\

;
float
lllOll\
OOOll\

=
(
k_\
fPi
*
4.0f
/
3.0f
)
*
lOlO\
lO\
OlOOO
*
lO\
lO\
lOOl\
OO\
O\

*
lOlOlOOlOO\
O
*
lll\
OlOllll\
l
;
lO\
ll\
OO\
O\
Ol\
OO
=
ll\
lOllO\
OO\
ll
+
lll\
OllO\
OOlO
;
lllOllOOOOl
.
SetToId\
enti\
t\
y
(
)
;
lll\
OllO\
OOOl\

.
M11
(
)
=
lllO\
llOO\
OlO
*
(
0.25f
*
lOlO\
lOOlOOO\

*
lOlO\
lOO\
l\
OOO
+
(
1.0f
/
12.0f
)
*
lO\
O\
lOllOO\
O
*
lOOlO\
llOOO
)
;
lll\
Oll\
OOO\
Ol\

.
M22
(
)
=
lllOllOOOOl
.
M11\

(
)
;
lll\
OllOOO\
O\
l
.
M33
(
)
=
(
lllOllOOO\
lO
*
0.5f
+
ll\
l\
Ol\
lO\
OO\
ll
*
0.4f
)
*
lO\
lOlOOlO\
OO
*
lOlOlOOlOOO
;
Mat3\
3
lll\
O\
lOlOlOO
;
lllOl\
OlOlOO
.
Set\
ToL\
ookDownVecto\
r
(
(
lllOlOlOOO\
l
-
lllOlO\
lOOOO\

)
/
lOOlO\
l\
l\
OOO
)
;
Ma\
t33
lllO\
llOOlOO
;
lllOllO\
O\
O\
Ol
=
lllOlOlOl\
OO\

.
Ge\
tTr\
ansp\
o\
seAsInv\
e\
rs\
e\

(
)
*
lllOllOOOOl
*
ll\
lO\
lOlOlOO\

;
lllOllO\
OOO\
O\

=
(
lllOlO\
l\
OOOO\

+
lllOlOlOOOl
)
*
0.5f
;
}
bo\
ol
Col\
li\
s\
i\
onOb\
j\
ectCapsule
::
Tes\
tLin\
eFo\
rC\
o\
lli\
si\
on
(
const
Vec3\

&
lOO\
lOl\
Olll
,
const
Vec3
&
lOOOlOOOOO
,
flo\
at\

lO\
OlOllOO\
O
,
Col\
lisi\
on
&
llO\
llll\
OlO\
l\

)
con\
s\
t
{
Vec3
lO\
OlOl\
l\
OOl
=
lOOlOlOlll\

+
lOOOlOOO\
OO
*
lO\
OlOllO\
OO\

;
float\

lll\
lOlO\
OO\
l\

;
Vec3
lOl\
ll\
lOOOl\

;
Vec3
lO\
llllO\
Ol\
O
;
boo\
l
lll\
OllOOlOl
=
fal\
se
;
if
(
Geometry
::
TestP\
ointMove\
mentAgai\
nstS\
ph\
e\
r\
e
(
lOO\
lOlOlll
,
lOOlOl\
lOOl
,
lll\
O\
lOl\
OO\
O\
O
,
lO\
l\
O\
lO\
OlOOO\

,
ll\
llOlOO\
Ol
,
lOllllOOOl
,
lOl\
l\
llO\
OlO
)
)
{
if\

(
lOll\
l\
l\
OO\
lO
.
Do\
t\

(
lllOlO\
lOO\
Ol
-
ll\
l\
OlOlO\
OOO
)
<
0.001f
)
{
float
lOlO\
l\
lOlll\

=
lO\
OOlOO\
O\
OO
.
Dot
(
lOl\
lll\
O\
O\
Ol
-
lOOlO\
lOlll
)
;
if\

(
lOl\
Oll\
Olll
<
llOll\
l\
lOlOl
.
lOll\
OOl\
OOOl
)
{
Vec3
lllOl\
lOOllO
=
lOOlOlOll\
l\

+
lOl\
OllOl\
ll\

*
lOOOlOOOOO
;
llOl\
lllO\
l\
Ol
.
Initialise
(
0
,
0
,
lO\
lOllOlll
/
lOOlOllOO\
O\

,
lOlOllOll\
l
,
lOlll\
lOO\
Ol\

,
lOllllOO\
lO
)
;
llO\
llllOl\
Ol\

.
Set\
Co\
l\
l\
isi\
o\
nO\
bjectA
(
const_c\
a\
st
<
CollisionO\
bjectC\
aps\
ule
*
>
(
this
)
)
;
lllO\
llOOlOl
=
tr\
u\
e
;
}
}
}
if
(
Ge\
ometry\

::
TestPoint\
Movem\
en\
tAgai\
ns\
tSp\
here\

(
lOOlOlO\
lll\

,
lO\
OlOllO\
Ol\

,
lllOlOl\
OOO\
l
,
lOlOl\
OOlOOO
,
ll\
ll\
Ol\
OOOl
,
lOlll\
lOOOl
,
lOl\
lllOOlO
)
)
{
if
(
lOll\
l\
l\
OOlO
.
Dot
(
ll\
l\
OlOlOO\
OO\

-
lll\
O\
l\
OlOOOl\

)
<
0.001f
)
{
floa\
t
lOlO\
llOlll
=
lOOOlOOOOO
.
Dot
(
lOllllOOOl
-
lO\
OlOl\
Oll\
l
)
;
if
(
lOl\
O\
llOll\
l
<
ll\
Ollll\
OlOl
.
lOllOO\
lOO\
Ol
)
{
Vec3
ll\
l\
OllO\
Oll\
O
=
lO\
Ol\
Ol\
Olll\

+
lOlOl\
lO\
ll\
l
*
lOOOlO\
OO\
OO
;
ll\
O\
llllO\
l\
Ol
.
Initi\
alise
(
0
,
0
,
lOlO\
llOlll
/
lOO\
l\
O\
llOOO
,
lO\
lOllOlll\

,
lOll\
l\
lOOOl\

,
lOl\
lll\
OOlO
)
;
llOl\
lllOlOl
.
Se\
tColli\
sionO\
bj\
ectA
(
co\
nst_cast
<
Colli\
sionObjectC\
a\
psul\
e
*
>
(
this
)
)
;
ll\
lOllOOlOl
=
tru\
e\

;
}
}
}
if
(
Geo\
m\
et\
r\
y
::
Test\
Sphe\
r\
e\
Mov\
e\
ment\
Ag\
a\
instL\
ine
(
lOO\
lOl\
Oll\
l
,
lO\
Ol\
O\
llOOl
,
lllOl\
O\
l\
O\
OO\
O
,
lll\
OlOlOOOl\

,
lOlOlOOl\
OOO
,
lll\
lOlOOOl
,
lOll\
l\
l\
OOOl
,
lOl\
l\
llO\
OlO
)
)
{
lOl\
l\
l\
lO\
OO\
l
+=
lOlll\
lOOlO
*
lO\
lOlOOlOO\
O
;
float\

lOlOllOl\
ll
=
lOOOlOOOOO
.
Do\
t\

(
lO\
ll\
llO\
OO\
l
-
lO\
O\
l\
OlO\
l\
l\
l\

)
;
if
(
lOl\
Ol\
lOlll\

<
llO\
llllOl\
Ol\

.
lOl\
lOOlOOOl
)
{
llOllllOlOl
.
Ini\
tia\
lis\
e
(
0
,
0
,
lOlO\
ll\
Olll\

/
lOOlO\
llOOO
,
lOlO\
llOlll
,
lOlll\
lOOOl
,
lO\
llllO\
OlO
)
;
llOllllOlOl
.
Set\
Collisio\
nO\
b\
jectA
(
const_cast
<
Colli\
s\
ionObj\
e\
c\
tC\
a\
p\
s\
u\
le
*
>
(
this
)
)
;
lllOllOOl\
Ol
=
tru\
e\

;
}
}
return
lllOl\
lO\
OlOl\

;
}
Co\
ll\
isionObjectC\
a\
psule\

*
TA\
C\
_\
CALL
Collisi\
o\
nObje\
ctCa\
psu\
le
::
Cr\
eateNew\

(
)
{
Collisi\
on\
Obj\
ectCapsule\

*
lOlOl\
l\
OOlll
;
lO\
OO\
O\
Ol\
lOOO
(
lOlO\
llOOlll
,
Co\
ll\
isionObj\
ect\
C\
apsule
)
;
retu\
r\
n\

lO\
lOll\
OOl\
ll
;
}
Colli\
sio\
nObje\
ctCa\
p\
sule\

::
Co\
ll\
i\
s\
io\
nObje\
ctCapsu\
le
(
)
:
Coll\
ision\
Obj\
ect\
Sim\
ple
(
Colli\
si\
o\
nOb\
ject
::
TYP\
E_CAPS\
U\
LE
)
{
lll\
OlO\
lOOOO
.
Cl\
ea\
r
(
)
;
lllOlOl\
OOOl
.
Cl\
e\
ar
(
)
;
lOl\
OlOOlOO\
O\

=
0.0f
;
}
Co\
ll\
isionO\
bj\
ec\
tCapsule\

::
~
CollisionO\
b\
j\
e\
c\
tCap\
sul\
e
(
)
{
Fin\
a\
lise
(
)
;
}
static
inline
bo\
o\
l
TA\
C_CALL
ll\
lOl\
lOOlll
(
con\
st
Vec3
&
lllOlOOll\
lO
,
con\
st
Vec3
&
lll\
OlO\
Ol\
ll\
l
,
co\
n\
st\

Vec3
&
ll\
lO\
ll\
Ol\
OOO\

,
const
Ve\
c\
3
&
lll\
OllOlOO\
l
,
lOllO\
l\
lOlOO
ll\
lO\
OOO\
Oll\
l\

,
void
*
lllOll\
OlOlO
)
{
return
fa\
lse
;
}
#ifndef DOXYGEN
void
TAC_C\
AL\
L\

lll\
Ol\
l\
OlOl\
l
(
co\
nst
MFrame
&
lOll\
Ollll\
ll
,
con\
st\

MF\
rame
&
lO\
lllOO\
OOOO
,
lO\
llO\
llOllO\

*
lOll\
lOOO\
OOl\

)
{
TA\
_A\
SSE\
RT
(
lOlllOO\
OOO\
l
->
lOllOOOllOl
->
GetColli\
s\
ion\
ObjectType
(
)
==
Col\
l\
isi\
onOb\
ject
::
TYPE_C\
APSULE
)
;
con\
st
Coll\
isionObje\
c\
tC\
apsule\

&
lllOl\
lO\
llOO
=
*
(
co\
n\
st\

Col\
lisio\
nObj\
ectC\
aps\
u\
le\

*
)
lO\
lllOOOOOl\

->
lOl\
l\
OOOl\
lOl
;
TA_A\
SSER\
T
(
lOlll\
OOOOOl
->
lOllOO\
Oll\
lO
->
GetC\
o\
llisionO\
bjectT\
ype
(
)
==
Co\
ll\
isi\
on\
Obje\
ct
::
TYPE\
_CAPSU\
L\
E\

)
;
const
Co\
l\
li\
sionO\
bject\
C\
a\
psule
&
ll\
lOllOllO\
l
=
*
(
const\

Colli\
sion\
Objec\
tCap\
su\
l\
e
*
)
lO\
ll\
lOOOOO\
l
->
lOl\
lOOOlllO
;
cons\
t
float
lO\
llO\
lOlOl
=
0.0001f
;
Vec3\

lllOll\
Olll\
O
=
lllO\
l\
l\
O\
llO\
O
.
ll\
lOl\
OlOOO\
O\

*
lOllOlll\
l\
ll
;
Vec3\

lll\
Ol\
lOl\
l\
ll
=
ll\
l\
Ol\
lOllOO
.
lllOlO\
l\
OOO\
l
*
lO\
llO\
llllll
;
Vec3
lllOlll\
OOOO
=
lllOll\
OllOO
.
lllOlOlO\
OOO\

*
lO\
lllOOO\
OOO
;
Vec3
lllOlll\
O\
OOl
=
lllOll\
Ol\
l\
OO
.
lllOlOlOOO\
l\

*
lOlllOO\
OOOO
;
float
ll\
lOl\
llOOl\
O\

=
lllOllOllOO
.
lOlOlOOlOO\
O
+
lll\
OllOllOl
.
lO\
l\
OlOOlOOO
;
bool\

lllOlllOOl\
l
=
fa\
lse
;
if
(
lllOl\
ll\
OOl\
l
)
re\
tu\
r\
n
;
Vec3
lll\
Ol\
llO\
lOO\

;
Ve\
c3\

lllOlllOlOl
;
Geo\
metry
::
Fi\
ndC\
los\
estP\
ointOnL\
i\
n\
eToL\
ine\

(
lllOll\
O\
lllO\

,
lllOllO\
llll\

,
lllOllOl\
l\
Ol
.
lllOlOl\
O\
O\
OO
,
lll\
OllOllOl
.
lllOlOlOOOl
,
ll\
lOlllOlO\
O\

,
ll\
l\
Olll\
OlOl
)
;
Vec3
lOOOlOOOOO
=
lll\
OlllOlO\
O\

-
ll\
l\
Ol\
l\
lOlOl
;
float\

lllO\
OlOlO\
l\

=
lOOOlOOOOO
.
Get\
M\
ag\
ni\
tudeSqrd
(
)
;
if
(
lllOOlO\
lOl\

<
lllO\
lllOOl\
O
*
lllO\
lllOOlO
&&
lll\
OO\
lOlOl
>
lO\
llOlO\
lOl
)
{
float
lOllll\
OOll
=
Sqrt
(
lll\
O\
O\
l\
OlOl
)
;
lO\
O\
O\
l\
OOOOO
/=
lOll\
llOOll
;
Co\
llis\
ion
lO\
l\
lOllO\
l\
Ol
;
lOllO\
llOlOl
.
In\
iti\
al\
is\
e
(
Co\
llision\

::
lOl\
l\
OOll\
llO\

,
0.0f
,
lllOlllOOl\
O
-
lOll\
llOOl\
l
,
(
lllOlll\
Ol\
OO
+
lllO\
ll\
lOlO\
l
)
*
0.5f
,
lO\
O\
OlOOO\
O\
O\

)
;
if
(
!
lll\
OlllOll\
O
(
lOllO\
llOlO\
l
,
lO\
l\
l\
l\
OOOOOl
)
)
ret\
urn
;
}
el\
se
if
(
lOlllOOOOOl\

->
lOl\
lOlllOOl\

)
{
float
llll\
Ol\
OOOl
;
Vec3
lOlll\
lOOOl
;
Vec3
lO\
llllOOl\
O\

;
if\

(
Geometry
::
Tes\
tL\
ineMoveme\
n\
tAgai\
nstCapsu\
l\
e\

(
ll\
lOllOll\
lO\

,
lllOllO\
ll\
ll
,
lllOlll\
OOOl
,
ll\
lOllOllO\
O\

.
lll\
Ol\
OlOOOl\

*
lO\
lll\
OOOOOO\

,
lllOll\
OllO\
l
.
lllOlO\
lOOOO
,
lll\
Ol\
lOl\
l\
Ol\

.
lllOlOlOOOl
,
lllOl\
l\
lOOlO
,
llllOl\
OOOl\

,
lOllll\
OOOl
,
lOll\
l\
lOOl\
O
)
)
{
Co\
lli\
si\
on\

lOllOllOlO\
l
;
lOll\
OllOlOl
.
Init\
i\
al\
ise
(
Co\
lli\
sio\
n
::
lO\
ll\
OOllllO\

,
llllO\
lOOOl\

,
0.0f
,
lOl\
l\
llOOOl
,
-
lOl\
ll\
l\
O\
O\
lO
)
;
if\

(
!
lllO\
lllOllO
(
lOl\
l\
OllOl\
Ol\

,
lOlllOOOOO\
l
)
)
return
;
}
}
}
voi\
d\

TA\
C_C\
AL\
L
lllOll\
lOl\
ll
(
const
MFrame
&
lOl\
lOlll\
lll
,
co\
nst
MFra\
me
&
lOlllOO\
OO\
OO\

,
lOl\
lOllO\
ll\
O\

*
lO\
lllOO\
OOOl
)
{
TA_ASSERT
(
lOll\
lOO\
OO\
Ol
->
lOll\
O\
OOllOl
->
GetColli\
sionObjec\
tTy\
p\
e\

(
)
==
Co\
lli\
sionObject
::
TYPE_S\
PHE\
RE
)
;
const\

Co\
llis\
ionObjectSphe\
re
&
ll\
lOllllOOO\

=
*
(
cons\
t
Col\
l\
i\
sionObj\
ectS\
phere\

*
)
lO\
lllOOOOO\
l\

->
lO\
llOO\
O\
llOl
;
TA_ASSERT
(
lOlll\
O\
OO\
OOl\

->
lOllOOOlllO\

->
GetC\
ollisionObjectTy\
pe
(
)
==
Co\
lli\
si\
on\
Obj\
ect
::
TYPE_CA\
PSULE
)
;
cons\
t
Co\
llisi\
onObj\
ectC\
apsule
&
lOlll\
OlOOOO\

=
*
(
con\
st
Co\
llisio\
nOb\
jec\
t\
Capsule
*
)
lOlllO\
OOOOl
->
lOllO\
OOl\
llO
;
co\
n\
s\
t
flo\
at
lOllOl\
O\
lOl
=
0.0001f
;
Vec3
lll\
Ollll\
OOl\

=
lll\
Ol\
l\
l\
l\
OOO
.
lllO\
OO\
OlOl\
O\

*
lO\
llOl\
lllll
;
float
lllO\
ll\
lOOlO\

=
lOl\
l\
lO\
l\
OOO\
O
.
lOl\
OlOOlO\
O\
O\

+
lllO\
llllOO\
O\

.
lOl\
OlOO\
lOO\
O
;
Vec3
lOlll\
lOOOl
=
Geo\
metr\
y
::
FindCl\
oses\
tPo\
intO\
n\
L\
in\
e
(
lllO\
llllO\
O\
l\

,
lOl\
ll\
Ol\
O\
OO\
O
.
lllO\
lOlOOO\
O
,
lO\
lllOl\
OO\
O\
O
.
lll\
OlOlOO\
Ol
)
;
Vec3
lO\
OO\
lOOOO\
O\

=
lllOll\
l\
l\
O\
O\
l
-
lOll\
l\
lOOOl\

;
floa\
t
lllOOlOlOl\

=
lOOOlO\
OOOO\

.
Get\
Mag\
n\
it\
u\
d\
eSqrd
(
)
;
if\

(
lllOOlOl\
O\
l
<
lllO\
l\
l\
lOOl\
O
*
lllOlllOOlO\

&&
lllOOlO\
lOl
>
lOl\
l\
O\
lOlO\
l
)
{
lOOO\
lOOOOO\

/=
Sqrt
(
lll\
OOl\
OlOl
)
;
Co\
llisi\
on
lOllOll\
Ol\
Ol
;
lOllO\
llOl\
O\
l
.
In\
iti\
al\
ise\

(
Coll\
i\
sion\

::
lOllO\
O\
l\
l\
llO
,
0.0f
,
ll\
lOll\
lOO\
lO
-
Sq\
r\
t
(
lll\
OOl\
OlOl
)
,
(
lOl\
lllOO\
O\
l\

+
lllOll\
llOOl\

)
*
0.5f
,
lOOO\
lO\
OOOO\

)
;
ll\
lOlllO\
l\
lO
(
lOl\
lOllOlOl\

,
lOlllOO\
O\
OO\
l
)
;
ret\
urn
;
}
Ve\
c3
ll\
l\
Ol\
lllOlO
=
lll\
Ol\
lll\
O\
O\
O
.
ll\
lOO\
OOl\
Ol\
O
*
lOlllOOO\
O\
OO\

;
fl\
oat\

ll\
llO\
l\
OOOl\

=
0.0f
;
if
(
!
lOll\
lOO\
O\
OOl
->
lO\
l\
lOlll\
OOl
)
return
;
if
(
Geo\
m\
e\
t\
ry
::
TestPoi\
ntMove\
me\
nt\
A\
gains\
tSph\
ere\

(
lllO\
llllO\
Ol
,
lllOllllOl\
O
,
lOlllO\
l\
OOO\
O\

.
lllOl\
O\
lO\
OOO
,
lllO\
lll\
OO\
lO
,
lll\
lOlOOOl\

,
lOll\
ll\
OOOl\

,
lOO\
OlOO\
OOO
)
)
{
if
(
lOOOlOOOOO\

.
Dot
(
lOlll\
Ol\
OOOO
.
lllOlOlOOOO\

-
lOl\
l\
lOlO\
OOO\

.
lll\
O\
lO\
l\
O\
OOl
)
>
0.0f
)
{
lOllllOO\
Ol\

+=
lOOOlOOOOO
*
lOlllOlOOOO
.
lOlOlOOl\
OOO
;
Coll\
ision
lOllOllOl\
Ol\

;
lOl\
lOl\
lOlO\
l
.
Ini\
tialise
(
Co\
ll\
i\
sion
::
lOllO\
OllllO
,
llllOlO\
OOl
,
0.0f
,
lOllllOOOl\

,
lOO\
OlOOOO\
O
)
;
lllO\
lll\
OllO\

(
lOllO\
llOlO\
l
,
lOl\
llOOOOOl
)
;
ret\
urn
;
}
}
if
(
Geomet\
r\
y\

::
TestPointM\
ov\
emen\
tA\
gainstSph\
ere
(
ll\
lOllllOOl
,
lllOllll\
Ol\
O
,
lO\
lllOlOOOO
.
lllOl\
Ol\
OOO\
l
,
lll\
Ol\
llOOlO\

,
ll\
l\
lOlOOO\
l
,
lOll\
llOOOl
,
lOOOl\
OOOOO
)
)
{
if
(
lOO\
OlOOO\
OO
.
Dot
(
lOlll\
Ol\
OOOO
.
lll\
OlOlO\
OO\
l
-
lOlllOl\
O\
OOO
.
lllOlO\
l\
OO\
OO
)
>
0.0f
)
{
lOlll\
lOOOl\

+=
lOO\
OlOOOOO\

*
lOlllOlOOOO
.
lOlOlOOl\
OOO
;
Co\
lli\
sio\
n
lOllOllOlOl
;
lOl\
lOllOlO\
l
.
Ini\
tial\
ise
(
Coll\
i\
sio\
n
::
lOll\
OO\
llllO
,
llllOl\
OOOl
,
0.0f
,
lOlll\
l\
OOOl
,
lOOOlOOO\
O\
O
)
;
lllOlllOl\
lO
(
lO\
ll\
OllOlOl
,
lOl\
llOO\
OO\
O\
l
)
;
ret\
urn
;
}
}
if\

(
Geom\
etry\

::
Te\
st\
S\
phereM\
ov\
e\
mentA\
gainstLi\
ne
(
ll\
lOl\
lll\
OO\
l
,
ll\
lOl\
l\
llOlO
,
lO\
lll\
OlOOOO\

.
lll\
O\
lOlOOOO
,
lOll\
lOlOOOO
.
ll\
l\
O\
lOlO\
OOl\

,
lll\
OlllO\
OlO
,
llll\
OlOOOl\

,
lOllll\
O\
O\
Ol
,
lOO\
O\
l\
OOOOO
)
)
{
lO\
ll\
ll\
O\
OOl
+=
lO\
OOlOO\
O\
OO
*
lOlll\
OlOO\
OO
.
lOlOlO\
OlOO\
O\

;
Collis\
io\
n
lO\
llO\
l\
lO\
lO\
l\

;
lO\
l\
lO\
llOlOl
.
Init\
ia\
l\
ise
(
Co\
ll\
ision\

::
lOllOOl\
l\
llO
,
llllOl\
O\
O\
Ol
,
0.0f
,
lOll\
l\
l\
O\
OO\
l
,
lOOOlOOOOO\

)
;
lllO\
lll\
O\
l\
l\
O
(
lO\
l\
lOllOl\
O\
l
,
lOlllOOO\
OOl
)
;
re\
tu\
rn
;
}
}
vo\
id
TAC_C\
ALL
lllOll\
llOll
(
cons\
t\

MF\
r\
a\
me
&
lOllO\
lll\
lll
,
const
MFram\
e
&
lOlllOOOOOO\

,
lOllOl\
l\
OllO
*
lOlll\
O\
OO\
O\
Ol
)
{
lllO\
OllO\
OOO\

(
)
;
TA_\
A\
SSERT
(
lOlll\
OOOOOl
->
lO\
l\
l\
OOOl\
l\
Ol
->
GetCo\
llisionObjectType\

(
)
==
Col\
lision\
Ob\
j\
ec\
t
::
TYPE\
_CAPSULE
)
;
const
Co\
l\
li\
sionO\
b\
jectCap\
sule
&
lOll\
lO\
lOOOO
=
*
(
const\

Col\
lisionO\
b\
je\
c\
tCa\
psule
*
)
lOlllOOOOO\
l
->
lO\
l\
l\
OOOllO\
l
;
TA_AS\
SER\
T
(
lOl\
llOOO\
OO\
l\

->
lOll\
O\
O\
O\
l\
l\
lO
->
Ge\
t\
Co\
l\
l\
isi\
onObjec\
t\
T\
ype\

(
)
==
Co\
llisio\
nOb\
jec\
t
::
TY\
PE_CACHED\
_P\
OLY\
_DAT\
A\

)
;
const
Co\
llisio\
nOb\
jec\
tCach\
ed\
PolyD\
ata
&
llOllllO\
l\
ll
=
*
(
cons\
t
Co\
llisionOb\
ject\
Cache\
dPol\
yD\
a\
ta
*
)
lOl\
ll\
OO\
O\
OOl
->
lO\
llOOO\
lllO
;
Vec3
lO\
lllOOlllO\

[
2
]
;
lOl\
llOOll\
lO
[
0
]
=
lOl\
ll\
O\
lOO\
OO
.
lllOlOl\
OO\
OO
*
lOl\
lOllllll
;
lO\
lllO\
OlllO
[
1
]
=
lOl\
l\
lOlOO\
OO
.
lll\
O\
lOlOOOl
*
lOllO\
llllll
;
Vec\
3
lO\
l\
lllO\
OOOl\

[
2
]
;
lO\
llll\
OO\
OOl\

[
0
]
=
lOll\
lO\
lOOOO
.
lll\
OlOlOOOO\

*
lOlllOOO\
O\
OO
;
lOlll\
lOOOOl
[
1
]
=
lOlllO\
lOO\
OO\

.
ll\
lO\
lOlOOOl
*
lO\
lllOO\
O\
OOO
;
for
(
int
lllOlllllOO
=
0
;
ll\
lOlllllO\
O
<
llOll\
llO\
l\
ll
.
lllO\
l\
OOlO\
OO\

(
)
;
)
{
co\
nst
Co\
llis\
ionOb\
jec\
tCachedPol\
yData
::
Polyg\
on\

*
llO\
OOl\
OOlO
=
(
co\
nst
CollisionObje\
ctC\
a\
ch\
e\
d\
Po\
lyD\
a\
ta
::
Polygon
*
)
llO\
llllOlll
.
lllOlOOOlll
(
lllOlll\
l\
l\
OO
)
;
lll\
Ol\
l\
lllOO\

+=
llOllllOlll
.
lll\
OOlO\
llll\

(
llOOOl\
OO\
l\
O
->
lOllO\
l\
lOll
)
;
#define lOlllOlOOll(lOOOllOOOl) llOOOlOOlO->llOllllOOO[lOOOllOOOl].lOOOOlllll
#define lOllllOOOOO(lllOllllOO, lllOlllllOl, llOOOlOOlO, lOOOOlllll, lOOOlOOOOO)								\
{																											\
	Collision lOllOllOlOl;																				\
	lOllOllOlOl.Initialise(																				\
		Collision::lOllOOllllO,																				\
		lllOllllOO,																								\
		lllOlllllOl,																								\
		lOOOOlllll,																							\
		lOOOlOOOOO);																							\
	lOllOllOlOl.lOllOOlOOOO = llOOOlOOlO->llOlllOOllO;														\
	lllOOllOlOl(lOllOllOlOl, lOlllOOOOOl);							\
}
#define lOlllOllOll(lllOllllOO, lllOlllllOl, llOOOlOOlO, lllllllll, lOOOOOOOOO, lOOOOlllll, lOOOlOOOOO, lOllOlOlOOO) \
	lllOlOOOlOO(lllOllllOO, lllOlllllOl, llOOOlOOlO->llOlllOOllO, lllllllll, lOOOOOOOOO, lOOOOlllll, lOOOlOOOOO, lOllOlOlOOO)
#define lOlllOlllll(lllOllllOO, lllOlllllOl, llOOOlOOlO, lOlllOOlll, lllOOlllOOl, lllOOOllOlO, lOOOOlllll, lOOOlOOOOO) \
	lllOOlllOOO(lllOllllOO, lllOlllllOl, llOOOlOOlO, lOlllOOlll, lllOOlllOOl, lllOOOllOlO, lOOOOlllll, lOOOlOOOOO)
#define lOlllOllOOl(lllllllll, lOOOOOOOOO, lOllOlOlOOO) \
	lllOlOOOlOl(lllllllll, lOOOOOOOOO, lOllOlOlOOO)
#define lOlllOllllO(lllOOOllOlO) \
	lllOOlllllO(lllOOOllOlO, lllOOllllll)
#define lOlllOOllll(llOOllllOO) (llOOOlOOlO->lOOOlOOOOO.Dot((llOOllllOO) - llOOOlOOlO->llOllllOOO[0].lOOOOlllll))
const
bool
lO\
l\
ll\
lOOlll
=
false
;
#include "../Physics/zpta002.inl"
#undef lOlllOlOOll
#undef lOllllOOOOO
#undef lOlllOOllll
#undef lOlllOllOll
#undef lOlllOlllll
#undef lOlllOllOOl
#undef lOlllOllllO
}
lllOOll\
OOOl
(
lOll\
lO\
OOOO\
l
)
;
}
void
TAC\
_CAL\
L
lllOl\
ll\
lll\
O
(
cons\
t\

MFrame
&
lOllOl\
lll\
l\
l
,
co\
nst
MFr\
ame
&
lOlllO\
OOOO\
O
,
lOllOll\
OllO\

*
lOlllOOOOOl\

)
{
TA_ASS\
ERT\

(
lOll\
lOOO\
OOl
->
lOll\
O\
O\
OllOl
->
GetCollisionOb\
j\
e\
ctType
(
)
==
Collisio\
n\
Object
::
TY\
PE_CAPS\
ULE\

)
;
TA_ASSE\
RT
(
lOlllOO\
OOOl
->
lOllOOOl\
llO\

->
GetCol\
l\
isionObj\
ectType
(
)
==
CollisionO\
bjec\
t
::
TYP\
E_LINE_\
LI\
ST\

)
;
con\
s\
t
Collis\
i\
onOb\
je\
ctC\
apsule
&
lO\
ll\
lOl\
OOO\
O
=
*
(
Co\
lli\
s\
ionObje\
c\
t\
Capsule
*
)
lOlllOOO\
OOl
->
lOl\
lOOO\
ll\
O\
l
;
co\
nst
Co\
l\
lisionObje\
ctL\
in\
e\
L\
ist
&
lllOll\
lll\
ll
=
*
(
Co\
l\
l\
i\
s\
io\
n\
Objec\
tL\
ineLi\
s\
t
*
)
lO\
lll\
OOOO\
O\
l
->
lO\
l\
l\
O\
OOl\
llO
;
con\
s\
t
float
lOl\
lOlO\
lOl
=
0.0001f
;
Vec\
3
lll\
lllll\
l\

=
lOlllOlOO\
O\
O
.
lllOl\
OlOOO\
O
*
lOllOllllll
;
Ve\
c3
lOOOOO\
OOO\
O
=
lO\
l\
llOlOOOO
.
lll\
O\
l\
O\
lOOOl\

*
lOllOll\
ll\
ll
;
Ve\
c\
3\

llllOOOO\
O\
OO
=
lOOOO\
O\
OOO\
O
-
lllllllll
;
for
(
int\

lllO\
O\
OOOlO
=
0
;
lllOO\
O\
O\
OlO
<
lllOl\
l\
lll\
l\
l
.
llllOOOOO\
Ol
.
lOOO\
l\
l\
l\
OO\
l\

(
)
;
ll\
lOOOOOl\
O
++
)
{
float
lll\
lOl\
OOOl
;
Vec3\

lOl\
lllOOO\
l\

;
Ve\
c3
lOlll\
lOO\
lO
;
con\
st\

Vec3\

&
lOOl\
O\
l\
Oll\
l
=
lllOllllll\
l
.
llllOO\
OOOOl\

[
lll\
OOO\
OOlO\

]
.
lOOl\
OlO\
ll\
l
;
cons\
t
Vec3
&
lOO\
lOllOO\
l\

=
lllOll\
lll\
ll
.
llllOOO\
OOOl
[
ll\
lOOOO\
OlO
]
.
lOO\
l\
Oll\
OOl
;
if
(
Geo\
m\
e\
try
::
Te\
s\
tPoint\
M\
ovementAga\
inst\
Sp\
here
(
lOOlOlOlll
,
lOOlO\
ll\
OOl
,
lllllllll
,
lOl\
ll\
OlOO\
OO
.
lOl\
Ol\
OOlOO\
O
,
ll\
llOlO\
OOl
,
lO\
llllOOOl\

,
lOllllOOlO
)
)
{
if\

(
lOllllOOlO\

.
Do\
t
(
lOOOOO\
OOO\
O
-
lll\
ll\
l\
lll\

)
<
0.0f
)
{
Col\
li\
sio\
n
lOllOll\
OlOl
;
lOllO\
llOl\
Ol
.
In\
iti\
a\
l\
ise
(
Co\
ll\
i\
s\
ion
::
lO\
ll\
O\
lOOOlO
,
0.0f
,
llll\
OlOOOl
,
lOll\
llO\
O\
Ol
,
lO\
llllOOlO
)
;
lOll\
O\
l\
lOlOl\

.
lOllOOOll\
ll
=
lllOOO\
OOlO\

;
if
(
!
lOlll\
O\
OO\
OOl\

->
lOll\
O\
lllO\
lO
)
lO\
llOllOlO\
l
.
lO\
llOOlOOOO
=
0
;
el\
se
lOll\
O\
llOlOl\

.
lOl\
lOOlOOO\
O
=
1
;
if\

(
!
lll\
OlllOl\
lO
(
lOllOll\
OlOl
,
lOll\
lOOOO\
Ol\

)
)
return
;
con\
tinue
;
}
}
if\

(
Geometry\

::
Test\
Po\
int\
Mo\
ve\
men\
tAg\
ainst\
Sp\
he\
re
(
lO\
Ol\
OlOlll
,
lOOl\
O\
ll\
O\
Ol
,
lO\
OOOOOOO\
O\

,
lOlllOl\
OOO\
O
.
lO\
lO\
lO\
OlO\
OO
,
ll\
llOl\
OOOl
,
lOl\
lllO\
OOl
,
lOllllOOlO
)
)
{
if
(
lOll\
llOOlO
.
Dot
(
llllll\
lll
-
lOOO\
OO\
OOO\
O
)
<
0.0f
)
{
Collision
lOl\
lOll\
OlOl
;
lO\
l\
l\
OllO\
lOl
.
In\
itial\
ise
(
Col\
lision
::
lOllOlOO\
Ol\
O
,
0.0f
,
llll\
Ol\
OOOl
,
lOlll\
lOO\
O\
l
,
lOll\
l\
lOO\
lO
)
;
lOllO\
l\
lO\
l\
Ol
.
lOl\
lOOOllll
=
ll\
lOOOO\
OlO
;
if
(
!
lOlll\
OOO\
OOl
->
lOllOlllOlO\

)
lOll\
OllOlO\
l\

.
lO\
llO\
O\
lOOOO
=
0
;
el\
se\

lOl\
lOllOlOl
.
lOllOOl\
OOOO
=
1
;
if
(
!
lllO\
l\
l\
lO\
l\
lO
(
lO\
llOll\
OlOl
,
lOl\
ll\
OOOOO\
l\

)
)
retu\
rn
;
cont\
i\
nue
;
}
}
if\

(
Geome\
try
::
TestSphereMov\
e\
m\
ent\
Aga\
instL\
ine
(
lOO\
lOlOlll\

,
lOOlO\
llOO\
l
,
llll\
ll\
l\
ll
,
lOOOOO\
OOO\
O\

,
lO\
ll\
lOl\
OO\
O\
O
.
lO\
l\
O\
l\
O\
OlOOO
,
llllOlO\
O\
Ol\

,
lOllll\
OO\
O\
l
,
lOllllOO\
lO\

)
)
{
lOllllOOOl
+=
lO\
ll\
llOOlO\

*
lOlll\
Ol\
OOOO
.
lO\
lOlO\
Ol\
OOO
;
Collision
lOllOllO\
lOl\

;
lOl\
lOll\
OlOl\

.
In\
itia\
lise\

(
Co\
l\
l\
ision
::
lOllO\
l\
OO\
Ol\
O\

,
0.0f
,
llllOlO\
O\
Ol\

,
lOl\
lllOOOl
,
lOll\
l\
lO\
OlO
)
;
lOl\
lO\
ll\
O\
lOl
.
lOll\
OOOll\
ll
=
lllOO\
OOOlO
;
if
(
!
lO\
l\
llOOOO\
O\
l
->
lOllOlllO\
l\
O
)
lO\
ll\
OllOlOl\

.
lOllOOlOOOO
=
0
;
el\
se
lO\
l\
l\
OllOlOl
.
lOl\
lOOl\
OOOO
=
1
;
if
(
!
ll\
lOl\
llO\
llO
(
lOl\
lOllO\
lOl
,
lOll\
lOOOOOl\

)
)
re\
t\
urn
;
co\
nt\
inue
;
}
}
}
#endif //
}
