//---------------------------------------------------------------------------------
// File Name: zpta011.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#define llOllOlOOOl
#define lOllOllOOOO
#include "CollisionObjectConvex.h"
#ifndef lOOllOllll
#include "../Common/zcta001.h"
#endif //
#ifndef TA_MFRAME_H
#include "../Common/MFrame.h"
#endif //
#ifndef TA_GEOMETRY_H
#include "../Common/Geometry.h"
#endif //
#ifndef TA_CONVEXHULL_H
#include "../Common/ConvexHull.h"
#endif //
#ifndef llOllOOOllO
#include "../Physics/zpta013.h"
#endif //
#ifndef TA_COLLISION_H
#include "Collision.h"
#endif //
#ifndef lllOOOlOllO
#include "../Physics/zpta007.h"
#endif //
#ifndef TA_COLLISIONOBJECTCAPSULE_H
#include "CollisionObjectCapsule.h"
#endif //
#ifndef TA_COLLISIONOBJECTCYLINDER_H
#include "CollisionObjectCylinder.h"
#endif //
#ifndef TA_COLLISIONOBJECTSPHERE_H
#include "CollisionObjectSphere.h"
#endif //
#ifndef TA_COLLISIONOBJECTCACHEDPOLYDATA_H
#include "CollisionObjectCachedPolyData.h"
#endif //
#ifndef TA_COLLISIONOBJECTLINELIST_H
#include "CollisionObjectLineList.h"
#endif //
#ifndef lOlOOlllOO
#include "../Common/zcta003.h"
#endif //
#ifndef TA_PHYSICSRENDER_H
#include "PhysicsRender.h"
#endif //
namespac\
e
TA
{
#define lllllOOlOOO(lOllOOOOll, lOOOlOOlll) ((lOOOlOOlll) + 1 < (lOllOOOOll).lOllOllOll ? (lOOOlOOlll) + 1 : 0)
co\
nst\

in\
t
ll\
ll\
l\
OO\
l\
OOl\

=
128
;
const
int
lll\
ll\
O\
Ol\
OlO
=
128
;
sta\
tic
Ve\
c3
lllllOO\
lO\
ll\

[
ll\
l\
l\
lO\
Ol\
OOl
]
;
st\
atic
Ve\
c3
lllllOOll\
OO
[
lllll\
OOlOOl
]
;
struct
ll\
lllOOllO\
l
{
Vec3
lOOO\
Olllll
;
Ve\
c\
3\

lll\
llOOl\
llO
;
Vec3
ll\
O\
llll\
l\
O\
l\
l\

;
Vec3
lOlllOlOlO\
l\

;
int
llOl\
l\
l\
OOll\
O\

;
int\

ll\
l\
ll\
OO\
ll\
ll
;
flo\
at\

lOl\
l\
OOlO\
OO\
l
;
}
;
st\
at\
ic
int\

ll\
lOOlO\
Ol\
ll
=
0
;
sta\
tic
con\
st
in\
t
lllOOlOlOOO\

=
32
;
st\
at\
ic\

lllllOOllOl
lllllOlO\
O\
O\
O
[
lllOO\
l\
OlO\
OO
]
;
stati\
c
vo\
i\
d
lllllO\
lOOOl
(
)
;
static\

void
lllllOlOOlO
(
)
;
static
void
lllllOl\
OOll
(
lOl\
lOllOllO\

*
lOll\
lOOOOO\
l
,
in\
t
lllll\
OOllll
,
u32\

llOlllO\
Oll\
O\

,
float
lllOl\
lllO\
O\

,
flo\
at
ll\
l\
llOl\
OlOO
,
con\
st\

Vec\
3
&
lOOOOl\
ll\
ll
,
cons\
t\

Vec3\

&
lllllOOlll\
O
,
const
Vec3
&
llOllll\
lOl\
l\

,
const
Vec3
&
lOlll\
OlO\
lOl
)
;
TA_ALI\
G\
N_16
struct
CollisionObje\
c\
tCon\
ve\
x\

::
lllllOlOlO\
l\

{
Vec\
3
lO\
lll\
OlOlO\
l\

;
in\
t
llOll\
l\
OllO
;
int
ll\
Ol\
llOll\
l
;
}
;
st\
ruct
Col\
li\
sion\
Ob\
jectConvex
::
Polygon
{
Ve\
c\
3\

lOOO\
lOOOOO
;
int\

lOllOllOll
;
floa\
t
lOlOll\
Oll\
l
;
u32
lllllO\
lOllO
;
u32
lllOlOO\
OllO
;
ll\
lllOlO\
lO\
l
llOlll\
lOOO
[
lOlllO\
OlO\
Ol
]
;
}
;
struct\

Col\
li\
s\
ionO\
bje\
ct\
C\
onvex\

::
lllllO\
l\
Olll
{
int\

llll\
lOllOOO
;
int
lllllO\
llOO\
l
;
int\

ll\
OlOll\
OO\
O
;
int
llO\
lOll\
OO\
l
;
}
;
st\
ru\
ct\

Col\
li\
si\
o\
nObjectC\
onvex
::
Vertex
{
in\
t
lllllO\
ll\
O\
lO
;
int
lll\
llOllOll
[
256
]
;
}
;
struc\
t
Colli\
si\
onObj\
ec\
tCon\
vex
::
Dat\
a
{
en\
um
{
ll\
lllOlll\
OO\

=
0x1
,
}
;
in\
t
lOlOll\
OOOl
;
Vec\
3
ll\
lO\
l\
l\
O\
O\
OOO
;
AABB
lOOO\
OOOlll
;
lOO\
OOl\
Oll\
O
<
Ve\
c3\

,
fa\
lse\

>
lll\
ll\
Olll\
Ol\

;
lOOOOl\
OllO
<
int\

,
false
>
lOll\
OOll\
O\
l
;
lOOOOl\
Ol\
lO
<
u8
,
false
>
lOl\
lOOllOO
;
lO\
OOOlOl\
lO
<
lllllOlOll\
l
,
fals\
e
>
lllllO\
lll\
l\
O
;
lOOO\
OlOllO
<
int
,
fa\
lse
>
ll\
lll\
O\
lllll
;
lOO\
OO\
lOllO
<
u8
,
false
>
ll\
llllOOOOO
;
}
;
#define llllllOOOOl(lOllllllllO, llOlOlllll) \
(*(CollisionObjectConvex::Polygon*)&(lOllllllllO)->GetData()->lOllOOllOO[(lOllllllllO)->lOlOOlOllO->lOllOOllOl[(llOlOlllll)]])
#define llllllOOOlO(lOllllllllO, lOlllOOlll) \
(*(CollisionObjectConvex::Vertex*)&(lOllllllllO)->GetData()->llllllOOOOO[(lOllllllllO)->lOlOOlOllO->lllllOlllll[(lOlllOOlll)]])
stati\
c
int
lll\
lllOOOll
(
in\
t
lO\
l\
lO\
llOl\
l
)
{
retu\
r\
n
sizeo\
f
(
Vec3\

)
+
si\
ze\
of
(
int
)
*
4
+
siz\
eof
(
const
Col\
lisi\
o\
n\
Obj\
ectConvex\

::
lllllOlOlO\
l
)
*
lOllOl\
lOll
;
}
void
Col\
lisionOb\
je\
ctConvex
::
Initialis\
e\

(
)
{
Init\
ialis\
e\
AsABo\
x\

(
1.0f
,
1.0f
,
1.0f
)
;
}
void
Collisi\
onO\
bje\
ct\
Co\
nve\
x
::
InitialiseAsABo\
x
(
fl\
oa\
t
llllO\
l\
OOOlO
,
fl\
oat\

llllOlOOO\
ll
,
float
lll\
lOlOO\
l\
OO
)
{
AABB
lOOO\
OOOlll
;
lOOOOO\
Oll\
l
.
v3Cente\
r
.
Clea\
r
(
)
;
lOOO\
O\
OOl\
l\
l
.
v3Ex\
ten\
t
.
Initial\
ise\

(
llll\
O\
lOOO\
l\
O
*
0.5f
,
llllOlOOOll\

*
0.5f
,
llll\
Ol\
O\
OlOO
*
0.5f
)
;
In\
i\
tiali\
seAsABox\

(
lO\
OOO\
O\
Ol\
ll
)
;
}
voi\
d\

Co\
l\
lis\
ionO\
b\
jec\
tConv\
ex
::
Initia\
liseAsABo\
x\

(
const
AAB\
B\

&
lOOOOO\
O\
ll\
l
)
{
llll\
l\
lOOlOO
(
lOOOOO\
O\
l\
ll
,
0
)
;
}
void\

Coll\
isi\
o\
n\
Obj\
e\
ctConv\
ex
::
Ini\
tial\
iseA\
sAnOrie\
ntedB\
ox
(
co\
n\
st
AAB\
B
&
lOOO\
O\
OOl\
ll
,
const\

MFrame\

&
lOO\
OOOOOOl
)
{
ll\
llllOOlO\
O\

(
lOOOO\
O\
Ol\
l\
l
,
&
lOOO\
OOOO\
O\
l
)
;
}
bool
Coll\
isionObj\
ec\
tCon\
ve\
x\

::
Initialise\
F\
rom\
Poin\
tL\
ist
(
co\
nst
Vec3
*
ll\
llOlOlOOl
,
int
lll\
lOl\
OlOl\
O
)
{
Conv\
ex\
Hull\

lll\
l\
ll\
OOl\
Ol
;
if
(
!
lll\
lllO\
OlOl\

.
In\
i\
t\
i\
ali\
s\
e
(
ll\
ll\
Ol\
OlOOl
,
ll\
llOlO\
l\
OlO\

,
lOl\
ll\
O\
OlO\
O\
l
)
)
{
lOOOl\
l\
l\
OlO
(
0
,
"CollisionObjectConvex::InitialiseFromPointList. Convex hull initialise failed")
;
AABB
lOOOOOO\
lll
;
if
(
ll\
llOlOlO\
lO
<=
0
)
{
lOOO\
OO\
Ol\
ll\

.
v3Cen\
t\
er
.
Clear
(
)
;
lOOOOOOlll\

.
v3Ex\
tent
.
x
=
0.5f
;
lOOO\
OOOlll
.
v3\
E\
x\
tent
.
y
=
0.5f
;
lOOOOOOlll
.
v3\
Exten\
t\

.
z
=
0.5f
;
}
else\

{
lOOOOOO\
lll
.
v3\
Cen\
t\
er
=
llll\
OlOlOOl
[
0
]
;
lOOOOOOlll
.
v3Extent
.
Cle\
ar\

(
)
;
for
(
in\
t\

lOl\
ll\
O\
Ol\
lO
=
0
;
lOll\
lOOllO\

<
llllOlOlOl\
O
;
lOlll\
O\
OllO
++
)
lOO\
O\
OOOll\
l
.
Exp\
an\
d\
ToFit\

(
llllOlO\
lOO\
l
[
lOll\
lOO\
l\
lO\

]
)
;
cons\
t
float
lll\
l\
ll\
OOl\
lO
=
0.04f
;
if\

(
lOOOO\
OOlll
.
v3Ex\
tent
.
x
<
llllllO\
O\
ll\
O\

)
lO\
OOOOOlll
.
v3E\
xt\
e\
nt
.
x
=
lll\
l\
llOOllO
;
if\

(
lOOOOOOlll
.
v3\
Extent\

.
y
<
lll\
l\
llOOll\
O
)
lOOO\
O\
O\
Olll\

.
v3\
E\
x\
tent
.
y
=
lll\
lll\
OOl\
lO
;
if
(
lOOOOOOlll
.
v3Ext\
ent
.
z
<
llllllOOllO
)
lOO\
OOOOlll\

.
v3Ext\
ent
.
z
=
llll\
l\
l\
OOll\
O
;
}
In\
itialiseA\
sABox
(
lOOOOO\
Oll\
l
)
;
return
fa\
lse
;
}
Init\
i\
ali\
se\
F\
r\
omC\
onv\
exHull\

(
ll\
ll\
l\
lO\
O\
lO\
l
)
;
ret\
urn
true
;
}
void
CollisionObj\
ectC\
onvex
::
In\
it\
ial\
is\
eFromPlaneLi\
s\
t
(
co\
n\
s\
t
Vec3\

*
llOOlOO\
Oll\

,
const
Vec3
*
llOOlOOlOO
,
in\
t\

llOO\
l\
OOlOl
)
{
Con\
vexHull
llll\
l\
lOO\
l\
Ol\

;
if
(
!
ll\
lll\
lOOlOl
.
Init\
ia\
lise\

(
ll\
O\
OlOOOll
,
llOOlOO\
lOO
,
ll\
O\
OlOO\
lOl
)
)
re\
turn
;
Initiali\
s\
eFromConve\
xHul\
l
(
ll\
llllOOl\
Ol
)
;
}
voi\
d
CollisionObjectCon\
v\
e\
x\

::
Initial\
iseFr\
omConvexHull
(
Co\
nv\
exH\
ull
&
ll\
llll\
O\
O\
l\
Ol
)
{
if
(
lO\
lO\
OlO\
llO\

)
{
lOO\
O\
lll\
Ol\
O
(
0
,
"CollisionObjectConvex::InitialiseAsABox. Already initialised.")
;
Fin\
alis\
e
(
)
;
}
lOOOOO\
llO\
OO
(
lOlO\
OlO\
llO\

,
Data
)
;
if
(
lll\
lllOO\
lOl
.
Ge\
tNu\
mP\
o\
i\
nts\

(
)
>
llll\
lO\
OlOOl
)
ret\
ur\
n
;
lOlO\
OlOll\
O
->
lO\
lO\
ll\
OO\
Ol\

=
0
;
lO\
lOOlO\
llO
->
lllllOll\
lOl
.
Initia\
l\
ise
(
0
,
ll\
llll\
OO\
lOl
.
GetNum\
Poi\
nts
(
)
)
;
for
(
int\

llllllO\
Olll
=
0
;
llllllO\
Ol\
ll\

<
ll\
ll\
llOOlO\
l
.
GetNumPoints
(
)
;
llllllOOl\
ll
++
)
lOlOOl\
Ol\
l\
O
->
lllllOl\
l\
l\
Ol\

.
lO\
OO\
lllOOO\

(
llllllOO\
lOl
.
GetPoint
(
llllll\
OO\
l\
ll
)
)
;
int\

ll\
OlllO\
O\
OOO
=
0
;
int
ll\
llll\
OlOO\
O
=
0
;
lOl\
OOlOllO
->
lO\
l\
lOO\
llO\
l
.
Initialise
(
0
,
lll\
lll\
OOlOl
.
GetN\
umPol\
y\
gons
(
)
)
;
int
llOlO\
l\
llll
;
for
(
llO\
lOlllll
=
0
;
llOl\
Olll\
ll
<
lll\
lll\
OOl\
Ol
.
Get\
NumPolyg\
on\
s\

(
)
;
llOlOlll\
l\
l
++
)
{
lOlOOlOll\
O\

->
lOllOOllOl
.
lOOOlll\
O\
OO
(
llOlllOOOOO
)
;
co\
n\
st
Con\
vexH\
ul\
l
::
Poly\
gon\

&
lOl\
lOOOOll
=
llllllOO\
lO\
l
.
GetPoly\
go\
n\

(
llOlOlllll\

)
;
llOlllOOO\
OO\

+=
ll\
llllOOOl\
l
(
lOllOOO\
Ol\
l
.
lOll\
Ol\
lOll
)
;
lll\
ll\
lOlOO\
O
+=
lO\
llOOOOll
.
lOllOll\
Oll
;
}
lO\
lOO\
l\
O\
llO
->
lOll\
OO\
ll\
OO\

.
Initialis\
e\

(
llO\
lll\
OOOOO
,
llOll\
lOO\
OOO\

)
;
int
ll\
Olll\
OO\
ll\
l
=
0
;
for
(
llOlO\
l\
lll\
l\

=
0
;
llOlOl\
ll\
ll
<
llll\
llOOlOl\

.
Get\
NumPolygons
(
)
;
llOlOllll\
l
++
)
{
const
ConvexH\
ul\
l
::
Pol\
ygon
&
lll\
ll\
lOlOOl
=
llll\
l\
l\
OO\
lOl
.
Get\
Polygon\

(
ll\
Ol\
Ol\
ll\
l\
l
)
;
Po\
lyg\
on
&
lOllOOOOl\
l
=
*
(
Polygo\
n
*
)
&
lOlOO\
lO\
ll\
O
->
lOllOOllOO
[
llOlll\
O\
Oll\
l
]
;
lOll\
OOO\
Oll
.
lOl\
l\
Oll\
Oll
=
lllll\
l\
O\
lOOl
.
lOl\
lOllOll\

;
for
(
int
lOl\
l\
lOOlll\

=
0
;
lO\
l\
llOOlll
<
lOllO\
OOO\
ll
.
lOllOll\
Ol\
l
;
lO\
l\
l\
lOOlll
++
)
{
lOllOOOOll\

.
llO\
llllO\
O\
O
[
lOlllOOlll
]
.
llOlllO\
l\
lO
=
ll\
llllO\
lOOl
.
llOllllOOO\

[
lOlllOO\
l\
ll\

]
.
llOlllOllO
;
lOllOOOO\
ll
.
llOl\
ll\
lOOO
[
lOl\
l\
lO\
Ol\
ll
]
.
llOl\
llOll\
l\

=
ll\
ll\
l\
lO\
lOOl
.
llOlll\
lOOO
[
lOl\
l\
lOOlll\

]
.
ll\
Oll\
l\
Ol\
ll
;
lOllOOO\
O\
ll
.
llOllll\
OOO
[
lOll\
lOOlll\

]
.
lOll\
l\
O\
lOlOl\

.
Cl\
ear
(
)
;
}
llOl\
llO\
Olll
+=
ll\
ll\
ll\
OOOll\

(
lOllOOOOll
.
lOll\
Ol\
lO\
ll
)
;
}
llllllOlO\
lO
(
)
;
lOlOOlOllO
->
lllll\
O\
llllO
.
Ini\
ti\
alis\
e\

(
0
,
llllllOlOOO\

>>
1
)
;
fo\
r
(
llOlOl\
llll
=
0
;
llO\
l\
O\
lllll
<
lllll\
lOOl\
Ol
.
GetNumPolygo\
n\
s\

(
)
;
llO\
lOll\
lll
++
)
{
Polygon
&
lOllO\
OOO\
ll
=
llll\
llOO\
O\
Ol
(
this
,
ll\
OlOlllll\

)
;
for\

(
int
ll\
llllO\
lOl\
l\

=
0
;
lllll\
l\
OlO\
l\
l\

<
lOllOO\
OOll
.
lOllOll\
Ol\
l
;
llllllOlOl\
l\

++
)
{
int
lll\
l\
lOl\
lOOO
=
lOl\
lOOOOll
.
llOllll\
O\
O\
O\

[
lll\
lllOlOl\
l
]
.
ll\
Olll\
OllO
;
int\

ll\
l\
llO\
llOOl
=
lOl\
lOOOOll
.
llO\
ll\
ll\
OOO
[
lllllO\
O\
lOOO\

(
lO\
l\
lOOOOll\

,
llllllOlOll
)
]
.
llOlllOllO
;
int
ll\
OlOlOlO\
O
;
for
(
ll\
O\
lOlO\
lOO\

=
0
;
llOlOlOlOO\

<
lO\
lOOlO\
l\
lO
->
ll\
lllOll\
llO\

.
lO\
OOl\
llOOl
(
)
;
ll\
OlOlOlOO
++
)
{
lllllOlOl\
ll\

&
llOlO\
lOOOO
=
lOlOO\
lO\
llO
->
lll\
llOllllO
[
llOlOlOlOO\

]
;
if
(
(
llOlOl\
OO\
OO\

.
lllll\
O\
ll\
O\
OO
==
ll\
lll\
OllOOO\

&&
llOl\
OlOOOO
.
ll\
ll\
lOll\
OOl
==
lllllOllO\
Ol\

)
||
(
llOlOlO\
OOO\

.
lllllO\
l\
lOO\
O\

==
lll\
l\
lO\
llO\
Ol
&&
llO\
lOl\
OOOO\

.
lllllO\
llOO\
l
==
lllll\
OllO\
OO
)
)
{
break
;
}
}
if
(
llO\
l\
O\
l\
OlOO
!=
lOlOOl\
Oll\
O
->
lllllOlll\
l\
O
.
lOOOl\
llO\
Ol\

(
)
)
co\
n\
t\
inu\
e
;
lllll\
Ol\
Oll\
l
&
llOl\
Ol\
O\
O\
O\
O\

=
lO\
lOOlO\
llO
->
llll\
lOllllO
.
lOOOl\
llOOO
(
)
;
llOlOlOOO\
O
.
lll\
llOllOO\
O
=
lllll\
O\
llOOO
;
ll\
OlOl\
OOOO\

.
llll\
lO\
l\
lOO\
l\

=
lllllOl\
lOOl
;
llOlO\
l\
OO\
O\
O
.
llOlOl\
lOOO
=
llOl\
Oll\
l\
l\
l\

;
llO\
lO\
l\
OOO\
O
.
llO\
lOll\
OO\
l
=
lOllOOO\
Oll
.
llO\
ll\
llOO\
O\

[
ll\
l\
lllOlOll
]
.
ll\
OlllOll\
l
;
}
}
TA_\
A\
SSERT
(
lO\
lOO\
lOllO
->
lllllO\
ll\
l\
l\
O
.
lO\
OO\
lllOO\
l
(
)
==
lOlO\
OlOl\
lO
->
ll\
lllOllllO\

.
lOOllllOll
(
)
)
;
lll\
lll\
O\
llOO
(
)
;
Init\
ialise\
Comm\
on
(
)
;
}
vo\
id\

Col\
lision\
Objec\
tCo\
nve\
x
::
Finalise
(
)
{
if
(
lOlOOlOllO\

)
{
lOO\
lOOOO\
OO\

(
lO\
lOOlOllO
,
Data
)
;
lOl\
O\
O\
l\
O\
llO
=
0
;
}
}
voi\
d
Coll\
isionO\
b\
je\
ct\
Conv\
ex\

::
Seri\
alis\
e
(
Seri\
ali\
s\
er\

&
lOOO\
l\
Ol\
lOl
,
const
Version
&
lllOlOOO\
l\
O
)
{
lOOOO\
O\
Oll\
O
(
lllO\
lOOOl\
O
<=
llOl\
l\
O\
OlOlO
,
"CollisionObjectConvex::Serialise. Version number is too new")
;
if
(
lOOOlOllOl
.
lOOO\
ll\
OOOO
(
)
)
{
if
(
lOlOO\
lOl\
lO
)
{
lO\
OO\
l\
llOlO
(
0
,
"CollisionObjectConvex::InitialiseAsABox. Already initialised.")
;
Fina\
lise
(
)
;
}
lOOOOOllOOO
(
lOlOO\
lO\
llO
,
Data
)
;
}
lO\
O\
O\
lO\
ll\
Ol
.
Serialise
(
lO\
lOOl\
Ol\
lO
->
lllOllOOO\
OO
)
;
lOOOlO\
l\
lOl
.
Seri\
alise\

(
lOlOOlOll\
O
->
lllOl\
lOO\
OOO
)
;
if\

(
lllO\
lO\
O\
O\
lO
>=
Versi\
o\
n
(
1015
,
0
)
)
lOOO\
lOllOl\

.
Seri\
al\
ise
(
lOlO\
OlO\
llO
->
lOlOllOOO\
l
)
;
els\
e
lO\
lOOlO\
llO
->
lOlOllOOOl
=
0
;
lOO\
OlOllO\
l\

.
lO\
OOlOllll\

(
lOlOO\
lOllO
->
lllll\
Oll\
lOl
)
;
lO\
OOlOl\
lO\
l\

.
lOO\
Ol\
Oll\
ll\

(
lOl\
OO\
lO\
ll\
O
->
lOl\
lOOl\
lO\
l
)
;
lO\
OOlOllO\
l
.
lOOOlOllll
(
lOl\
O\
O\
lOllO
->
lOllOOllO\
O\

)
;
lOO\
Ol\
OllOl
.
lOOOl\
O\
l\
l\
ll
(
lOlOOlO\
llO
->
lllllOll\
l\
lO
)
;
lOO\
OlOll\
Ol
.
lOOOlO\
ll\
ll
(
lOlO\
O\
l\
Oll\
O
->
lllllOllll\
l
)
;
lOO\
O\
lOllO\
l
.
lOOOlOllll
(
lOlOOlOll\
O
->
ll\
llllOOOOO
)
;
}
AA\
BB\

Col\
lision\
ObjectCo\
nvex\

::
Cal\
c\
ul\
ate\
Boun\
d\
in\
gBo\
x
(
)
const
{
AABB
lO\
OOOOO\
lll
;
if\

(
lO\
l\
OOlOllO
&&
lOlOOlOllO
->
ll\
lllOll\
lOl
.
lOOOlllOOl
(
)
)
{
lOO\
OOOOlll
.
Initialise
(
lOlO\
OlOllO
->
llll\
lOl\
llOl
[
0
]
,
k_\
v3Zer\
o\

)
;
for
(
int\

lOlllOO\
lll\

=
1
;
lOlllOOlll\

<
lOlOOlOl\
lO
->
lllll\
OlllO\
l
.
lO\
OOll\
lO\
Ol\

(
)
;
lOll\
lOOl\
l\
l\

++
)
lOOOOO\
Olll\

.
Expand\
T\
oFit
(
lOlOOlO\
ll\
O\

->
lllllOlllO\
l
[
lOlllO\
O\
lll
]
)
;
}
els\
e\

{
lO\
O\
OOO\
Olll\

.
v3Cen\
te\
r
.
Clear
(
)
;
lOOOO\
OOlll
.
v3Ex\
tent
.
Cle\
a\
r
(
)
;
}
retur\
n
lOOOO\
OOl\
ll
;
}
void
Collis\
i\
o\
nO\
bjec\
tConvex
::
Ca\
lcul\
a\
teMass\

(
float
ll\
lOlOll\
lll
,
floa\
t
&
lOll\
O\
OOO\
lO\
O\

,
Ve\
c3
&
lllOllOOOO\
O\

,
Mat33\

&
lllOl\
lOOOOl\

)
const\

{
float
ll\
l\
l\
llO\
l\
lOl\

=
0.0f
;
floa\
t
llllll\
OlllO\

=
0.0f
;
flo\
a\
t\

llll\
llOll\
ll
=
0.0f
;
float
llllll\
lOOOO
=
0.0f
;
float
ll\
lll\
llOO\
O\
l
=
0.0f
;
flo\
a\
t
llll\
ll\
l\
OOlO\

=
0.0f
;
float\

llll\
lllOO\
l\
l
=
0.0f
;
float
lllll\
l\
l\
O\
lOO\

=
0.0f
;
flo\
at
llllll\
lOl\
Ol
=
0.0f
;
floa\
t
lllllllOl\
lO
=
0.0f
;
for
(
int\

llOlOlllll
=
0
;
llOl\
Ol\
l\
lll\

<
lOlOOl\
Ol\
lO
->
lOllOOllO\
l
.
lO\
O\
Olll\
OOl
(
)
;
llO\
lOllll\
l
++
)
{
Po\
l\
y\
gon
&
lOll\
OOO\
Oll\

=
*
(
Pol\
y\
gon
*
)
&
lOlOOlOl\
l\
O
->
lOl\
lOO\
llOO
[
lOlOO\
lOllO
->
lOllOOllO\
l
[
llOlOlllll
]
]
;
for
(
int
llll\
l\
llOlll
=
0
;
lll\
llll\
O\
lll\

<
lO\
llOOO\
O\
l\
l
.
lOllOllOl\
l
-
2
;
lllll\
l\
lOlll\

++
)
{
co\
n\
st\

Vec3\

&
ll\
l\
llllll
=
lOlOOlOllO\

->
ll\
ll\
lO\
lllOl
[
lOllOOOO\
l\
l
.
ll\
O\
l\
lllO\
O\
O
[
0
]
.
llOlll\
OllO
]
;
const\

Vec3\

&
lOOO\
O\
OOO\
OO\

=
lO\
lOOlOl\
lO
->
lllllOlllOl
[
lOllOOOOll
.
llOllllOO\
O
[
ll\
ll\
l\
llOl\
ll
+
1
]
.
llOll\
l\
O\
llO\

]
;
const\

Vec3
&
ll\
llOOOl\
lO\

=
lOlOOlOl\
lO
->
lllll\
Oll\
l\
Ol
[
lOl\
lOOO\
Oll\

.
llOl\
l\
llOOO
[
lllllllOll\
l
+
2
]
.
ll\
O\
lllOll\
O\

]
;
float\

lll\
lllllO\
OO
;
flo\
a\
t
lll\
lllllOO\
l
;
fl\
oa\
t
llllO\
lllOO
;
llllll\
ll\
OO\
O
=
ll\
lll\
llll
.
x
+
lO\
O\
O\
O\
OOO\
O\
O\

.
x
;
ll\
llllllO\
Ol\

=
lllllllll
.
x
*
llllll\
lll
.
x
;
llll\
O\
lllO\
O
=
ll\
lllll\
l\
OO\
l\

+
lOOOO\
OO\
O\
OO\

.
x
*
llll\
l\
lllOO\
O
;
float\

ll\
llllll\
Ol\
O
=
lll\
lllllO\
OO
+
llllOOO\
ll\
O
.
x
;
float\

ll\
lll\
lllO\
ll
=
llllO\
l\
l\
lOO\

+
ll\
l\
l\
O\
OO\
l\
lO
.
x
*
lllll\
lllO\
lO
;
flo\
at
lll\
ll\
llllOO
=
lllllll\
l\
l
.
x
*
llllllllOOl\

+
lOOOOOOOOO
.
x
*
lll\
lOlll\
OO
+
ll\
llOOOllO\

.
x
*
lll\
l\
llllOl\
l\

;
ll\
l\
ll\
lllOO\
O
=
lll\
ll\
llll\

.
y
+
lOOO\
O\
OO\
OOO
.
y
;
llllll\
l\
lOOl
=
llll\
ll\
lll
.
y
*
llll\
lllll
.
y
;
ll\
l\
lOl\
l\
lO\
O
=
lllll\
lllO\
Ol\

+
lOOOOOOOOO\

.
y
*
llllllllOOO\

;
float\

ll\
l\
lll\
lllOl\

=
ll\
lll\
lllOOO
+
llllOOO\
llO
.
y
;
fl\
oa\
t
lll\
ll\
lllllO
=
llllOl\
llOO\

+
llllOOO\
llO
.
y
*
ll\
lllll\
ll\
O\
l
;
fl\
o\
at
llllllllll\
l\

=
lllllll\
l\
l
.
y
*
lllll\
lllOO\
l
+
lOOOO\
OOOOO\

.
y
*
ll\
llOl\
l\
lO\
O
+
lll\
lOO\
OllO
.
y
*
ll\
llll\
llllO
;
llll\
llll\
O\
OO
=
lll\
l\
lllll
.
z
+
lOO\
OO\
OO\
O\
O\
O
.
z
;
lllll\
l\
l\
lO\
O\
l
=
lllllllll
.
z
*
ll\
lllllll\

.
z
;
llllOlll\
O\
O
=
llllllll\
OOl
+
lOOO\
OOOOO\
O
.
z
*
lll\
ll\
l\
l\
lOOO
;
float\

lO\
O\
OOOOOOO\
O\
O
=
llllll\
llO\
O\
O
+
llllOOO\
l\
lO
.
z
;
fl\
o\
at\

lOOOOO\
OOOOOl
=
llllO\
lllOO
+
lll\
lO\
OOll\
O
.
z
*
lO\
O\
OO\
O\
OOOOO\
O
;
fl\
oat\

lOOOOO\
OOOOlO\

=
lllll\
llll\

.
z
*
lll\
l\
l\
lllOOl
+
lOOOOOOO\
O\
O\

.
z
*
llllO\
ll\
lOO
+
llllO\
OOllO
.
z
*
lO\
OOOOOOOOO\
l
;
Ve\
c3
lO\
l\
lllOllO
=
(
lO\
OOOOO\
OO\
O
-
lll\
lll\
lll
)
.
Cro\
ss\

(
llllOO\
Oll\
O
-
lllllllll
)
;
llllllOl\
lOl\

+=
lO\
l\
lllOllO
.
x
*
lllll\
lllOlO
;
ll\
lll\
lOlll\
O
+=
lOl\
lllOllO\

.
x
*
lllll\
lll\
Ol\
l
;
llll\
llOlll\
l\

+=
lO\
ll\
llOllO
.
y
*
llllll\
llllO
;
lllllllO\
OOO\

+=
lOllll\
OllO
.
z
*
lOOO\
OOOOOOOl
;
lll\
llllOOOl\

+=
lOllllOll\
O\

.
x
*
lllll\
ll\
l\
lOO
;
lllllllOOl\
O
+=
lOll\
llOllO
.
y
*
ll\
lllllllll\

;
lllllllO\
Oll\

+=
lOl\
lll\
O\
ll\
O
.
z
*
lOO\
OOOOOOOlO\

;
ll\
l\
l\
l\
lll\
OOO
=
lllll\
llll\

.
y
*
(
ll\
ll\
ll\
ll\
Oll
+
ll\
l\
l\
lllll
.
x
*
(
llllllll\
O\
lO
+
lll\
lllll\
l
.
x
)
)
+
lOOOOOOOOO\

.
y
*
(
llll\
llll\
Oll\

+
lOOOOOO\
OOO\

.
x
*
(
ll\
ll\
llllOlO
+
lO\
OOOOO\
O\
OO
.
x
)
)
+
ll\
llOOOll\
O
.
y
*
(
ll\
llllllO\
l\
l\

+
ll\
l\
l\
OOO\
llO
.
x
*
(
ll\
llllllOlO\

+
llll\
OOOll\
O\

.
x
)
)
;
llllll\
lOlO\
O
+=
lOllllOllO
.
x
*
llll\
llll\
OOO\

;
llllllllOOO
=
llllll\
ll\
l\

.
z
*
(
lllll\
lll\
llO
+
ll\
lllll\
ll
.
y
*
(
lllllllllOl
+
lllll\
llll
.
y
)
)
+
lOOOOOO\
OOO\

.
z
*
(
llllllll\
llO
+
lO\
OO\
O\
O\
OOOO
.
y
*
(
lll\
llll\
llO\
l
+
lOO\
OO\
OOOO\
O\

.
y
)
)
+
llllOO\
Ol\
l\
O
.
z
*
(
llllll\
llll\
O\

+
llllOO\
O\
llO
.
y
*
(
lllllll\
ll\
O\
l\

+
llllOOO\
llO\

.
y
)
)
;
ll\
llll\
lOlOl\

+=
lO\
lll\
l\
Ol\
lO
.
y
*
ll\
l\
lll\
ll\
OOO
;
lll\
lllllOOO\

=
lllllllll
.
x
*
(
lOO\
O\
OOOOOOOl
+
ll\
ll\
ll\
lll
.
z
*
(
lOOOO\
O\
OOO\
OOO
+
lll\
llllll
.
z
)
)
+
lOOOOOO\
OOO\

.
x
*
(
lOO\
OO\
OO\
O\
OO\
O\
l
+
lO\
O\
OOOO\
OOO\

.
z
*
(
lO\
O\
OO\
OOO\
OOOO
+
lOOO\
OOOOOO
.
z
)
)
+
llllOOOl\
lO
.
x
*
(
lOO\
OOOOOO\
O\
Ol
+
llllOOOllO
.
z
*
(
lOOOOOOO\
O\
OOO\

+
llllOO\
Oll\
O\

.
z
)
)
;
llll\
ll\
lOllO\

+=
lO\
l\
l\
ll\
OllO
.
z
*
lll\
l\
lll\
lOO\
O
;
}
}
lOllOO\
O\
O\
lOO\

=
llll\
ll\
O\
llOl
*
(
1.0f
/
6.0f
)
;
lOOO\
O\
O\
Oll\
O
(
lOl\
lO\
OOO\
l\
O\
O
>
0.0f
,
"CollisionObjectConvex::CalculateMass: Mass is less or equal too zero")
;
ll\
lOllOOOOO\

.
x
=
lll\
lllOlll\
O\

;
lllO\
ll\
O\
OOOO\

.
y
=
lll\
lll\
O\
l\
ll\
l\

;
lllOllOOO\
OO
.
z
=
lllllllO\
OOO
;
lllOllOOOOO
*=
1.0f
/
(
24.0f
*
lOllOOOOl\
OO
)
;
co\
nst
float
lOOOOO\
OO\
OOll
=
1.0f
/
60.0f
;
ll\
ll\
lllOOOl
*=
lOOOOOOO\
OO\
ll
;
lll\
ll\
l\
lOOl\
O\

*=
lOOO\
OO\
OOOOll
;
lllllllOOll\

*=
lOOOOOOOOOll
;
con\
s\
t\

flo\
at
lOO\
OOO\
OOOl\
OO
=
1.0f
/
120.0f
;
lllllllO\
lOO
*=
lOOO\
OOOOO\
lO\
O
;
ll\
lll\
llOl\
Ol
*=
lOO\
OOOOOO\
l\
OO
;
llll\
lllOl\
lO
*=
lOOOO\
OOO\
O\
lOO
;
lllOllO\
OOOl
.
M11
(
)
=
lllll\
llOO\
lO
+
ll\
l\
l\
lllOOl\
l\

-
lOllOOO\
OlOO
*
(
lll\
OllOOOOO
.
y
*
lll\
Oll\
O\
OOO\
O
.
y
+
lllO\
llOOOO\
O
.
z
*
ll\
l\
Ol\
lOOOOO\

.
z
)
;
ll\
lO\
l\
lOOOOl
.
M22\

(
)
=
lllllllOOOl
+
lllllllOO\
ll
-
lO\
ll\
O\
OOOlOO
*
(
lllOllOOOOO\

.
z
*
lllOllOO\
OO\
O
.
z
+
lllOllOO\
OO\
O
.
x
*
ll\
l\
O\
ll\
OOOOO
.
x
)
;
ll\
l\
Oll\
OOOO\
l
.
M33
(
)
=
llll\
l\
llOO\
Ol\

+
lllll\
ll\
OOlO\

-
lOllO\
OOO\
lO\
O\

*
(
lllOllO\
OOOO
.
x
*
lllOllOOO\
OO
.
x
+
lll\
O\
llO\
OOOO
.
y
*
lllOl\
l\
OO\
OO\
O\

.
y
)
;
lllOl\
lO\
O\
OO\
l\

.
M1\
2\

(
)
=
ll\
lOllOO\
O\
O\
l
.
M21
(
)
=
lOl\
lOO\
OOl\
OO
*
lllO\
l\
lOOOOO
.
x
*
lll\
Oll\
OO\
OOO
.
y
-
lllllllOlOO
;
ll\
lOl\
lOOOOl
.
M23
(
)
=
ll\
lOllO\
OOOl
.
M3\
2
(
)
=
lOllO\
OOOlOO
*
lllO\
llOOO\
OO
.
y
*
lllOllOOOO\
O\

.
z
-
lllllllOlO\
l\

;
lllOll\
OOOOl
.
M1\
3\

(
)
=
lllOl\
lOO\
O\
Ol\

.
M3\
1
(
)
=
lOl\
l\
O\
OOOl\
OO
*
lll\
OllOOOOO
.
z
*
ll\
lOllOOO\
O\
O\

.
x
-
lll\
llll\
O\
llO\

;
lOllO\
OO\
O\
lO\
O
*=
ll\
lO\
l\
Ollll\
l
;
lllOllO\
O\
OOl
*=
lllOl\
O\
lll\
l\
l
;
}
void
Coll\
is\
ionObj\
e\
ctCon\
v\
ex
::
Transf\
or\
m
(
co\
n\
st
MFrame
&
lOllOlll\
lOO\

)
{
TA_\
ASSERT
(
lOlO\
OlOllO\

)
;
for
(
int
lOll\
l\
OO\
lll
=
0
;
lOl\
llOOl\
ll\

<
lOlOO\
lOllO
->
lllll\
Ol\
llO\
l
.
lO\
O\
Ol\
l\
lOO\
l
(
)
;
lOl\
l\
l\
OOlll
++
)
lOl\
OOlOl\
lO\

->
lllllOlll\
O\
l
[
lOlll\
O\
O\
ll\
l\

]
*=
lOllOl\
ll\
lOO
;
llllllOl\
O\
lO
(
)
;
lOl\
OOlOllO
->
lllO\
llOOOO\
O
*=
lO\
ll\
Oll\
llOO
;
lOlOO\
lOllO
->
lOl\
O\
ll\
OOOl
&=
~
Data
::
ll\
lllOlllO\
O\

;
}
vo\
id
Collis\
i\
onObjectConvex
::
Render
(
co\
nst
MFram\
e
&
lOO\
O\
OOOOOl\

)
{
TA_ASS\
E\
R\
T\

(
lO\
lOOlOllO
)
;
Vec3
lO\
OOOOOOOl\
O\
l
[
lOll\
lOOlOOl
]
;
Vec3\

lll\
Ol\
OllOOl\

[
lOl\
llO\
OlOOl
]
;
int\

llOlOl\
llll\

;
for
(
llOlO\
l\
l\
lll
=
0
;
llOlOlllll
<
lOlOO\
lO\
llO
->
lO\
llO\
Ol\
l\
O\
l
.
lOO\
O\
ll\
lOOl\

(
)
;
llOlOl\
llll
++
)
{
Polyg\
o\
n
&
lO\
llOOOOll\

=
*
(
Poly\
go\
n
*
)
&
lOlOOlOllO
->
lOl\
l\
O\
OllOO
[
lOlO\
O\
lOllO
->
lOllOOllOl
[
llOl\
Olllll
]
]
;
TA_AS\
SERT
(
lOllOOOO\
l\
l
.
lOll\
Oll\
O\
ll
<=
lOlllOOlO\
Ol\

)
;
int
lOlllOO\
ll\
l
;
const
Vec3
lOOOOOOOOllO
=
lOllO\
OOOll
.
lOOO\
lOOOOO
*
lOOOO\
OO\
O\
Ol\

.
m33Rotat\
io\
n\

;
for\

(
lOll\
l\
OOlll\

=
0
;
lO\
l\
llOOll\
l
<
lOl\
lOOOOl\
l
.
lO\
l\
l\
Oll\
O\
ll\

;
lOlllOOlll\

++
)
{
lO\
OOOOOOOlOl
[
lOlllOOll\
l\

]
=
lOlO\
OlOl\
l\
O
->
lllll\
O\
lllOl
[
lOllOOO\
Oll\

.
llOllllOO\
O
[
lOlllOO\
lll
]
.
llO\
ll\
lOll\
O\

]
*
lO\
OOOOOOOl\

;
lllOlOllOOl
[
lO\
lllOOlll\

]
=
lO\
OOOO\
O\
OO\
llO
;
}
PhysicsR\
ende\
r\

::
Render\
Polyg\
on\

(
lOll\
OOOOll
.
lOllO\
l\
lOll\

,
lOOOOO\
OOOlOl\

,
lllO\
lOll\
OOl
)
;
#ifdef lOOOOOOOOlll
Vec3
lOOO\
OOOO\
lOOO
;
lOOO\
OOOOlOOO
.
Clea\
r
(
)
;
for
(
lOll\
lOOlll\

=
0
;
lOl\
llOOl\
ll
<
lOllOO\
OOll
.
lOllOll\
Ol\
l
;
lOlllOOlll
++
)
{
int
ll\
OOll\
OOll
=
lO\
lllOOl\
ll\

;
Vec\
3
&
ll\
l\
ll\
l\
lll
=
lOl\
OOlO\
l\
lO
->
ll\
lllO\
l\
l\
l\
Ol
[
lO\
l\
lOOOOll
.
ll\
O\
l\
lll\
OO\
O
[
lOlllOOlll
]
.
llOll\
lOllO
]
;
in\
t
ll\
OOl\
l\
OlO\
O
=
(
lOlllO\
O\
l\
l\
l
+
1
<
lO\
l\
l\
O\
O\
OOll
.
lOllOllO\
ll
)
?
lOll\
l\
O\
Olll
+
1
:
0
;
Vec3
&
lOO\
O\
OO\
OOOO
=
lOlO\
OlOl\
lO\

->
lll\
ll\
OlllOl
[
lO\
llOO\
OOll
.
llOlll\
l\
OOO
[
llO\
OllOlO\
O
]
.
llOlll\
Ol\
lO
]
;
lOOOOOO\
O\
lO\
OO\

+=
llll\
lll\
ll\

;
Ve\
c3
llOOllllO\
O\

=
(
llll\
lllll\

+
lOO\
OOOOOOO
)
*
0.5f
;
Physic\
sRender
::
Ren\
de\
rArr\
ow
(
llOOll\
llOO
*
lOOOO\
O\
OOO\
l
,
lOll\
OOOOl\
l
.
llOl\
ll\
lOOO
[
lOl\
llO\
O\
lll
]
.
lOlll\
O\
lOl\
Ol
*
0.25f
*
lOOOOOO\
OOl
.
m33R\
otat\
io\
n\

,
lO\
O\
O\
O\
O\
OOlOOl
(
255
,
0
,
255
,
0
)
)
;
}
TA_ASSE\
RT\

(
lOllOO\
OO\
l\
l
.
lOll\
Ol\
l\
Oll
)
;
lOOOOOOOlOOO\

/=
(
float
)
lOll\
O\
OOOll
.
lOl\
lO\
l\
lO\
ll
;
Physics\
R\
en\
der
::
Ren\
derArro\
w
(
lOOO\
OOOOl\
OOO
*
lOOOOOOO\
Ol
,
lOllOOO\
O\
l\
l\

.
lOOOlOOOO\
O
*
lOOOOOOOOl\

.
m33Rotatio\
n\

,
lOOOO\
O\
OOlOOl
(
255
,
255
,
0
,
0
)
)
;
#endif //
}
#ifdef lOOOOOOOOlll	
for
(
int
lO\
l\
llOO\
lll
=
0
;
lOlllOOlll\

<
lO\
lOO\
lOll\
O
->
lll\
llOl\
llOl\

.
lOOOlllOO\
l
(
)
;
lO\
l\
l\
lOOlll
++
)
{
const
Vec\
3
&
lll\
lllll\
l
=
lOlO\
OlOll\
O
->
lllllOlllOl
[
lOlllOOl\
ll
]
;
Ver\
t\
ex
&
lOOOOOOOlOlO
=
ll\
llll\
OOOlO
(
th\
is
,
lOlll\
OO\
lll
)
;
for
(
int
lOOOOO\
OOlO\
ll
=
0
;
lOO\
O\
O\
O\
O\
Ol\
Oll\

<
lOOO\
OOOOl\
OlO
.
lll\
llO\
llO\
lO
;
lOOOO\
OO\
OlOll\

++
)
{
const
Vec3
&
lOO\
OO\
O\
O\
OOO
=
lOlOOlOll\
O\

->
lllllOlllO\
l\

[
lOO\
O\
OOOOlO\
lO\

.
lllllOllOll
[
lOOO\
O\
OOOlOl\
l
]
]
;
Ph\
y\
sicsR\
e\
n\
der
::
Rend\
erA\
rr\
ow\

(
ll\
lll\
l\
lll
*
lO\
OO\
OOO\
OO\
l
,
(
(
lO\
O\
OO\
OO\
OOO\

-
llllllll\
l
)
*
lO\
OO\
OOOOOl
.
m33Rotation\

)
*
0.25f
,
lO\
O\
OO\
OOOl\
O\
Ol\

(
255
,
255
,
0
,
255
)
)
;
}
}
#endif //
#ifdef lOOOOOOOllOO
fo\
r
(
llO\
l\
Olll\
ll
=
0
;
ll\
O\
l\
O\
lllll
<
lOlOOlO\
ll\
O
->
lOllO\
O\
ll\
Ol\

.
lOOOlll\
O\
Ol\

(
)
;
ll\
OlOlllll
++
)
{
Polyg\
on
&
lOllOOOOll
=
*
(
Pol\
y\
gon\

*
)
&
lO\
lO\
OlOll\
O
->
lOllO\
Oll\
OO\

[
lOlOO\
lOllO
->
lOllO\
O\
llOl
[
llOlOl\
llll
]
]
;
TA_\
ASSE\
RT
(
lO\
l\
l\
O\
O\
OOll
.
lOllOllO\
ll
<=
lOl\
llOOlO\
Ol\

)
;
in\
t
lOll\
lOO\
l\
ll\

;
for
(
lO\
l\
llOOlll
=
0
;
lO\
l\
l\
lOOlll
<
lOllOOOOll
.
lOllOllOll\

;
lOlllOOlll
++
)
{
lOOOOOOOOlOl
[
lOlllOOlll\

]
=
lOlO\
OlOl\
lO\

->
lllll\
OlllOl
[
lOl\
lOO\
OO\
ll
.
ll\
OllllOOO
[
lO\
lllO\
Olll
]
.
llOlll\
OllO
]
*
lOOO\
OO\
OOO\
l
;
}
if\

(
lO\
OO\
O\
OOO\
llO\
l
==
&
lOllOOOO\
l\
l
)
{
fo\
r
(
lOlllO\
O\
lll
=
0
;
lOll\
lOOlll
<
lOllOOO\
O\
ll
.
lOl\
lO\
llOll
;
lOlllOOlll\

++
)
{
int
llO\
OllOO\
ll\

=
lOlll\
OOlll
;
Ve\
c\
3
&
lllllllll
=
lOO\
OO\
OOOO\
lOl\

[
llOOll\
OO\
ll
]
;
int\

llOOllOlOO
=
(
lOlllOOl\
l\
l
+
1
<
lOl\
lOOOOll
.
lOll\
Ol\
lOll
)
?
lOlll\
OO\
l\
ll
+
1
:
0
;
Vec3
&
lOOOOO\
OOO\
O
=
lOOOO\
O\
OOOl\
Ol\

[
llOOl\
lO\
lOO
]
;
Physic\
s\
R\
e\
nder
::
Re\
nderLine
(
lll\
llll\
l\
l
,
lOOO\
OOOO\
OO
,
lOOOOOOOlOOl
(
255
,
255
,
255
,
0
)
)
;
}
}
}
#endif //
}
bo\
ol
Collision\
O\
bject\
Co\
nv\
ex\

::
Tes\
t\
L\
ineFo\
rCol\
l\
i\
sion
(
co\
nst
Ve\
c\
3
&
lO\
OlOlO\
lll
,
co\
nst
Vec\
3
&
lOO\
Ol\
OOOOO
,
float
lOOlO\
llO\
OO
,
Co\
ll\
is\
ion
&
ll\
OllllOlOl
)
const
{
if\

(
!
lOlO\
O\
l\
OllO
)
ret\
urn\

false
;
for
(
int
llOlOlllll
=
0
;
ll\
OlOll\
lll\

<
lOlOO\
lO\
llO
->
lOl\
lOOl\
lO\
l\

.
lOOO\
lllOOl
(
)
;
llO\
lOlll\
ll
++
)
{
Po\
lygon
&
lOll\
OOOOl\
l
=
llllllOOOOl
(
this
,
llOl\
Ollll\
l
)
;
flo\
at
lO\
lllOlllO
=
lOll\
OOOOl\
l
.
lO\
O\
Ol\
OOO\
OO
.
Dot
(
lOOl\
OlOlll
)
-
lOll\
OO\
OOll
.
lOlO\
llOl\
ll
;
float
lO\
lll\
l\
OOO\
O
=
lOlllOlllO\

+
lOll\
OO\
OOl\
l
.
lOOOlOO\
OOO\

.
Dot
(
lOOOl\
OOOOO
)
*
lOO\
lO\
llOOO
;
if
(
lOll\
lOlllO\

<
0.0f
||
lOl\
lllOO\
OO
>=
0.0f
)
continue
;
float
lllOllllOO
=
lOl\
llO\
lll\
O\

/
(
lOlllOlll\
O
-
lOllllO\
OO\
O
)
;
if
(
lll\
Ollll\
OO\

>=
llOlll\
lOlOl
.
lll\
Oll\
l\
lO\
O\

)
continue\

;
Vec\
3
lO\
OOOOOOlllO
=
lO\
OlO\
lOll\
l
+
(
lOOlO\
llO\
O\
O\

*
lllO\
lll\
lOO
)
*
lOO\
OlOO\
OO\
O
;
in\
t\

llOlOlOlOO
;
for\

(
llOl\
OlOlOO
=
0
;
ll\
Ol\
OlOlOO
<
lOllOOOOll
.
lOllOl\
lOll
;
llOl\
OlO\
lOO
++
)
{
const\

lllll\
OlOlO\
l
&
lOOOOO\
OOlOlO\

=
lO\
l\
l\
OOOOl\
l
.
ll\
Oll\
llOOO
[
llOl\
OlOlOO
]
;
con\
s\
t
Vec\
3
&
llOOllllOO
=
lOlO\
Ol\
OllO
->
lllllOll\
lOl
[
lOOOOOOOlOlO\

.
llOl\
l\
lOl\
lO
]
;
if
(
lOOOOOOO\
lOlO
.
lOlllOlOlO\
l
.
Do\
t
(
lOO\
OOO\
OO\
l\
llO
-
llOOll\
llO\
O
)
<
0.0f
)
break
;
}
if
(
ll\
OlO\
lOlOO\

<
lOllOOO\
Ol\
l
.
lOllOll\
Ol\
l
)
continue
;
llOll\
llOlOl
.
lO\
l\
Ol\
l\
O\
OOl
|=
Collision
::
FLAG\
_COLLISI\
ON_\
O\
CCURRED\

;
llO\
llllOlO\
l
.
lOO\
OOlll\
ll
=
lOOO\
OOOOlllO\

;
llOllllOl\
Ol
.
lOOOlOOOOO
=
lOllOO\
OOll
.
lOOO\
l\
OOOO\
O
;
ll\
Ol\
ll\
lO\
lO\
l
.
lllOllll\
OO\

=
lllO\
llllOO
;
llOllllOlOl
.
lOllOOlOO\
Ol\

=
ll\
lOl\
lll\
OO
*
lOOl\
Oll\
OOO
;
llOllllOlO\
l\

.
Se\
tColl\
i\
sionO\
b\
jectA\

(
const_cas\
t
<
Collis\
io\
nO\
bj\
ect\
Conv\
e\
x
*
>
(
th\
is
)
)
;
ret\
ur\
n
true
;
}
re\
t\
urn
false\

;
}
Co\
llis\
ionO\
bje\
ct\
C\
o\
nvex
*
TAC_\
CA\
LL
Collisi\
onO\
bje\
ctConvex
::
CreateN\
e\
w
(
)
{
Collis\
i\
on\
ObjectCo\
n\
v\
ex
*
lOl\
O\
llOOlll
;
lOO\
O\
O\
Ol\
lOOO
(
lOlOl\
lOO\
lll
,
Coll\
ision\
Ob\
ject\
Convex
)
;
return
lOlOllOOll\
l
;
}
Collis\
ionO\
bjectCon\
ve\
x
::
Coll\
is\
io\
nOb\
j\
ectCo\
nv\
ex
(
)
:
Collisi\
onObj\
e\
ctSimple
(
Colli\
sion\
Object
::
TYPE\
_\
CONVEX\

)
{
lOlOO\
lOllO
=
0
;
}
Collis\
io\
n\
Ob\
j\
e\
ctConvex
::
~
Co\
l\
l\
isionObj\
e\
ct\
Convex
(
)
{
Finalis\
e\

(
)
;
}
void
Co\
llision\
Ob\
j\
ectCo\
nv\
ex
::
Ini\
t\
iali\
seCo\
m\
mon\

(
)
{
TA_ASSERT
(
lOlOOlO\
llO
)
;
lOlOOl\
OllO
->
lllll\
Olllll\

.
Ini\
t\
iali\
se\

(
0
,
lOlOOlO\
ll\
O
->
llll\
l\
O\
lllOl
.
lOO\
O\
lllO\
O\
l
(
)
)
;
const
in\
t
lOOOOO\
OOllll
=
lO\
lOOlOllO\

->
llll\
l\
O\
l\
llOl
.
lOOOl\
llOOl
(
)
+
lOl\
O\
O\
lOllO
->
ll\
lll\
OllllO\

.
lO\
O\
OlllO\
O\
l\

(
)
*
2
;
lOlOO\
lOllO
->
lll\
lllOOOOO
.
In\
itiali\
se
(
0
,
lOOOOOO\
Ollll\

*
si\
zeof
(
int
)
)
;
for\

(
in\
t
lOlllOOlll
=
0
;
lOl\
l\
l\
OOl\
ll
<
lO\
lOOlOll\
O\

->
ll\
ll\
lO\
l\
l\
lO\
l
.
lOOO\
l\
ll\
OOl
(
)
;
lO\
lllOO\
lll
++
)
{
lOlOOlO\
ll\
O
->
llll\
lOllll\
l\

.
lOO\
OlllOOO\

(
lOl\
OO\
lOllO\

->
ll\
llllOOOO\
O\

.
lOOOl\
l\
lOOl
(
)
)
;
lOlOOl\
O\
ll\
O\

->
llllllOOOO\
O
.
lOOlllllOl\

(
size\
of
(
int
)
)
;
int
&
lOOOOO\
OlOO\
OO\

=
(
in\
t\

&
)
lOlOO\
l\
OllO
->
llll\
llOOOO\
O\

[
lOlOO\
lOllO
->
ll\
ll\
llOO\
O\
OO\

.
lOO\
OlllOOl
(
)
-
si\
ze\
of
(
int
)
]
;
lOOOOOO\
l\
OOO\
O\

=
0
;
fo\
r\

(
int\

llOl\
OlO\
lOO\

=
0
;
ll\
OlOl\
O\
lOO
<
lOlOOlOllO
->
lll\
llO\
llllO
.
lOO\
Olll\
OOl\

(
)
;
llOlOl\
O\
l\
OO
++
)
{
if
(
lO\
lOOlOl\
l\
O
->
lllllO\
llllO
[
llOlOl\
OlOO\

]
.
lllllOl\
l\
OO\
O
==
lOlll\
OOlll
)
{
lOlO\
Ol\
Ol\
lO\

->
llllllOOOOO\

.
lOO\
lllll\
Ol\

(
si\
zeof
(
int
)
)
;
int\

&
lO\
OOOO\
OlO\
OOl
=
(
in\
t
&
)
lO\
lOOlOl\
lO
->
lll\
ll\
l\
O\
OOOO
[
lOlOOlOl\
lO\

->
llllllO\
OO\
OO
.
lOOOlllOOl
(
)
-
si\
z\
e\
of
(
int\

)
]
;
lOO\
OO\
OOlOOOl\

=
lO\
lO\
OlO\
llO
->
llll\
l\
Ol\
lllO
[
llOlOl\
O\
lO\
O
]
.
lllllO\
llO\
Ol
;
lOO\
OOO\
OlOOO\
O
++
;
}
else
if
(
lOlO\
O\
lOll\
O
->
llll\
lOl\
l\
llO
[
llO\
lOlOlO\
O
]
.
lll\
llO\
llOO\
l
==
lOll\
lOOl\
ll
)
{
lOlOOlOllO\

->
ll\
ll\
llOOOOO
.
lOOlll\
llOl\

(
sizeof\

(
int
)
)
;
int
&
lOO\
OOO\
O\
lOOOl\

=
(
in\
t\

&
)
lOlOOlOllO
->
llllllOOOOO\

[
lOl\
OO\
lOl\
l\
O\

->
llllllOOO\
OO
.
lO\
OOlllO\
Ol
(
)
-
sizeo\
f
(
int\

)
]
;
lOOOOOO\
lO\
OO\
l
=
lOlOOlO\
llO
->
lll\
l\
lO\
l\
ll\
lO
[
llOlOlOl\
OO
]
.
lllllOllOOO
;
lOOOO\
O\
OlOOOO
++
;
}
}
}
TA\
_\
ASS\
ER\
T
(
lOlOOlO\
llO
->
lllllOll\
ll\
l
.
lOOO\
l\
llOO\
l
(
)
==
lOl\
OO\
lOllO
->
ll\
lll\
Olllll
.
lO\
Ol\
lll\
Ol\
l
(
)
)
;
TA\
_\
A\
SSERT
(
lO\
lOOlOllO
->
llllllOOO\
O\
O
.
lOOO\
l\
ll\
OOl
(
)
==
lOl\
O\
OlOl\
lO
->
llll\
llOOOOO
.
lOOllll\
Oll
(
)
)
;
}
void
Coll\
isi\
onObjec\
tConvex\

::
llllll\
OOlOO\

(
con\
st\

AABB
&
lOOOOOOlll\

,
const
MFrame
*
lO\
OO\
OOOlOOlO
)
{
#ifdef lOOOOOOOllOO
lOO\
OOOOOl\
l\
O\
l
=
0
;
#endif //
if\

(
lOlOOlOllO
)
{
lOOOlllOlO\

(
0
,
"CollisionObjectConvex::InitialiseAsABox. Already initialised.")
;
Finalise
(
)
;
}
lOOOOOll\
OOO\

(
lOlOO\
l\
OllO
,
Data\

)
;
if
(
!
lOOO\
O\
OO\
lOOlO\

||
(
lOO\
OOO\
OlO\
OlO
->
m33R\
o\
tation
.
v3X
.
IsEq\
ualWit\
hInErr\
or
(
k_v3Un\
itX
,
0.00001f
)
&&
lO\
O\
O\
OOOlOOl\
O
->
m3\
3R\
ota\
ti\
on
.
v3\
Y
.
IsEqualW\
i\
thInError
(
k_\
v\
3Uni\
tY
,
0.00001f
)
&&
lOOOOOO\
lOOlO
->
m33Ro\
t\
at\
ion
.
v3Z
.
IsEqualW\
it\
hInError\

(
k_v3Un\
i\
tZ
,
0.00001f
)
)
)
lOlOOlOll\
O
->
lOl\
O\
llOOOl
=
Dat\
a\

::
lllll\
Olll\
OO
;
else
lO\
lOOlO\
llO
->
lOlOl\
lOOO\
l\

=
0
;
lO\
l\
OOlOllO
->
lllllOlllO\
l
.
Ini\
t\
i\
alise
(
8
,
8
)
;
lOlO\
OlOl\
lO
->
lllllOlllOl
[
0
]
.
In\
it\
ialise
(
1.0f
,
1.0f
,
1.0f
)
;
lOlOOlO\
l\
l\
O
->
lllllO\
ll\
l\
Ol
[
1
]
.
Initi\
alis\
e
(
-
1.0f
,
1.0f
,
1.0f
)
;
lO\
lOOlOll\
O
->
ll\
lll\
Olll\
Ol
[
2
]
.
Initial\
ise\

(
-
1.0f
,
1.0f
,
-
1.0f
)
;
lOlO\
Ol\
O\
ll\
O
->
lllll\
Ol\
ll\
O\
l\

[
3
]
.
Ini\
tiali\
se
(
1.0f
,
1.0f
,
-
1.0f
)
;
lOl\
OOlOllO\

->
lllll\
O\
ll\
l\
Ol
[
4
]
.
In\
it\
ia\
lise
(
1.0f
,
-
1.0f
,
1.0f
)
;
lOlOOl\
OllO\

->
ll\
lll\
O\
l\
l\
lOl
[
5
]
.
Initiali\
se
(
-
1.0f
,
-
1.0f
,
1.0f
)
;
lOlOOl\
OllO
->
lllllOl\
llO\
l
[
6
]
.
Ini\
tialise\

(
-
1.0f
,
-
1.0f
,
-
1.0f
)
;
lO\
lO\
OlOl\
lO\

->
llll\
lOlllO\
l
[
7
]
.
In\
i\
t\
i\
a\
lise
(
1.0f
,
-
1.0f
,
-
1.0f
)
;
for
(
int
lO\
ll\
lOOlll\

=
0
;
lOlllOOlll
<
lOlO\
Ol\
OllO\

->
llll\
lOll\
lO\
l
.
lOOOlllOO\
l
(
)
;
lO\
lllOOl\
ll
++
)
{
lOlO\
OlOllO
->
lllll\
Oll\
lOl\

[
lOl\
llOOlll\

]
.
x
*=
lOOOOOOlll
.
v3Exten\
t\

.
x
;
lOlO\
OlOll\
O
->
lllll\
Olll\
Ol\

[
lOll\
lOOll\
l\

]
.
y
*=
lOOOOOOlll
.
v3Ex\
tent
.
y
;
lO\
lO\
OlOllO
->
lllllOl\
llOl
[
lO\
lllOOlll
]
.
z
*=
lOO\
OO\
OOlll
.
v3E\
xt\
ent
.
z
;
lOlOOlOll\
O\

->
ll\
l\
llOlll\
Ol
[
lO\
ll\
lOOlll
]
+=
lOO\
OO\
OO\
lll
.
v3Center
;
if
(
lO\
OOO\
O\
OlOOlO\

)
{
lOlOO\
lOllO\

->
ll\
lllOlll\
Ol\

[
lO\
lllOOl\
ll\

]
*=
*
lOO\
OOOOlOOlO
;
}
}
int\

llO\
l\
ll\
OOOO\
O
=
llllllOOOll
(
4
)
*
6
;
lOlOO\
lO\
ll\
O
->
lOl\
lOOllOO\

.
Ini\
tialise
(
llOlll\
O\
OOO\
O
,
llOlllOOOOO
)
;
int
lOOO\
OOOlOOl\
l
=
0
;
Poly\
go\
n
*
llOOOlOOl\
O
;
lOlO\
O\
lO\
l\
l\
O
->
lOll\
OOll\
Ol
.
In\
iti\
al\
i\
se
(
6
,
6
)
;
lOlO\
OlOllO
->
lOll\
OO\
ll\
Ol
[
0
]
=
lOOOOO\
O\
lO\
Oll\

;
llOOO\
lO\
O\
lO
=
(
Pol\
ygon
*
)
&
lOlO\
Ol\
OllO\

->
lOllOOllOO
[
lOO\
OOOOl\
OOll
]
;
llOOOlOOlO\

->
lO\
llO\
llOl\
l\

=
4
;
ll\
O\
OO\
lOOlO\

->
llOll\
llOOO
[
0
]
.
llOll\
lOllO
=
3
;
llOO\
OlOOlO
->
ll\
Ol\
l\
llOOO
[
1
]
.
llOlllO\
llO\

=
2
;
ll\
OOOl\
OOlO
->
llOllllOOO
[
2
]
.
llOlllOllO
=
1
;
ll\
OOOl\
O\
O\
lO
->
llOl\
lllOOO
[
3
]
.
llOlllOllO
=
0
;
lOOO\
OOOlO\
Oll
+=
lll\
lllOOOll
(
llO\
OO\
lO\
O\
lO
->
lOl\
lOll\
O\
l\
l
)
;
lO\
lOOlOll\
O\

->
lOllOOllOl\

[
1
]
=
lOOOO\
O\
OlOO\
ll
;
llO\
O\
OlOO\
lO\

=
(
Pol\
y\
g\
o\
n
*
)
&
lOl\
OOlOllO
->
lO\
llOO\
llOO\

[
lOOOOOO\
l\
OOll
]
;
llOOOlOO\
lO\

->
lOllOll\
Oll
=
4
;
llO\
OOl\
OOl\
O
->
ll\
O\
l\
ll\
lOO\
O
[
0
]
.
ll\
OlllO\
l\
lO
=
4
;
llOOOl\
OO\
lO
->
llO\
llllOOO
[
1
]
.
llOl\
l\
lOll\
O
=
5
;
llOOOl\
OOlO\

->
ll\
Oll\
l\
lOOO
[
2
]
.
llO\
lllOl\
l\
O\

=
6
;
llO\
O\
Ol\
OOlO
->
llOll\
l\
l\
OOO\

[
3
]
.
llOlllOl\
lO
=
7
;
lOOOO\
OOlOO\
l\
l
+=
ll\
l\
lllOOOl\
l
(
llOOOlOO\
lO\

->
lO\
llOllO\
ll
)
;
lOlOOl\
OllO
->
lOll\
OO\
llOl
[
2
]
=
lO\
O\
OO\
OO\
lOOl\
l
;
llOOOl\
O\
OlO
=
(
Poly\
gon
*
)
&
lOlOOl\
Ol\
lO
->
lO\
llOOl\
lO\
O
[
lOOOOOOlOOll
]
;
ll\
O\
OOlOO\
l\
O
->
lO\
llOllOll
=
4
;
llOOOlOOlO
->
llO\
llllOOO
[
0
]
.
llOlllO\
llO
=
0
;
llOOO\
l\
O\
O\
lO
->
llOl\
l\
l\
lO\
O\
O
[
1
]
.
llOll\
lO\
ll\
O
=
1
;
llOOOlOO\
lO
->
ll\
OllllOOO
[
2
]
.
llO\
ll\
lOllO
=
5
;
llOO\
OlOOlO
->
ll\
O\
l\
lllOOO\

[
3
]
.
llOl\
llOllO
=
4
;
lOOOOOOlOOll\

+=
llllllO\
O\
Oll
(
llO\
OOl\
O\
O\
lO\

->
lOllOl\
lOll\

)
;
lOlOOlOllO
->
lOll\
OO\
ll\
O\
l
[
3
]
=
lO\
OOOOOl\
OOll
;
llOO\
OlOOlO\

=
(
Po\
lyg\
on
*
)
&
lOl\
O\
OlOllO
->
lO\
l\
lOOll\
OO
[
lOOOO\
OOlOOll
]
;
llOOOlOOlO
->
lO\
ll\
Oll\
Ol\
l
=
4
;
llOOO\
lOOlO\

->
llOl\
l\
ll\
OO\
O
[
0
]
.
ll\
OlllOll\
O
=
1
;
llOO\
O\
lOOl\
O
->
llOllll\
OOO
[
1
]
.
llOll\
l\
Oll\
O
=
2
;
llOOO\
lOO\
l\
O
->
llOll\
llOOO
[
2
]
.
ll\
Ol\
llOllO\

=
6
;
llOOO\
lOOlO
->
llOl\
ll\
lO\
O\
O
[
3
]
.
llO\
lll\
O\
ll\
O
=
5
;
lO\
OOO\
OOlOOl\
l
+=
llll\
ll\
OOOll
(
ll\
O\
OOlO\
OlO\

->
lO\
llOllOll
)
;
lOlOOlOllO\

->
lO\
l\
lOOllOl
[
4
]
=
lOOOO\
O\
Ol\
OOll\

;
llO\
O\
O\
lOOlO
=
(
Polygo\
n
*
)
&
lOl\
OOl\
Oll\
O
->
lO\
ll\
OOl\
lOO
[
lOOO\
OOOlO\
O\
ll
]
;
llOOOlO\
OlO
->
lOll\
OllOl\
l\

=
4
;
ll\
O\
OOlOOlO\

->
llOl\
ll\
lO\
O\
O
[
0
]
.
llO\
lllOllO
=
2
;
llOOOlO\
OlO
->
llOll\
llOO\
O\

[
1
]
.
llOlllO\
llO\

=
3
;
llOOOlOOl\
O
->
llOll\
l\
lOOO\

[
2
]
.
llOll\
lOllO
=
7
;
llOO\
OlO\
OlO
->
llOl\
lllOOO
[
3
]
.
llOl\
llOllO
=
6
;
lOOO\
O\
OOlOO\
ll
+=
ll\
l\
lllOO\
Oll
(
llOO\
Ol\
O\
OlO\

->
lO\
ll\
O\
llOl\
l\

)
;
lO\
l\
O\
OlOllO
->
lOl\
lO\
OllOl
[
5
]
=
lOOO\
OOO\
lOO\
ll
;
llOO\
Ol\
OOlO
=
(
Polygo\
n
*
)
&
lOlOOlOll\
O
->
lOll\
O\
OllO\
O
[
lOOO\
OOO\
lOOll
]
;
llOOOlOOl\
O
->
lOll\
Ol\
l\
O\
ll
=
4
;
ll\
OO\
OlO\
O\
lO\

->
ll\
OllllO\
O\
O
[
0
]
.
ll\
OlllO\
llO\

=
3
;
llOOOl\
O\
OlO
->
llO\
lll\
lO\
OO
[
1
]
.
llOlllOll\
O
=
0
;
llO\
O\
O\
lOO\
lO\

->
llO\
l\
lllO\
O\
O
[
2
]
.
llOlllOl\
lO
=
4
;
llOOO\
lOOlO
->
ll\
O\
ll\
l\
lOO\
O\

[
3
]
.
llOlllOl\
l\
O
=
7
;
lOO\
OOO\
OlO\
Oll
+=
llllllO\
OOll
(
llOOOlO\
OlO\

->
lO\
llOllO\
ll
)
;
TA_\
ASSERT
(
lO\
OOOO\
O\
l\
OOll
==
lOlO\
OlOl\
lO\

->
lOll\
OOllO\
O\

.
lOOOlll\
OO\
l
(
)
)
;
lOlOOlO\
llO\

->
lllllOll\
l\
lO\

.
In\
itia\
l\
ise
(
0
,
12
)
;
in\
t
llOlOll\
l\
l\
l
;
fo\
r
(
llOl\
Olll\
ll
=
0
;
llOlOlllll
<
lOlOOlO\
llO
->
lOl\
lOOllOl
.
lO\
O\
OlllOOl
(
)
;
llOlOll\
lll\

++
)
{
Polygon\

&
lOllO\
OOOll
=
*
(
Po\
l\
ygon
*
)
&
lO\
l\
O\
Ol\
OllO
->
lO\
llOOll\
OO\

[
lOlOO\
lOllO
->
lOllOO\
llOl
[
llOl\
Ollll\
l
]
]
;
TA_ASSER\
T
(
lO\
llOOOOll\

.
lOll\
O\
ll\
O\
ll
<=
lOl\
llOOlO\
Ol
)
;
for
(
int
lOlll\
OO\
ll\
l
=
0
;
lOl\
llO\
O\
ll\
l
<
lO\
ll\
OOO\
Ol\
l
.
lOll\
O\
l\
lOl\
l
;
lOl\
l\
lOOlll
++
)
{
lOllO\
O\
O\
Oll
.
llOl\
lll\
OOO
[
lO\
lllOOll\
l
]
.
llOlllOlll
=
-
1
;
}
}
fo\
r
(
llOl\
O\
ll\
l\
l\
l
=
0
;
ll\
OlOlllll\

<
lOlOOlO\
llO
->
lOll\
O\
OllOl\

.
lOOOll\
lO\
Ol
(
)
;
llOlOllll\
l
++
)
{
Poly\
g\
o\
n
&
lOl\
lOO\
OOll
=
*
(
Polygo\
n
*
)
&
lOlOOlOllO\

->
lOll\
OOl\
lOO
[
lOlOOlOllO
->
lOllOOll\
Ol
[
llO\
lOlllll
]
]
;
TA_A\
SSERT\

(
lOllO\
O\
OOll
.
lOllOll\
O\
ll
<=
lO\
l\
ll\
O\
OlOOl\

)
;
for\

(
int
lOlllOOl\
ll
=
0
;
lOlllOOl\
ll\

<
lOllOOOOl\
l
.
lOll\
Oll\
O\
l\
l
;
lO\
ll\
lOOl\
ll
++
)
{
int
lOOOOO\
OlOlOO
=
lO\
llOOOOll
.
llOl\
ll\
lOOO\

[
lO\
lllOO\
lll
]
.
llOll\
lOllO\

;
if
(
lOll\
OOOOll
.
llO\
l\
lll\
OOO
[
lO\
lllOO\
lll
]
.
ll\
O\
lll\
Olll
!=
-
1
)
continue
;
int
lOO\
O\
OOOlO\
lOl
=
(
lOlll\
O\
Ol\
ll
+
1
<
lOl\
lOOOOll
.
lO\
llOllOl\
l\

)
?
lO\
llOOOOll
.
ll\
O\
ll\
llOO\
O
[
lOll\
l\
O\
O\
lll
+
1
]
.
ll\
OlllO\
llO
:
lOllOOOO\
ll
.
ll\
O\
llllOOO
[
0
]
.
llOlllOllO
;
for
(
int
lOOO\
OOOl\
O\
ll\
O
=
llOl\
Ollll\
l\

+
1
;
lOOOOOOlOllO
<
lOlO\
OlO\
l\
l\
O
->
lOll\
O\
OllO\
l\

.
lOOOl\
l\
lOOl
(
)
;
lO\
OOOO\
OlOl\
lO
++
)
{
Po\
ly\
gon
&
lOOO\
OO\
O\
lOl\
ll
=
*
(
Pol\
ygon
*
)
&
lOl\
OOlOllO
->
lOll\
OO\
l\
lOO
[
lOl\
O\
O\
lOllO
->
lOllOO\
llOl
[
lOOO\
OO\
O\
lOllO\

]
]
;
for
(
in\
t\

lOO\
OO\
O\
OllOO\
O
=
0
;
lO\
OOOOOllOOO
<
lOO\
OOOOl\
Ol\
l\
l
.
lOll\
OllOll
;
lOOO\
OOOllO\
OO
++
)
{
int\

lOOOOO\
OllO\
Ol
=
lOOOOOOlOll\
l
.
llOllll\
OOO
[
lOOOOOOllO\
OO
]
.
llOlll\
Ol\
lO\

;
in\
t
lOO\
O\
OOOllOl\
O
=
(
lOO\
OOOOl\
lOO\
O\

+
1
<
lOOOOO\
O\
lOlll\

.
lOllOl\
lO\
ll
)
?
lOOOOO\
OlOl\
ll
.
llO\
llllOOO
[
lO\
OOO\
O\
Ol\
lOO\
O\

+
1
]
.
ll\
Oll\
lOll\
O
:
lO\
OOOOO\
lOlll\

.
llOllllOO\
O
[
0
]
.
llO\
lll\
O\
llO\

;
if\

(
(
lO\
O\
OOO\
OlOlOO
==
lO\
OOOOO\
ll\
OO\
l
&&
lO\
OOOOOl\
OlO\
l\

==
lO\
O\
OOOOllOl\
O
)
||
(
lOO\
O\
OOOlO\
lOO
==
lOO\
OOOOllOlO\

&&
lOO\
OOOO\
lOlOl\

==
lOO\
OO\
O\
OllO\
O\
l
)
)
{
lOllO\
O\
OOll
.
llOll\
llOO\
O
[
lO\
ll\
lOOll\
l
]
.
llOlllOl\
ll
=
lO\
OOO\
OOlOllO\

;
lO\
O\
OOOO\
l\
Ol\
ll
.
llOllllO\
OO
[
lO\
OO\
O\
O\
O\
llO\
OO
]
.
llOl\
l\
lOll\
l
=
llOlOlllll
;
lllllOl\
Olll
&
llO\
lOlOOO\
O\

=
lOlO\
O\
lOllO
->
ll\
lll\
O\
l\
lll\
O
.
lO\
OOll\
lOOO\

(
)
;
llOlOlOOO\
O\

.
lllllOllOO\
O
=
lOOOOOOlO\
lOO
;
llOlOl\
OOOO
.
llll\
lOl\
l\
OOl\

=
lOOOOO\
OlOl\
Ol\

;
llOlOl\
OOOO\

.
llOl\
OllO\
OO
=
llO\
l\
O\
l\
lll\
l
;
ll\
Ol\
O\
lOO\
OO\

.
llOl\
OllO\
Ol\

=
lOOO\
OO\
Ol\
O\
llO
;
br\
eak
;
}
}
}
TA_AS\
SERT
(
lOllOOOO\
l\
l
.
ll\
Ol\
lllOOO\

[
lOlll\
OOlll
]
.
ll\
O\
lllOl\
l\
l
!=
-
1
)
;
}
}
TA_ASSERT
(
lOlO\
OlOll\
O
->
lllllOll\
ll\
O
.
lO\
OO\
ll\
lOOl
(
)
==
lOlO\
O\
l\
OllO
->
lllllO\
llllO
.
lOO\
lll\
lO\
ll\

(
)
)
;
for
(
llOl\
Olllll
=
0
;
llOlO\
llll\
l\

<
lOlOOlOllO
->
lOllO\
Ol\
lOl
.
lOOO\
lllOO\
l
(
)
;
llOlOll\
ll\
l\

++
)
{
Polygon\

&
lO\
llOOOOll
=
*
(
Polygon\

*
)
&
lO\
lO\
OlOllO
->
lOllOOll\
OO
[
lO\
l\
OOlOllO
->
lOll\
O\
OllO\
l
[
ll\
OlOl\
llll
]
]
;
TA_AS\
SERT
(
lO\
llOOOOl\
l
.
lO\
llO\
llOll
<=
lOlll\
OOlOOl
)
;
Vec3
lO\
OOlOOOOO\

;
lOO\
Ol\
OO\
OOO\

.
Clear
(
)
;
int\

lOll\
l\
OOlll
;
for\

(
lOll\
lO\
Ol\
l\
l
=
1
;
lOlll\
OOll\
l
<
lO\
l\
lO\
O\
OOll
.
lOllOll\
O\
ll
;
lOlllOOl\
ll
++
)
{
in\
t
llO\
Oll\
OO\
ll\

=
lO\
ll\
lOOlll
;
Ve\
c\
3
&
lllll\
llll\

=
lOlOOlOl\
lO
->
llll\
lO\
ll\
lOl
[
lOllOOOOll\

.
ll\
Oll\
llO\
OO
[
llOO\
l\
lOOl\
l
]
.
llO\
l\
ll\
Ol\
l\
O
]
;
int
llOOllO\
l\
OO\

=
(
lOlllOOlll
+
1
<
lO\
llO\
O\
OOll\

.
lOllO\
l\
lOl\
l
)
?
lOl\
llOOl\
l\
l
+
1
:
0
;
Vec3
&
lOOO\
OO\
O\
O\
OO
=
lO\
lO\
OlOl\
lO\

->
ll\
l\
ll\
Oll\
lO\
l\

[
lO\
l\
l\
OOOOl\
l
.
llOllllOOO
[
llOOllO\
lOO\

]
.
llO\
lllOllO
]
;
Vec\
3
&
llllOOOl\
l\
O
=
lOlOOlOllO
->
lll\
llOlllOl\

[
lOllOOOOl\
l\

.
llOlll\
lOOO
[
0
]
.
llOl\
llOl\
l\
O
]
;
Vec3\

lOlll\
OlOlOl
=
lOOOlOO\
OOO
.
Cross
(
lOOO\
OO\
OO\
OO
-
llllllll\
l
)
;
lO\
O\
OlO\
OOOO
+=
(
lllllllll
-
ll\
llO\
OOllO\

)
.
Cross\

(
lOOO\
O\
OOOOO
-
ll\
llOO\
O\
llO\

)
;
}
floa\
t
lO\
lll\
lOO\
ll
=
lOOO\
lOO\
OO\
O\

.
Ge\
tM\
agni\
t\
ude
(
)
;
TA_ASS\
E\
RT
(
lOll\
llOOl\
l
>
0.0f
)
;
lOOOlOOOO\
O
/=
lOllll\
OOll
;
lOllOO\
O\
O\
ll
.
lOOO\
lOOOOO
=
lOOOlOO\
OOO
;
lO\
llOO\
OOl\
l
.
lOlOllOll\
l
=
lOl\
lOOOOll
.
lOOO\
lOO\
OOO
.
Dot
(
lOl\
OOlOl\
lO
->
lll\
l\
lOlll\
Ol\

[
lO\
llOOOO\
ll
.
ll\
O\
ll\
llO\
OO
[
0
]
.
ll\
O\
lllO\
llO
]
)
;
for
(
lOll\
lOOl\
ll
=
0
;
lOl\
llOOl\
l\
l
<
lO\
ll\
OO\
OOll
.
lOllOll\
O\
ll
;
lOl\
llOO\
lll
++
)
{
in\
t
llOOllOOll
=
lOll\
lO\
Oll\
l\

;
Vec3
&
lll\
l\
ll\
lll
=
lOlOOlO\
llO
->
lllllOlll\
O\
l\

[
lO\
l\
lOOO\
Ol\
l
.
llOl\
l\
l\
l\
O\
OO
[
llOO\
l\
lOO\
l\
l\

]
.
llOll\
l\
OllO
]
;
int
llOOllOlOO\

=
(
lOlllOO\
lll
+
1
<
lOl\
lOOOOll
.
lOllOll\
Ol\
l
)
?
lO\
lllOO\
lll\

+
1
:
0
;
Vec\
3
&
lO\
O\
OO\
OOOOO
=
lOlOOl\
O\
ll\
O
->
lll\
ll\
OlllO\
l
[
lOll\
O\
OO\
O\
ll\

.
llOllllOOO\

[
llOOl\
lOl\
OO
]
.
ll\
O\
lll\
O\
l\
l\
O
]
;
Vec\
3
lO\
lll\
OlOlOl
=
lOO\
O\
lO\
OO\
O\
O
.
Cr\
oss
(
lOOOO\
OO\
O\
O\
O
-
lllllllll\

)
;
lOllllOO\
l\
l
=
lOlllOl\
Ol\
O\
l
.
GetM\
a\
g\
n\
i\
tude
(
)
;
TA_A\
S\
SERT
(
lOlll\
lOOl\
l\

>
0.0f
)
;
lOl\
l\
lOlO\
l\
O\
l
/=
lOl\
ll\
lOO\
l\
l
;
lOllOOOOll
.
llOllllOOO
[
lOll\
lOOll\
l
]
.
lOlll\
OlOlO\
l
=
lOl\
llO\
l\
O\
lOl
;
}
}
llllllOllOO
(
)
;
Initi\
ali\
seCommo\
n
(
)
;
}
void
Coll\
isionObj\
ectConve\
x
::
ll\
llll\
O\
llO\
O
(
)
{
TA_ASS\
ERT
(
lOl\
OO\
lOllO\

)
;
lOlO\
OlOllO
->
lllOl\
lOO\
OOO\

.
Cle\
ar
(
)
;
if
(
lOlOOlOllO\

->
lOlO\
llOOOl
&
Dat\
a\

::
llll\
l\
O\
ll\
lOO\

)
{
if
(
lOlOOlO\
llO
->
lllllOlll\
Ol\

.
lOOOll\
lO\
O\
l
(
)
)
{
lO\
l\
O\
OlOllO
->
lO\
OO\
O\
OOl\
ll\

.
Initiali\
se
(
lOlOOlOllO
->
lll\
l\
lOlllOl\

[
0
]
,
k_v3Zero
)
;
for\

(
int
lO\
lllO\
Olll
=
1
;
lOll\
l\
OO\
lll
<
lOlO\
Ol\
OllO
->
lllllOl\
llOl
.
lOOOlllOO\
l
(
)
;
lO\
lll\
O\
Olll
++
)
lOlOOlOllO
->
lOOO\
OOOlll
.
Exp\
andTo\
Fit\

(
lOlOOlOllO
->
lllllOll\
lO\
l
[
lOll\
lO\
O\
l\
l\
l
]
)
;
lOlOOlO\
llO
->
lllOllO\
O\
O\
O\
O\

=
lOlOOlOllO
->
lO\
OO\
OO\
Ol\
l\
l\

.
v3\
Center
;
}
}
el\
s\
e
{
if
(
lO\
l\
OO\
lO\
llO
->
lllllO\
lllO\
l
.
lOOOlllOOl
(
)
)
{
for\

(
int
lOl\
llO\
Oll\
l
=
0
;
lO\
lllOOll\
l
<
lOl\
OOlOllO
->
ll\
lllO\
l\
ll\
O\
l\

.
lOOOll\
lOOl
(
)
;
lOll\
l\
OO\
ll\
l
++
)
lOlO\
O\
lO\
l\
lO
->
ll\
lO\
l\
lOOOO\
O
+=
lO\
lOO\
lOllO
->
lllllOlllOl
[
lO\
l\
llOOlll
]
;
lO\
lOOl\
Oll\
O
->
lll\
Ol\
l\
OO\
OOO
/=
(
float\

)
lO\
lOOlOll\
O
->
ll\
lll\
O\
lll\
Ol
.
lOOOl\
ll\
O\
O\
l
(
)
;
}
}
}
void
Collis\
ionO\
bj\
ec\
tConvex\

::
llll\
llOl\
OlO
(
)
{
for
(
int
llOlOl\
llll\

=
0
;
ll\
O\
lO\
l\
llll
<
lO\
l\
OOlOllO
->
lOllOO\
llOl
.
lOOOlllO\
Ol
(
)
;
ll\
O\
lOlll\
ll\

++
)
{
Polygo\
n
&
lOl\
lOOOOll
=
lll\
lllOOOOl
(
th\
is
,
llO\
l\
Olll\
ll\

)
;
TA\
_ASSERT
(
lOll\
OOOO\
ll\

.
lO\
ll\
O\
llOl\
l
>=
3
)
;
in\
t\

lllllOll\
OOO
=
lO\
l\
lOOOO\
ll
.
llOlll\
lOOO\

[
0
]
.
ll\
O\
lll\
O\
ll\
O
;
Ve\
c\
3
lOOO\
lOOOOO\

;
lOO\
O\
lO\
OO\
OO
.
Clear
(
)
;
int
llllllOl\
Oll\

;
for
(
llllllO\
lOl\
l
=
1
;
llllllO\
lOl\
l
<
lO\
l\
lOOOOll\

.
lOl\
lOl\
lOll\

;
ll\
l\
ll\
lO\
lOl\
l
++
)
{
int
ll\
lllOl\
lO\
Ol
=
lO\
l\
l\
OOO\
Oll
.
llOllllOOO
[
lll\
lllOlOll
]
.
llO\
l\
ll\
O\
llO
;
int
lOOO\
OOO\
llOll\

=
lO\
llOO\
OOl\
l
.
llOl\
l\
llOO\
O
[
lll\
llO\
O\
lOOO\

(
lOllOO\
O\
Oll\

,
llllllO\
lO\
ll
)
]
.
llO\
l\
l\
lOl\
lO
;
lOO\
O\
lOOOOO
+=
(
lOlOO\
lOllO\

->
llll\
l\
Oll\
lOl
[
ll\
lllO\
ll\
OOl
]
-
lO\
lOOl\
Oll\
O
->
ll\
lllOlllOl\

[
lllllOl\
lOO\
O
]
)
.
Cross\

(
lOl\
O\
Ol\
OllO\

->
ll\
lll\
Ol\
llOl
[
lO\
O\
OOOOllOll
]
-
lOlOOl\
Oll\
O
->
lllll\
OlllOl
[
lllllOllOOO
]
)
;
}
TA\
_ASSERT
(
lO\
O\
OlO\
OOOO\

.
Get\
Mag\
nitu\
de
(
)
>
0.0f
)
;
lO\
OOlOOOOO
.
Normalis\
e
(
)
;
lO\
llOOOOl\
l\

.
lOOOl\
OOOOO
=
lOOOlOOOOO
;
lOllO\
OOOll
.
lOlO\
ll\
O\
l\
ll\

=
lOOOlOO\
OOO
.
Dot
(
lOl\
OOl\
Oll\
O
->
llll\
lOlllOl
[
lllllOllOOO\

]
)
;
for\

(
ll\
llllO\
lO\
ll
=
0
;
ll\
ll\
ll\
OlO\
ll
<
lOllOOO\
Ol\
l
.
lOllOll\
O\
ll
;
lll\
l\
llO\
lOll
++
)
{
int
llll\
lO\
llOOl
=
lOll\
OO\
O\
Oll\

.
llOllllOOO
[
ll\
lll\
lO\
lOll
]
.
llOlllO\
llO\

;
in\
t
lOOOOOOl\
lOll
=
lOl\
lOO\
OOll
.
llO\
ll\
l\
lOOO
[
lll\
llO\
OlOO\
O
(
lOllO\
O\
O\
Ol\
l
,
lll\
lllOlOll\

)
]
.
llOll\
lOllO
;
Ve\
c\
3
lOll\
lOl\
OlOl
=
lOOO\
l\
O\
OO\
OO
.
Cro\
ss
(
lO\
lOOlOllO
->
lllllOlllOl
[
lOO\
O\
OOOllOll
]
-
lO\
lOO\
l\
OllO
->
lllllOll\
lO\
l
[
lllllOllO\
O\
l
]
)
;
TA_\
ASSERT
(
lO\
lllOl\
OlO\
l\

.
GetMagn\
itud\
e
(
)
>
0.0f
)
;
lOlllO\
lOlOl\

.
Nor\
malis\
e
(
)
;
lO\
llOOOOll\

.
ll\
Ol\
ll\
lOOO\

[
llll\
ll\
O\
l\
Oll
]
.
lOll\
l\
OlO\
lOl
=
lOlllO\
lOlOl
;
}
}
}
in\
line
void
Coll\
isionOb\
jectCo\
nv\
e\
x
::
lO\
OOOOOlll\
O\
O
(
in\
t
lOOOO\
OO\
ll\
lOl\

,
const
Vec\
3
*
lO\
OOO\
O\
OOO\
l\
Ol
,
in\
t
&
lOO\
OO\
OOllllO
,
int
&
lOOOO\
OOl\
l\
lll
,
flo\
at
&
lO\
OOOOl\
OO\
O\
OO
)
co\
nst\

{
TA_\
A\
SSERT\

(
lO\
l\
OO\
l\
OllO\

)
;
in\
t\

llOl\
Oll\
lll
;
for
(
llOl\
O\
l\
llll
=
0
;
llOlOlllll
<
lOl\
OOl\
OllO
->
lOllOO\
ll\
Ol\

.
lOO\
O\
l\
ll\
OOl
(
)
;
llOlOl\
l\
lll\

++
)
{
Polygon
&
lOllOO\
OO\
l\
l
=
lll\
lll\
OOOOl
(
th\
is
,
ll\
OlOlllll\

)
;
floa\
t
lO\
O\
OOO\
l\
OOOOl\

=
k_\
fM\
axFlo\
at
;
int
lOO\
OO\
OlOO\
OlO
=
-
1
;
for\

(
int
lOlll\
OO\
lll
=
0
;
lO\
l\
ll\
OOlll\

<
lO\
OOOO\
O\
lll\
O\
l\

;
lOl\
l\
l\
OO\
lll
++
)
{
flo\
at
lOlOllO\
lll\

=
lOllO\
OOOll
.
lO\
OO\
l\
OO\
OOO
.
Dot
(
lOO\
O\
O\
OOOOlO\
l\

[
lOll\
lOOlll
]
)
-
lOllOOOOll
.
lOl\
OllO\
l\
ll
;
if
(
lOO\
OOOlOO\
OOl
>
lOlOllOll\
l
)
{
lOO\
OOOlOOOOl
=
lOlO\
l\
lO\
lll\

;
lO\
OOOOlOOOlO
=
lO\
lllOOlll
;
}
}
TA_A\
SSE\
RT
(
lOO\
O\
OOl\
O\
O\
OlO
!=
-
1
)
;
if
(
lOOOOO\
lOOOOO\

<
lOO\
OOOlOO\
OOl
)
{
lO\
OOOOlOO\
OOO
=
lOO\
O\
OOlOOOOl
;
lO\
OOO\
OOllllO
=
llO\
lOl\
llll
;
lOOOOOO\
ll\
lll
=
lOO\
OOO\
lOO\
OlO
;
}
}
TA_ASSE\
RT\

(
lOOOOO\
O\
ll\
l\
lO
!=
-
1
)
;
TA_ASSERT\

(
lOOOO\
O\
O\
lllll\

!=
-
1
)
;
}
inlin\
e
void
Collisi\
onObjectCon\
v\
e\
x
::
lOO\
OOOlOOOll
(
in\
t\

lO\
OOOOOlll\
Ol
,
co\
ns\
t
Ve\
c\
3
*
lOOOOOlO\
Ol\
OO
,
cons\
t
Vec3
*
lOO\
O\
O\
OlOO\
lOl\

,
Po\
lygo\
n
&
lO\
l\
l\
OO\
OOll\

,
lOllO\
l\
lO\
llO
*
lOl\
ll\
O\
OOOO\
l\

,
cons\
t
MFram\
e
&
lOO\
O\
O\
OOO\
Ol
,
flo\
at
lOOOOOlOO\
l\
l\
O
)
co\
n\
st\

{
for
(
int
llllllOO\
ll\
l
=
0
;
lllll\
lOOl\
ll
<
lOO\
OOO\
OlllO\
l
;
lll\
lllO\
O\
ll\
l
++
)
{
co\
nst
Vec3
&
lllllllll
=
lOOO\
O\
O\
lOOlO\
O\

[
lll\
lll\
OOlll
]
;
const
Ve\
c3
&
lOOOO\
OOO\
O\
O
=
lOOOOOlOOlOl
[
llll\
l\
lOO\
lll
]
;
float
lOlO\
llO\
OlO
=
lOll\
OOOOll
.
lOOO\
lOOOOO
.
Dot
(
lll\
llllll
)
-
lOllOOO\
Ol\
l\

.
lOlOll\
Olll\

;
fl\
oa\
t
lOlOllOOl\
l\

=
lO\
l\
lO\
OOOll
.
lOOOl\
O\
O\
OOO
.
Dot
(
lO\
OOOOO\
OOO
)
-
lOllOOOOll
.
lOlOllOlll
;
floa\
t\

ll\
l\
O\
l\
lllO\
O
;
float
lOllOO\
lO\
O\
Ol\

;
Vec3
ll\
OOllllOO\

;
if
(
lOlOllOO\
lO
>
0.0f
)
{
if\

(
lOlOll\
OO\
ll
>
0.0f
||
!
lOll\
lOOOOOl
->
lOllO\
l\
llOOl
)
conti\
n\
ue
;
TA\
_ASSERT\

(
(
lOlOl\
lOOlO
-
lOlO\
llOOll\

)
!=
0
)
;
lllOlll\
lOO\

=
lOlOllOOl\
O
/
(
lOlO\
ll\
OOlO
-
lOlOll\
OOl\
l
)
;
lOl\
lOOlOO\
Ol
=
0
;
llOOllll\
OO
=
lllllllll\

+
lllOl\
lllO\
O\

*
(
lOOOOOO\
OOO\

-
ll\
lllllll\

)
;
}
else
{
lll\
Olll\
lO\
O
=
0.0f
;
lO\
l\
l\
OOl\
OOOl
=
-
lOlOllOOlO
;
llO\
Ollll\
OO
=
llll\
l\
lll\
l
;
}
in\
t
llOlOlOlOO\

;
for
(
ll\
OlOlOlO\
O
=
0
;
llOl\
OlOlOO
<
lOl\
l\
OOOOl\
l
.
lO\
l\
l\
OllOl\
l\

;
llOlO\
l\
Ol\
O\
O
++
)
{
con\
st
Vec3\

&
ll\
llllll\
l
=
lO\
lO\
OlOl\
lO
->
lllllOlllO\
l
[
lOllOO\
OOll\

.
llO\
llllOOO
[
llOlOlO\
lOO
]
.
ll\
OlllOllO
]
;
con\
st\

Vec3
&
lO\
OOlOOOOO\

=
lOllO\
OOOll
.
llOllllOOO
[
llOlO\
lOlOO
]
.
lOlll\
OlOl\
Ol\

;
if
(
lO\
OO\
lOOOOO
.
Dot
(
llOOll\
llOO
-
lll\
lll\
lll
)
<
0.0f
)
break
;
}
if
(
llO\
lO\
l\
OlO\
O\

!=
lOl\
lOO\
O\
O\
ll
.
lOllO\
l\
lOl\
l\

)
continue
;
Collis\
i\
on
lOllOllO\
lOl\

;
lOllOllOl\
Ol\

.
Init\
ial\
ise
(
Collision
::
lOllOOl\
lllO
,
ll\
lOllll\
OO\

,
lOllO\
Ol\
OOO\
l
,
llOOll\
llOO
*
lO\
OOOOOOO\
l
,
(
lOl\
lOOOOll
.
lOOOlOO\
OOO
*
lO\
OOO\
O\
lO\
O\
llO
)
*
lO\
OOOOOO\
Ol
.
m33\
Ro\
tation
)
;
lllOl\
llO\
llO\

(
lOllOllO\
lOl
,
lOlll\
OOOO\
Ol\

)
;
}
}
fl\
o\
at
Colli\
sionOb\
jec\
tConvex
::
lOOO\
OOlO\
Olll\

(
con\
st
Vec3
*
lO\
OOO\
OlOlOOO
,
const\

Co\
llision\
Obje\
ctCo\
n\
vex\

&
lllO\
l\
lO\
llOl
,
int
&
lOOOOOlOlOOl\

,
in\
t
&
lOOOOOl\
OlOlO
)
co\
n\
st
{
con\
st
Collis\
ionO\
bjec\
tCon\
vex\

&
ll\
lOllOl\
lOO
=
*
th\
is
;
floa\
t\

lOOOOOl\
Ol\
Oll
=
k_\
f\
Max\
Float
;
for
(
;
;
)
{
bool
lOOO\
OOlOllOO
=
true\

;
{
const
Vec\
3\

&
lOOOOOl\
OllO\
l
=
lOOOOOl\
OlOOO
[
lOOOOO\
lOl\
OlO\

]
;
co\
ns\
t
Coll\
isi\
onObjectC\
on\
vex
::
Po\
lyg\
on
&
lOll\
OlOOOO
=
llll\
ll\
OO\
O\
O\
l
(
&
lllO\
l\
lOll\
OO
,
lOOOOOlO\
lOOl\

)
;
lOO\
OOOlO\
lOll
=
lOllO\
lOOOO
.
lOOO\
lOOOOO\

.
Do\
t
(
lOOOOO\
lOllOl\

)
-
lO\
ll\
OlOOOO\

.
lO\
lOllOlll
;
fo\
r
(
int
lO\
O\
OllOOO\
l
=
0
;
lOO\
Oll\
OO\
O\
l
<
lOll\
OlOOO\
O
.
lO\
llOl\
lO\
l\
l
;
lOOOl\
lOOOl
++
)
{
const
Coll\
i\
sionObjectConvex
::
Poly\
go\
n\

&
lOO\
OO\
O\
lOlllO
=
llllllOOOOl
(
&
lll\
Ol\
l\
Oll\
OO
,
lO\
llO\
lOO\
OO
.
llOllllOOO
[
lOOOl\
lOO\
Ol\

]
.
llO\
lllO\
lll
)
;
float
lOlOllOll\
l
=
lOOOOO\
l\
O\
lllO
.
lOOOlOOOOO
.
Dot\

(
lOOOO\
O\
lOllO\
l\

)
-
lO\
O\
O\
OOl\
Olll\
O
.
lO\
l\
O\
l\
lOlll
;
if
(
lOOOOOlOlOll
<
lOlOllO\
lll
)
{
lOOOOOlOl\
Oll
=
lOlOll\
Olll
;
lOOOOOlOlOOl\

=
lO\
OOl\
lOOOl\

;
lOOOOOlOl\
lO\
O\

=
false\

;
}
}
}
{
cons\
t
Colli\
s\
io\
n\
Obj\
ectCo\
n\
vex
::
Po\
lyg\
o\
n\

&
lOllOl\
OO\
O\
O
=
llllllOOOOl
(
&
ll\
lOl\
l\
Oll\
OO
,
lOOOOOlOlOO\
l
)
;
const
Vec3
&
lOO\
OO\
OlOl\
lOl
=
lO\
OOOOlOlOOO
[
lOO\
OOOl\
OlOl\
O
]
;
cons\
t
Collis\
io\
n\
Ob\
jec\
t\
Convex\

::
Verte\
x
&
lOO\
O\
OO\
lOll\
ll
=
llllll\
OOOl\
O
(
&
lll\
OllOll\
OO\

,
lOOOOOlOlOl\
O
)
;
lOOOO\
OlO\
l\
Ol\
l
=
lOl\
lO\
l\
OOOO\

.
lO\
OO\
lOOOOO
.
Dot
(
lOOOOOl\
OllOl
)
-
lOllOl\
OO\
OO
.
lO\
l\
OllOll\
l\

;
for
(
int\

lOOOllO\
OOl\

=
0
;
lOOOllOO\
Ol
<
lOO\
OOOlOllll
.
lll\
llOllOlO
;
lOOOll\
OOOl
++
)
{
co\
nst\

Vec3
&
lO\
OO\
O\
OllOO\
O\
O
=
lOOOOOlOl\
O\
OO
[
lOOOOOlO\
llll
.
llll\
l\
OllO\
ll
[
lOO\
Ol\
lOOO\
l
]
]
;
flo\
at
lO\
lOllOlll
=
lOllOlOO\
O\
O
.
lOOOlOOOO\
O\

.
Dot
(
lOO\
OOOllO\
O\
OO
)
-
lOllO\
lOO\
OO\

.
lOlOll\
O\
lll
;
if
(
lOOOOOlOlOll\

>
lOl\
OllOlll
)
{
lOOOOO\
l\
OlO\
ll
=
lOlOl\
lOlll
;
lOO\
OOOlOlOlO
=
lOOOOOl\
Ollll
.
lllllOllOll
[
lOOOllO\
OOl
]
;
}
}
}
if\

(
lO\
O\
OO\
OlOl\
lOO
)
brea\
k
;
}
re\
turn
lOOOOOlO\
lO\
ll
;
}
int\

Col\
l\
i\
sionObje\
ctConvex
::
lOO\
OOOl\
lOO\
Ol
(
in\
t
lOOOOOOlllll
,
co\
ns\
t
Vec3
&
lOOOOOllO\
OlO
)
co\
nst
{
const
Ve\
c3
&
lOOO\
O\
OllOOll\

=
lOlOOlO\
llO
->
ll\
lllOll\
lOl
[
lOOO\
OO\
Oll\
lll
]
;
cons\
t
Col\
l\
isionObjec\
tConve\
x
::
Ve\
r\
tex
&
lO\
OOOOOOlO\
lO\

=
llll\
l\
lO\
OOlO\

(
this
,
lOO\
OOO\
Olll\
ll
)
;
floa\
t
lOOO\
OO\
lOl\
Oll
=
lOOOOOllOOlO
.
Do\
t
(
lOOOOOllOOll
)
;
for
(
;
;
)
{
boo\
l
lO\
O\
OOOl\
lO\
lOO
=
fa\
ls\
e
;
for\

(
in\
t
lOOOllO\
O\
O\
l\

=
0
;
lOO\
Oll\
O\
OOl
<
lO\
O\
OOOOOlOlO\

.
lllll\
OllO\
lO
;
lO\
OOllOOOl
++
)
{
co\
n\
st
Ve\
c3
&
lOOOOOllOlO\
l
=
lOlOOl\
Oll\
O
->
lll\
llOlllOl
[
lOOOOOOOlOlO\

.
ll\
lllOllOll
[
lO\
OOl\
lOO\
Ol\

]
]
;
flo\
at
lOlOllO\
l\
ll
=
lOOO\
OOllO\
Ol\
O
.
Do\
t
(
lOOOOOl\
l\
Ol\
Ol
)
;
if
(
lOOOOO\
lOlOll\

>
lOlO\
llO\
l\
ll
+
Fab\
s
(
lO\
l\
Ol\
lOl\
ll\

)
*
0.001f
)
{
lOOO\
OOlOlOll
=
lOlO\
llOll\
l
;
lOOOOOO\
lllll
=
lO\
OOOOOOlOlO
.
llll\
lOl\
lOl\
l\

[
lOOO\
ll\
OOO\
l
]
;
lOO\
OOOllOlO\
O\

=
tr\
ue
;
}
}
if
(
!
lOOOO\
O\
llOlO\
O
)
return\

lOOOOOOll\
l\
l\
l
;
}
}
int
Collis\
ionO\
bjec\
t\
Convex
::
lO\
O\
OOO\
l\
lOl\
lO\

(
const
Vec3
&
lOOOO\
OllOOl\
O
)
cons\
t\

{
if
(
lOlOO\
l\
OllO\

->
lO\
l\
Oll\
OOO\
l\

&
Data
::
lllllO\
lll\
OO
)
{
Vec3
lOlOOO\
OOOl\
l\

=
lOl\
OO\
l\
Ol\
lO
->
lOOOOOOlll
.
v3C\
ente\
r\

-
lOOO\
OO\
llOOlO
;
u32\

lO\
OOlO\
Ol\
ll\

=
(
(
(
u3\
2
&
)
lOl\
O\
OOOOOl\
l
.
x
)
>>
31
)
|
(
(
(
(
u32
&
)
lO\
lOOOOOO\
ll\

.
y
)
>>
30
)
&
0x2
)
|
(
(
(
(
u3\
2
&
)
lOlO\
OOOOOll
.
z
)
>>
29
)
&
0x4
)
;
TA_ASS\
ERT
(
lO\
O\
Ol\
OOlll
>=
0
)
;
TA_A\
SS\
E\
RT
(
lO\
O\
O\
lOOlll
<
8
)
;
sta\
ti\
c\

co\
nst
int
lOO\
OOOllOll\
l\

[
8
]
=
{
0
,
1
,
4
,
5
,
3
,
2
,
7
,
6
}
;
retur\
n
(
lOOOO\
OllO\
lll\

[
lO\
O\
OlOOlll\

]
)
;
}
int
lOOOOO\
Olll\
l\
l
=
-
1
;
flo\
a\
t
lOOOOOl\
O\
lOl\
l
=
k_fM\
axF\
lo\
at\

;
for
(
int
lO\
ll\
l\
OO\
lll
=
0
;
lOll\
lOOlll
<
lOlOOlOll\
O\

->
lll\
ll\
OlllOl\

.
lOOOlllO\
Ol
(
)
;
lO\
lll\
OOlll
++
)
{
co\
ns\
t
Vec3\

&
llOOll\
llOO
=
lO\
lOOlOll\
O\

->
ll\
lll\
OlllOl
[
lO\
ll\
lOO\
lll
]
;
fl\
oat\

lOlOllO\
l\
l\
l
=
llOOll\
ll\
O\
O\

.
Dot\

(
lOOOOOl\
lO\
Ol\
O
)
;
if\

(
lOO\
OOOlO\
l\
Ol\
l
>
lOlOll\
O\
lll\

)
{
lO\
OOOO\
lOl\
Oll
=
lO\
lOllOl\
ll\

;
lOOOOOOl\
llll
=
lOlll\
OO\
lll
;
}
}
TA_ASS\
E\
R\
T
(
lO\
OOOOOl\
llll
!=
-
1
)
;
re\
tu\
rn\

lO\
OOOOOlll\
l\
l\

;
}
#ifndef DOXYGEN
stru\
c\
t
lO\
OOO\
O\
l\
llO\
O\
O
{
Vec\
3
lOOO\
O\
Ol\
llOOl
[
4
]
;
Vec3\

lOOO\
O\
O\
lllOlO
[
4
]
;
Vec3\

lOO\
O\
O\
OlllO\
ll
[
4
]
;
int
lOO\
OOOllllOO
;
in\
t
lOOO\
O\
Oll\
llOl
;
in\
t\

lO\
OO\
OOlllllO
;
flo\
at\

lOlllOOOll
;
Vec3
lO\
lOOlOOOlO\

;
int\

llOl\
lOOl\
Ol
;
int
lO\
lll\
OOllO
;
}
;
lOlOlO\
l\
OO\
l
vo\
id
lOOOOO\
ll\
ll\
ll
(
lO\
OO\
OOlllOOO\

&
lOOOOl\
OOOOOO
,
cons\
t\

in\
t
lOOOOlOOOOO\
l
,
const
int
lOOOOl\
OOO\
O\
lO
,
const
int\

lOOO\
OlO\
OO\
Oll
,
co\
nst
in\
t
lO\
O\
OOl\
OOOl\
OO
)
{
Vec3\

lO\
OOOl\
lO\
lOO
=
lOOOO\
lOOO\
OOO
.
lOOOOOlllOll
[
lOO\
OOlOOOOlO
]
-
lO\
OOO\
l\
OO\
OOOO\

.
lOOOOOl\
llO\
ll
[
lOOOO\
l\
OO\
O\
OOl
]
;
fl\
oa\
t
lOOOOlOO\
OlOl\

=
lOOOOlOOO\
OO\
O
.
lOOO\
OOl\
ll\
Oll
[
lO\
O\
OOlOO\
O\
OOl\

]
.
Do\
t
(
lOOOO\
ll\
OlOO
)
;
fl\
o\
at\

lO\
OOOlO\
OOll\
O
=
lOOOOlOOOOOO
.
lO\
O\
OOOlllOll
[
lOOO\
O\
l\
OO\
OOlO
]
.
Dot
(
lOOOO\
llOlOO
)
;
float
lOOOOl\
OOOll\
l
=
lOO\
OOlO\
OOOO\
O\

.
lO\
OO\
OO\
lllOl\
l
[
lOOOOl\
OOO\
O\
ll\

]
.
Do\
t\

(
lOOOOllOl\
OO\

)
;
lOO\
OOl\
lOlOO\

=
lOOO\
O\
l\
OOO\
OO\
O
.
lOOO\
OOlllOll\

[
lOOOO\
l\
O\
O\
O\
O\
ll
]
-
lOO\
OOl\
OOOO\
OO
.
lOOOOOlll\
Oll
[
lOO\
OO\
lOO\
OOOl\

]
;
float
lO\
O\
OOlOO\
lOOO
=
lOOOOl\
OOOOO\
O\

.
lOOOOOlll\
Oll
[
lOOO\
O\
lO\
OOO\
Ol
]
.
Do\
t\

(
lOOO\
O\
llOlOO
)
;
flo\
at
lOOOOlOOl\
OO\
l
=
lOO\
OO\
lO\
O\
O\
OOO
.
lO\
OO\
OOlllOll
[
lO\
OOO\
lOOOO\
l\
O
]
.
Dot\

(
lOOOO\
llOlOO
)
;
floa\
t
lOOOOOOOll
=
lOOOOlO\
OOOOO
.
lO\
OOO\
Olll\
Oll
[
lOOOOlOOO\
Oll
]
.
Do\
t
(
lO\
OO\
OllO\
l\
OO
)
;
Vec3
lO\
O\
O\
OlOOl\
OlO
;
lO\
O\
OOlO\
OlOlO
.
x
=
(
lOOOO\
lOO\
O\
llO
*
lO\
OOOOOOll\

-
lO\
OOOl\
OOlOO\
l\

*
lOO\
OOlO\
OOl\
l\
l\

)
;
lOOOOlOOlOlO
.
y
=
-
(
lOOO\
O\
lOOOl\
Ol
*
lOOO\
OO\
OO\
ll\

-
lOOOOl\
OOlOOO\

*
lOOOO\
lO\
O\
Olll
)
;
lOOOOlOOlOlO\

.
z
=
(
lOO\
OO\
lOOOlOl
*
lOOOOlOOlOOl\

-
lOOOOlOO\
l\
OO\
O
*
lOOOO\
lOOOll\
O
)
;
{
con\
st
floa\
t
lO\
O\
O\
lOlOlll
=
lO\
OO\
OlOOlO\
l\
O\

.
x
+
lOOOOlOOlOlO\

.
y
+
lOOOOlOO\
lOl\
O
.
z
;
if\

(
lOOOl\
O\
l\
Olll
>
0.001f
)
{
Vec3
lOOOOlOOl\
Oll\

;
lOOOOlO\
OlO\
ll\

=
lOOO\
OlO\
OlO\
lO
/
lOO\
OlOl\
O\
ll\
l
;
lO\
OO\
OlO\
O\
lOl\
l
=
lO\
O\
OOlO\
OlOll
.
x
*
lOOOOlO\
O\
OOO\
O\

.
lOOOOOl\
llOl\
l
[
lOOOOlOOOOOl
]
+
lO\
OO\
OlOOlOll
.
y
*
lOOOOl\
OOOOOO
.
lOOO\
O\
Ol\
llOll\

[
lOOO\
OlOOO\
OlO
]
+
lO\
OOOlOOlOll
.
z
*
lOOO\
Ol\
O\
OOOOO
.
lOOO\
OO\
lll\
Oll
[
lOO\
OOlOOOO\
ll
]
;
flo\
a\
t
lO\
O\
OO\
OlllO
=
(
lOOOOl\
O\
O\
OO\
O\
O
.
lOO\
OOO\
lllO\
l\
l\

[
lOOO\
O\
lOOO\
OOl
]
-
lOOOOlOOO\
OOO
.
lO\
OOOOll\
lOll
[
lO\
OOOl\
O\
OOOlO
]
)
.
Do\
t\

(
lO\
OOOlOOl\
Oll\

)
;
TA_\
A\
S\
SERT
(
Fa\
bs
(
lOOOOO\
ll\
l\
O
<
0.001f
)
)
;
lOOOO\
OlllO
=
(
lOOOOlOO\
OOOO
.
lOOOOOll\
l\
Oll
[
lOOO\
OlOOOOl\
O
]
-
lOOOOlOOO\
OO\
O\

.
lOOOOOlllOl\
l
[
lOOOO\
lOOOOll
]
)
.
Do\
t\

(
lOOOOlOOlOl\
l
)
;
TA_\
ASSERT
(
Fa\
bs\

(
lOOOO\
OlllO
<
0.001f
)
)
;
lO\
OO\
OOll\
lO
=
(
lOOO\
O\
lOOOOOO
.
lOO\
OOOl\
l\
lOl\
l
[
lOO\
OOl\
OOOOll
]
-
lO\
OOOlOO\
OO\
OO
.
lOOOOO\
lllOll
[
lOO\
O\
OlOOOO\
Ol\

]
)
.
Dot
(
lOOOOlOOlOll
)
;
TA_ASSERT
(
Fab\
s
(
lOOOOOll\
lO
<
0.001f
)
)
;
lOOOO\
OlllO
=
(
lOOOOlO\
OOOOO\

.
lOOO\
O\
OlllO\
ll\

[
lOOOOl\
O\
O\
OO\
ll
]
-
lOOOOlOOO\
OO\
O
.
lOOOO\
Olll\
Oll
[
lOOOOlOO\
O\
OO\
l\

]
)
.
Cross
(
lO\
OO\
O\
lO\
OOOOO
.
lOOO\
O\
OlllOll
[
lO\
OOOlO\
OOOlO
]
-
lOOOOlOOOOOO
.
lOOOOOl\
ll\
Ol\
l
[
lOOOO\
lO\
OOOOl
]
)
.
Do\
t
(
lOOOOlOOlOll
-
lOOO\
Ol\
O\
O\
O\
OO\
O
.
lOOOOOl\
llOll
[
lOOOOlOOO\
OO\
l
]
)
;
TA\
_AS\
SER\
T
(
Fa\
bs
(
lOOO\
OOll\
l\
O
<
0.001f
)
)
;
}
}
if
(
lOOO\
OlO\
OlOlO
.
x
>
0.0f
&&
lOOO\
OlOO\
lOlO
.
y
>
0.0f
&&
lOOOO\
lOOlO\
lO
.
z
>=
0.0f
)
{
lOOOOlOOOO\
OO\

.
llOl\
lOOlO\
l
++
;
cons\
t\

floa\
t
lOOOlOlOlll
=
lOOOOl\
OO\
lOlO
.
x
+
lOO\
OOlOOlOl\
O
.
y
+
lOOOO\
l\
OO\
l\
OlO\

.
z
;
TA_AS\
S\
ER\
T
(
lOO\
O\
lO\
lOlll
>
0.0f
)
;
lOOOOlOO\
lOl\
O\

/=
lOOOlO\
lOl\
ll
;
lOOO\
OlOO\
l\
OlO\

=
lOOO\
Ol\
OO\
lOlO\

.
x
*
lOO\
O\
O\
lOOOO\
OO
.
lO\
O\
OOO\
lllOll
[
lO\
OOOlO\
OOOOl
]
+
lOO\
O\
Ol\
OOl\
OlO
.
y
*
lOOOO\
lO\
O\
OOOO\

.
lOOO\
OOlllOll
[
lOOO\
OlOOOOlO
]
+
lOO\
OO\
lOOlOlO
.
z
*
lOO\
O\
OlOOO\
OOO
.
lOOOOOlll\
Oll\

[
lOO\
OOlOOOOll
]
;
cons\
t
float
lOlllOOlO\
l
=
lOO\
O\
Ol\
O\
OlOlO
.
Ge\
tMa\
gnitud\
eSqrd
(
)
;
if
(
lOOO\
O\
lO\
OO\
OOO
.
lOl\
ll\
OOOl\
l\

>
lOlllOOlOl
)
{
lO\
OOO\
lOOO\
OOO
.
lOlllOOOll\

=
lOlll\
O\
OlOl
;
lOO\
OO\
l\
OOOOOO
.
lOOOOOllll\
OO
=
lOOOOl\
OOO\
lOO
;
lOO\
OO\
l\
OOOO\
OO\

.
lOlO\
OlOOOlO
=
lOOO\
O\
lOOlOlO
;
}
}
}
lO\
lOlOlO\
Ol
voi\
d\

lOO\
OOlOOll\
OO
(
const
Vec3
&
ll\
ll\
ll\
l\
ll
,
const\

Vec3
&
lOO\
OOO\
O\
OOO\

,
const\

Vec\
3
&
llllO\
OO\
llO\

,
Vec\
3
&
lOlOOlOO\
OlO\

)
{
Vec3
lOOOOl\
l\
OlOO
=
lOOOOOOOOO\

-
ll\
lll\
lll\
l\

;
floa\
t
lOOOOl\
OO\
OlOl\

=
llll\
lll\
l\
l\

.
Dot\

(
lOOOOl\
lOl\
OO
)
;
float
lOO\
OOlO\
OOll\
O
=
lOOOOO\
O\
OOO
.
Dot
(
lOOOO\
ll\
Ol\
OO
)
;
float
lOOO\
OlO\
OOlll
=
llll\
O\
OOl\
lO\

.
Dot
(
lOOOO\
l\
lOlO\
O
)
;
lO\
O\
OOl\
lOlO\
O
=
ll\
ll\
OO\
Oll\
O
-
llllll\
lll\

;
flo\
at
lOO\
O\
Ol\
O\
O\
l\
O\
O\
O
=
ll\
lllllll
.
Dot
(
lOOOOl\
lOlOO
)
;
float\

lOOOOlO\
O\
lOOl\

=
lO\
OOOOOOO\
O
.
Dot
(
lO\
OOOl\
l\
OlOO
)
;
fl\
oat
lOOOO\
OOOl\
l
=
llll\
OOOllO\

.
Dot
(
lOOOOllOl\
O\
O
)
;
Ve\
c3
lOOOOl\
OO\
lOlO
;
lOOOO\
lOOlO\
lO\

.
x
=
(
lOOOOlOOOllO
*
lOO\
O\
OOOOl\
l
-
lO\
OOOl\
OOlO\
Ol
*
lOO\
O\
OlOO\
Ol\
ll
)
;
lOOOOlOOlOlO
.
y
=
-
(
lOOOOlOOO\
lOl
*
lO\
OO\
OO\
O\
Oll
-
lOOOOlO\
O\
l\
O\
OO
*
lOOOOlOO\
O\
ll\
l\

)
;
lO\
OOO\
lOOlOlO\

.
z
=
(
lO\
OOO\
l\
OOO\
lOl\

*
lOOOOl\
OO\
lOOl
-
lOOOOlOO\
lO\
O\
O
*
lOOOOlO\
OOllO
)
;
{
con\
s\
t
flo\
at
lO\
OOlO\
lO\
lll
=
lO\
OOOl\
OO\
l\
OlO
.
x
+
lO\
OOO\
lOOlOlO
.
y
+
lOOOOl\
O\
O\
lOl\
O
.
z
;
TA\
_ASSE\
RT\

(
lO\
OO\
lOlOlll
>
0.0f
)
;
lOOOOl\
O\
OlOl\
O
/=
lOO\
OlOlOlll\

;
lOO\
O\
OlOOlO\
lO
=
lOO\
OOlO\
Ol\
OlO
.
x
*
lllllllll
+
lOO\
OOlOOlOlO
.
y
*
lO\
OO\
OOOOOO\

+
lOOOOlOOlO\
lO
.
z
*
llllO\
OO\
l\
lO\

;
lOlOOlOOOl\
O
=
lOOO\
O\
lOOlOlO
;
}
}
lOlOlOlOOl
void
lOOOO\
l\
OO\
l\
lOl\

(
lOOOO\
OlllO\
O\
O
&
lO\
OO\
O\
lOOO\
OO\
O
,
const
in\
t
lOOOOlOOOO\
Ol
,
const\

in\
t\

lOOO\
O\
l\
O\
OO\
OlO\

,
con\
s\
t
int
lOOOOlO\
OO\
Oll
,
const
in\
t
lO\
OO\
O\
lOOOlOO
)
{
Vec\
3
lOOOOl\
l\
OlOO
=
lOO\
OOlO\
O\
O\
O\
O\
O\

.
lOOOOOlll\
O\
ll
[
lO\
OOOlOOOOlO
]
-
lOOOOl\
OOO\
OOO
.
lO\
OO\
OO\
lllOl\
l
[
lOOO\
OlOOO\
OOl
]
;
fl\
oa\
t\

lOOO\
OlOOOlO\
l
=
lOO\
OOlOO\
OOO\
O
.
lOOO\
OOl\
l\
lOll
[
lOOOOlOO\
OOOl
]
.
Dot\

(
lOO\
OOllOlOO
)
;
floa\
t\

lO\
OO\
O\
lO\
OO\
llO
=
lOOO\
Ol\
OOO\
OOO
.
lOOOOO\
l\
llOll
[
lO\
O\
OOl\
OO\
OOlO
]
.
Dot
(
lOO\
O\
Oll\
Ol\
O\
O
)
;
Ve\
c3
lO\
OOOl\
OOlOl\
O
;
lOOO\
OlOOlO\
lO
.
x
=
lOOO\
O\
lOO\
Ol\
lO
;
lOOO\
O\
lOOlOl\
O
.
y
=
-
lO\
OOOlOOOlOl
;
if
(
lOO\
OO\
l\
OOlOl\
O
.
x
>
0.0f
&&
lOOO\
OlOOlOlO
.
y
>
0.0f
)
{
lO\
O\
OO\
lO\
OOOOO
.
llO\
llOOl\
Ol
++
;
co\
n\
st
fl\
oa\
t
lO\
OOlOlOll\
l
=
lO\
O\
O\
O\
lO\
O\
lOlO
.
x
+
lOOOOlOO\
lOlO
.
y
;
TA_ASS\
E\
RT
(
lOOOlO\
lOlll
>
0.0f
)
;
const
float
lOOOlOl\
lO\
OO
=
1.0f
/
lO\
OOlOlOlll\

;
lOO\
OOlOOlOlO\

.
x
*=
lOO\
O\
lOllOOO
;
lOO\
O\
O\
lO\
OlOlO
.
y
*=
lO\
O\
O\
lOll\
OOO
;
lO\
O\
OO\
lOOl\
OlO
=
lOOOOlOOlOlO\

.
x
*
lOOOOlOOOOO\
O
.
lOOOOO\
lllOll
[
lOOO\
OlOOOO\
Ol
]
+
lOO\
OOl\
OOl\
OlO\

.
y
*
lOOO\
Ol\
O\
OO\
OOO
.
lOO\
OO\
OlllOll
[
lOOOOlO\
OO\
Ol\
O
]
;
floa\
t
lOOOOO\
lllO
=
(
lO\
OOOl\
OOOOOO
.
lOOOOO\
l\
llO\
ll
[
lOOOOlOOOOO\
l\

]
-
lOOOOl\
OOOOOO
.
lOOOOOlll\
O\
l\
l
[
lOOOOlO\
O\
OOlO
]
)
.
Dot
(
lO\
OO\
OlO\
OlOlO
)
;
TA\
_ASSERT\

(
Fabs\

(
lO\
OOOOlllO
)
<
0.001f
)
;
Vec3
llllOOOlll\

=
(
lOOOO\
lOO\
l\
OlO\

-
lO\
OOO\
lOOO\
O\
OO\

.
lOOOOOlllOll\

[
lOOOOlO\
O\
O\
OOl
]
)
.
Cro\
ss
(
lOOOOlOOOOOO
.
lOOOOOll\
lO\
ll
[
lO\
OOOlOOOOlO
]
-
lOOOOlOOlOlO
)
;
TA\
_A\
S\
SE\
R\
T
(
Fa\
bs\

(
lll\
lOOO\
l\
l\
l
.
Ge\
t\
Mag\
nit\
u\
deSqrd\

(
)
)
<
0.001f
)
;
con\
st
flo\
at
lO\
l\
llO\
O\
l\
Ol
=
lOOOOl\
OOlOlO
.
Ge\
tMagnit\
ud\
eS\
q\
r\
d
(
)
;
if
(
lOO\
OOlOOOOO\
O
.
lOl\
llOOOll\

>
lOlllOO\
l\
Ol\

)
{
lO\
O\
OO\
l\
OO\
OO\
OO\

.
lOlllOOO\
ll
=
lO\
l\
llOOlOl
;
lOOOOlOOO\
OOO
.
lOO\
OOO\
lll\
l\
O\
O
=
lOOOOl\
OOO\
Ol\
l
;
lOOOOlO\
O\
OOOO
.
lOOOOOlll\
lOl
=
lOOOOl\
OOOl\
OO
;
lO\
OO\
Ol\
OOOO\
OO
.
lOlOO\
l\
OOOlO
=
lOOOOl\
OOl\
O\
lO
;
}
}
}
lOlO\
lO\
lOO\
l\

void
lOOOO\
lO\
Ol\
llO
(
con\
st
Vec\
3
&
ll\
l\
l\
lllll
,
cons\
t
Vec3
&
lOOOOO\
O\
OOO
,
Ve\
c3
&
lOlOOl\
OOO\
l\
O
)
{
Vec\
3
lOOOO\
llOlOO
=
lOOOOOOOOO\

-
lllllllll
;
float
lO\
OO\
OlOOOl\
Ol
=
llll\
ll\
lll
.
Dot\

(
lOO\
OOll\
O\
lOO
)
;
float\

lOOOOlOO\
OllO
=
lOOOOOOO\
OO
.
Dot
(
lOO\
OOllO\
lOO\

)
;
lOlOO\
lOOO\
lO
.
x
=
lOO\
OOlOO\
OllO
;
lO\
lOOlOOOlO
.
y
=
-
lOOOOlOOOlOl\

;
{
const\

fl\
oat
lOOOlOl\
Olll
=
lO\
lOO\
lOOOlO
.
x
+
lO\
lOO\
lOOOlO\

.
y
;
TA_ASSERT\

(
lO\
OOlO\
lO\
lll
>
0.0f
)
;
con\
st\

fl\
o\
at
lOOOl\
OllOOO
=
1.0f
/
lOOO\
lO\
lOl\
ll
;
lOlOOlOOOlO
.
x
*=
lO\
OOlO\
l\
lO\
O\
O\

;
lOlOO\
lO\
OOlO
.
y
*=
lOOO\
lO\
llOOO
;
lOlO\
OlO\
O\
OlO\

=
lOlO\
OlO\
O\
Ol\
O
.
x
*
lll\
lll\
lll\

+
lOlOOl\
O\
O\
O\
lO
.
y
*
lOO\
OOOO\
OOO
;
}
}
lOlOlO\
l\
OOl
vo\
id
lO\
OOOlOO\
llll
(
lOOOO\
Ol\
l\
l\
OOO
&
lOOOOl\
OOO\
OOO
,
const
int\

lOOOO\
lOOOO\
O\
l
,
cons\
t
int
lOOOOlO\
OOOl\
O\

,
con\
st
in\
t
lOOOO\
lO\
OOO\
l\
l
,
const
int
lOOOOl\
OO\
O\
lOO
)
{
const\

float
lOl\
llOOlOl
=
lO\
OOOlOO\
O\
O\
OO
.
lO\
OO\
OOl\
llOll\

[
lO\
O\
OO\
lOOOO\
Ol
]
.
GetM\
agni\
t\
u\
deS\
qrd
(
)
;
if
(
lOOO\
OlOOOO\
O\
O
.
lOll\
lOOO\
ll
>
lOlll\
OOl\
O\
l
)
{
lOOOOl\
O\
OO\
OOO\

.
lOlll\
OO\
Oll
=
lOlllOOlOl
;
lOO\
OOlOOO\
OO\
O\

.
lOlOO\
lOOOlO\

=
lOO\
OOlOOOO\
OO
.
lOOOOO\
ll\
lOl\
l\

[
lOOOOlOOOOOl\

]
;
lOOOOlO\
OO\
OO\
O
.
lOOOOO\
ll\
llOO
=
lOOOOlO\
OOOl\
O
;
lO\
O\
OOl\
O\
OO\
OOO\

.
lOO\
OOO\
ll\
l\
lOl
=
lOOOOl\
O\
OO\
Oll\

;
lOOOO\
lOO\
OO\
OO
.
lOOOO\
Ol\
llllO
=
lOOO\
O\
lO\
O\
O\
lOO\

;
}
}
lOlO\
lOlOOl
vo\
id
lOOOO\
lOlOOOO\

(
lOO\
OOOlllOOO
&
lOOO\
OlOO\
O\
OOO
,
int
lOOO\
OlOlOOOl
)
{
sw\
i\
tch
(
lOOO\
OlOlOO\
Ol
)
{
case
0
:
lO\
OO\
OlO\
OOO\
OO
.
lOOOOO\
l\
l\
lOl\
l
[
0
]
=
lOO\
OOlO\
OO\
OOO
.
lOOOO\
OlllO\
l\
l
[
1
]
;
case
1
:
break\

;
defau\
lt
:
ll\
l\
OOOlllO\

;
}
lOOOO\
lO\
OOO\
OO
.
lO\
lllOOll\
O\

--
;
}
lOlO\
lOlOOl
void\

lOOO\
OlOlOOlO
(
lOOOOOl\
llOOO\

&
lOOOOlOOOOO\
O\

,
in\
t\

lOOOOlOlOOOl
)
{
swit\
ch
(
lOOOOl\
Ol\
O\
OO\
l
)
{
case
0
:
lOOOOlOO\
O\
OO\
O
.
lOO\
OOO\
lllOll
[
0
]
=
lOOOOlOO\
O\
OOO\

.
lOOOOOlll\
Oll
[
1
]
;
cas\
e\

1
:
lOOOOlOOO\
OOO\

.
lO\
O\
OOOlllOll
[
1
]
=
lOOOO\
lOOOOOO
.
lOO\
OOOlllOll
[
2
]
;
case
2
:
break
;
de\
fault
:
ll\
l\
O\
OO\
lllO\

;
}
lO\
OOOlOOOO\
OO\

.
lOlllO\
OllO
--
;
}
lOlO\
lOlOOl
vo\
id
lOO\
OOlOlOOll
(
lOOO\
OOl\
llOO\
O
&
lOOOOlOOOOOO
,
in\
t
lOOO\
OlOl\
O\
OO\
l
)
{
sw\
i\
tc\
h
(
lOOOO\
l\
OlOO\
Ol
)
{
ca\
se
0
:
lOO\
OO\
lO\
OOO\
OO
.
lOOO\
OOll\
lOl\
l\

[
0
]
=
lOOOOlOOOO\
OO
.
lOOOOOll\
lOll
[
1
]
;
ca\
s\
e
1
:
lOOOOlOOO\
OO\
O\

.
lOOOOO\
lllO\
ll
[
1
]
=
lOO\
O\
OlO\
OO\
OOO
.
lOO\
OOOl\
l\
lOll
[
2
]
;
case
2
:
lO\
O\
O\
OlOOOOOO\

.
lOOOOOll\
l\
O\
ll
[
2
]
=
lOOOO\
lOOO\
OO\
O\

.
lOOO\
OOl\
llOl\
l
[
3
]
;
case
3
:
br\
eak
;
default
:
lllOO\
OlllO
;
}
lOO\
O\
Ol\
O\
O\
OOO\
O\

.
lOll\
lOOll\
O
--
;
}
void
TAC_C\
ALL\

llllOOl\
OO\
l\
O\

(
con\
s\
t
MFr\
ame\

&
lOll\
Ol\
l\
ll\
ll
,
co\
nst
MFra\
me
&
lO\
ll\
l\
O\
OOO\
OO\

,
lOllOllO\
ll\
O
*
lOlll\
OOOOOl
)
{
int
lOlllOOl\
ll
;
TA_\
ASSERT\

(
lO\
ll\
lOOOOOl
->
lOll\
OOOl\
lOl
->
Get\
Collisio\
nObjectT\
y\
pe
(
)
==
Co\
lli\
si\
onObject
::
TYPE_\
CON\
V\
EX
)
;
TA\
_AS\
S\
E\
RT
(
lOlllOOOOO\
l\

->
lO\
ll\
OO\
Ol\
llO
->
Get\
C\
o\
llis\
ionO\
b\
j\
ectT\
y\
pe\

(
)
==
Col\
l\
i\
si\
onOb\
j\
ect\

::
TYPE_\
C\
ONVEX
)
;
co\
ns\
t
CollisionOb\
ject\
Conv\
e\
x
&
lll\
O\
ll\
Oll\
OO
=
*
(
Coll\
ision\
O\
bje\
ctConve\
x
*
)
lO\
lllOOOOOl
->
lOl\
lO\
O\
Oll\
Ol\

;
co\
n\
st
Co\
llisionObjectConvex
&
ll\
l\
O\
l\
l\
Ol\
lO\
l
=
*
(
Colli\
sionO\
bjectC\
onvex
*
)
lOlllO\
OOOOl
->
lOl\
lOOO\
l\
llO\

;
MFra\
me
lOOO\
OlOlOlOO
=
lO\
llOlllll\
l\

.
Ge\
t\
I\
nv\
ers\
e
(
)
;
Coll\
is\
i\
o\
nObjectCon\
vex
::
Polygon
*
llOOl\
lllOl
=
0
;
Co\
l\
lisionObjectC\
on\
ve\
x
::
Poly\
g\
o\
n
*
llOOlllll\
O
=
0
;
fl\
oat
lOO\
O\
Ol\
Ol\
O\
lOl
=
0.0f
;
float
lOOOOlO\
lOllO
=
0.0f
;
con\
s\
t
bo\
ol
lOOOOlOlO\
ll\
l
=
fals\
e
;
if
(
lOOOO\
lO\
lOlll
)
{
Vec3
lOOOOlOllO\
OO\

;
sta\
tic
lO\
OO\
OOlllO\
O\
O
lOOOOl\
O\
O\
OO\
OO
;
bool
lOOOOl\
O\
l\
lOOl
=
fa\
lse\

;
int\

llO\
llOll\
Ol
=
0
;
lO\
O\
OOlOOOOOO
.
lOll\
lOOllO
=
0
;
lOOOOlO\
llOOO
=
k_v3U\
nitY
;
int
lO\
OOO\
lOll\
OlO\

=
0
;
in\
t\

lOOOOlOllOll\

=
0
;
floa\
t
lO\
OO\
OlOlll\
OO
=
0.8f
;
for
(
;
;
)
{
llO\
l\
l\
Oll\
Ol
++
;
if
(
ll\
OllOllOl
>
40
)
{
bre\
ak
;
}
lOOO\
OlOl\
l\
O\
lO\

=
lllOllOllOO
.
lO\
O\
OOOl\
l\
OOOl
(
lOOO\
O\
lOl\
lOl\
O
,
lO\
O\
O\
OlOllO\
OO
*
lOOO\
OlO\
l\
OlOO
.
m33Ro\
t\
ation
)
;
lOOOOlOllO\
ll\

=
lllOl\
lOl\
lOl
.
lOOO\
OOll\
OO\
Ol
(
lOOOOlOllO\
ll
,
-
lO\
O\
OOl\
O\
llOO\
O\

)
;
lOO\
OOl\
O\
OO\
O\
OO
.
lO\
O\
OO\
Ol\
llOOl\

[
lOOO\
OlOOOOO\
O
.
lOl\
ll\
OOl\
l\
O
]
=
lllOll\
OllO\
O\

.
lO\
l\
OOlO\
llO
->
ll\
lllOlllOl
[
lOOOO\
lOll\
Ol\
O
]
;
lOOOO\
lOOOOO\
O
.
lO\
OOO\
OlllOlO
[
lOOO\
Ol\
OOOOOO
.
lOll\
lO\
Ol\
lO\

]
=
lllOll\
Ol\
lOl
.
lOlOOl\
OllO
->
lll\
ll\
Oll\
l\
Ol\

[
lOOO\
Ol\
OllOll\

]
;
if
(
!
lOll\
lO\
OO\
O\
Ol
->
lOl\
lOl\
llOO\
l
)
{
Vec3
lO\
lOOO\
OO\
Oll
=
lOOOO\
lO\
O\
OOOO
.
lOO\
OO\
OlllOOl
[
lOOOOl\
O\
OOOOO
.
lO\
lllOOllO\

]
*
lOl\
lO\
llll\
ll\

-
lO\
OO\
O\
lOOO\
O\
OO\

.
lOO\
O\
OOll\
lOl\
O\

[
lO\
O\
OOlOOOOOO
.
lOlllOO\
llO
]
;
if
(
lOOOOlOllO\
OO\

.
Dot
(
lOlO\
OOOOOl\
l
)
>
-
0.0001f
)
{
if
(
llOl\
l\
O\
l\
lOl
==
1
)
in\
t\

lOlOOOllOl
=
0
;
retur\
n
;
}
}
lOOO\
O\
lOOOOOO
.
lOOOOOll\
lO\
O\
l\

[
lO\
O\
O\
OlOO\
OO\
OO
.
lO\
lllOOllO
]
=
lOOOOlOlll\
OO
*
(
lOOO\
OlOOOO\
OO
.
lOOOO\
Ol\
l\
lOOl
[
lO\
O\
O\
O\
l\
OOO\
OOO
.
lOlllOOllO
]
-
lll\
O\
llO\
l\
lOO
.
lOlOOlOl\
lO
->
ll\
lOllOOOO\
O
)
+
lll\
O\
llOl\
lOO
.
lO\
lO\
OlOllO\

->
lllO\
l\
lOOOOO
;
lOOO\
OlOO\
OOO\
O
.
lOO\
OOOlll\
OlO
[
lO\
OOO\
lOOO\
OOO
.
lOl\
llOOllO
]
=
lOOOOlO\
l\
l\
lO\
O\

*
(
lO\
O\
OOl\
O\
OOOOO\

.
lOOOOO\
ll\
lOlO\

[
lOOO\
OlOO\
O\
OOO
.
lOlllOO\
l\
lO
]
-
lllOllOll\
Ol
.
lOlOO\
lO\
llO\

->
lll\
OllOOO\
OO\

)
+
lllOllO\
llOl
.
lOlOOl\
OllO
->
lllOllOOOOO\

;
Ve\
c3\

lOO\
OOl\
O\
lllOl
=
lO\
OO\
O\
lOOO\
OOO
.
lO\
O\
OO\
O\
lll\
OOl
[
lO\
OO\
OlO\
OOO\
O\
O
.
lO\
lllOOl\
lO\

]
*
lOllOlllll\
l
-
lOOO\
Ol\
OOO\
OOO
.
lO\
OOOO\
lllOl\
O\

[
lOO\
OOlOOOOOO
.
lOlllOOll\
O\

]
;
if\

(
lOO\
OOlO\
llO\
OO\

.
Dot\

(
lOOOOlO\
ll\
lOl
)
>
-
0.0001f
)
break
;
lO\
OOOl\
OOOOOO\

.
lOOOOO\
ll\
l\
Oll
[
lO\
OOOlO\
O\
O\
OOO\

.
lOlllOOllO
]
=
lOOOOl\
Oll\
lOl
;
{
#ifdef lOOOOlOllllO
for
(
lOO\
OllOOOl
=
0
;
lOOOllOOOl\

<=
lO\
OO\
OlOOOOOO
.
lO\
l\
llO\
Ol\
lO
;
lOOOllOO\
Ol\

++
)
{
Phy\
sics\
Render
::
Rende\
r\
L\
ine\

(
k_mFrameId\
entity
.
v3\
Trans\
lat\
ion
,
k_m\
Frame\
Identity
.
m3\
3\
Ro\
ta\
t\
i\
on
.
v3\
X\

)
;
Ph\
y\
sic\
sRen\
der
::
Re\
n\
der\
Li\
n\
e
(
k_mF\
ram\
eIde\
n\
tity
.
v3Tra\
nslat\
i\
o\
n\

,
k_mFr\
a\
meIdentity
.
m33Rotation
.
v3Y
)
;
Phys\
icsRen\
der
::
Rend\
e\
rLin\
e
(
k_\
mFram\
e\
Identity\

.
v3Tra\
n\
slation
,
k_mFr\
ame\
I\
dentity\

.
m3\
3Rotati\
on
.
v3Z
)
;
for
(
int
lOOlOOlOlO
=
lOOOllO\
OOl
+
1
;
lO\
OlOOlOl\
O
<=
lOO\
OOlOOOOO\
O
.
lO\
lllO\
OllO\

;
lO\
O\
lOOlOlO\

++
)
{
Phys\
icsR\
e\
n\
der
::
RenderLine\

(
lOOOOlO\
OOOOO
.
lO\
O\
OOOlllO\
ll
[
lOOO\
ll\
O\
O\
Ol
]
,
lOOOOlO\
OOOOO\

.
lO\
OOOOlllOl\
l
[
lOOlO\
Ol\
Ol\
O
]
,
0xFF00FFFF
)
;
}
}
#endif //
}
int
lOOOO\
l\
Olllll\

=
3
;
switch
(
lO\
OOOlOO\
OOOO
.
lOl\
ll\
OOl\
lO
)
{
ca\
se
0
:
lOOO\
O\
lOll\
OOO
=
lO\
OOOl\
OOOOOO
.
lO\
O\
OOOll\
lOl\
l
[
lOOOOlOO\
OOOO\

.
lOlllOOllO
]
;
lOO\
OOlOOOOOO
.
lOlllOO\
llO
++
;
break
;
ca\
s\
e
1
:
lOOOOl\
OO\
OOOO\

.
lOO\
OO\
Olll\
l\
OO
=
-
1
;
lOOOOlO\
OOOOO\

.
lOOOOOllll\
Ol\

=
-
1
;
lO\
O\
O\
Ol\
OOOO\
OO\

.
lO\
OOO\
O\
ll\
l\
l\
lO\

=
-
1
;
lOOO\
OlOO\
OOOO
.
lOlllOOOll
=
k_\
f\
MaxFl\
oat
;
lOOOOlOOOOOO
.
llOl\
lOOlOl
=
0
;
lO\
OO\
OlOOllO\
l\

(
lOO\
O\
OlOOOO\
OO
,
0
,
1
,
2
,
3
)
;
lO\
OOOl\
OO\
OOOO
.
lO\
OOOO\
llllOO\

=
-
1
;
lO\
OOOl\
OOOO\
OO
.
lOOOOOllllO\
l\

=
-
1
;
lOOOOlO\
OOOOO\

.
lO\
lllOOllO\

++
;
if
(
lOOOO\
l\
OO\
OO\
OO
.
llO\
l\
l\
OOl\
Ol
!=
1
)
{
lO\
OOO\
lOOlll\
l
(
lO\
OO\
Ol\
OOO\
OOO\

,
0
,
1
,
2
,
3
)
;
lO\
O\
OO\
l\
OOllll
(
lOOOOlOOO\
OOO
,
1
,
0
,
2
,
3
)
;
if\

(
lO\
OOOlO\
OOO\
O\
O\

.
lOOO\
OOlll\
lOO
!=
-
1
)
lOOOOlOlOOOO
(
lOO\
O\
Ol\
OO\
O\
OO\
O
,
lO\
O\
OO\
lO\
OOOOO
.
lOOOO\
OllllOO\

)
;
}
lOO\
OOlOllOO\
O
=
lOOOOlO\
OOO\
O\
O
.
lOl\
OOlO\
OOl\
O
;
break
;
case
2
:
lOOOO\
lOOO\
OOO
.
lOOOOOll\
llO\
O\

=
-
1
;
lOO\
OO\
lOOOO\
OO\

.
lOOOOOl\
ll\
l\
O\
l\

=
-
1
;
lOOO\
OlOOOOOO
.
lOOO\
O\
Ol\
llll\
O
=
-
1
;
lOOOOlOO\
OO\
OO
.
lO\
lllO\
OOll
=
k_fMax\
F\
loat\

;
lOOOO\
lOOOOOO\

.
llOl\
lOOlOl
=
0
;
lO\
OOOOllllll
(
lOOO\
O\
lOO\
OOO\
O
,
0
,
1
,
2
,
3
)
;
lOOO\
OlOO\
O\
O\
O\
O
.
lOOOOOllllOO
=
-
1
;
if\

(
lOOOOlO\
O\
OOOO
.
llOll\
OOlOl
!=
1
)
{
lOOO\
OlO\
O\
ll\
Ol
(
lO\
O\
OOlO\
OO\
OO\
O
,
0
,
1
,
2
,
3
)
;
lO\
OOOl\
OO\
llOl
(
lOO\
O\
Ol\
OOO\
OOO
,
0
,
2
,
1
,
3
)
;
lOOOOlOOl\
lOl\

(
lOOOO\
l\
OOOOOO
,
1
,
2
,
0
,
3
)
;
lO\
OO\
OlO\
OOO\
OO
.
lOOO\
OOlll\
lOl
=
-
1
;
if
(
lOOOOlOOOOOO
.
llO\
l\
lOOl\
O\
l\

!=
3
)
{
lO\
OOOlOO\
ll\
ll
(
lOOOOlOOOOO\
O
,
0
,
1
,
2
,
3
)
;
lOOO\
Ol\
OOl\
ll\
l
(
lOO\
OOlO\
OOOO\
O
,
1
,
0
,
2
,
3
)
;
lOOO\
OlOOll\
l\
l
(
lO\
OO\
Ol\
O\
OOOOO
,
2
,
0
,
1
,
3
)
;
}
}
lOOOOlOOOOOO
.
lO\
ll\
lOOl\
lO
++
;
if
(
lOOOOlOOO\
O\
O\
O
.
lOO\
O\
OOll\
llOl\

!=
-
1
)
{
lOO\
OOl\
OlO\
O\
lO
(
lOO\
OOl\
OOOOOO\

,
lOOOOlOOOOO\
O
.
lO\
O\
OOOllllO\
l
)
;
lOOOO\
lO\
lOOOO
(
lOOOO\
lO\
OO\
OOO
,
lO\
OOOlO\
OOOOO
.
lOOOOO\
lll\
l\
OO
)
;
}
else
if\

(
lO\
OO\
OlOOO\
O\
O\
O
.
lOO\
O\
OOllllOO
!=
-
1
)
{
lOOOOlOlOOlO
(
lOOOOlOOO\
O\
OO
,
lO\
OO\
OlOOOOO\
O\

.
lOOOO\
Olll\
lOO
)
;
}
lO\
OOO\
l\
O\
llOOO
=
lOOO\
OlOOO\
OOO
.
lOl\
OOlOOOlO\

;
break\

;
case
3
:
{
lOO\
OOlO\
O\
OOOO
.
lOO\
O\
OOllll\
OO\

=
-
1
;
lOOOOlOOOOOO
.
lO\
OOOOl\
lllOl
=
-
1
;
lOO\
OOlOOO\
O\
OO
.
lOOOOOll\
ll\
l\
O
=
-
1
;
lOOOOl\
OO\
O\
OOO\

.
lOlll\
OO\
Oll\

=
k_fMa\
xFloat
;
lOOO\
O\
lO\
OOOO\
O
.
llOllOOl\
Ol
=
0
;
lOO\
OOOl\
lllll
(
lOOO\
Ol\
OO\
O\
O\
O\
O
,
0
,
1
,
2
,
3
)
;
lOO\
O\
OOllllll
(
lOOOO\
lO\
O\
OO\
OO
,
1
,
2
,
3
,
0
)
;
lOOO\
OO\
lll\
lll
(
lO\
OOOlOO\
OOOO
,
2
,
3
,
0
,
1
)
;
lOO\
OO\
Olll\
lll\

(
lO\
O\
O\
Ol\
O\
OO\
OOO
,
3
,
0
,
1
,
2
)
;
{
lO\
OOOlOOllO\
l\

(
lOOOO\
lOO\
OOO\
O
,
0
,
1
,
2
,
3
)
;
lO\
OOOlO\
OllOl
(
lOOOOl\
OOOO\
OO
,
0
,
2
,
1
,
3
)
;
lO\
OOOl\
OOllOl\

(
lOO\
O\
OlOOOO\
O\
O\

,
0
,
3
,
0
,
3
)
;
lOOO\
O\
lOOllOl
(
lOOOOlOOOOO\
O
,
1
,
2
,
0
,
3
)
;
lOOOOl\
OOllOl
(
lO\
OOO\
lO\
OOOOO
,
1
,
3
,
2
,
3
)
;
lOOOOlOOllO\
l
(
lO\
OOO\
lOO\
OOO\
O
,
2
,
3
,
0
,
1
)
;
lOO\
OOl\
OOllll
(
lO\
OOOlOOOOOO
,
0
,
1
,
2
,
3
)
;
lOOO\
OlOOllll\

(
lOO\
O\
O\
lOOOO\
OO
,
1
,
0
,
2
,
3
)
;
lO\
O\
OOl\
OO\
lll\
l
(
lOOOOlOO\
OO\
OO\

,
2
,
0
,
1
,
3
)
;
lO\
OO\
OlOOlll\
l\

(
lOOO\
Ol\
O\
OOOOO
,
3
,
0
,
1
,
2
)
;
}
lOOOO\
lOOOOOO
.
lOll\
l\
O\
Oll\
O
++
;
if
(
lO\
OOO\
lO\
O\
O\
O\
OO
.
lOOOO\
Olll\
llO
!=
-
1
)
{
lOOOOl\
OlOO\
ll
(
lOOO\
O\
lO\
OO\
OOO\

,
lOO\
O\
Ol\
O\
OOOO\
O
.
lOOO\
O\
Ol\
l\
l\
llO
)
;
if
(
lOO\
OOlO\
OO\
OOO\

.
lOOOOOlll\
l\
Ol
!=
-
1
)
{
lOOOOlOlOOlO
(
lOO\
O\
OlO\
OOOOO
,
lOOOOl\
O\
OOO\
OO
.
lO\
O\
OOO\
ll\
llOl
)
;
lOOOOl\
Ol\
OOO\
O\

(
lO\
O\
OOl\
O\
O\
OOO\
O\

,
lOOOOl\
O\
O\
OOO\
O
.
lOO\
OO\
OllllOO
)
;
}
}
else
if
(
lO\
OOOlOOOOOO
.
lOOO\
O\
Olll\
l\
Ol\

!=
-
1
)
{
lOOO\
O\
lOlOO\
ll
(
lO\
O\
OOl\
O\
OOOO\
O
,
lOOO\
O\
l\
OOO\
OOO
.
lOOO\
O\
O\
llllO\
l
)
;
lOOOOlOlOO\
l\
O
(
lOOO\
Ol\
O\
O\
OOO\
O\

,
lOOOOlOOOOOO
.
lOOO\
O\
OllllOO
)
;
}
else
{
TA_A\
SS\
E\
RT
(
lOO\
O\
O\
l\
OO\
OOOO\

.
lOOO\
OOl\
ll\
lOO
!=
-
1
)
;
if
(
lOOO\
OlO\
O\
O\
OOO
.
lO\
OOOOllll\
O\
O
==
3
)
{
lOOO\
OlOllOO\
l\

=
true\

;
break\

;
}
lOOOO\
lO\
lO\
Oll\

(
lO\
O\
O\
O\
lOOOO\
OO\

,
lOOOOl\
OOOOO\
O
.
lOOOO\
OllllOO\

)
;
}
lO\
O\
OOl\
OllOOO
=
lO\
OOOlOOOOOO
.
lO\
lOOlOO\
OlO\

;
}
br\
ea\
k
;
def\
aul\
t
:
lllOOO\
l\
llO
;
}
#ifdef lOOOOlOllllO
if
(
lOOOOlOlllll
==
3
)
{
Ph\
ysics\
R\
e\
nd\
er
::
Ren\
derL\
i\
n\
e\

(
k_v\
3Ze\
ro
,
lOO\
OOlO\
llOOO
,
0xFFFF8000
)
;
}
#endif //
if
(
lO\
OOOlOllO\
Ol\

)
br\
eak
;
}
{
Vec3
lO\
OOOOOO\
O\
llO
=
lOOOOlOllOOO
/
lOllO\
lll\
l\
ll
.
m33Rotati\
on\

;
fl\
oat\

lO\
OOOll\
OOO\
O\
O
=
2.0f
;
for
(
int
llO\
lOlllll\

=
0
;
llO\
lOlllll\

<
lllO\
ll\
Oll\
OO\

.
lOlO\
O\
lOllO
->
lOl\
l\
OOllOl\

.
lOOO\
ll\
lOOl\

(
)
;
llO\
lO\
lllll\

++
)
{
Collis\
ionOb\
j\
e\
ct\
Co\
nv\
ex\

::
Pol\
y\
g\
on\

&
lOllOl\
OOOO
=
llllll\
O\
OO\
Ol\

(
&
ll\
lOl\
lOll\
OO\

,
llOlOll\
l\
ll\

)
;
flo\
at
lOl\
OOOlO\
OlO
=
lOO\
OO\
O\
OO\
Oll\
O\

.
Do\
t
(
lOl\
lO\
lO\
OOO
.
lO\
OO\
lOOO\
OO
)
;
if
(
lOOOOll\
O\
OOOO
>
lOlOOOlOOlO
)
{
lOOOOll\
OOOOO
=
lOlO\
O\
OlOOlO\

;
llOOllllOl
=
&
lOllOlO\
OOO
;
}
}
}
{
Vec3
lO\
O\
OOOOOOl\
lO\

=
-
lOO\
OO\
lO\
llOO\
O\

;
fl\
oat
lO\
OO\
OllOOOOO
=
2.0f
;
for
(
int
llOlOll\
lll\

=
0
;
llOl\
O\
lllll
<
lll\
OllOllOl\

.
lOlOOlOllO\

->
lOl\
lOO\
llOl
.
lOO\
OlllOOl
(
)
;
llOl\
Olllll
++
)
{
Colli\
s\
i\
onObjec\
t\
Conve\
x
::
Po\
lygon
&
lOllOlOOl\
O
=
llllllOOOOl
(
&
lllOll\
Oll\
O\
l
,
ll\
OlOlllll
)
;
float\

lOlO\
OO\
lOOl\
O
=
lO\
O\
OOOOOOll\
O
.
Dot
(
lO\
llOlOOlO
.
lOOOlO\
O\
OOO
)
;
if
(
lOOOOllOOOOO
>
lOlOOOlOOlO
)
{
lOOOOllOO\
OOO
=
lOlOOOlOOlO
;
llOOlllllO
=
&
lOllOlOOlO
;
}
}
}
}
in\
t
lOO\
O\
O\
llO\
OOOl\

=
lllOllOll\
OO\

.
lOlOO\
lO\
l\
l\
O
->
ll\
lllO\
lllOl\

.
lOOOll\
lOOl
(
)
;
TA_A\
SS\
ERT
(
lOO\
OOllOOO\
Ol
<
lllllOOlOOl
)
;
for
(
lO\
lllOOlll
=
0
;
lOl\
llOO\
lll
<
lOO\
OOllOO\
OOl
;
lOlll\
O\
Oll\
l
++
)
{
ll\
lllOOl\
Oll\

[
lOlll\
OOlll
]
=
lllOl\
l\
Oll\
O\
O
.
lOlOOlOllO
->
ll\
lllOll\
l\
Ol
[
lOlll\
OO\
l\
l\
l
]
*
lOl\
lOllll\
l\
l
;
}
in\
t
lOOOOll\
OOOlO\

=
lllOl\
lOll\
O\
l
.
lO\
lO\
OlOllO\

->
llll\
lOl\
llOl
.
lOO\
OlllO\
Ol
(
)
;
TA_\
ASSERT\

(
lO\
OOO\
l\
lO\
OO\
l\
O\

<
ll\
lllO\
OlOOl
)
;
st\
atic
Vec3\

lOOOOO\
l\
O\
lO\
O\
O
[
lllllOOl\
OO\
l\

]
;
fo\
r\

(
lOlllOOl\
ll
=
0
;
lO\
l\
llO\
Ol\
l\
l
<
lO\
OOOllOOOlO
;
lO\
l\
ll\
OO\
l\
ll
++
)
{
lOOOOO\
lO\
lOOO\

[
lOll\
l\
OOlll
]
=
ll\
l\
Oll\
O\
llOl
.
lO\
lO\
OlOl\
lO
->
lllll\
Oll\
lOl
[
lO\
lllO\
Olll
]
*
lO\
O\
OOlOl\
O\
l\
OO
;
}
if\

(
!
lOOOOlO\
lO\
l\
ll
)
{
int
lO\
O\
OO\
llOOOll
;
int
lOOOOl\
lO\
Ol\
OO
;
int
lO\
OOOllOOl\
Ol
;
in\
t\

lOOOO\
ll\
OOll\
O\

;
fl\
o\
at\

lOO\
OOlO\
lOllO\

;
float
lO\
OOOlOlOlOl
;
{
lOOO\
Oll\
O\
OlOl\

=
-
1
;
lOOOOllO\
OlOO
=
-
1
;
lOOO\
O\
lOlOl\
O\
l
=
-
k_fMax\
Fl\
oat
;
lllOllOllOl\

.
lO\
OOOOOl\
llOO
(
lll\
OllOllOO\

.
lOlOOlOllO
->
lll\
ll\
OlllOl\

.
lOO\
Oll\
lOOl
(
)
,
lll\
llO\
O\
lO\
ll\

,
lOOOOllOO\
l\
O\
l
,
lOOOOllOOlO\
O
,
lOOOOl\
Ol\
Ol\
Ol
)
;
llOOl\
llllO\

=
&
lll\
lllOOOOl
(
&
lllO\
llO\
llOl\

,
lOO\
OOl\
l\
OOl\
O\
l
)
;
TA_ASSERT
(
lOOOOllO\
OlOO
!=
-
1
)
;
if
(
lOOOOlO\
lO\
lOl\

>
0.0f
&&
llO\
O\
lllll\
O
->
lOO\
O\
lO\
OOO\
O\

.
Dot
(
ll\
lOllOllOO
.
lOl\
OOlOllO
->
lllllO\
lllOl
[
lOO\
OOl\
l\
OOlOO
]
*
lOlllO\
OO\
O\
OO
)
>
llOOl\
llllO
->
lOl\
Oll\
Olll
)
retu\
r\
n
;
lOOOO\
llOOOll
=
-
1
;
lOOO\
Oll\
O\
O\
llO
=
-
1
;
lOOOOlOlOl\
l\
O\

=
-
k_fMa\
xFloa\
t\

;
lll\
O\
llO\
llOO
.
lOOOOOO\
l\
ll\
OO\

(
lllOllOllOl
.
lOlOOlOl\
l\
O\

->
lllllOlllOl
.
lOOOlllOOl
(
)
,
lOOO\
O\
OlOl\
OOO
,
lOOOOllOOOl\
l
,
lOOOOllO\
OllO
,
lOOOOlOlOl\
lO
)
;
llOO\
ll\
llOl
=
&
llllllOOO\
Ol\

(
&
lllOllOll\
OO\

,
lOOOO\
l\
lOOO\
ll
)
;
TA_\
A\
SSER\
T
(
lOO\
OO\
llOOllO\

!=
-
1
)
;
if\

(
lOOO\
OlOl\
OllO
>
0.0f
&&
ll\
OOllll\
Ol
->
lOOO\
lOO\
OOO
.
Do\
t
(
ll\
lO\
ll\
Oll\
Ol\

.
lOlOOlOllO
->
llll\
lOlllOl\

[
lOOOO\
llOOllO\

]
/
lO\
l\
llOO\
O\
OOO\

)
>
llOOll\
llOl
->
lOl\
OllOlll
)
return
;
}
if\

(
lOOOOl\
OlOlOl
<
lOOOOlO\
lOllO
)
{
Vec3\

lO\
OOOl\
lOOl\
ll
=
llOOllllOl
->
lOOOlOOOO\
O\

*
lOll\
O\
l\
llll\
l
.
m33R\
ota\
t\
i\
on
;
fl\
oat
lOO\
OO\
llOOOOO
=
2.0f
;
for
(
in\
t\

llO\
lOlllll
=
0
;
llOlO\
lllll
<
lllO\
llOl\
lO\
l
.
lOl\
O\
O\
lOll\
O
->
lOllOOl\
l\
Ol\

.
lO\
OOlllO\
Ol\

(
)
;
ll\
OlOllll\
l
++
)
{
CollisionO\
bj\
ec\
tConvex
::
Polygon
&
lOll\
O\
l\
O\
OlO
=
lll\
lll\
O\
OOOl\

(
&
lll\
Ol\
lO\
llOl
,
llOl\
Oll\
lll
)
;
float
lO\
lOOOlOO\
lO
=
lOO\
OOllOOlll\

.
Dot\

(
lOl\
l\
O\
lOO\
lO
.
lO\
O\
O\
lOOO\
O\
O
)
;
if
(
lOOOOllOOOO\
O
>
lOlO\
OO\
lO\
OlO\

)
{
lOOOO\
l\
lO\
OOOO
=
lOlO\
OOlOOlO\

;
ll\
OOlllllO
=
&
lOllOl\
OOlO
;
}
}
}
el\
se
{
Ve\
c3\

lOOOOllOlOOO
=
ll\
OO\
l\
llllO
->
lOO\
OlOOOOO
/
lOllO\
l\
l\
l\
l\
l\
l
.
m33R\
o\
tat\
i\
on
;
float\

lOOOOllOO\
OOO
=
2.0f
;
fo\
r\

(
int
llOl\
Olll\
ll
=
0
;
ll\
OlOlllll\

<
lllOl\
lO\
l\
l\
OO
.
lO\
lO\
Ol\
O\
ll\
O
->
lO\
llOOllOl\

.
lOO\
Oll\
lOOl
(
)
;
llO\
lOl\
llll
++
)
{
Coll\
isionObjectConvex
::
Polyg\
o\
n
&
lO\
llO\
lO\
OOO\

=
llll\
ll\
OOO\
Ol
(
&
lllOll\
OllOO
,
ll\
OlO\
l\
llll
)
;
floa\
t
lOl\
O\
OOlOO\
lO\

=
lOOOOllOlOOO
.
Dot
(
lOll\
OlOOO\
O
.
lOOOlOOOOO\

)
;
if\

(
lO\
OO\
OllO\
OO\
O\
O\

>
lOlOOOlOOlO
)
{
lOO\
OO\
l\
lOOOO\
O
=
lOlOOOlO\
Ol\
O
;
llO\
Ol\
lllOl
=
&
lOllOlOO\
OO\

;
}
}
}
}
TA_ASSERT
(
llOOll\
l\
lOl\

)
;
TA_\
ASSERT
(
ll\
OOl\
llllO
)
;
#ifdef lOOOOOOOllOO
lll\
Ol\
lOl\
lOO\

.
lOOOO\
OO\
OllOl
=
llOO\
lll\
lOl
;
ll\
l\
OllO\
l\
lOl
.
lOOOOO\
OOllOl
=
llOOll\
l\
llO
;
#endif //
fo\
r
(
lOlll\
OOl\
ll
=
0
;
lOlll\
OOlll\

<
lllOllO\
l\
lOO
.
lOlOOl\
O\
llO
->
ll\
l\
llOlll\
Ol
.
lO\
OOlll\
O\
Ol
(
)
;
lOlll\
OOlll
++
)
ll\
lll\
OO\
llOO
[
lOlllOO\
lll
]
=
lllOllOl\
lOO
.
lO\
lOOlOllO\

->
lll\
llOl\
llO\
l
[
lOlll\
OOll\
l
]
*
lOl\
llOOOOOO
;
ll\
lOl\
l\
O\
l\
lO\
l
.
lOOOOO\
lO\
O\
Oll
(
lO\
O\
OOllOOO\
Ol\

,
llll\
l\
OO\
lOll
,
ll\
l\
l\
lOOllOO
,
*
ll\
OOlllllO
,
lO\
lllOO\
OOO\
l
,
k_mF\
r\
ameIde\
n\
t\
i\
t\
y\

,
1.0f
)
;
sta\
ti\
c
Vec3
lO\
O\
OOllOl\
O\
Ol\

[
ll\
lll\
OOlOOl
]
;
MFr\
ame
lOOOOllO\
lOlO\

=
lO\
lllOO\
OOOO
.
GetInver\
se
(
)
;
fo\
r
(
lO\
ll\
lOOlll
=
0
;
lO\
ll\
lO\
Ol\
ll
<
ll\
lOl\
lOllOl\

.
lO\
lOO\
lOllO
->
ll\
l\
llO\
lllO\
l\

.
lOOOl\
llOOl
(
)
;
lOlllO\
Oll\
l
++
)
lOOO\
OllOl\
OOl
[
lOlllOOlll\

]
=
lllOl\
lOllOl\

.
lOl\
O\
Ol\
Oll\
O
->
ll\
ll\
l\
Olll\
Ol\

[
lOl\
l\
l\
OOlll\

]
*
lOOOOllOlO\
lO
;
lll\
O\
ll\
OllOO\

.
lOOO\
OOlO\
OOll
(
lO\
OOO\
ll\
O\
OOlO
,
lO\
O\
OOOl\
OlOOO\

,
lOOO\
O\
l\
lO\
lOO\
l
,
*
llOOllllOl
,
lOlllOOOOOl
,
lOll\
Ol\
l\
lll\
l\

,
-
1.0f
)
;
for
(
int
lOOO\
Ol\
l\
Ol\
Ol\
l
=
0
;
lOOOO\
ll\
OlO\
l\
l\

<
llO\
Ollll\
Ol
->
lOl\
lOllO\
ll
;
lOOOOll\
OlO\
ll
++
)
{
int
lOOOOllO\
ll\
OO
=
lO\
OO\
Oll\
OlOl\
l
;
in\
t\

lO\
OOOllOl\
lOl\

=
llOOll\
llOl
->
llO\
llllOO\
O
[
lO\
OOOll\
Ol\
l\
O\
O
]
.
llO\
ll\
lOl\
l\
O
;
int
lOOOOllOlll\
O
=
(
lOOO\
O\
l\
lOlOll
+
1
<
llOOlll\
l\
Ol\

->
lOll\
OllOll
)
?
lOOOOllOlOll
+
1
:
0
;
int
lO\
O\
OOl\
l\
Ollll
=
llOOll\
llOl
->
llO\
l\
ll\
l\
OOO
[
lO\
OOOllOll\
l\
O
]
.
llOlllOl\
lO
;
lOOO\
Oll\
Oll\
O\
O
=
lOOOOllOllO\
l
;
lOOO\
Oll\
OlllO\

=
lOOOO\
l\
lOllll
;
for
(
int
lOOOO\
lll\
OOO\
O
=
0
;
lOOOOlll\
OOOO
<
ll\
OOllll\
lO
->
lOl\
lOll\
Oll
;
lOOOOlllOO\
OO
++
)
{
int
lOOOO\
lllOO\
Ol
=
lOOO\
OlllOOOO\

;
int
lOOOO\
ll\
lOOl\
O
=
ll\
OOlll\
ll\
O
->
llOllllOOO\

[
lOOOO\
lllOOOl
]
.
ll\
Ol\
l\
lOllO
;
in\
t
lO\
OOOl\
l\
lOOl\
l
=
(
lO\
OOO\
ll\
lOOOO
+
1
<
llOOlllllO
->
lOl\
lO\
ll\
Ol\
l\

)
?
lOO\
OO\
l\
llO\
OOO\

+
1
:
0
;
in\
t
lO\
O\
OOlll\
OlOO
=
llO\
Olllll\
O
->
llOlll\
lOO\
O
[
lOOO\
Oll\
l\
OOl\
l
]
.
llOlllOllO
;
lOO\
O\
Oll\
l\
OOOl\

=
lOO\
OOlll\
OOl\
O
;
lOOOOlllOO\
l\
l
=
lOOOO\
lllOl\
OO
;
Vec3
ll\
lllO\
Ol\
l\
l
;
Vec3
lllllO\
ll\
Ol
;
if
(
Geo\
metr\
y
::
Fin\
dC\
los\
e\
stP\
ointOnLine\
T\
oLin\
eUnClam\
p\
ed
(
ll\
lOllOllOl
.
lO\
lOOl\
O\
llO
->
lll\
ll\
Ol\
llOl
[
lOOOOlllOOlO
]
,
ll\
l\
Ol\
lO\
ll\
Ol
.
lOlOOl\
O\
llO\

->
lll\
llOlllOl\

[
lOOOO\
l\
llO\
lOO\

]
,
ll\
lllOO\
lOll
[
lOOOO\
llOll\
OO
]
,
lll\
l\
lOO\
lOl\
l\

[
lOOOOllO\
ll\
l\
O\

]
,
lllllOllOl\

,
llll\
lOOl\
ll
)
)
{
if
(
lOOO\
OlOlOlOl
<
lO\
OOOlO\
lOllO
)
{
fl\
oa\
t
lOlOll\
O\
lll
=
llO\
Oll\
llOl\

->
lOO\
OlOOO\
OO
.
Dot
(
ll\
lllOllOl
*
lOOOOlOlOlOO
)
-
ll\
OO\
llllOl\

->
lOl\
Oll\
Oll\
l
;
if
(
lOlOllOlll
<
-
0.00001f
)
{
Ve\
c3
lOOOlOOOOO
=
lllllOllO\
l\

-
ll\
lllOOl\
ll
;
fl\
oat\

lO\
lll\
lO\
O\
ll
=
lOOOlOOOO\
O
.
GetMagnit\
ude
(
)
;
if
(
lO\
l\
ll\
lO\
Oll
>
0.00001f
)
{
lOO\
Ol\
OOO\
O\
O
/=
lOlll\
lOOll
;
Collision
lOll\
Oll\
Ol\
Ol
;
lO\
llOllO\
lO\
l
.
Ini\
tialis\
e
(
Co\
ll\
i\
sio\
n\

::
lO\
l\
l\
OOl\
ll\
lO
,
0.0f
,
-
lO\
l\
Oll\
Olll
,
ll\
l\
l\
lOl\
lOl\

,
lOOOlOOOOO
)
;
if
(
!
lllO\
lllOll\
O
(
lOl\
l\
OllOlOl
,
lOlllOO\
OOOl
)
)
retu\
r\
n\

;
}
co\
ntinu\
e
;
}
}
el\
se
{
fl\
oat\

lOlOllOll\
l
=
llO\
Ol\
llllO
->
lOOOl\
OOOO\
O\

.
Dot\

(
lllll\
OO\
l\
ll
)
-
llO\
Oll\
l\
l\
l\
O\

->
lO\
lOll\
O\
lll\

;
if
(
lO\
lOl\
lO\
lll
<
-
0.00001f
)
{
Vec3
lOOO\
lOOOO\
O
=
llll\
lOllOl
-
lll\
llOOl\
ll
;
flo\
at
lOllll\
OO\
l\
l
=
lOO\
O\
lOOOOO
.
Ge\
tM\
a\
gn\
itude
(
)
;
if
(
lOllllOOll\

>
0.00001f
)
{
lOOO\
lOO\
OO\
O\

/=
lOllllO\
Ol\
l
;
Collisi\
o\
n\

lOllO\
l\
lO\
lOl
;
lO\
llOllOl\
Ol\

.
Initialise\

(
Co\
llisi\
on
::
lOllOOl\
ll\
lO
,
0.0f
,
-
lOlO\
l\
lOlll\

,
ll\
lllOOll\
l\

,
lOOOl\
OO\
OOO\

)
;
if
(
!
lllO\
lllOllO
(
lOl\
l\
Oll\
OlOl
,
lOl\
llOOOOOl
)
)
re\
t\
ur\
n
;
continue\

;
}
}
}
}
if\

(
lO\
lllOOO\
OO\
l
->
lO\
llOll\
lO\
Ol
)
{
Vec\
3
lOll\
llO\
OlO
;
Vec3\

lOll\
ll\
OOOl\

;
fl\
oat
llllOl\
OO\
O\
l
;
if
(
Geo\
m\
et\
ry
::
TestEdgeM\
ovementAgainstEdge\

(
lllllOOlOll
[
lOO\
OOllOll\
OO\

]
,
lllll\
OO\
lOll
[
lOOOO\
llOlll\
O\

]
,
lll\
llOOllOO
[
lOO\
OOll\
O\
llOO
]
,
llll\
lOOll\
OO\

[
lOOO\
Ol\
l\
Olll\
O
]
,
lllOllOllOl
.
lOl\
OOlOl\
l\
O\

->
ll\
lll\
Oll\
lOl
[
lOOOOl\
l\
lOOlO
]
,
ll\
l\
OllOllOl
.
lOlOOlO\
ll\
O\

->
lll\
llOlllOl
[
lO\
OO\
Oll\
l\
Ol\
OO
]
,
ll\
l\
lOlOOO\
l
,
lOll\
ll\
OOOl
,
lO\
llll\
O\
O\
lO
)
)
{
if
(
lOO\
OO\
lOl\
Ol\
Ol
<
lOO\
OO\
lOlO\
l\
lO
)
{
if
(
lO\
l\
ll\
l\
OOlO
.
Dot
(
llO\
O\
lll\
lOl\

->
lOO\
OlO\
OO\
O\
O\

*
lOllOlll\
ll\
l
.
m3\
3\
Rotat\
i\
on
)
>
0.0f
)
lO\
l\
lllOOl\
O
=
-
lO\
lll\
lO\
OlO
;
}
else
{
if\

(
lOllllOO\
lO
.
Do\
t\

(
llOOlllllO
->
lO\
OOl\
OO\
OOO
)
<
0.0f
)
lOlll\
lO\
OlO\

=
-
lOlll\
lOO\
l\
O
;
}
Col\
lisi\
on\

lOllOllOl\
Ol
;
lO\
l\
l\
Ol\
lO\
lOl
.
Ini\
tialise
(
Coll\
is\
io\
n
::
lOll\
O\
Ol\
ll\
lO
,
llllO\
lOOOl
,
0.0f
,
lOl\
lllO\
O\
Ol
,
lOllllOOlO\

)
;
if
(
!
lllO\
lllOllO
(
lOl\
lOllOlOl\

,
lO\
ll\
lOOOO\
Ol
)
)
retu\
rn
;
}
}
}
}
}
voi\
d
TAC_\
C\
A\
L\
L
llllOOOO\
OlO
(
co\
nst
MFrame
&
lOllO\
ll\
l\
ll\
l
,
co\
nst\

MFrame
&
lOl\
l\
lO\
O\
OOOO\

,
lOllO\
llOll\
O
*
lO\
l\
llOOO\
OOl
)
{
TA_ASSERT\

(
lOlllOOO\
OOl\

->
lO\
l\
lOOOllOl
->
Ge\
t\
Col\
lisi\
on\
Obj\
e\
ctType
(
)
==
Co\
ll\
is\
i\
onObje\
ct
::
TY\
PE\
_\
C\
APSULE
)
;
TA_ASSERT
(
lOlllOOO\
O\
Ol
->
lOllO\
OO\
lll\
O
->
Ge\
tCo\
ll\
is\
i\
o\
nObje\
ct\
Type
(
)
==
Colli\
sion\
Object\

::
TYPE\
_CONVEX
)
;
con\
st\

Co\
l\
lisio\
nO\
b\
jectCapsu\
le
&
lO\
l\
ll\
O\
lO\
OOO\

=
*
(
Collis\
ionObjec\
t\
Cap\
sule
*
)
lOlllOO\
OO\
O\
l
->
lO\
l\
lOOOl\
lOl
;
con\
s\
t
Collis\
ionObje\
ct\
Conve\
x
&
lOOOOlllOl\
Ol
=
*
(
Col\
l\
isionObjectC\
onvex
*
)
lOlllO\
OOOO\
l
->
lO\
llOOOlllO\

;
bool
lOll\
OlllOOl
=
lOlllOOOO\
Ol
->
lOll\
O\
l\
l\
lO\
Ol\

;
Vec3
lOlllOOl\
llO
[
2
]
;
lOlll\
OOlllO
[
0
]
=
lOlllOlOOOO
.
lllOlOl\
OOOO
*
lOllOl\
lllll
;
lOlllOOl\
llO
[
1
]
=
lOlllOlOOOO
.
lllOlOlOOOl\

*
lOllOl\
l\
llll
;
Ve\
c3\

lOll\
llOO\
OOl\

[
2
]
;
lOll\
llO\
OOOl
[
0
]
=
lOll\
lO\
l\
OOOO
.
ll\
lO\
l\
OlOOOO
*
lOlllOOOO\
OO\

;
lOllll\
O\
OO\
Ol
[
1
]
=
lO\
l\
l\
l\
OlOOOO
.
ll\
l\
Ol\
OlOOO\
l\

*
lOlll\
OOO\
OOO
;
int
lO\
OOO\
OOllllO
=
-
1
;
int
lOOO\
OOOll\
lll
=
-
1
;
float\

lOO\
OO\
OlOO\
O\
OO\

=
-
k_fMaxFloat
;
lOO\
OOlllOl\
Ol
.
lO\
OOOOOl\
l\
lOO
(
2
,
lO\
ll\
l\
OO\
lllO
,
lOO\
OOOOll\
llO
,
lOOOOOOlll\
ll\

,
lOOOO\
Ol\
OO\
OOO\

)
;
con\
st\

Colli\
sionObj\
ectC\
onvex
::
Po\
lygo\
n
*
llOOO\
lO\
O\
lO\

=
&
llll\
llOOOOl
(
&
lO\
O\
O\
Olll\
OlOl
,
lO\
OOOO\
Ol\
ll\
l\
O
)
;
#define lOlllOlOOll(lOOOllOOOl) lOOOOlllOlOl.GetData()->lllllOlllOl[llOOOlOOlO->llOllllOOO[lOOOllOOOl].llOlllOllO]
#define lOllllOOOOO(lllOllllOO, lllOlllllOl, llOOOlOOlO, lOOOOlllll, lOOOlOOOOO)								\
{																											\
	Collision lOllOllOlOl;																				\
	lOllOllOlOl.Initialise(																				\
		Collision::lOllOOllllO,																				\
		lllOllllOO,																								\
		lllOlllllOl,																								\
		lOOOOlllll,																							\
		lOOOlOOOOO);																							\
	lllOlllOllO(lOllOllOlOl, lOlllOOOOOl);										\
}
#define lOlllOllOll(lllOllllOO, lllOlllllOl, llOOOlOOlO, lllllllll, lOOOOOOOOO, lOOOOlllll, lOOOlOOOOO, lOllOlOlOOO)				\
{																											\
	Collision lOllOllOlOl;																				\
	lOllOllOlOl.Initialise(																				\
		Collision::lOllOOllllO,																				\
		lllOllllOO,																								\
		lllOlllllOl,																								\
		lOOOOlllll,																							\
		lOOOlOOOOO);																							\
	lllOlllOllO(lOllOllOlOl, lOlllOOOOOl);										\
}
#define lOlllOlllll(lllOllllOO, lllOlllllOl, llOOOlOOlO, lOlllOOlll, lllOOlllOOl, lllOOOllOlO, lOOOOlllll, lOOOlOOOOO)	\
{																											\
	Collision lOllOllOlOl;																				\
	lOllOllOlOl.Initialise(																				\
		Collision::lOllOOllllO,																				\
		lllOllllOO,																								\
		lllOlllllOl,																								\
		lOOOOlllll,																							\
		lOOOlOOOOO);																							\
	lllOlllOllO(lOllOllOlOl, lOlllOOOOOl);										\
}
#define lOlllOllOOl(lllllllll, lOOOOOOOOO, lOllOlOlOOO)
#define lOlllOllllO(lllOOOllOlO)
#define lOlllOOllll(llOOllllOO) (llOOOlOOlO->lOOOlOOOOO.Dot(llOOllllOO) - llOOOlOOlO->lOlOllOlll)
con\
st
bool
lOll\
llOOl\
ll
=
true
;
#include "../Physics/zpta002.inl"
#undef lOlllOlOOll
#undef lOllllOOOOO
#undef lOlllOOllll
#undef lOlllOllOll
#undef lOlllOlllll
#undef lOlllOllOOl
#undef lOlllOllllO
}
void
TA\
C_CALL
llllOOl\
O\
lOl
(
cons\
t\

MFrame\

&
lOllOl\
lllll\

,
co\
ns\
t
MF\
ra\
me
&
lO\
l\
llOOO\
OO\
O
,
lOll\
OllOll\
O
*
lOl\
llOOOOO\
l\

)
{
TA_\
ASSERT\

(
lOl\
llOOO\
OOl
->
lOll\
O\
O\
O\
llOl
->
GetC\
o\
ll\
is\
ionO\
bje\
ct\
Type
(
)
==
Coll\
i\
s\
io\
n\
Obj\
ec\
t
::
TY\
PE_CYLIND\
E\
R
)
;
TA_A\
SS\
E\
RT
(
lO\
l\
ll\
OOOOO\
l
->
lOllOO\
Ol\
ll\
O
->
GetC\
o\
lli\
s\
ionObjectTyp\
e
(
)
==
Col\
li\
si\
onO\
bje\
c\
t
::
TYP\
E\
_C\
O\
NVEX
)
;
con\
s\
t
Coll\
ision\
Obj\
ect\
C\
ylinder
&
ll\
OOl\
lO\
l\
llO
=
*
(
Col\
li\
sionObjectCylin\
de\
r\

*
)
lO\
lllOOOOOl
->
lOl\
l\
OO\
Ol\
lOl
;
co\
n\
st
Colli\
s\
ionObjec\
tConv\
e\
x
&
lOO\
O\
Olll\
OlOl
=
*
(
Collis\
ionObj\
ec\
tConv\
ex
*
)
lOll\
lOOOOOl
->
lOllO\
OOlllO\

;
bo\
ol\

lOl\
l\
OlllOOl
=
lO\
l\
llO\
OOOOl
->
lOllO\
ll\
lOO\
l
;
Ve\
c\
3
lOlllOOlllO
[
2
]
;
lOll\
l\
OO\
ll\
l\
O
[
0
]
=
llO\
OllOlllO\

.
lll\
Ol\
OlOOOO\

*
lOllO\
lll\
lll\

;
lOll\
lO\
Oll\
lO
[
1
]
=
ll\
OOl\
l\
O\
l\
llO
.
lllO\
lOlOO\
Ol
*
lOllOl\
lllll
;
Vec3\

lOllll\
O\
OO\
Ol
[
2
]
;
lOl\
lllO\
OOOl
[
0
]
=
llOOll\
OlllO
.
ll\
lOl\
Ol\
OOOO
*
lOll\
l\
OOOOOO
;
lOlll\
lOOO\
O\
l
[
1
]
=
llOO\
ll\
Oll\
lO\

.
lll\
O\
lO\
lOOO\
l
*
lO\
l\
ll\
O\
O\
O\
OOO
;
Vec3
llO\
Ol\
lOl\
Ol\
l
=
lO\
lllOOl\
ll\
O
[
1
]
-
lOlllO\
Olll\
O
[
0
]
;
TA\
_ASSER\
T\

(
ll\
OOllOlOll
.
Ge\
t\
Magni\
tu\
d\
e
(
)
>
0.0f
)
;
llOOll\
OlOl\
l
.
Norma\
lise
(
)
;
in\
t
lOOO\
OOOl\
lll\
O\

=
-
1
;
int\

lOOOOO\
Ol\
llll
=
-
1
;
flo\
a\
t
lO\
OO\
OO\
lOOOOO
=
-
k_\
f\
M\
axFloat\

;
lOOOOlllOlO\
l
.
lOOO\
O\
OOll\
l\
OO
(
2
,
lOl\
ll\
OOl\
l\
lO
,
lOOOOOOl\
ll\
lO\

,
lOOO\
OO\
O\
lllll\

,
lOOO\
O\
Ol\
OOOO\
O
)
;
const
CollisionObjectConvex
::
Polygon
*
llOOOlOOlO
=
&
lll\
lllOOOO\
l
(
&
lOOOO\
lll\
O\
l\
O\
l
,
lOOOOOO\
llllO
)
;
#define lOlllOlOOll(lOOOllOOOl) lOOOOlllOlOl.GetData()->lllllOlllOl[llOOOlOOlO->llOllllOOO[lOOOllOOOl].llOlllOllO]
#define lOllllOOOOO(lllOllllOO, lllOlllllOl, llOOOlOOlO, lOOOOlllll, lOOOlOOOOO)								\
{																											\
	Collision lOllOllOlOl;																				\
	lOllOllOlOl.Initialise(																				\
		Collision::lOllOOllllO,																				\
		lllOllllOO,																								\
		lllOlllllOl,																								\
		lOOOOlllll,																							\
		lOOOlOOOOO);																							\
	lllOlllOllO(lOllOllOlOl, lOlllOOOOOl);										\
}
#define lOlllOllOll(lllOllllOO, lllOlllllOl, llOOOlOOlO, lllllllll, lOOOOOOOOO, lOOOOlllll, lOOOlOOOOO, lOllOlOlOOO)				\
{																											\
	Collision lOllOllOlOl;																				\
	lOllOllOlOl.Initialise(																				\
		Collision::lOllOOllllO,																				\
		lllOllllOO,																								\
		lllOlllllOl,																								\
		lOOOOlllll,																							\
		lOOOlOOOOO);																							\
	lllOlllOllO(lOllOllOlOl, lOlllOOOOOl);										\
}
#define lOlllOlllll(lllOllllOO, lllOlllllOl, llOOOlOOlO, lOlllOOlll, lllOOlllOOl, lllOOOllOlO, lOOOOlllll, lOOOlOOOOO)	\
{																											\
	Collision lOllOllOlOl;																				\
	lOllOllOlOl.Initialise(																				\
		Collision::lOllOOllllO,																				\
		lllOllllOO,																								\
		lllOlllllOl,																								\
		lOOOOlllll,																							\
		lOOOlOOOOO);																							\
	lllOlllOllO(lOllOllOlOl, lOlllOOOOOl);										\
}
#define lOlllOllOOl(lllllllll, lOOOOOOOOO, lOllOlOlOOO)
#define lOlllOllllO(lllOOOllOlO)
#define lOlllOOllll(llOOllllOO) (llOOOlOOlO->lOOOlOOOOO.Dot(llOOllllOO) - llOOOlOOlO->lOlOllOlll)
con\
st
bool
lOllllO\
O\
l\
l\
l\

=
tru\
e
;
#include "../Physics/zpta003.inl"
#undef lOlllOlOOll
#undef lOllllOOOOO
#undef lOlllOOllll
#undef lOlllOllOll
#undef lOlllOlllll
#undef lOlllOllOOl
#undef lOlllOllllO
}
void
TA\
C_\
CALL
llllO\
OlOlOO
(
cons\
t
MF\
rame
&
lO\
llO\
lll\
lll
,
co\
nst\

MF\
r\
ame\

&
lOlllOOOOOO
,
lOllOll\
Ol\
lO
*
lOll\
lO\
OO\
OOl
)
{
TA_\
ASSE\
RT
(
lO\
lllO\
OOOOl
->
lO\
llOOOllOl\

->
GetColl\
is\
ion\
Obj\
ectType
(
)
==
Coll\
i\
sionO\
bje\
ct
::
TYPE_SP\
HE\
RE
)
;
TA\
_AS\
SERT
(
lOll\
lOOOO\
O\
l\

->
lOllOO\
Ol\
l\
lO
->
GetColl\
isionObj\
ectT\
y\
pe\

(
)
==
Coll\
ision\
Ob\
j\
e\
ct
::
TYPE_CON\
VEX\

)
;
cons\
t
Co\
ll\
i\
sio\
n\
O\
bjectS\
phere\

&
lll\
Ollll\
OOO
=
*
(
Co\
l\
li\
s\
ionObj\
ectSpher\
e\

*
)
lOlllOOOOO\
l
->
lOll\
OO\
Ol\
lOl
;
co\
nst
Collisi\
on\
Ob\
jec\
tConv\
ex
&
lO\
O\
OO\
lllOlO\
l\

=
*
(
Collision\
Objec\
tC\
o\
nve\
x
*
)
lOlllOOO\
OOl
->
lO\
llOOOl\
ll\
O
;
Vec3
lOO\
l\
O\
lOlll
=
ll\
lOllll\
O\
OO
.
ll\
lOOOOlOl\
O
*
lO\
l\
l\
Ollllll
;
Vec3
lOOlOllOOl\

=
lllO\
ll\
l\
lOOO
.
lllOOO\
O\
l\
O\
lO
*
lOll\
l\
OOO\
O\
O\
O
;
bo\
ol
lOllOlllOOl
=
lOlll\
OO\
O\
OOl
->
lO\
llOlllOOl
;
in\
t\

lOOOOOOl\
lllO
=
-
1
;
int
lOOOOOOll\
l\
ll
=
-
1
;
fl\
oat
lOOO\
O\
OlOOO\
OO
=
-
k_fMax\
Float
;
lOOO\
Olll\
Ol\
Ol
.
lOOOO\
OOlllOO\

(
1
,
&
lOO\
lOlOlll
,
lO\
OOOO\
OllllO
,
lOOO\
OOOl\
llll\

,
lO\
OOOOlOOOOO
)
;
cons\
t
Collis\
ionO\
b\
jectCon\
v\
ex
::
Polyg\
on\

*
ll\
OOOlOOlO
=
&
llll\
llOOOOl
(
&
lOOOO\
ll\
lOl\
O\
l
,
lOO\
OOOO\
llllO
)
;
#define lOlllOlOOll(lOOOllOOOl) lOOOOlllOlOl.GetData()->lllllOlllOl[llOOOlOOlO->llOllllOOO[lOOOllOOOl].llOlllOllO]
#define lOllllOOOOO(lllOllllOO, lllOlllllOl, llOOOlOOlO, lOOOOlllll, lOOOlOOOOO)								\
{																											\
	Collision lOllOllOlOl;																				\
	lOllOllOlOl.Initialise(																				\
		Collision::lOllOOllllO,																				\
		lllOllllOO,																								\
		lllOlllllOl,																								\
		lOOOOlllll,																							\
		lOOOlOOOOO);																							\
	lllOlllOllO(lOllOllOlOl, lOlllOOOOOl);										\
}
#define lOlllOllOll(lllOllllOO, lllOlllllOl, llOOOlOOlO, lllllllll, lOOOOOOOOO, lOOOOlllll, lOOOlOOOOO, lOllOlOlOOO)				\
{																											\
	Collision lOllOllOlOl;																				\
	lOllOllOlOl.Initialise(																				\
		Collision::lOllOOllllO,																				\
		lllOllllOO,																								\
		lllOlllllOl,																								\
		lOOOOlllll,																							\
		lOOOlOOOOO);																							\
	lllOlllOllO(lOllOllOlOl, lOlllOOOOOl);										\
}
#define lOlllOlllll(lllOllllOO, lllOlllllOl, llOOOlOOlO, lOlllOOlll, lllOOlllOOl, lllOOOllOlO, lOOOOlllll, lOOOlOOOOO)	\
{																											\
	Collision lOllOllOlOl;																				\
	lOllOllOlOl.Initialise(																				\
		Collision::lOllOOllllO,																				\
		lllOllllOO,																								\
		lllOlllllOl,																								\
		lOOOOlllll,																							\
		lOOOlOOOOO);																							\
	lllOlllOllO(lOllOllOlOl, lOlllOOOOOl);										\
}
#define lOlllOllOOl(lllllllll, lOOOOOOOOO, lOllOlOlOOO)
#define lOlllOllllO(lllOOOllOlO)
#define lOlllOOllll(llOOllllOO) (llOOOlOOlO->lOOOlOOOOO.Dot(llOOllllOO) - llOOOlOOlO->lOlOllOlll)
#define lOOOOlllOllO
const
bo\
o\
l
lOl\
l\
llO\
Olll
=
tr\
ue
;
#include "../Physics/zpta004.inl"
#undef lOOOOlllOllO
#undef lOlllOlOOll
#undef lOllllOOOOO
#undef lOlllOOllll
#undef lOlllOllOll
#undef lOlllOlllll
#undef lOlllOllOOl
#undef lOlllOllllO
}
vo\
id
TAC\
_CALL\

ll\
lOlOO\
l\
lO\
O
(
cons\
t
MFrame\

&
lO\
llOl\
llll\
l
,
con\
s\
t
MFrame
&
lOlllOOOOOO\

,
lOllOl\
lOl\
l\
O
*
lOlllO\
OO\
OOl\

)
{
TA\
_A\
SS\
ERT
(
lOlllOOO\
OO\
l
->
lOllOO\
OllOl
->
GetColl\
isi\
onObj\
ectT\
y\
pe
(
)
==
Coll\
ision\
O\
bject
::
TY\
PE\
_\
CO\
NVE\
X
)
;
Co\
lli\
sion\
ObjectC\
onvex
&
lOOO\
Ol\
llOlll
=
*
(
Collis\
ionO\
b\
ject\
C\
o\
n\
v\
ex\

*
)
lOll\
lOO\
OOOl
->
lOllOOO\
llOl
;
TA_A\
SSER\
T
(
lOll\
lO\
OO\
O\
Ol\

->
lOllOOO\
lllO\

->
GetCol\
l\
is\
i\
onO\
bjectType\

(
)
==
CollisionO\
bject\

::
TYPE_C\
A\
CHED_\
POL\
Y_DATA
)
;
Collision\
Obje\
ctC\
ach\
edPo\
lyData\

&
llO\
ll\
llOlll
=
*
(
Coll\
isio\
nObject\
Ca\
chedPo\
lyData
*
)
lOlll\
OO\
O\
OOl
->
lOl\
lOOOl\
ll\
O\

;
TA_\
ASS\
ERT
(
lOO\
OOlll\
Ol\
ll
.
lO\
lOO\
l\
OllO
)
;
TA\
_A\
SSERT
(
lO\
O\
O\
OlllOl\
ll
.
lO\
lOOl\
O\
ll\
O
->
ll\
l\
llOlllOl
.
lO\
OOlll\
OO\
l
(
)
<
llll\
l\
OOlO\
Ol\

)
;
int\

lOlllOOlll\

;
lll\
l\
lO\
lOOOl
(
)
;
for\

(
lOll\
l\
OO\
l\
ll
=
0
;
lOlll\
O\
O\
ll\
l
<
lOOOO\
ll\
l\
Ol\
ll
.
lOlO\
OlOllO
->
ll\
l\
llOlllO\
l
.
lOOO\
lllOOl
(
)
;
lOl\
l\
l\
OOl\
ll
++
)
lllll\
O\
Ol\
Oll\

[
lOlllO\
Olll\

]
=
lO\
OO\
Ol\
ll\
Olll
.
lOl\
OOlOl\
lO
->
lllllO\
lllOl
[
lOll\
l\
O\
O\
l\
ll\

]
*
lOllOllllll
;
fo\
r
(
lOlllOOlll
=
0
;
lOl\
llOOlll
<
lO\
OOO\
lllOlll
.
lOlOO\
lO\
llO\

->
lllllOlll\
Ol
.
lOOOlllOOl
(
)
;
lOlll\
OO\
lll
++
)
ll\
ll\
lO\
Ol\
lOO
[
lO\
ll\
lOO\
lll\

]
=
lO\
OOOlllO\
lll
.
lOlO\
Ol\
O\
llO\

->
ll\
l\
llOlllOl
[
lOlll\
O\
Ol\
ll
]
*
lOlllOOOO\
OO
;
const\

Vec3
lOOOO\
ll\
l\
lO\
OO
=
lO\
OOOll\
lOlll
.
Ge\
tDat\
a\

(
)
->
lllOl\
lO\
OO\
OO
*
lOllOl\
l\
llll
;
for
(
in\
t
lllOll\
lllOO
=
0
;
ll\
l\
Ol\
llllO\
O
<
llO\
lll\
lOlll
.
lO\
O\
O\
ll\
OOOl\
O
.
lOO\
Oll\
lO\
Ol\

(
)
;
)
{
Collisi\
onO\
b\
jectC\
a\
c\
hedPolyData
::
Polyg\
on
*
ll\
O\
O\
OlOOlO
=
(
Col\
lis\
io\
nOb\
jectCachedPol\
y\
Da\
t\
a\

::
Pol\
ygon\

*
)
&
llOl\
lllO\
lll\

.
lOOOllO\
OOlO
[
lllO\
l\
l\
ll\
lO\
O
]
;
ll\
l\
O\
ll\
ll\
l\
OO
+=
llOll\
l\
lOlll
.
lll\
O\
Ol\
Ollll
(
llOOOlOOlO
->
lOllOllOll
)
;
TA_ASSE\
RT
(
lOO\
O\
OlllOll\
l
.
Ge\
tData
(
)
->
lllllOlllOl
.
lOO\
Olll\
O\
Ol
(
)
<
lllllO\
OlOOl\

)
;
int
lOOOO\
llllOOl
=
0
;
for
(
lOOOOlll\
lO\
Ol
=
0
;
lOOOOllllOO\
l
<
lO\
OOOlll\
O\
lll
.
GetData\

(
)
->
lllllOl\
l\
lOl
.
lO\
OOl\
l\
lOOl
(
)
;
lOOO\
O\
lll\
l\
OOl
++
)
{
cons\
t
Vec3
&
lOO\
OO\
l\
l\
llO\
l\
O
=
ll\
OOOlOOl\
O
->
llOl\
lllOOO
[
0
]
.
lOOOOlllll
;
const
Ve\
c3
&
lllllllll
=
lO\
OOOllll\
O\
OO
;
const
Vec3
&
lOOOOOOOOO\

=
llll\
l\
OOlOll
[
lOOOOlll\
lOOl
]
;
flo\
at\

lO\
lO\
l\
lO\
OlO
=
llOOO\
lOO\
lO
->
lOOOlOOOOO
.
Dot
(
lllll\
llll
-
lOO\
OOllllO\
lO
)
;
float
lOlO\
ll\
O\
O\
ll\

=
llO\
OOlOOlO
->
lOOOlOOOOO
.
Do\
t\

(
lOOO\
OOOOOO
-
lOOOOlll\
lOlO
)
;
if
(
lOlOllOOll\

>=
0.0f
||
lOl\
OllOO\
lO\

<=
0.0f
)
continue
;
TA\
_ASSE\
RT
(
lO\
lOll\
O\
O\
l\
O
-
lO\
lOl\
lO\
Ol\
l
>
0.0f
)
;
float
lOllll\
O\
O\
OlO\

=
lOlOllOOlO
/
(
lOlOllOOlO\

-
lO\
lOl\
lOO\
ll\

)
;
Ve\
c\
3
lOlllOl\
lOlO
=
llll\
l\
ll\
ll
+
(
lO\
O\
OO\
OOOOO
-
llllll\
l\
ll
)
*
lO\
l\
ll\
lOO\
Ol\
O
;
int
lO\
O\
Oll\
OOO\
l
;
for\

(
lOOOll\
OO\
O\
l\

=
0
;
lOO\
Oll\
O\
O\
O\
l
<
llOOO\
lO\
OlO\

->
lOll\
Ol\
l\
O\
ll
;
lOOOllO\
OOl\

++
)
{
const\

Vec3
&
lOlllO\
lOOl\
O
=
llOOOlOOlO
->
llOllllOOO\

[
lOOO\
ll\
O\
OOl
]
.
lOOO\
O\
lllll
;
if\

(
llOO\
Ol\
OOlO
->
ll\
Oll\
l\
lO\
OO\

[
lOOOl\
lOOO\
l
]
.
lOl\
llOlO\
l\
Ol
.
Dot
(
lOll\
l\
OllOlO\

-
lOll\
lOlOOl\
O
)
<
0.0f
)
br\
ea\
k
;
}
if
(
lOO\
O\
l\
lOO\
Ol\

!=
llO\
OOl\
O\
OlO
->
lOl\
lOl\
lO\
l\
l
)
co\
ntinu\
e
;
const
float
lOOOOl\
l\
llOl\
l
=
ll\
OOOlO\
Ol\
O
->
lOOOl\
OOO\
OO
.
Dot
(
lOll\
lO\
ll\
OlO
-
lO\
OOOO\
OOOO\

)
;
Coll\
ision
lOllOllOlO\
l
;
lOllOl\
lOlOl
.
Ini\
tialise
(
Collision
::
lOllOOllllO
,
0.0f
,
lO\
OO\
Oll\
llO\
ll\

,
lOO\
OO\
OOOOO
,
ll\
OOOlOOl\
O
->
lO\
O\
OlOO\
O\
OO\

)
;
lOll\
Ol\
lOl\
Ol\

.
lOl\
l\
OOl\
OO\
OO
=
llO\
OOlOOlO
->
llO\
lll\
O\
Ol\
lO\

;
lllOOllOlOl
(
lOllOllOlOl
,
lOlllOOOOOl
)
;
}
in\
t
lO\
OOO\
lllllOO
=
0
;
int
lOOOO\
lllll\
Ol
=
0
;
fo\
r
(
lOO\
OOllllOOl
=
0
;
lO\
OOO\
lll\
lOOl
<
lO\
O\
OOll\
lOl\
ll
.
Ge\
tD\
ata\

(
)
->
ll\
ll\
lOlllO\
l
.
lO\
O\
O\
lllOOl
(
)
;
lO\
OO\
Ol\
ll\
l\
O\
Ol
++
)
{
const\

Vec3
&
lOOOO\
l\
lll\
OlO
=
llOO\
O\
l\
OO\
l\
O
->
llOll\
llOO\
O
[
0
]
.
lOO\
OOlllll\

;
const
Vec3
&
llll\
lllll
=
lllllOOlOl\
l
[
lOO\
OO\
llllOOl
]
;
cons\
t\

Vec\
3
&
lOOOOOOOOO\

=
ll\
l\
l\
lOOllOO
[
lO\
OO\
Ol\
l\
llOOl
]
;
fl\
oa\
t
lOl\
O\
llOOl\
O
=
ll\
O\
OOlOOlO
->
lOOOlOOOOO
.
Dot
(
llllllll\
l
-
lOOOOl\
l\
llO\
lO
)
;
float\

lOl\
Ol\
lOOll
=
llOOO\
l\
O\
OlO
->
lOOOlOOO\
OO
.
Dot
(
lOOOOOOOOO
-
lOO\
OOl\
l\
l\
lOl\
O
)
;
if
(
lOlOllO\
Oll
>=
0.0f
&&
lOl\
Ol\
lOOlO
>=
0.0f
)
{
lO\
OOOlllll\
OO
++
;
con\
tin\
u\
e\

;
}
if
(
lO\
l\
OllOOlO
<=
0.0f
)
{
if
(
lOlOll\
OOll
<=
0.0f
)
lOOOO\
ll\
lllOl
++
;
co\
ntinu\
e
;
}
TA_ASSERT
(
lOlO\
llOO\
lO
-
lOlOllOO\
l\
l
>
0.0f
)
;
fl\
oat
lOl\
l\
l\
lOOOl\
O
=
lOlOl\
lOOl\
O
/
(
lOl\
O\
llOOl\
O
-
lO\
lOl\
lO\
Ol\
l
)
;
Ve\
c\
3
lOll\
lOl\
lOlO
=
lllllll\
ll
+
(
lO\
OOOOO\
OOO
-
llll\
l\
llll
)
*
lOl\
ll\
lOOO\
lO\

;
#ifdef _DEBUG
if
(
lOO\
lO\
O\
O\
llO\

)
{
flo\
at\

lOOOOl\
lll\
llO
=
llOOOl\
O\
OlO
->
lO\
O\
OlOOOOO
.
Dot
(
lOlllO\
ll\
OlO
-
lOO\
O\
O\
l\
lllO\
l\
O
)
;
TA\
_ASSERT
(
Fabs
(
lOOOOllllllO\

)
<
0.0001f
)
;
}
#endif //
in\
t
lOOO\
ll\
OO\
Ol\

;
for
(
lOOOl\
l\
OOO\
l\

=
0
;
lOO\
O\
ll\
O\
OO\
l
<
llOO\
OlOOlO
->
lOllOll\
Oll
;
lOO\
O\
l\
l\
OOOl
++
)
{
con\
st
Ve\
c3
&
lOlllOlOOlO
=
llOOO\
lO\
OlO
->
llO\
ll\
ll\
OOO
[
lOOOllOOOl\

]
.
lOO\
OOll\
l\
ll
;
if\

(
llOO\
Ol\
O\
OlO
->
ll\
Oll\
llOOO\

[
lO\
OOllOO\
O\
l
]
.
lOl\
l\
l\
O\
lOl\
Ol
.
Dot
(
lO\
lllOllOlO
-
lOlll\
Ol\
OOlO\

)
<
0.0f
)
break
;
}
if\

(
lOOOllOOOl
!=
llOOOlOO\
lO\

->
lOllOl\
lOl\
l
)
continue
;
Col\
li\
sion
lO\
llO\
llOlOl
;
lOl\
l\
O\
ll\
O\
lO\
l
.
Initialis\
e\

(
Co\
llision
::
lOllOOl\
l\
llO
,
lOl\
l\
l\
lOOOlO
,
0.0f
,
lll\
l\
lllll
,
llOOOlOOlO
->
lOOOlO\
OOOO
)
;
lOll\
O\
llOlO\
l
.
lOl\
lOOl\
O\
O\
OO
=
llOOOlOOlO
->
ll\
OlllOOl\
lO
;
lllOOllOlOl
(
lOll\
OllOl\
Ol
,
lOlll\
OOO\
OO\
l
)
;
}
if
(
lO\
OO\
O\
lllllOO
==
lO\
O\
OOll\
lOlll
.
GetDat\
a
(
)
->
lll\
l\
lOlll\
Ol
.
lOOOlll\
OOl
(
)
||
lO\
OO\
O\
l\
l\
l\
llOl\

==
lOO\
OOll\
lO\
lll\

.
GetDa\
ta\

(
)
->
lllll\
O\
l\
llOl
.
lOOOll\
l\
OO\
l
(
)
)
cont\
inue
;
for
(
in\
t
lOOOOl\
l\
l\
l\
lll
=
0
;
lOO\
OOl\
lllll\
l\

<
lOOOOlllOlll
.
Ge\
t\
Data
(
)
->
lll\
ll\
Ollll\
O
.
lOO\
Oll\
lO\
O\
l
(
)
;
lOOO\
Olllllll
++
)
{
const
Col\
lision\
O\
bj\
ectCon\
vex
::
lllllO\
lOl\
ll
&
llOlOlOO\
O\
O
=
lO\
O\
O\
O\
lllO\
l\
ll
.
Ge\
t\
Da\
ta
(
)
->
llll\
lOlll\
lO
[
lOOOOllllll\
l
]
;
co\
nst
Ve\
c3
&
lllll\
llll
=
lOllOll\
llll\

.
v3Translatio\
n
;
const\

Ve\
c3
&
lOOOO\
OOO\
OO
=
llll\
lO\
Ol\
Oll
[
llO\
l\
OlOOOO
.
lll\
llOll\
O\
Ol
]
;
co\
n\
st
Vec\
3\

&
llllOOOl\
lO
=
llll\
lO\
O\
lO\
l\
l
[
llOlOlOOOO
.
lll\
l\
l\
Ol\
lOO\
O
]
;
Vec\
3\

lOOOl\
OOO\
OOOO
=
(
lO\
OO\
OOOOO\
O
-
ll\
lll\
llll\

)
.
Cross
(
ll\
llOOOllO
-
lll\
llll\
ll\

)
;
TA_A\
SSERT\

(
lO\
OO\
lO\
O\
OOOO\
O
.
GetMagni\
tude\
Sqrd
(
)
>
0.0f
)
;
Ve\
c3
lOOOlOOOO\
OO\
l
=
lOOOlOOOOOOO
.
Cr\
oss
(
lOOOOOO\
OO\
O
-
llllll\
lll\

)
;
Ve\
c3
lOOOl\
OOOO\
Ol\
O\

=
lO\
OOl\
OOOO\
OOO
.
Cross
(
llllOOOl\
lO
-
lOOO\
O\
O\
O\
O\
O\
O
)
;
Vec\
3
lO\
OOlO\
OO\
O\
Ol\
l\

=
lOOOlOOOOOO\
O\

.
Cross
(
lll\
l\
l\
llll
-
llll\
OOO\
ll\
O
)
;
for
(
int\

lOO\
Ol\
OOOOlO\
O
=
0
;
lO\
OOlOOOO\
lOO
<
ll\
OOOl\
OOlO
->
lO\
llOllO\
ll
;
lOOO\
lOOO\
OlO\
O\

++
)
{
co\
n\
st\

Ve\
c3
&
lOllllO\
O\
lO\
O
=
llOO\
Ol\
OOlO
->
llO\
ll\
llOOO
[
lO\
OOlO\
O\
OO\
lOO
]
.
lOO\
OO\
ll\
ll\
l
;
const
Vec3\

&
lOlllO\
l\
l\
OO\
O
=
llO\
OOlOOlO
->
llOllllOOO\

[
lOOOl\
OOO\
OlO\
O
<
llOOOlOOlO\

->
lOllO\
llOll\

-
1
?
lOOOl\
OOO\
Ol\
OO
+
1
:
0
]
.
lO\
OOOlllll
;
fl\
oat
lOlOl\
lOO\
lO
=
lOOOl\
OOO\
OOOO
.
Dot
(
lOllllOOlO\
O
-
llllll\
ll\
l\

)
;
floa\
t\

lOlOllOOll\

=
lOOOl\
O\
OOOOOO\

.
Dot\

(
lO\
lllOl\
lOOO\

-
llllll\
lll
)
;
con\
st
float
lOllOlO\
lO\
l\

=
0.0001f
;
if
(
(
lOl\
O\
llOOll
>
lOl\
lOlO\
lOl
&&
lOl\
OllOOlO
<
-
lOll\
OlOlOl
)
||
(
lOl\
Oll\
OOl\
O
>
lOl\
lOlOl\
Ol\

&&
lOlO\
l\
lOO\
ll
<
-
lOllO\
l\
OlOl
)
)
{
TA_A\
SSERT
(
Fabs
(
lOlOllOOlO
-
lOlOllOO\
l\
l\

)
>
0.0f
)
;
float
lOO\
OlOO\
O\
OlOl
=
lOl\
Oll\
OOl\
O\

/
(
lOlO\
ll\
O\
O\
lO
-
lOl\
OllOOll
)
;
Vec3
lOlllO\
lOOlO
=
lOl\
lllOOl\
OO
+
(
lOll\
lOllO\
OO
-
lO\
ll\
ll\
OOl\
OO
)
*
lOOOl\
OOOOl\
Ol
;
if\

(
lOOOlOOOOO\
Ol
.
Dot
(
lOl\
l\
lOlO\
OlO
-
llllllll\
l
)
>=
0.0f
&&
lOO\
OlO\
OOOOlO
.
Dot
(
lOlll\
OlOOl\
O\

-
lOO\
O\
OOO\
OOO
)
>=
0.0f
&&
lOO\
OlOOO\
OOll\

.
Dot
(
lO\
lll\
Ol\
O\
O\
lO
-
lll\
lOO\
O\
l\
lO
)
>=
0.0f
)
{
Ve\
c3
lll\
llOO\
l\
llO\

=
(
ll\
llOO\
OllO
-
lOOOOOOOOO
)
.
Cross
(
lOlllOllOOO\

-
lOllllOOlOO
)
;
flo\
at
lO\
ll\
l\
lOOll\

=
lllllOO\
lllO
.
GetMagn\
it\
ud\
e
(
)
;
if
(
lOl\
l\
ll\
O\
Oll\

>
lOllOl\
OlOl
)
{
lllllOOl\
ll\
O
/=
lOll\
llOO\
ll
;
if
(
lllllO\
OlllO\

.
Do\
t
(
lO\
ll\
lOlOOlO\

-
ll\
ll\
lll\
ll\

)
<
0.0f
)
lllllOOl\
llO\

=
-
lll\
llOOlll\
O
;
flo\
at\

lO\
O\
Ol\
OO\
OO\
l\
l\
O
=
Fabs
(
lOOOlOO\
OOOl\
O
.
Do\
t
(
lOlllOlO\
OlO
-
lO\
OOO\
OOOOO
)
*
lllllO\
OlllO\

.
Dot
(
lOOOlOOOOOlO
)
/
lO\
OOlOOOOOlO\

.
Ge\
tMag\
nitudeSqrd\

(
)
)
;
lllllOl\
OOll
(
lOlllO\
OOO\
Ol
,
lO\
O\
O\
O\
lllll\
ll
,
llO\
OOlO\
OlO
->
llOlllOOl\
lO
,
0.0f
,
lO\
OOlOOOOllO
,
lOll\
lO\
lOOl\
O\

,
llll\
lOOlllO\

,
ll\
OO\
OlO\
Ol\
O\

->
lOOOlOOOOO\

,
llOO\
Ol\
OOlO\

->
ll\
OllllOOO
[
lO\
OOlOOO\
OlOO
]
.
lOlllOlOlOl
)
;
con\
ti\
nue
;
}
}
}
if
(
lOl\
llOO\
O\
OOl
->
lOll\
Ol\
llOOl
)
{
Vec3\

lOl\
lllO\
OlO
;
Vec3
lO\
ll\
llOOOl
;
flo\
at
ll\
llOlO\
OOl
;
if\

(
Geo\
metry
::
Te\
st\
EdgeM\
oveme\
n\
tAgainstE\
dg\
e
(
lllll\
OO\
lOll
[
llOlO\
l\
OOOO
.
lllllOll\
OO\
l\

]
,
lllll\
OOl\
O\
l\
l
[
llO\
lOl\
OOOO
.
lll\
l\
l\
OllOOO
]
,
lll\
llOOllO\
O\

[
llOlOlOOOO
.
llll\
lOllOOl
]
,
lll\
llOOllOO
[
ll\
O\
l\
Ol\
OOO\
O
.
lllll\
Ol\
lO\
OO
]
,
lOl\
l\
llO\
OlOO\

,
lO\
lllOllOOO\

,
llllOlOOOl\

,
lOll\
l\
l\
OO\
Ol
,
lOllll\
OOlO\

)
)
{
lllll\
OlO\
O\
ll
(
lO\
lllOOOOOl
,
lOO\
OOl\
l\
l\
llll
,
llO\
O\
Ol\
O\
O\
l\
O
->
ll\
OlllO\
OllO
,
lll\
l\
OlOOOl
,
0.0f
,
lO\
l\
lllOOOl\

,
lO\
ll\
llOOlO
,
llO\
OOlOOlO
->
lO\
OOlO\
OOOO
,
ll\
OOOlO\
OlO
->
llO\
llllO\
O\
O
[
lOOO\
lO\
OO\
O\
lO\
O\

]
.
lOlll\
OlOlOl
)
;
}
}
}
}
}
ll\
lllOl\
OOlO
(
)
;
}
static
void
lllllOlO\
O\
O\
l
(
)
{
TA\
_A\
SS\
ER\
T
(
lllOOl\
O\
Ol\
ll
==
0
)
;
}
st\
ati\
c\

void
ll\
ll\
l\
O\
lOOlO\

(
)
{
lllOOlOOll\
l\

=
0
;
}
stati\
c\

void
lll\
llOlO\
Oll
(
lOllOllOllO\

*
lOlllOOOOO\
l\

,
in\
t\

llll\
lO\
Ollll
,
u3\
2
llO\
lllOOllO
,
floa\
t
lllOll\
llOO\

,
float
ll\
l\
llOl\
OlOO
,
cons\
t
Vec\
3
&
lOO\
OOlll\
ll\

,
cons\
t
Ve\
c3
&
ll\
lllOOlllO
,
co\
ns\
t\

Vec\
3\

&
llOlll\
llO\
ll
,
co\
ns\
t
Vec3\

&
lOlllOlOlO\
l\

)
{
TA\
_ASS\
ER\
T
(
lllOOlO\
Oll\
l
<=
ll\
lO\
O\
lOlOOO
)
;
int\

lllOO\
llOllO
;
fo\
r\

(
lllOOllO\
llO\

=
0
;
lllOO\
llOllO\

<
lllOOl\
OO\
lll
;
lll\
OOll\
Ol\
lO
++
)
{
lllll\
OOll\
Ol
&
lllOOllOlll
=
lll\
ll\
O\
lOO\
OO\

[
lllOO\
llOl\
lO
]
;
if
(
lllOOl\
lO\
ll\
l
.
lllllOOll\
ll
==
lllllOOll\
l\
l
&&
llOO\
ll\
OO\
Ol\
O
::
llOOll\
OOOll
(
lll\
OOllO\
l\
l\
l
.
lO\
OOO\
ll\
ll\
l\

,
lOOOOlllll
)
)
{
if\

(
(
ll\
l\
llOOl\
llO\

-
lllOOllOlll
.
lllllOOlll\
O
)
.
Get\
MagnitudeSqrd
(
)
>
0.01f
)
contin\
ue
;
Vec\
3
lOllO\
O\
ll\
l\
Ol
=
lll\
ll\
OO\
ll\
lO
;
if
(
lO\
llOOll\
lOl
.
Do\
t\

(
ll\
O\
lllllO\
ll
)
<
0.0f
&&
lOll\
O\
Oll\
lOl\

.
Dot
(
lll\
OOllO\
l\
ll
.
llOlll\
l\
lOll
)
<
0.0f
)
lOllOOlllOl\

=
-
lOllOO\
lllOl\

;
if
(
lO\
llOOll\
lOl\

.
Dot\

(
lOll\
lOl\
Ol\
Ol\

)
>
0.0f
)
{
lO\
llOOl\
ll\
Ol\

=
llO\
l\
l\
l\
llOll
;
lllllOlOl\
O\
O
=
0.0f
;
}
els\
e
if\

(
lO\
llOO\
ll\
lO\
l
.
Dot
(
ll\
l\
OOllOlll
.
lOll\
lOlO\
lO\
l
)
>
0.0f
)
{
lO\
llOOlllOl
=
lll\
OOllOll\
l
.
llOll\
ll\
lOl\
l
;
lllllOlOlOO\

=
0.0f
;
}
llll\
l\
O\
lO\
lOO\

*=
Fab\
s\

(
lllll\
O\
Oll\
lO
.
Dot\

(
lOllOOlll\
Ol\

)
)
;
Co\
llision
lOllOllOlOl
;
lOllOllOlO\
l\

.
In\
i\
t\
ialise\

(
Co\
llisi\
on
::
lOllO\
O\
llllO
,
ll\
lO\
ll\
llOO
,
llll\
lOlOlO\
O
,
lOOOOlll\
l\
l
,
lO\
llOOll\
lOl
)
;
lOllOllOl\
Ol\

.
lOl\
lOO\
lOOOO
=
llO\
l\
llOOl\
lO\

;
lllOOllOlOl\

(
lOllOll\
OlOl\

,
lO\
l\
ll\
OO\
OO\
Ol\

)
;
lllOOl\
lOlll
.
lllllO\
Ollll
=
-
1
;
brea\
k
;
}
}
if
(
ll\
lOOllOll\
O
!=
lll\
OO\
l\
OOl\
ll
)
re\
t\
urn
;
if
(
lllO\
O\
lOOlll
>=
lllOOlO\
lOOO
)
{
re\
turn
;
}
lllll\
OO\
l\
lOl\

&
ll\
l\
OOllOll\
l
=
ll\
lllOlOOOO\

[
lllOOlOOll\
l
++
]
;
lllOO\
llO\
l\
ll\

.
lll\
llOOl\
lll
=
lllll\
O\
Olll\
l\

;
ll\
lO\
OllOlll
.
lOO\
O\
Olllll
=
lOO\
O\
Olllll
;
lll\
OO\
l\
lOlll
.
lllllO\
Olll\
O\

=
ll\
ll\
lO\
O\
lllO
;
lllO\
Ol\
l\
Olll
.
llO\
l\
l\
lllOll
=
llOl\
l\
lllOl\
l
;
ll\
l\
O\
Oll\
Ol\
l\
l
.
lOlllO\
lO\
lOl
=
lOl\
ll\
OlOlOl
;
ll\
lOO\
llO\
lll\

.
lO\
l\
lO\
O\
lO\
OOl
=
lllllOlOlO\
O
;
}
void
TAC_\
CALL\

lll\
l\
OOlO\
Oll
(
con\
s\
t
MFr\
a\
me\

&
lOllOllllll
,
const
MFrame\

&
lOlllOOOOOO\

,
lOll\
OllOllO
*
lOlllOO\
OO\
Ol
)
{
TA\
_ASSERT\

(
lO\
l\
ll\
O\
OOOOl\

->
lO\
l\
lOO\
OllOl\

->
Get\
Col\
li\
sionO\
bje\
ctTyp\
e
(
)
==
CollisionObject\

::
TYPE_LI\
NE_LIST
)
;
TA\
_AS\
SERT
(
lOlll\
OO\
O\
OOl
->
lO\
llOO\
Ol\
l\
lO
->
GetCol\
lisi\
onObje\
c\
tType\

(
)
==
Collisi\
o\
nObject
::
TYPE_CON\
V\
EX\

)
;
const
Co\
llisionObj\
ect\
Li\
neL\
ist
&
lllOllllll\
l
=
*
(
Colli\
sion\
Obje\
ctLineLis\
t
*
)
lOll\
lOO\
OOOl\

->
lOl\
lOOO\
l\
lOl\

;
con\
st
Co\
llis\
ionObject\
Conve\
x
&
lO\
OOOl\
llOlO\
l
=
*
(
Col\
l\
i\
sionObject\
Conv\
e\
x
*
)
lOlllOOOOOl
->
lOllOO\
Olll\
O
;
for
(
int
ll\
l\
O\
OO\
OOl\
O
=
0
;
lll\
OOO\
OOlO
<
lllOlllllll
.
ll\
l\
lOOO\
O\
OOl
.
lOOOll\
lOOl
(
)
;
lllO\
O\
OOOlO\

++
)
{
con\
st
Ve\
c\
3
lOO\
lOlO\
lll
=
ll\
lO\
l\
ll\
l\
l\
ll
.
llllOO\
OOOO\
l
[
lllOO\
O\
OOlO
]
.
lOOlO\
lO\
l\
ll
*
lOllOl\
lll\
ll\

;
co\
nst\

Vec\
3
lO\
OlOllOOl
=
ll\
lOl\
llllll
.
llll\
OO\
OOOOl
[
lllOOOOOlO
]
.
lOO\
lO\
llO\
Ol
*
lOllO\
l\
llll\
l
;
for\

(
in\
t
llOlO\
llll\
l\

=
0
;
ll\
OlOllll\
l\

<
lOOO\
Ol\
llOlOl
.
lOlOOlO\
llO
->
lOllOOllOl\

.
lOOO\
lll\
OOl
(
)
;
ll\
O\
lOll\
l\
ll
++
)
{
Collisio\
n\
ObjectC\
o\
n\
v\
ex\

::
Po\
l\
y\
gon
&
lOllOOOOll
=
llllllOOOOl\

(
&
lOO\
OO\
l\
l\
lOlOl
,
llOlOll\
l\
ll
)
;
flo\
at
lOl\
l\
lOl\
l\
lO\

=
lOl\
lOOOOll\

.
lOO\
OlO\
OO\
OO\

.
Do\
t\

(
lO\
OlOlOlll
)
-
lO\
llOOOOll
.
lOlO\
l\
l\
Olll
;
float
lOllllOOOO
=
lO\
llO\
O\
OOl\
l
.
lOOOlOOOOO
.
Do\
t
(
lO\
OlO\
llOOl
)
-
lOllOOOOl\
l
.
lOl\
O\
llOl\
ll
;
if
(
lOl\
llOl\
llO
<
0.0f
||
lOll\
llOO\
OO
>=
0.0f
)
continue
;
float\

lllOl\
ll\
lOO
=
lOlll\
OlllO
/
(
lO\
l\
llOlllO
-
lOl\
l\
llOOOO
)
;
Vec3
lO\
OOO\
OOOlll\
O
=
lOOlO\
lO\
lll\

+
(
lOOlOllO\
Ol
-
lOO\
lO\
lOlll
)
*
lllOll\
llOO
;
int
ll\
OlOlOlOO
;
for\

(
llOlO\
lO\
lOO
=
0
;
llOlOlOlOO
<
lOllO\
OOOl\
l
.
lOllOl\
lOll
;
llOl\
OlOl\
OO
++
)
{
const
Co\
llisi\
onOb\
j\
ectCo\
nvex
::
llll\
lO\
lOlOl\

&
lO\
OO\
O\
OO\
O\
lOlO
=
lOl\
lOOOOll
.
llOllllO\
OO
[
llOlOlO\
lOO\

]
;
co\
nst
Vec3\

&
ll\
OOl\
lllOO
=
lOOOOl\
llO\
lOl\

.
lOlOOlOllO
->
lll\
l\
l\
O\
lllOl
[
lOO\
OOO\
O\
O\
lOlO
.
llOl\
ll\
O\
l\
lO
]
;
if
(
lOOO\
OOOOlO\
lO\

.
lOl\
l\
lO\
lO\
l\
O\
l
.
Dot\

(
lO\
O\
O\
O\
O\
OO\
lllO
-
llO\
OllllO\
O
)
<
0.0f
)
break\

;
}
if
(
llO\
lOl\
OlOO
<
lOllOOOOll
.
lO\
llOl\
lO\
l\
l
)
con\
tin\
ue
;
Colli\
sion
lOll\
OllO\
lO\
l\

;
lOl\
lOllOlOl
.
In\
itiali\
se
(
Collis\
i\
on
::
lOllO\
lOOO\
lO
,
0.0f
,
ll\
lO\
ll\
llOO
,
lOOOO\
OO\
Ol\
llO\

,
-
lOllOOO\
Oll
.
lO\
OOl\
O\
OOOO
)
;
lOll\
Oll\
OlOl
.
lOllOOOllll
=
ll\
lOOO\
OOl\
O\

;
if
(
!
lOlll\
O\
O\
OOOl\

->
lO\
ll\
OlllO\
lO
)
lOllOllOlO\
l\

.
lOll\
O\
O\
lOOO\
O
=
1
;
el\
se\

lO\
ll\
OllOlOl
.
lO\
llOOlOO\
OO
=
0
;
if\

(
!
ll\
lOlll\
Oll\
O
(
lOllOl\
lOl\
Ol
,
lO\
l\
llOOOO\
Ol\

)
)
re\
turn
;
co\
ntin\
ue
;
}
}
}
#endif //
}
