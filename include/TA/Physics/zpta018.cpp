//---------------------------------------------------------------------------------
// File Name: zpta018.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#define TA_PHYSICS_INTERNAL
#define lOllOllOOOO
#include "DynamicObject.h"
#ifndef TA_RANDFUNC_H
#include "../Common/RandFunc.h"
#endif //
#ifndef TA_PHYSICS_H
#include "Physics.h"
#endif //
#ifndef TA_COLLISIONOBJECTCOMBO_H
#include "CollisionObjectCombo.h"
#endif //
#ifndef TA_COLLISIONOBJECTCOMPLEX_H
#include "CollisionObjectComplex.h"
#endif //
#ifndef llOOlOlllll
#include "../Physics/zpta001.h"
#endif //
#ifndef llllOOOOlOO
#endif //
#ifndef lOOllOOOllll
#include "../Physics/zpta011.h"
#endif //
#ifndef llllOOOOlOl
#include "../Physics/zpta010.h"
#endif //
names\
pace
TA
{
fl\
o\
at
lOOlOlllll\
O\
O
=
1.0f
;
flo\
a\
t
lOOlOlllll\
l\
l
=
0.001f
;
const
fl\
oa\
t
lOOll\
O\
OlOOOO
=
1.0e-9f
;
const
fl\
o\
at
lO\
OllOOlO\
OOl
=
1.0e9f
;
static\

u32
lO\
Ol\
l\
OOlOOlO\

=
1
;
voi\
d
Dy\
na\
mic\
Object\

::
Initia\
lis\
eFro\
mFile
(
const
Ch\
ar
*
lllOO\
OlOO\
l
)
{
Co\
lli\
si\
o\
n\
Obj\
e\
ctCombo\

*
lO\
OllOOlOOll
=
Co\
lli\
sionObjectCombo
::
Cre\
ateNew
(
)
;
lOO\
l\
lOO\
l\
OOl\
l
->
Ini\
tia\
lis\
eFrom\
File
(
lllOOOlOOl
)
;
Initialise\

(
lOO\
llOOl\
OO\
ll
)
;
lOOllOOl\
OO\
l\
l
->
Releas\
e
(
)
;
}
void
DynamicObject
::
In\
iti\
aliseAsABox
(
const
AAB\
B
&
lO\
OO\
OOOl\
l\
l
)
{
Collis\
ionObjec\
tC\
omb\
o\

*
lOO\
l\
lOOlOOl\
l
=
Coll\
isionObject\
C\
om\
bo
::
Cr\
e\
ate\
N\
ew
(
)
;
lOOl\
lOO\
l\
OOll
->
InitialiseA\
s\
ABox
(
lOOOOOO\
l\
ll
)
;
Initiali\
se
(
lOOl\
lO\
Ol\
OOl\
l
)
;
lOO\
l\
lOOlOOl\
l
->
Re\
lea\
se
(
)
;
}
vo\
id
Dynam\
icOb\
ject
::
Init\
ial\
i\
seA\
sA\
nOr\
iente\
dB\
o\
x
(
const
AABB
&
lOOOOOOlll
,
const
MFrame
&
lO\
OOO\
OOOO\
l
)
{
Col\
li\
s\
ionObject\
Com\
bo
*
lOOl\
lOOlOOll
=
Co\
l\
lis\
i\
on\
Ob\
ject\
Com\
bo\

::
Cre\
ateNew
(
)
;
lOOllOO\
lOO\
l\
l
->
Init\
ia\
li\
seAsAnOrientedBox
(
lOO\
O\
O\
OOll\
l
,
lOOOOOOOOl
)
;
In\
iti\
alise
(
lO\
O\
llOO\
lOOl\
l
)
;
lOO\
ll\
O\
OlO\
Oll
->
Releas\
e
(
)
;
}
void
Dynam\
ic\
Ob\
ject
::
In\
i\
t\
ia\
l\
iseAsA\
Capsu\
le
(
co\
nst\

Ve\
c3\

&
lOOlO\
lOlll
,
con\
st
Vec3
&
lOO\
l\
Oll\
OO\
l
,
flo\
a\
t
llll\
Olll\
l\
l
)
{
Collis\
io\
nObj\
ectC\
ombo
*
lOOl\
l\
O\
OlOOll\

=
Col\
lisionO\
bjectCombo
::
Crea\
teNew
(
)
;
lOOl\
lOOlOO\
ll
->
InitialiseAs\
ACapsule
(
lO\
OlOlOl\
ll
,
lOOlO\
llOOl
,
lll\
lOlllll
)
;
Init\
ia\
lis\
e
(
lOOll\
OOlO\
Oll\

)
;
lO\
Ol\
lOOlOOl\
l
->
Re\
leas\
e\

(
)
;
}
vo\
i\
d
Dy\
na\
micObje\
c\
t\

::
Init\
ia\
li\
seAsASphe\
r\
e
(
co\
nst
Vec\
3\

&
v3C\
enter
,
float
ll\
llO\
ll\
lll
)
{
Coll\
i\
si\
o\
n\
Ob\
je\
ctComb\
o
*
lOOll\
OOlO\
Oll
=
Collisio\
nO\
b\
ject\
Comb\
o
::
Crea\
t\
e\
N\
ew\

(
)
;
lO\
OllOOlOO\
ll
->
In\
itial\
i\
s\
e\
AsA\
Sphere
(
v3\
C\
ente\
r\

,
llllOll\
ll\
l\

)
;
Initia\
lise
(
lOOllOOlO\
O\
ll
)
;
lO\
OllOOl\
OO\
ll
->
Rel\
ease
(
)
;
}
void
Dynam\
i\
cObje\
ct\

::
InitialiseAsAC\
y\
l\
in\
der
(
cons\
t
Vec\
3
&
lOOlOlOlll\

,
cons\
t\

Ve\
c3
&
lO\
OlOl\
lOO\
l
,
float
llllOl\
lll\
l
)
{
Collision\
Object\
C\
om\
bo\

*
lOOllO\
OlO\
O\
ll\

=
Colli\
sionObjec\
tComb\
o
::
Cre\
ateNew
(
)
;
lO\
OllOOlOOll
->
Initiali\
s\
e\
A\
s\
A\
Cy\
lind\
er
(
lOO\
lO\
l\
Oll\
l
,
lOO\
lO\
llOOl\

,
llllO\
lllll
)
;
Initi\
a\
l\
ise
(
lOOllOOlO\
Oll\

)
;
lOO\
ll\
OO\
l\
OOll
->
Rel\
ea\
s\
e
(
)
;
}
voi\
d\

Dy\
nam\
ic\
Object
::
Ini\
ti\
al\
is\
e\
FromPoin\
tList
(
const\

Ve\
c\
3
*
llllO\
lOlOOl
,
int
llll\
OlOlO\
lO
)
{
Collisio\
n\
Ob\
j\
e\
c\
tCom\
bo\

*
lOOllOO\
lOOll\

=
Coll\
is\
ionObjec\
tCo\
m\
b\
o
::
Creat\
e\
Ne\
w\

(
)
;
lOOllOOlOOll
->
In\
it\
i\
al\
is\
eFromP\
ointList\

(
lll\
lOl\
Ol\
OOl
,
lll\
l\
Ol\
OlOlO
)
;
Ini\
ti\
a\
l\
i\
se
(
lOOl\
lOOlOOll\

)
;
lOO\
llOOl\
O\
Oll
->
Re\
le\
as\
e
(
)
;
}
vo\
id
Dynam\
icObj\
ect\

::
Ini\
t\
ia\
lise\

(
Co\
l\
lis\
ionObjec\
tCo\
mbo
*
lO\
Oll\
OOlOOll
)
{
TA\
_ASSERT
(
lOOl\
lO\
O\
lO\
O\
ll
)
;
In\
iti\
alise\
Co\
mmon
(
)
;
lOOl\
l\
OOlOlOO
=
lOOl\
lO\
OlOOll
;
lOO\
llOO\
lOlO\
O\

->
AddRef
(
)
;
SetCollisionObj\
e\
ctChanged
(
)
;
Clea\
r
(
)
;
}
void\

Dyn\
am\
icObj\
e\
ct
::
Initial\
i\
s\
e
(
CollisionO\
bje\
ct\
C\
o\
mp\
lex\

*
lO\
OllOOlOl\
Ol\

)
{
TA_A\
SSERT\

(
lOOll\
OOl\
Ol\
O\
l
)
;
Initia\
lise\
Com\
mon
(
)
;
lOO\
ll\
OO\
lO\
l\
OO
=
lO\
Ol\
lO\
OlOlOl\

;
lO\
OllOOlOlOO
->
Add\
Ref\

(
)
;
SetC\
ol\
lisionObj\
ec\
tChanged\

(
)
;
lOO\
ll\
OOlO\
l\
lO
.
SetToIdent\
ity
(
)
;
lOO\
ll\
O\
Ol\
Olll
.
SetToI\
d\
enti\
ty
(
)
;
lOlO\
lO\
lOOlO
=
1.0e9f
;
lO\
Ol\
OllllOlO\

=
1.0f
/
lOlOlOlOO\
lO\

;
Set\
InfiniteMass
(
tru\
e
)
;
Set\
Movem\
e\
ntD\
isable\
d\

(
tr\
ue
)
;
lOOllOOll\
OOO\

=
1.0e6f
;
lOOllOOllOO\
l
=
0.0f
;
Clear\

(
)
;
}
vo\
i\
d
Dyn\
a\
micO\
b\
jec\
t\

::
Ini\
tia\
liseA\
sWorldObject
(
)
{
Initia\
liseC\
ommo\
n
(
)
;
lOOllOOl\
OlO\
O\

=
0
;
SetMove\
m\
entDisabl\
ed
(
true\

)
;
lOOllOOllOlO\

(
tru\
e
)
;
Se\
tC\
o\
l\
lis\
ion\
Di\
sab\
led
(
tru\
e
)
;
SetIn\
finit\
eMass
(
true
)
;
lOOllOOlOllO
.
SetToI\
dent\
ity\

(
)
;
lO\
OllO\
OlOlll\

.
SetToIden\
t\
ity
(
)
;
lOl\
Ol\
Ol\
OOlO
=
1.0e9f
;
lOOlOllllOl\
O
=
1.0f
/
lOlO\
lOlOO\
lO
;
lOOllOO\
l\
lOOO\

=
1.0e6f
;
lO\
O\
l\
lOOl\
lOO\
l
=
0.0f
;
Clear
(
)
;
}
voi\
d
Dyn\
amic\
Ob\
ject
::
Fin\
a\
l\
i\
se\

(
)
{
TA_A\
S\
SERT\

(
!
AddedTo\
Physic\
s
(
)
)
;
lOlOlOl\
O\
OlO
=
0.0f
;
lOOlO\
lll\
l\
Ol\
O\

=
0.0f
;
lOOllO\
OlOll\
O
.
Se\
tToId\
enti\
ty
(
)
;
lO\
OllOOlOll\
l
.
SetToI\
den\
t\
it\
y
(
)
;
lOOllOOllOll
.
SetTo\
Ide\
ntit\
y
(
)
;
lO\
Ol\
lOO\
lll\
O\
O
.
SetToIden\
tity
(
)
;
lOOl\
l\
OOlllOl
=
1.0f
;
lOOll\
O\
O\
l\
lllO
=
-
1.0f
;
lOOllOOlllll
=
0.0f
;
lOOll\
OlO\
OO\
OO\

=
1.0f
;
lOOllOlOO\
OOl
=
0
;
lll\
Ol\
Olll\
O
=
0
;
lOOll\
OlOOOlO
=
0
;
lO\
Ol\
lOl\
OO\
Ol\
l
.
Cl\
ear
(
)
;
lOOl\
Oll\
l\
OO\
l\
l
.
Clear
(
)
;
lOO\
l\
lOl\
OOlOO
.
Clea\
r
(
)
;
lOOllOlOO\
lO\
l
.
Clear
(
)
;
lO\
Ol\
lO\
lO\
Oll\
O
.
Cl\
ear
(
)
;
lO\
O\
lO\
l\
lll\
OOl
.
Clear\

(
)
;
lOO\
lOl\
lllOll\

.
Clear
(
)
;
lO\
O\
llOl\
OO\
lll
.
Cl\
ear
(
)
;
lOO\
llOlOl\
OOO
.
Clear
(
)
;
lO\
O\
llO\
lO\
lO\
Ol\

=
0
;
lOOl\
lOlO\
lO\
lO
=
0
;
lOOllOlOlOll\

.
In\
itial\
i\
se\

(
k_\
v3Ze\
r\
o
,
k_v3\
Z\
er\
o
)
;
lO\
O\
llOlOll\
OO
=
-
1
;
lOO\
llO\
lOllOl
=
0
;
lOO\
ll\
O\
l\
OlllO
=
0
;
if\

(
lOO\
llOOlO\
lOO
)
{
lOO\
llOO\
lOlOO
->
Relea\
s\
e
(
)
;
lOOllOOlOlO\
O
=
0
;
}
lOOl\
lOl\
O\
ll\
ll
=
0
;
lOOl\
lO\
l\
l\
O\
OOO\

=
0
;
lOOll\
OllOOOl
=
0
;
TA\
_ASSER\
T
(
lOOllO\
llOO\
lO
==
0
)
;
TA\
_ASS\
ER\
T
(
lOOll\
Oll\
OOll\

==
0
)
;
lOO\
l\
l\
Ol\
lOOlO
=
0
;
lOOllOll\
OOll
=
0
;
lOOllOllOlO\
O
=
0
;
lOOllOllOl\
Ol
=
-
1
;
ClearLine\
In\
terse\
ct\
io\
n\
s
(
)
;
lOOl\
lOllOllO
.
Finalis\
e\

(
)
;
Remo\
veAllJoints
(
)
;
lO\
Oll\
Oll\
Oll\
l
.
Fin\
alise
(
)
;
lOO\
llOl\
llOOO
.
Finalise
(
)
;
lOOl\
l\
OlllO\
Ol
(
)
;
TA_ASSER\
T
(
lOOll\
Ol\
llOlO
==
0
)
;
TA\
_ASSERT
(
lOOl\
l\
Ol\
ll\
Oll
==
0
)
;
}
voi\
d
Dyna\
m\
i\
c\
Ob\
ject
::
SetFra\
me\

(
cons\
t
MF\
ra\
me
&
lO\
ll\
Oll\
llO\
O\

)
{
lO\
O\
llO\
lO\
OlOl
=
lOllO\
l\
lll\
O\
O
;
lOOlO\
lll\
OO\
ll\

=
lO\
O\
l\
lO\
l\
OOOl\
l\

*
lOOllOlO\
OlO\
l
;
lOO\
ll\
O\
l\
OOlOO
=
lO\
OlO\
l\
l\
lOOll
;
lOOllO\
lO\
O\
l\
l\
O
=
lOllOllllOO\

;
lO\
OllO\
l\
lllOO
=
lOll\
Olll\
lOO
;
lOOll\
Ollll\
Ol
=
lOllOllll\
OO\

;
lOOl\
l\
Oll\
lllO
=
lO\
llO\
l\
ll\
lOO\

;
Update\
WorldSpa\
ceI\
ner\
t\
i\
alTen\
sor
(
)
;
Calcula\
teW\
orldAABB
(
)
;
lO\
Oll\
Ollll\
ll
(
)
;
if
(
Ad\
de\
dToPh\
ysic\
s
(
)
)
{
TA_AS\
SERT
(
lOOll\
O\
lllO\
lO
)
;
lOOllO\
ll\
lO\
lO
->
Get\
Physi\
c\
s
(
)
.
lOO\
ll\
l\
OO\
O\
OOO\

(
this
)
;
}
{
for
(
Joint\
Iterator
lOl\
O\
OlO\
Ol\
O\

=
lOO\
llOllOlll
.
lOlOOOOlOO
(
)
;
!
lOl\
O\
OlOOlO
.
AtEnd
(
)
;
++
lOlO\
Ol\
OOlO
)
{
Phy\
sic\
sJoint
&
lOOlll\
OOO\
OO\
l
=
*
lO\
l\
O\
OlO\
O\
lO
;
lOO\
ll\
l\
OOO\
OOl
.
lO\
OlllOOO\
Ol\
O
(
Eule\
rAn\
gles
(
0.0f
,
0.0f
,
0.0f
)
)
;
}
}
{
for
(
List
<
Phy\
sic\
sJo\
int
*
>
::
Iter\
ator\

lO\
lO\
OlOOl\
O
=
lOO\
ll\
Oll\
lO\
OO
.
lO\
lO\
O\
OO\
lOO
(
)
;
!
lO\
lOOlOOlO
.
At\
E\
nd\

(
)
;
++
lOlOOlO\
OlO
)
{
PhysicsJoint
*
lOl\
l\
lOOlOO\
O
=
*
lOlO\
Ol\
OO\
l\
O
;
lO\
lllO\
Ol\
OOO\

->
lOOlll\
OO\
OOlO
(
EulerAngles
(
0.0f
,
0.0f
,
0.0f
)
)
;
}
}
}
vo\
id\

Dyna\
m\
i\
cO\
bje\
ct
::
SetP\
ositi\
o\
n\

(
const
Vec\
3\

&
lOOO\
Ollll\
l
)
{
SetFram\
e\

(
MFram\
e
(
lOO\
O\
O\
lllll
,
lOOll\
OlOO\
lOl
.
m3\
3R\
ot\
a\
ti\
on\

)
)
;
}
vo\
id
Dyn\
amicO\
b\
jec\
t
::
SetCente\
rOffset
(
cons\
t
Vec3
&
lOOl\
llOOO\
Oll
)
{
lO\
OllOlO\
O\
O\
l\
l
=
lO\
Oll\
lOO\
O\
Oll
;
lOOlOll\
lOOll
=
lOOllO\
lOOO\
ll
*
lOOll\
Ol\
OO\
lOl
;
lO\
OllO\
lOOl\
O\
O
=
lOOllOlOOO\
ll
*
lOOllOlOOl\
lO
;
}
void
Dyn\
amicOb\
ject
::
SetMass\

(
float
lOll\
O\
OOOlOO
)
{
lOOOlllOlO\

(
lOl\
l\
OOOOlO\
O
>=
lOOl\
lOOlOO\
O\
O
,
"Mass is less than 1.0e-9f, automatically increasing to 1.0e-9f.")
;
lO\
OOl\
l\
lOlO
(
lOllOOO\
O\
l\
OO
<=
lO\
OllOOlOOOl
,
"Mass is greater than 1.0e9f, automatically decreasing to 1.0e9f.")
;
if
(
lO\
llOOOOlOO
<
lO\
O\
llOOlOOO\
O
)
lOllOOOOlOO
=
lOOll\
OOlOOO\
O
;
if
(
lOl\
lOOOOlOO\

>
lOOllOOlOOOl\

)
lO\
llO\
OOOl\
OO
=
lOOll\
OOl\
OOOl\

;
floa\
t
lO\
O\
l\
l\
l\
O\
OO\
lOO
=
lOl\
l\
O\
OO\
O\
lOO
/
lOlO\
lOlO\
OlO
;
lO\
lOlO\
lOOlO
=
lOllOOO\
OlOO
;
lOOlOll\
llOlO\

=
1.0f
/
lOlO\
l\
Ol\
OOlO
;
lOOllOOl\
Ol\
l\
O
*=
lO\
Ol\
llOOOl\
OO
;
lOOll\
OOlOlll\

=
lOOll\
OOlOllO
.
GetI\
nver\
s\
e
(
)
;
Upd\
a\
teWor\
ldSp\
ace\
Ine\
rtialTenso\
r
(
)
;
}
void
Dynamic\
O\
b\
ject\

::
SetIn\
er\
t\
i\
aFr\
omBo\
x\

(
const
AABB\

&
lO\
O\
O\
OOOlll
)
{
lO\
Ol\
lOO\
lO\
llO\

.
SetT\
oIde\
nt\
it\
y
(
)
;
fl\
oat
lOlO\
OO\
lOOOl\

=
lOOO\
OOOlll
.
v3\
E\
xte\
nt
.
x
*
2.0f
;
flo\
at
lO\
lOOOlO\
O\
l\
l\

=
lOO\
O\
OO\
Ol\
ll
.
v3\
Exte\
n\
t
.
y
*
2.0f
;
floa\
t
lOlOO\
OlOlO\
O
=
lOO\
OOOOl\
l\
l
.
v3Ex\
ten\
t\

.
z
*
2.0f
;
lOOllOOlO\
llO
.
M11\

(
)
=
lOlOlO\
lOOlO\

/
12.0f
*
(
lOlO\
OOl\
OOll
*
lOlOOOlO\
Ol\
l\

+
lO\
lO\
OOlOl\
OO
*
lOlOOO\
l\
OlOO
)
;
lO\
OllOOlO\
llO
.
M22\

(
)
=
lOlOlOlOOlO
/
12.0f
*
(
lOlO\
O\
O\
l\
OOO\
l
*
lOl\
OO\
OlO\
O\
O\
l
+
lO\
l\
OO\
OlOl\
OO
*
lO\
lOOO\
lO\
lOO
)
;
lOO\
llOOlO\
llO
.
M3\
3
(
)
=
lO\
lOlOlOOlO
/
12.0f
*
(
lOlOOOlOO\
Ol
*
lO\
lOOO\
lOO\
O\
l
+
lO\
lOOO\
lOO\
l\
l\

*
lOlO\
OOlOOll
)
;
lOOll\
O\
OlOlll
=
lOOllO\
OlO\
ll\
O
.
GetI\
nv\
erse
(
)
;
lOOll\
O\
l\
OOOll
=
lOOOOO\
O\
l\
ll
.
v3C\
ent\
e\
r
;
Upd\
at\
eWor\
l\
d\
SpaceIner\
tialTen\
sor\

(
)
;
}
void\

DynamicObje\
ct
::
Se\
tI\
nertia\
FromBox
(
float
lOlOOOlOOOl\

,
floa\
t
lO\
lOOOlOOll
,
float
lOlO\
OO\
lOlOO
)
{
lO\
OllOO\
l\
OllO
.
SetToIde\
nti\
ty
(
)
;
lOOl\
lOOl\
Oll\
O
.
M11
(
)
=
lOlOlOlOO\
lO
/
12.0f
*
(
lOlOO\
OlOOll\

*
lOlO\
O\
O\
l\
OOll\

+
lOlOOOl\
OlOO
*
lOlOOO\
lOl\
OO
)
;
lOOllO\
OlOllO\

.
M22\

(
)
=
lOlOlOlOOl\
O
/
12.0f
*
(
lO\
lOO\
Ol\
OO\
O\
l
*
lOlO\
O\
OlOOOl
+
lO\
lOO\
OlOlO\
O
*
lO\
lOO\
OlOlOO
)
;
lO\
OllO\
OlO\
llO
.
M33
(
)
=
lOl\
Ol\
Ol\
OOlO\

/
12.0f
*
(
lO\
l\
O\
OOlOO\
O\
l
*
lOlOOOlOO\
Ol
+
lOlOOO\
lO\
Oll
*
lOl\
OOOl\
O\
Oll\

)
;
lO\
Ol\
lOOlOlll
=
lOOll\
OO\
lOl\
l\
O
.
GetInver\
se
(
)
;
Updat\
eWo\
rldS\
pa\
ceIne\
rtialT\
e\
n\
sor\

(
)
;
}
voi\
d
Dynamic\
Ob\
ject
::
SetRot\
atio\
nDisabled
(
bo\
ol
ll\
lO\
llOO\
OO
)
{
const
float
lOOl\
ll\
O\
O\
OlOl
=
10000.0f
;
if
(
lll\
Ol\
lOOOO
)
{
if
(
ll\
lOlOlllO
&
lOOll\
lOOOl\
lO
)
retur\
n
;
ll\
lOlOll\
lO\

|=
lOOlllOOOllO\

;
lO\
OllOOlO\
llO
*=
lO\
OlllO\
OO\
lOl
;
lOOllOOlOll\
l
=
lOOllO\
OlO\
llO
.
Ge\
tInverse
(
)
;
lO\
OlO\
llll\
Oll
.
Clear
(
)
;
}
else
{
if
(
!
(
lllO\
l\
OlllO
&
lOOlllO\
O\
OllO
)
)
retu\
rn\

;
lll\
OlOl\
llO
&=
~
lOOll\
lO\
OOll\
O
;
lOOll\
OO\
lO\
l\
lO
/=
lO\
OlllOOOlOl
;
lO\
Ol\
l\
OO\
lOll\
l
=
lO\
Oll\
OOl\
Ol\
lO
.
GetInverse
(
)
;
}
UpdateWor\
ldS\
paceIne\
r\
t\
ial\
Ten\
s\
or
(
)
;
}
void
DynamicObject
::
SetM\
ovement\
D\
isabled
(
bo\
ol
lllOllOO\
OO
)
{
if
(
lllO\
l\
lO\
OOO\

)
{
if\

(
ll\
lOlOlllO
&
lOOlllOOO\
lll
)
re\
turn
;
ll\
lOl\
OlllO
|=
lOOl\
llOOO\
lll
;
lOOlO\
l\
lll\
Ol\
l
.
Cl\
ear
(
)
;
lOO\
l\
O\
ll\
llO\
Ol
.
Clea\
r
(
)
;
Set\
ToRestin\
g
(
)
;
lO\
OllOl\
ll\
l\
ll\

(
)
;
}
else
{
if
(
!
(
lllO\
l\
Olll\
O\

&
lO\
O\
lllOOOl\
ll
)
)
retu\
rn
;
lll\
OlOll\
lO\

&=
~
lOOl\
llOOO\
lll\

;
lO\
OllOlll\
lll
(
)
;
lO\
OlllOOlO\
OO
(
fals\
e
)
;
}
}
vo\
i\
d
Dy\
n\
amicOb\
j\
ect
::
Se\
t\
Infinite\
M\
as\
s
(
bool
lllOllOOO\
O
)
{
if
(
lllOllOOO\
O
)
{
if
(
(
lllOlOll\
lO\

&
lOOlllOOlOOl\

)
==
0
)
{
lllOlOlllO\

|=
lOOlllO\
OlOOl
;
lOOl\
l\
Oll\
lll\
l\

(
)
;
}
}
else
{
if\

(
(
lllOlOll\
lO
&
lO\
O\
lllOOlOO\
l\

)
)
{
ll\
l\
Ol\
Olll\
O
&=
~
lO\
OlllO\
OlOOl
;
lOOllOll\
l\
lll
(
)
;
lO\
Olll\
O\
OlOOO
(
false
)
;
}
}
}
Phy\
sics
*
Dyn\
am\
i\
c\
Obj\
ect\

::
GetPhysi\
c\
s
(
)
{
if\

(
!
lOOllOlllOlO
)
re\
t\
ur\
n
0
;
else
re\
t\
ur\
n
&
lOOllOl\
ll\
Ol\
O
->
GetP\
hysi\
cs
(
)
;
}
void\

Dyn\
a\
m\
icO\
b\
ject
::
SetToMo\
v\
in\
g
(
int\

lOOlllOOlOlO\

)
{
if
(
Mo\
vementDisabled
(
)
)
return
;
if\

(
!
AddedT\
o\
P\
hy\
sic\
s\

(
)
)
return
;
TA_AS\
SE\
RT\

(
lOOllOl\
ll\
OlO
)
;
if
(
!
Is\
In\
MovingL\
i\
st
(
)
)
lOOll\
OlllOlO
->
GetPhy\
sics
(
)
.
lOOl\
l\
l\
O\
OlOll
(
th\
i\
s
,
lOOlll\
OOl\
OlO
)
;
if
(
Is\
InMov\
in\
gList\

(
)
)
lOO\
ll\
lOOllO\
O
(
)
;
}
void
DynamicOb\
ject\

::
SetTo\
Resting
(
)
{
if\

(
!
AddedToPhysics
(
)
)
return\

;
TA_ASSERT
(
lOO\
ll\
Olll\
OlO
)
;
lO\
Ol\
lO\
lll\
OlO
->
Ge\
tPh\
ys\
i\
cs
(
)
.
SetDynamicO\
bjec\
tAtRest\

(
th\
is\

)
;
}
void
TA
::
Dyna\
micObject
::
SetV\
e\
loci\
ties\
ToMove\
ToFrame
(
co\
n\
st
MFra\
me
&
lOO\
OOOOOOl
,
float
lOOlllOOll\
Ol\

)
{
if
(
lOOl\
llOOllOl\

>
0.0f
)
{
SetN\
ex\
tFram\
e\

(
lOOOOOOOOl
)
;
Set\
L\
inearVelocity
(
(
GetNextCent\
erOfMa\
ss\

(
)
-
Ge\
tCen\
t\
er\
OfMass
(
)
)
/
lOO\
l\
l\
lOO\
llOl
)
;
Mat\
3\
3\

lO\
O\
ll\
lOOlllO\

=
GetF\
rame
(
)
.
m33R\
ot\
ati\
o\
n
.
GetTransposeAsInv\
erse
(
)
*
GetN\
e\
xtF\
rame
(
)
.
m33Ro\
ta\
t\
io\
n\

;
Ve\
c3
lO\
OOOOlllOl
;
float
lO\
OOOOl\
l\
llO
;
lOOlll\
OOlllO\

.
Get\
R\
otat\
io\
nA\
xi\
s\
A\
ndMagn\
i\
tude\

(
lO\
OO\
O\
Oll\
lOl
,
lOOOOOl\
l\
llO\

)
;
SetAn\
g\
ul\
arVe\
locit\
y
(
lOOO\
OOlllO\
l
*
lOOO\
OOllllO
/
lOO\
lllO\
O\
l\
l\
Ol\

)
;
}
}
Ve\
c3\

Dy\
namic\
Obj\
ect
::
GetVel\
oci\
tyA\
tW\
orldPositi\
on
(
const\

Vec3
&
lOO\
OOl\
l\
lll\

)
const
{
retur\
n
lOOlOll\
llOOl
+
lOOlOl\
lllOll\

.
Cr\
oss
(
lOOOO\
l\
ll\
ll
-
lOO\
l\
Oll\
lOOll
)
;
}
void
Dynamic\
Object
::
Ap\
plyIm\
pu\
lse
(
co\
n\
st
Vec3
&
lOOlll\
OO\
llll\

,
con\
s\
t
Vec3
&
lOO\
lllOl\
OOOO
)
{
if
(
!
lOOlllOlO\
OO\
l\

(
)
)
return
;
lOOlOll\
l\
lOOl\

+=
lOOlll\
O\
Olll\
l
*
lOO\
lOl\
ll\
lOlO
;
lOOlO\
lll\
l\
O\
ll
+=
(
lOO\
lll\
OO\
lll\
l
.
Cr\
oss
(
lOOl\
OlllOOl\
l\

-
lOOll\
l\
OlOOOO
)
*
lOO\
llO\
Ol\
llO\
O
)
*
lOOlOlllllOO
;
}
vo\
i\
d\

Dyn\
am\
i\
cObject
::
Ac\
c\
u\
mulat\
e\
G\
ra\
vit\
y\

(
)
{
if\

(
lO\
OllOlll\
OlO
)
lOOlllOl\
OOlO\

+=
lOOl\
l\
O\
l\
ll\
OlO
->
Ge\
tPh\
y\
s\
ics
(
)
.
Get\
Gr\
av\
it\
y
(
)
*
(
lOl\
OlOl\
OOlO
*
lOOll\
lOl\
O\
O\
l\
l
)
;
}
void
DynamicObje\
c\
t
::
Accumu\
l\
ate\
F\
orce\
AndTo\
rque
(
cons\
t
Vec3\

&
lOOlll\
OlOlOO
,
const
Ve\
c3
&
lOOl\
llO\
lOOOO
)
{
lOOl\
llOl\
OO\
lO
+=
lOO\
lllOlOlOO
;
lOOl\
llO\
lOlOl
+=
lO\
Oll\
lOlOlOO\

.
Cro\
ss\

(
lOOlOl\
l\
lOOll\

-
lO\
O\
lllOlOOOO
)
;
}
voi\
d
Dynamic\
O\
bje\
ct
::
Acc\
umu\
l\
ateLin\
earF\
o\
r\
ce
(
cons\
t
Ve\
c3
&
lOOlllO\
lOl\
O\
O
)
{
lOOl\
l\
lOl\
OOlO
+=
lOOl\
l\
lOlO\
lO\
O
;
}
vo\
i\
d
DynamicOb\
j\
ect
::
Appl\
yF\
orceAndTo\
rq\
ueTo\
Velo\
cities
(
float\

lOO\
lllO\
Oll\
Ol
)
{
if\

(
!
IsI\
nMoving\
L\
ist
(
)
)
ret\
urn
;
lOOlO\
llll\
OOl\

+=
lOO\
l\
llOlOO\
lO
*
(
lOOlOllllO\
l\
O
*
lOO\
lllOOllOl
)
;
lOO\
lOl\
ll\
lOll
+=
(
lO\
Ol\
l\
lOlO\
lOl\

*
lO\
OllOOll\
lOO\

)
*
lO\
O\
l\
llO\
Oll\
Ol
;
}
void
DynamicObject
::
Cl\
earF\
orce\
A\
ndTorque
(
)
{
lOOlllOlOOlO
.
Clear
(
)
;
lO\
Oll\
l\
OlOlOl
.
Clear
(
)
;
}
void
Dyn\
amic\
Obj\
ec\
t\

::
Clear\

(
)
{
lOOl\
O\
ll\
l\
OOll
.
Clear
(
)
;
lOOllOlOO\
l\
O\
O\

.
Cl\
e\
ar
(
)
;
lOO\
llOlOOlOl
.
Clear
(
)
;
lOOl\
l\
OlOOll\
O
.
Clear
(
)
;
lO\
O\
l\
lOl\
lllOO
.
Cl\
ear
(
)
;
lOOllO\
llllOl
.
Cle\
ar
(
)
;
lOOll\
Oll\
l\
llO
.
Cl\
e\
ar
(
)
;
lOOlO\
l\
l\
l\
lOO\
l
.
Cle\
ar
(
)
;
lOOlOllllOll
.
Clear
(
)
;
lOOlllO\
lOOlO
.
Clear
(
)
;
lO\
Oll\
lO\
lOlOl
.
Clear
(
)
;
lOOl\
llOlOllO
.
Clea\
r
(
)
;
lOOlllOlOl\
l\
l
.
Clear
(
)
;
UpdateW\
or\
ldSp\
ace\
Ine\
rti\
alT\
ensor\

(
)
;
}
vo\
id\

Dynam\
icO\
b\
ject
::
Up\
da\
teWorldSpaceIn\
er\
tia\
lTen\
sor\

(
)
{
lOOllOOllO\
ll
=
lOO\
llO\
l\
O\
OlOl
.
m3\
3Rota\
ti\
on
.
GetTr\
an\
s\
poseAsI\
nverse
(
)
*
lOO\
llOOl\
Oll\
O
*
lOOllOl\
OOl\
Ol
.
m3\
3\
Rot\
at\
ion\

;
lOOllO\
Ol\
l\
lO\
O
=
lO\
OllOOllO\
l\
l\

.
Get\
Inve\
rse\

(
)
;
}
vo\
id
Dyn\
am\
i\
cObject
::
Upd\
ate\

(
float
lO\
Oll\
lOO\
ll\
Ol
)
{
lO\
OOOO\
Oll\
O
(
lOOl\
lOlllOlO\

,
"DynamicObject::Update: Error, not added to physics")
;
if
(
GetF\
ind\
V\
e\
locity\
From\
Ne\
xtFr\
ame
(
)
)
{
TA\
_\
ASS\
ERT
(
lOO\
lllOOllOl
>
0.0f
)
;
lOOlOllllOOl
=
(
GetNe\
xtC\
enterOfM\
a\
ss
(
)
-
GetCe\
nterOfMas\
s
(
)
)
/
lOOll\
l\
O\
Oll\
O\
l
;
Mat\
3\
3\

lOOlll\
OO\
ll\
l\
O\

=
lOOl\
lO\
lO\
OlOl\

.
m33Ro\
t\
atio\
n
.
Get\
Tr\
ans\
po\
seAs\
Inver\
s\
e
(
)
*
lOOllO\
l\
O\
Oll\
O
.
m33R\
o\
tati\
o\
n
;
Vec3\

lOOO\
OOlllOl
;
float
lOOOOOl\
ll\
lO
;
lOOlllO\
O\
ll\
l\
O
.
GetRot\
at\
ionAxisAndMagnitude
(
lOOOOOlllOl
,
lO\
OOO\
Ol\
lllO
)
;
lOOlO\
llllO\
ll
=
(
lOOOOOlll\
Ol\

*
(
lOOO\
OOllllO
/
lOOlllOOllOl\

)
)
;
}
el\
se
{
TA_\
ASSERT\

(
lO\
OllOlll\
Ol\
O
)
;
lOOlOllll\
OO\
l\

+=
lO\
Ol\
lOlllOl\
O\

->
GetPh\
y\
sics
(
)
.
GetGravi\
ty
(
)
*
(
lO\
O\
lllOlOOll
*
lOOlllOOll\
Ol
)
;
ApplyVel\
oci\
ty\
T\
o\
Ne\
xtFr\
ame
(
lOOll\
lO\
OllOl\

)
;
}
}
void
Dynam\
ic\
O\
bje\
ct
::
UpdateGrap\
hics
(
flo\
at
lOOlllO\
O\
llOl
,
float
lO\
Olll\
Ol\
lOOO
)
{
lOOl\
lO\
ll\
lll\
O
=
lOOllOlOOlOl
;
}
static
Vec3
lOOlllO\
llO\
O\
l
(
con\
st
Vec\
3
&
llll\
OOOOOl
,
cons\
t
Ve\
c3
&
llll\
OOOOlO\

,
co\
n\
st\

Vec\
3
&
llllOOOO\
ll
,
const
Vec3
&
llll\
OOOlOO
,
float
lllOlll\
lOO
)
{
lllOlll\
lOO\

+=
1.0f
;
Vec\
3
ll\
llO\
OOllO
=
llllOOO\
OOl
;
Vec3
lllllllll\

=
llllOOOlO\
O
+
lll\
l\
OOO\
O\
Ol
-
llll\
O\
OOOl\
O\

;
Vec3
lO\
O\
OO\
O\
O\
OOO
=
llllOOOO\
lO\

-
llll\
OOO\
O\
O\
l
-
llll\
l\
l\
lll
;
Vec3\

llllOOOlll\

=
ll\
llO\
O\
Ol\
lO
+
lOOOO\
O\
OOO\
O
*
ll\
lOl\
lllOO
+
lllllllll\

*
(
ll\
lOllll\
OO
*
ll\
lOllllOO
)
;
re\
tur\
n\

llll\
OOOlll
;
}
vo\
i\
d
Dy\
nam\
icObject
::
Extrapola\
te\

(
co\
nst\

MFr\
ame
&
lOO\
lll\
OllOlO
,
const
MFr\
a\
me
&
lO\
Ol\
llOllO\
l\
l
,
con\
st
Ve\
c\
3
&
lOOlllO\
lll\
OO\

,
const
Vec3
&
lOOl\
l\
l\
Oll\
lO\
l
,
flo\
at\

lO\
O\
lllOOllO\
l
,
flo\
a\
t
lOO\
ll\
l\
OllllO
)
{
Ve\
c3
lOOlllO\
lllll\

=
lOO\
lllOll\
OOl
(
lOO\
llOlO\
O\
Oll
*
lO\
OlllOllOlO
,
lO\
OllOlOO\
Oll
*
lO\
Oll\
lOll\
Oll\

,
lOOlllOl\
llOl
*
lO\
O\
ll\
l\
OOllOl
,
(
lOOll\
l\
OlllO\
l
+
(
lOOll\
l\
Ol\
llOl
-
lOOlll\
O\
ll\
lO\
O
)
)
*
lOO\
lllOOllOl
,
lOOlllOllll\
O\

/
lOOlll\
OOll\
Ol
)
;
Vec3
lO\
O\
l\
lll\
OO\
OO\
O
=
(
lO\
OlllOlllll\

-
GetC\
ente\
rO\
fM\
a\
ss
(
)
)
/
lOOlll\
OOl\
lO\
l
;
fl\
o\
at
lOOllllOOO\
Ol
=
lOOlll\
l\
OOOOO\

.
Ge\
tMagnit\
ude\

(
)
;
float
lO\
Olll\
l\
OOOlO
=
lOO\
l\
l\
lOlllOl\

.
GetMagni\
tude
(
)
+
5.0f
;
if
(
lO\
OllllOOOOl
>
lOOlll\
lO\
OOlO
+
5.0f
/
lOOlllOOll\
Ol
)
{
SetFrame
(
MFrame
(
lOOlllOllll\
l
-
lOOllO\
lOOOll
*
lOOl\
llOllOl\
l
.
m33Rotati\
on
,
lOOlllO\
llOll
.
m33\
Ro\
tation
)
)
;
SetLinearVel\
oc\
i\
ty
(
lOOl\
ll\
Olll\
O\
l
)
;
SetAngularVeloc\
ity
(
k_v3\
Z\
ero
)
;
}
els\
e
{
Mat\
3\
3
lO\
Olll\
OO\
l\
l\
lO
=
lO\
Ol\
llO\
llOl\
O\

.
m33Rotat\
ion
.
Ge\
tTran\
spo\
seAsInverse
(
)
*
lOO\
ll\
l\
O\
llO\
ll
.
m3\
3\
Rot\
ati\
on
;
Vec3
lOO\
OO\
Ol\
llOl
;
fl\
oa\
t
lOOOOOllllO
;
lOOl\
llO\
Ol\
llO\

.
Ge\
tRot\
atio\
nAxi\
sA\
ndMagnit\
ud\
e
(
lOOOO\
OlllOl
,
lOO\
OOO\
lll\
lO
)
;
float
lO\
O\
l\
ll\
lO\
OOl\
l
=
lO\
OOOOllllO
;
lOOO\
OOl\
lllO
*=
(
lO\
OlllOlll\
lO\

/
lOOll\
lOOllOl\

+
1.0f
)
;
lOO\
lllO\
Ol\
ll\
O\

.
Initi\
al\
ise
(
lOOOOOlllOl
,
lOOOOOll\
llO
)
;
Mat33
lOO\
llll\
OOlOO
=
lOO\
l\
llO\
llO\
l\
O\

.
m3\
3R\
otation
*
lO\
Olll\
O\
OlllO
;
lO\
OlllOOlllO
=
GetFr\
ame
(
)
.
m33R\
ot\
at\
ion
.
GetT\
ra\
nsp\
ose\
AsI\
nve\
rs\
e
(
)
*
lOOl\
lllOOlOO
;
lOO\
lll\
OOl\
llO
.
GetRotatio\
nA\
x\
isA\
nd\
Magnitude
(
lOOO\
OOl\
llO\
l
,
lOOO\
OOll\
llO
)
;
const\

float
lOOllllO\
OlOl\

=
1.0f
;
if
(
Fa\
bs
(
lOOOO\
Oll\
llO
)
>
Fabs
(
lOO\
l\
lllOOOll
)
+
lOOl\
ll\
lOOl\
O\
l
)
lOOOOOllllO
=
Si\
gn\

(
lOOO\
OOll\
l\
lO\

)
*
(
Fa\
b\
s
(
lO\
OllllOOOll\

)
+
lOOll\
llOOlOl
)
;
Set\
Li\
nearVelo\
city
(
lOOll\
llOOO\
OO
)
;
SetAn\
gul\
arV\
eloc\
ity
(
lOOO\
O\
Ol\
llOl
*
lOO\
OOOlll\
lO
/
lOOl\
llOOllOl
)
;
ApplyVe\
loc\
ityToN\
extF\
rame\

(
lOOll\
lOOll\
O\
l
)
;
}
}
voi\
d
DynamicO\
bjec\
t
::
ApplyVeloci\
tyToNe\
x\
t\
Fr\
a\
m\
e
(
float
lO\
Ol\
llOOllOl
)
{
if
(
GetFi\
ndV\
el\
oc\
ity\
F\
romNex\
tFrame
(
)
)
return
;
lOOllO\
lOOllO\

=
lOOl\
lOlOOlOl\

;
const
float
lOO\
llllOOllO
=
TA_MAX\
_AN\
G\
ULAR_\
VELOCIT\
Y\

;
if
(
lOOl\
O\
lll\
lOll\

.
Get\
Ma\
gnitudeSq\
rd
(
)
>
lOO\
llllO\
Ol\
lO\

*
lOOl\
l\
llO\
Ol\
lO\

)
{
lO\
O\
lOl\
ll\
lOl\
l
=
lOOlOllll\
Oll
.
GetN\
or\
mal
(
)
*
lOOl\
ll\
lO\
Oll\
O
;
}
con\
st\

fl\
oat
lOOllllO\
Olll
=
TA_MAX\
_LINE\
AR_\
VE\
L\
OC\
ITY\

;
if\

(
lO\
OlO\
l\
lllOOl
.
Get\
Ma\
g\
n\
itude\
Sqrd\

(
)
>
lO\
Oll\
ll\
O\
Ol\
ll
*
lOOl\
lllOOl\
l\
l
)
{
lO\
OlOl\
l\
l\
lOOl
=
lOOlO\
l\
lll\
OO\
l
.
GetNorm\
a\
l
(
)
*
lOOll\
llOOlll\

;
}
if
(
lll\
O\
lOl\
l\
l\
O
&
lO\
Oll\
lO\
OO\
ll\
O
)
{
lOOl\
O\
llllOll
.
Clear
(
)
;
}
else
{
if
(
!
Is\
AllD\
ampingD\
isa\
ble\
d
(
)
)
lO\
O\
lOll\
ll\
Oll
*=
0.998f
;
float
lOll\
llO\
O\
ll
=
lOOlO\
lll\
lOll
.
Ge\
t\
Ma\
gnit\
ude\

(
)
;
if
(
lOllllO\
Oll
>
0.00001f
)
{
Vec3
lOO\
l\
l\
l\
lOlOOO
=
lOOlOlll\
lOll\

/
lO\
l\
lllOOll
;
Mat33
m3\
3Rot\
ation
(
lOOl\
lllOlO\
OO\

,
lOl\
lllOOll
*
lOOlllOOllO\
l\

)
;
lOOl\
lOlO\
OllO\

.
m3\
3R\
otation
*=
m33Rotation
;
}
}
lOOllO\
lO\
OlO\
O
=
lO\
O\
lOlllOO\
l\
l
+
lO\
OlOllllOOl
*
lO\
OlllOOll\
Ol\

;
lOOllOl\
OOl\
lO\

.
v3T\
r\
ans\
la\
ti\
on
=
lOO\
ll\
OlOO\
lOO
+
(
-
lOOllOlOOOll
)
*
lOO\
llO\
lOOllO\

.
m33\
Rotation
;
Vec3
lOOllllOl\
O\
Ol
=
(
lOOlOllllO\
ll\

*
lOOl\
lOlO\
Oll\
O
.
m33Rotation
.
GetT\
r\
an\
s\
p\
oseAsInvers\
e
(
)
)
*
lOOl\
l\
OO\
lO\
ll\
O
-
(
lOOlOllll\
Oll
*
lOOllO\
lOOlOl
.
m3\
3Rota\
tion
.
Ge\
t\
Transpos\
e\
AsInv\
e\
rse
(
)
)
*
lOOllO\
OlO\
l\
lO
;
lO\
O\
lO\
lll\
lOll
-=
(
lOOll\
llO\
lOOl
*
lOOllO\
OlO\
lll
)
*
lOOl\
lO\
lOOl\
lO
.
m3\
3Rotatio\
n
;
}
vo\
id
Dynam\
i\
cObje\
c\
t
::
Appl\
y\
Ne\
xtFr\
a\
me
(
)
{
lOO\
llOllllO\
l\

=
lOOllOlO\
OlO\
l\

;
lO\
OllOlOOl\
O\
l
=
lOOl\
l\
OlOOll\
O
;
lO\
OllO\
lOOlO\
l\

.
m33Rot\
atio\
n
.
Or\
t\
hogo\
n\
a\
li\
se
(
)
;
lOOlO\
lllOO\
ll
=
lOOllO\
lOOlO\
O
;
UpdateW\
orldSpaceInert\
ialTens\
or
(
)
;
}
vo\
i\
d
Dynamic\
Obj\
e\
c\
t
::
Ren\
d\
er
(
)
{
TA_ASSERT
(
lOOllOOl\
Ol\
O\
O
)
;
lOOllOO\
lOlOO
->
Ren\
der\

(
lOOl\
lOl\
OO\
l\
Ol
)
;
}
void
Dynamic\
Object
::
Calcu\
l\
ateW\
orldA\
ABB\

(
)
{
TA_\
ASSER\
T\

(
lOO\
llOOlO\
lO\
O
)
;
lOOllOlOlOll
=
lOOll\
OO\
lOlOO
->
Ge\
t\
AABB
(
)
*
lO\
Ol\
lOl\
OOlOl
+
lOOllOOl\
Ol\
OO\

->
GetAAB\
B
(
)
*
lO\
Oll\
OlOOl\
l\
O
;
}
void
TA\

::
Dy\
namicOb\
j\
ec\
t
::
SetCo\
llisionObjec\
t
(
Collisio\
nObj\
e\
c\
t\
Com\
bo\

*
lOOll\
OO\
lOO\
ll
,
int
lO\
l\
O\
llOO\
Ol
)
{
lOOll\
OO\
lO\
lOO
->
Rel\
e\
a\
se
(
)
;
lOOl\
lO\
Ol\
Ol\
OO\

=
lO\
Ol\
lOOlOOl\
l
;
lO\
O\
ll\
OOlOlOO
->
AddRef
(
)
;
SetCollisionO\
bje\
ctCh\
anged
(
lOlOll\
OOOl
)
;
}
void\

TA
::
Dy\
n\
amicO\
bjec\
t
::
SetCo\
llisio\
n\
ObjectC\
han\
ged\

(
int
lOlOl\
lOO\
Ol\

)
{
TA_A\
SSERT\

(
lOOllOO\
lOlOO
)
;
Colli\
sionOb\
jectCo\
mbo\

*
lOO\
l\
lOOlOO\
ll\

=
Ge\
t\
Collis\
i\
onObj\
ec\
tCom\
bo
(
)
;
if
(
!
lO\
O\
l\
lOOlO\
Oll\

)
{
lO\
O\
llO\
l\
lOllO
.
In\
it\
ial\
ise
(
0
,
0
)
;
Clear\
L\
ine\
Inters\
ect\
io\
ns\

(
)
;
re\
tur\
n\

;
}
if
(
lOlOllO\
OOl
&
(
RE\
INI\
T\
_\
FLAG\
_UPDA\
TE_MASS
|
REI\
N\
I\
T\
_FLAG_\
UPDATE\
_\
IN\
ERTIA_\
TEN\
S\
O\
R
|
RE\
I\
NIT\
_FL\
AG_UPDATE\
_\
CENTE\
R_OFF\
S\
ET\

)
)
{
const\

fl\
oa\
t
lOO\
llll\
Ol\
Ol\
O
=
10.0f
;
float
lOllOOOOl\
OO\

=
0.0f
;
Ma\
t33
lllOll\
OOOO\
l
;
Ve\
c3
lOOl\
ll\
O\
O\
OO\
ll
;
lllOll\
OO\
O\
Ol
.
SetTo\
Ide\
nt\
ity\

(
)
;
lOO\
lll\
OO\
OOll
.
Cle\
ar
(
)
;
lO\
Oll\
O\
Ol\
OOll
->
Ca\
l\
culateM\
as\
s
(
lO\
Olll\
l\
OlOl\
O
,
lOllOOOOlOO
,
lO\
Ol\
llOOO\
Ol\
l
,
lllOllOOO\
O\
l
)
;
lOOll\
OOllOO\
O\

=
lOOllOO\
lOOl\
l
->
Ge\
tA\
ABB\

(
)
.
v3Ext\
ent
.
Get\
Ma\
gnit\
ude
(
)
;
if
(
lOl\
OllO\
O\
Ol
&
RE\
INIT_FL\
AG_UPDATE_CE\
NTE\
R_\
O\
FFSET
)
{
lOO\
llOlOOOll
=
lOO\
l\
ll\
OOOOl\
l
;
}
if
(
lOl\
O\
llOOOl
&
REINI\
T\
_FL\
AG\
_UPDATE_INER\
TIA\
_TE\
N\
SOR
)
{
lOO\
llOOlOl\
lO
=
lllO\
ll\
O\
OOOl
;
if
(
(
lOl\
OllOOOl
&
RE\
IN\
I\
T_\
FLA\
G\
_UPD\
AT\
E_\
MASS
)
==
0
)
lOO\
l\
l\
OO\
l\
OllO
*=
lOlOlO\
lOOl\
O
/
lOll\
OOO\
Ol\
O\
O
;
lOOllOOlO\
lll
=
lOOll\
O\
O\
lOllO
.
GetInve\
rse
(
)
;
}
if\

(
lOlO\
l\
lOOOl
&
RE\
IN\
IT\
_FLAG_UP\
D\
ATE\
_MASS\

)
{
lOl\
OlOlOOlO\

=
lOll\
OOO\
OlOO
;
SetM\
a\
ss
(
lOllOOO\
O\
lOO\

)
;
}
}
int
lO\
OllllOlOll
=
lOO\
llOOlOOll\

->
GetMa\
xN\
umLineCol\
lisions
(
)
;
if
(
lOO\
llOllO\
llO
.
lO\
OO\
l\
l\
lOOl
(
)
!=
lOO\
ll\
ll\
OlOl\
l\

)
{
lOOl\
lOllOl\
l\
O
.
Initi\
alise\

(
lO\
Olll\
lOlOl\
l
,
lOOll\
ll\
Ol\
O\
ll\

)
;
lOOllOllOllO
.
lOOl\
l\
ll\
O\
l\
O
(
)
;
Cl\
earL\
i\
neIntersecti\
o\
n\
s\

(
)
;
}
lO\
O\
ll\
Ollll\
l\
l
(
)
;
}
voi\
d
TA
::
Dyna\
m\
icO\
bject\

::
ReinitC\
o\
ll\
isionAs\
A\
Box
(
const
AABB
&
lOOOO\
O\
Olll
,
int
lOl\
Ol\
l\
OOOl
)
{
lOOllOOlO\
l\
O\
O\

->
Release
(
)
;
Collis\
ionObj\
e\
ctC\
omb\
o
*
lO\
OllOO\
lOO\
ll\

=
Co\
lli\
sionOb\
jectCombo\

::
CreateNe\
w
(
)
;
lO\
Oll\
O\
O\
lOOll
->
In\
it\
ialiseAs\
ABox\

(
lO\
OO\
OO\
Olll
)
;
lOOllOOlOlOO\

=
lOOllO\
OlOOl\
l
;
SetCol\
lisio\
n\
O\
bj\
e\
c\
tChan\
ge\
d
(
lO\
lOl\
lO\
OO\
l\

)
;
}
void
TA
::
Dyn\
a\
mic\
O\
bj\
e\
ct\

::
Rein\
i\
tC\
o\
llisi\
onAs\
An\
O\
rientedBox
(
con\
st
AABB
&
lO\
OOO\
OOlll
,
cons\
t
MF\
rame
&
lOOOOOO\
OOl
,
int
lO\
lO\
llOO\
Ol
)
{
lOOllOOlOlOO
->
Rel\
ease
(
)
;
Co\
llis\
io\
n\
ObjectCombo
*
lO\
OllO\
OlOO\
ll
=
Collisi\
on\
Object\
C\
ombo\

::
Crea\
teN\
ew\

(
)
;
lOO\
llOOlO\
Oll
->
In\
itialiseAsAnO\
r\
ien\
t\
edBox
(
lO\
OOOOOlll
,
lOOOO\
OO\
OO\
l
)
;
lOOl\
l\
OO\
lO\
lOO
=
lOOllOO\
lO\
Oll
;
SetCo\
ll\
is\
i\
o\
n\
Obje\
ctChanged
(
lO\
l\
Oll\
O\
OO\
l
)
;
}
vo\
id
TA
::
DynamicOb\
jec\
t
::
Rei\
ni\
t\
Coll\
i\
sio\
nAs\
ACaps\
ule
(
co\
nst\

Vec3
&
lOOlOlOlll
,
con\
st
Vec3
&
lOO\
lOllOOl
,
fl\
oa\
t
llllOlllll
,
int
lOlOll\
OOOl\

)
{
lOOllOOlO\
l\
OO
->
Rel\
ea\
se
(
)
;
Collisio\
nO\
b\
jec\
t\
Co\
mbo
*
lO\
Ol\
lO\
O\
lOOl\
l
=
Col\
li\
si\
onObjectC\
ombo
::
Cr\
eateN\
ew
(
)
;
lOOll\
OOlOOll
->
Initi\
a\
liseAsA\
Capsu\
le
(
lOOlOlOll\
l
,
lOOlO\
ll\
OOl
,
ll\
l\
lO\
llll\
l
)
;
lO\
OllOOlOlOO\

=
lOOl\
lOOl\
O\
Oll
;
SetCol\
lisionObj\
e\
c\
tC\
hange\
d
(
lOl\
OllOOOl
)
;
}
voi\
d\

TA
::
DynamicObject\

::
Re\
i\
nit\
Col\
lisio\
nAsASphe\
re
(
con\
st\

Vec\
3
&
v3C\
enter\

,
floa\
t
llll\
O\
lllll
,
int
lOlO\
l\
l\
OOOl
)
{
lOOllO\
OlOlO\
O
->
Release
(
)
;
Col\
li\
sionOb\
j\
e\
c\
tComb\
o
*
lO\
OllOOl\
OOl\
l\

=
Collisio\
nObjec\
t\
Combo\

::
Cre\
ateNew
(
)
;
lOOll\
OOlOOl\
l
->
InitialiseAsASph\
e\
re
(
v3Center
,
ll\
l\
l\
Olllll\

)
;
lOOl\
lOOlOl\
O\
O
=
lO\
Oll\
O\
O\
lOOll
;
Se\
tColl\
isionObj\
ectCha\
nge\
d
(
lO\
lOllO\
OOl
)
;
}
voi\
d
TA
::
Dyna\
m\
i\
cO\
bject
::
Re\
i\
n\
it\
Co\
l\
lisionAsA\
Cyl\
inder
(
const
Vec3
&
lOOlOlOlll
,
cons\
t
Ve\
c\
3\

&
lOOlO\
ll\
OOl
,
floa\
t\

ll\
ll\
Ol\
l\
lll\

,
in\
t
lOlOl\
lOO\
Ol
)
{
lOOllO\
OlOlOO\

->
Re\
lease
(
)
;
Col\
lis\
ionO\
bjectC\
om\
bo
*
lO\
OllOOlO\
Oll
=
Coll\
isionObjec\
tCom\
b\
o
::
CreateN\
ew
(
)
;
lOOllOO\
lOOl\
l
->
Ini\
ti\
ali\
s\
eA\
sACyli\
n\
der\

(
lOO\
lOlOlll
,
lO\
Ol\
Oll\
O\
Ol\

,
lll\
l\
Olll\
ll\

)
;
lO\
Ol\
lO\
OlOl\
OO
=
lOOl\
lOOlOOl\
l
;
SetC\
o\
ll\
isionObjectC\
han\
ged
(
lOlOll\
OO\
O\
l
)
;
}
boo\
l
Dyn\
ami\
cO\
bject\

::
Tes\
tLineForCollision
(
const
Vec3
&
lOOlOlOlll
,
con\
st
Ve\
c3
&
lOOO\
lOOOOO
,
floa\
t\

lOOlOll\
OOO
,
Collisio\
n
&
llOllll\
O\
lOl
)
con\
st
{
if
(
lOOll\
OOlOlOO\

->
Tes\
tLineForCollision
(
lOOlO\
lO\
l\
ll
/
lOOllO\
lOOlOl\

,
lOOOlOOO\
OO
/
lOOll\
OlOOlOl
.
m33Ro\
t\
a\
ti\
on\

,
lOOlOll\
OOO
,
llO\
llllOlOl
)
)
{
ll\
OllllOl\
Ol\

.
lOllOOOlO\
ll
=
(
Dyna\
mic\
Object
*
)
this
;
llOllll\
OlOl\

.
SetOb\
je\
ctB
(
0
)
;
llO\
lll\
lOl\
Ol
.
lOOO\
Ol\
ll\
ll
*=
lOO\
llOl\
OOlO\
l
;
llOl\
lllOlO\
l\

.
lOO\
O\
lOOOOO\

*=
lOOl\
l\
OlOOlOl
.
m33Rota\
ti\
on
;
ret\
u\
r\
n\

true
;
}
else
{
ret\
u\
rn\

fal\
se
;
}
}
vo\
id
Dyna\
m\
i\
cO\
bje\
c\
t
::
lOOllll\
O\
llOO
(
in\
t
lO\
Olll\
lO\
ll\
O\
l
,
Dyn\
a\
mic\
Ob\
ject\

*
lOlllOOO\
llO\

,
Col\
lisi\
o\
n\
Obje\
ct
*
lO\
l\
Ol\
lO\
OOOl
,
u32
llO\
ll\
l\
OO\
llO
,
fl\
o\
at
lOllOO\
lOOOl
,
const
Vec3
&
lO\
OO\
Oll\
lll
,
con\
s\
t
Vec3
&
lOO\
OlO\
O\
OOO
)
{
Line\
Intersec\
tio\
n
&
lOOllll\
O\
lllO
=
lO\
Ol\
lOllOll\
O
[
lO\
Ollll\
Ol\
lOl
]
;
if
(
lOO\
ll\
llO\
ll\
l\
O\

.
lOll\
OO\
lOO\
Ol
==
-
1.0f
||
lO\
OllllOl\
llO
.
lOllOOlOOOl
>
lOl\
l\
OOlOOOl
)
{
lOO\
lll\
lOlllO
.
lOll\
OO\
lOOOl
=
lOllOOlOOOl
;
if\

(
lO\
O\
l\
lllOll\
lO
.
lO\
lll\
OOOllO
)
lOOllllOlllO
.
lOlllO\
OO\
ll\
O
->
Rel\
ease
(
)
;
lOOl\
ll\
lO\
lllO
.
lOlllOOO\
l\
l\
O
=
lOll\
lOOOl\
lO
;
if
(
lOO\
llllOlllO\

.
lOl\
ll\
O\
O\
Ol\
lO\

)
lO\
Olll\
lOlllO
.
lOlllOOOl\
lO
->
AddRef
(
)
;
if
(
lO\
OllllOlllO\

.
lO\
lOllO\
OOOl\

)
lOOllllOlll\
O\

.
lO\
lO\
llOOO\
O\
l
->
Relea\
se
(
)
;
lOOl\
ll\
lOlllO
.
lO\
lOl\
lOOOOl
=
lOlOl\
l\
OO\
O\
Ol
;
lO\
O\
llllO\
lllO
.
lOl\
O\
llOOO\
Ol\

->
Add\
R\
ef
(
)
;
lOOllllOll\
lO
.
ll\
Olll\
O\
O\
llO\

=
llO\
l\
llOOllO
;
lOO\
llllOlll\
O\

.
lOOOO\
lllll
=
lO\
OOOlll\
l\
l
;
lO\
O\
ll\
llO\
lllO
.
lOOOlOO\
OOO
=
lOOO\
l\
O\
O\
OOO
;
}
}
Phy\
sicsJoint
&
Dynam\
icOb\
j\
e\
ct
::
AddJoin\
t
(
Dynamic\
Objec\
t\

*
lOOl\
lllOll\
l\
l\

)
{
Phy\
sicsJo\
i\
nt
&
lO\
Olllll\
O\
OOO\

=
lOOllOll\
Ol\
l\
l\

.
lOOOlllOOO
(
)
;
if
(
lOOllllOllll
)
lOOll\
llOlll\
l
->
lOOll\
O\
lllOOO
.
lOOOlllOOO
(
&
lOOllll\
lOOOO
)
;
lO\
Olll\
ll\
O\
OOO
.
In\
iti\
al\
i\
s\
e\

(
th\
is\

,
lOOllllOllll
)
;
lO\
OllO\
llll\
l\
l\

(
)
;
return
lOOllll\
lOOOO
;
}
#ifndef TA_REMOVE_DEPRECATED
Physi\
cs\
J\
oin\
t
&
DynamicOb\
j\
ec\
t\

::
AddJoin\
t
(
Dy\
nam\
ic\
Obje\
c\
t
*
lOOllllOlll\
l\

,
const
Vec3
&
lOOO\
lllOlll\
l\

,
co\
n\
st\

Vec3
&
lOOlllllOOOl
,
const
Mat33
&
lOO\
lllllOO\
lO
,
co\
ns\
t
EulerAn\
g\
les
&
lOOlllllOO\
ll\

,
con\
s\
t
Eul\
e\
rA\
n\
gle\
s
&
lOOlllllO\
lO\
O
)
{
Physi\
c\
sJ\
oint
&
lOOlllllOO\
O\
O\

=
lOOllOll\
Ol\
ll\

.
lOOOll\
l\
O\
OO
(
)
;
if\

(
lOOll\
l\
lOl\
lll\

)
lO\
OllllOllll\

->
lOO\
ll\
OlllO\
O\
O\

.
lOOOll\
l\
O\
O\
O
(
&
lOOl\
lll\
lOOOO
)
;
lOOlllllOO\
OO
.
Ini\
tia\
lis\
e
(
th\
is
,
lO\
O\
llllOl\
ll\
l
)
;
lOOll\
l\
ll\
OOOO
.
Re\
set\

(
lOOO\
ll\
lO\
llll
,
lOOll\
lll\
OOOl
,
lOOl\
l\
l\
ll\
OOlO
,
lOOl\
llllOO\
ll
,
lOOl\
l\
lllO\
l\
OO
)
;
lOO\
ll\
O\
ll\
llll\

(
)
;
return\

lO\
OlllllOOOO
;
}
Ph\
ysic\
sJoin\
t\

&
Dy\
namicO\
b\
j\
ect
::
Add\
J\
o\
in\
tTy\
peHinge
(
DynamicObject
*
lOOll\
ll\
Oll\
l\
l\

,
cons\
t
Ve\
c3
&
lOOOl\
llOllll
,
co\
n\
st
Ve\
c\
3
&
lOOllll\
lO\
OOl
,
const\

Vec\
3
&
lOO\
ll\
ll\
l\
OlOl\

,
con\
st\

Vec3\

&
lOO\
ll\
lllOllO
,
fl\
o\
at
lOOl\
l\
lllOl\
ll
,
floa\
t
lOOlllll\
lOO\
O
)
{
Physi\
csJ\
o\
int\

&
lOOlllllO\
OOO
=
lO\
Oll\
Ol\
lOlll\

.
lOOOlll\
OOO\

(
)
;
if\

(
lOOll\
llOllll\

)
lOOl\
lllOllll
->
lO\
O\
llOll\
lOOO\

.
lOOOlll\
OO\
O
(
&
lOOlllllO\
OOO
)
;
lOOl\
llllOOOO\

.
Ini\
t\
i\
ali\
s\
e
(
thi\
s
,
lOOllllOl\
l\
ll\

)
;
lO\
Olllll\
OO\
O\
O
.
Re\
setAsTy\
p\
e\
Hing\
e
(
lOO\
O\
ll\
lOll\
ll
,
lO\
O\
lll\
ll\
OOO\
l\

,
lOOlllllO\
lOl
,
lO\
O\
lll\
l\
l\
OllO
,
lOOlllll\
O\
lll
,
lO\
Olll\
lllOO\
O
)
;
return
lOOlllllOO\
OO
;
}
Phy\
sicsJo\
in\
t
&
Dyn\
a\
mic\
Obje\
ct\

::
Add\
J\
ointTy\
pe\
Sock\
et
(
Dyn\
a\
micObj\
ect\

*
lOO\
llllOllll\

,
const
Vec3\

&
lOOOlllOl\
ll\
l\

,
const\

Vec3
&
lOO\
lllll\
OO\
Ol
,
co\
ns\
t
Ve\
c3\

&
lOOllllllO\
O\
l
,
con\
st\

Vec3
&
lOOlll\
lllO\
lO\

,
float\

lOOl\
l\
l\
lllOOO
)
{
Ph\
ysic\
sJoin\
t
&
lO\
Olll\
l\
lOOOO\

=
lOOllO\
ll\
Olll\

.
lO\
OOlllOO\
O
(
)
;
if\

(
lO\
Ol\
ll\
lOlll\
l
)
lO\
O\
l\
l\
llO\
l\
lll\

->
lOOl\
lOlllO\
O\
O
.
lOOO\
lllO\
OO
(
&
lOO\
ll\
lllOOOO
)
;
lO\
OlllllO\
OOO
.
In\
i\
t\
ial\
i\
se
(
this
,
lO\
O\
lll\
lOlll\
l
)
;
lOOllll\
l\
OO\
OO
.
ResetA\
sTyp\
e\
S\
oc\
ke\
t
(
lOO\
O\
lllO\
ll\
ll
,
lOOl\
ll\
llOOOl
,
lOOllllllOO\
l\

,
lOOl\
lllllOlO
,
lO\
Ol\
lllllOOO
)
;
re\
turn
lOOlllllOOOO
;
}
Phy\
si\
csJoi\
nt
&
Dyna\
micObjec\
t
::
AddJ\
o\
intTyp\
eLi\
m\
it\
e\
d\
Socke\
t
(
Dyn\
am\
icObject
*
lOOlll\
l\
Ollll
,
const
Vec3
&
lO\
OOll\
lOll\
ll
,
cons\
t
Vec3
&
lO\
Ollll\
lOOOl\

,
const
Mat\
33
&
lOOl\
l\
lllOOlO
,
float
lO\
O\
lllll\
lOll
,
flo\
at
lOOllllll\
lOO
)
{
Physic\
sJoi\
nt
&
lO\
Oll\
lllOOOO
=
lOOl\
lOllOlll
.
lO\
OOlllOOO\

(
)
;
if
(
lOO\
lll\
lOllll
)
lOOl\
lllO\
ll\
ll
->
lOOllOlllOOO
.
lOO\
Oll\
lO\
OO
(
&
lOOl\
l\
l\
llO\
OOO\

)
;
lOOlllllO\
OOO
.
Initialise\

(
th\
is
,
lO\
Oll\
l\
lOl\
lll
)
;
lOO\
ll\
lllOOOO
.
Re\
set\
AsTypeLi\
m\
i\
t\
edSocket
(
lOOOlllOl\
lll\

,
lOOllll\
lO\
O\
Ol
,
lOOlllll\
OOlO
,
lOOllll\
ll\
Oll\

,
lOOllllll\
lO\
O\

)
;
retur\
n
lOOl\
lll\
l\
OOOO
;
}
Ph\
ysi\
cs\
J\
o\
int
&
Dy\
n\
am\
icO\
bjec\
t
::
Add\
Joi\
n\
tTypeSquare\
Socket
(
Dy\
namic\
Object
*
lOOll\
l\
lOlll\
l
,
cons\
t\

Vec3\

&
lO\
OOlll\
Ol\
ll\
l
,
co\
ns\
t
Vec3
&
lOOll\
l\
ll\
OO\
Ol
,
const
Mat3\
3
&
lOOll\
lllOO\
lO\

,
float
lOOlllllllOl
,
fl\
o\
at
lOOlll\
lll\
l\
lO
,
floa\
t\

lO\
Olllll\
ll\
l\
l\

,
floa\
t\

lOlOOOO\
OOOOO
,
floa\
t
lO\
l\
OOOOOOOOl
,
float
lOl\
OO\
OOOOO\
l\
O\

)
{
Physi\
c\
s\
Jo\
in\
t
&
lO\
Ol\
ll\
l\
l\
OO\
OO
=
lOOllOllOlll
.
lOO\
O\
lllOOO
(
)
;
if
(
lOO\
l\
lll\
Olll\
l
)
lOOlll\
lOllll\

->
lOOl\
lOll\
lOOO
.
lOO\
Ol\
ll\
OO\
O
(
&
lOOll\
lllOO\
OO
)
;
lOOll\
lllOOO\
O
.
Initialise
(
this
,
lOO\
llllO\
llll
)
;
lOOlllllOOOO
.
Re\
se\
t\
AsTy\
p\
eSq\
ua\
r\
eSoc\
ket
(
lO\
OOlll\
O\
l\
lll
,
lO\
O\
lllllOOOl
,
lOO\
ll\
ll\
lO\
OlO
,
lOOlll\
ll\
l\
l\
Ol\

,
lOO\
llllllllO\

,
lO\
Olll\
l\
llll\
l
,
lO\
l\
OOOOOO\
OOO
,
lO\
lOO\
O\
O\
OOOOl\

,
lOlOO\
O\
OO\
OO\
l\
O
)
;
re\
t\
urn
lOO\
llll\
lOOOO
;
}
PhysicsJoint\

&
DynamicObje\
c\
t
::
AddJoint\
T\
yp\
eSlider
(
DynamicObje\
ct\

*
lO\
Olll\
lO\
l\
lll\

,
con\
st
Vec3
&
lOO\
O\
ll\
lOll\
ll\

,
cons\
t
Vec3
&
lOl\
OOOOOOOl\
l\

,
co\
n\
st
Vec3\

&
lOlOOOOO\
O\
l\
OO
)
{
Phys\
i\
cs\
Joi\
nt
&
lO\
O\
llll\
lOO\
OO
=
lOOllOllOl\
ll
.
lOOOlll\
OOO
(
)
;
if
(
lO\
Olll\
lO\
llll
)
lOO\
llllOllll\

->
lOO\
l\
lOl\
llO\
O\
O\

.
lOO\
O\
lllOO\
O
(
&
lO\
Olll\
ll\
OO\
OO
)
;
lOOlll\
ll\
OOOO
.
Initiali\
se
(
thi\
s
,
lOOllllO\
llll
)
;
lOO\
lllll\
O\
OOO
.
Res\
etAsTypeS\
li\
der
(
lOO\
Ol\
llO\
llll
,
lOl\
O\
O\
OO\
OOO\
ll
,
lOlO\
OOOO\
OlO\
O
)
;
retu\
rn
lOOlllllOOO\
O
;
}
Physics\
Jo\
i\
n\
t\

&
Dy\
nam\
icO\
bjec\
t
::
AddRotationCons\
traint
(
Dynamic\
Ob\
ject
*
lOOllll\
Oll\
ll
,
cons\
t
Mat3\
3\

&
lOOlllllOOl\
O
,
const\

Eu\
le\
r\
A\
ngles
&
lOOl\
l\
lllOOll
,
const\

Eul\
erA\
n\
gles
&
lOOlllllOlO\
O
)
{
lOOllll\
Ol\
lll
=
0
;
Ph\
ysic\
sJo\
int
&
lOOlllllOOOO\

=
lOO\
llO\
ll\
O\
ll\
l
.
lOOOlllOOO
(
)
;
if
(
lOO\
ll\
llOl\
ll\
l
)
lOOll\
llOll\
ll
->
lOO\
l\
lOll\
l\
OO\
O
.
lOO\
OlllOO\
O\

(
&
lOOl\
ll\
llO\
OOO
)
;
lO\
Ollll\
lOOOO\

.
Init\
i\
alise
(
this
,
lOOll\
llOllll
)
;
lOOllll\
lOO\
OO
.
Res\
et\
As\
TypeRotationConst\
r\
ain\
t\

(
lOOllll\
l\
OOlO
,
lOOllll\
lO\
O\
ll
,
lOO\
lllll\
O\
lOO\

)
;
re\
tur\
n
lOOlll\
l\
lOOO\
O
;
}
Phy\
sicsJoin\
t
&
DynamicO\
b\
ject
::
AddV\
ector\
Constr\
a\
i\
nt\

(
Dy\
namicObj\
ect
*
lOOll\
llO\
lll\
l
,
const
Ve\
c3\

&
lOO\
l\
l\
llllOOl
,
const\

Vec3
&
lOO\
llllllOlO\

,
floa\
t
lO\
Ol\
l\
l\
ll\
lOOO
)
{
lO\
Ollll\
O\
lll\
l\

=
0
;
PhysicsJ\
oint
&
lO\
Olll\
l\
lOOO\
O\

=
lOO\
llOllOl\
ll
.
lOO\
OlllO\
OO
(
)
;
if
(
lOOl\
l\
llOl\
ll\
l
)
lO\
OllllOl\
l\
ll
->
lOOllOl\
llOOO
.
lO\
OO\
l\
l\
l\
OOO\

(
&
lOOlll\
llOOO\
O\

)
;
lOOl\
llllOO\
OO
.
Initialise
(
this
,
lO\
Ollll\
Ollll\

)
;
lOOllll\
lOOOO\

.
Reset\
AsTypeVector\
Constr\
a\
in\
t
(
lOOllllllOOl\

,
lOOllllll\
OlO
,
lO\
Ol\
l\
l\
ll\
lOOO
)
;
retur\
n
lOOl\
llllOO\
OO
;
}
#endif //
void\

Dynami\
cOb\
jec\
t
::
RemoveAllJo\
ints
(
)
{
{
for
(
JointIte\
r\
a\
t\
or
lOl\
OOlOO\
lO\

=
lOOl\
lOllOll\
l
.
lO\
lOOOOlOO\

(
)
;
!
lOlOOlOOlO\

.
AtE\
nd
(
)
;
)
{
Phys\
icsJoint
&
lOOl\
ll\
O\
OOO\
Ol
=
*
lO\
lO\
OlOOlO
;
++
lOlOOl\
O\
OlO
;
TA_A\
SS\
ER\
T
(
lO\
OlllOOOOO\
l
.
GetObjec\
tA
(
)
==
this
)
;
RemoveJo\
int
(
lOO\
lll\
O\
OOOOl
)
;
}
}
{
for
(
Lis\
t\

<
PhysicsJoint
*
>
::
Iterat\
or
lOlOO\
lO\
OlO\

=
lOOll\
OlllOOO
.
lOlOOOOlOO
(
)
;
!
lOl\
OOlO\
Ol\
O
.
At\
End\

(
)
;
)
{
Ph\
ysics\
Joint\

*
lOll\
l\
OOlOOO
=
*
lOlO\
OlO\
OlO
;
++
lOl\
O\
OlOO\
lO
;
TA_ASSERT
(
lOlllOOl\
OOO
->
GetObj\
ectB
(
)
==
this
)
;
lOlllO\
OlO\
OO
->
Get\
Object\
A
(
)
->
Remov\
e\
Jo\
int
(
*
lOlllO\
OlO\
OO
)
;
}
}
lOOl\
lO\
lllll\
l
(
)
;
}
vo\
id
Dynami\
cObject
::
Remov\
eJoin\
t
(
Phy\
sic\
sJo\
in\
t\

&
lOOlllOOO\
OOl\

)
{
if
(
lOO\
lll\
OOOOOl
.
Ge\
tO\
bje\
ctA\

(
)
!=
this
)
{
lOOOOOOll\
O
(
0
,
"DynamicObject::RemoveJoint: Joint doesn't exist in this dynamic object.")
;
return\

;
}
if
(
lOO\
ll\
lOOOOOl
.
Ge\
tO\
bjectB\

(
)
)
{
List
<
Ph\
y\
si\
csJ\
o\
int
*
>
::
Iterat\
or\

lOlOOlOOlO
=
lOOlllOOOOOl
.
Get\
Objec\
tB\

(
)
->
lO\
Ol\
l\
OlllO\
OO
.
lO\
lO\
OO\
OlOO\

(
)
;
for
(
;
!
lOlOOlOOlO\

.
At\
En\
d
(
)
;
++
lOlOOlOOlO
)
{
Ph\
ysi\
csJoi\
nt\

*
&
lO\
lllOOl\
OOO
=
*
lOlO\
O\
lOO\
lO
;
TA\
_\
ASSERT\

(
lOl\
llO\
OlOOO
->
Get\
Ob\
j\
e\
c\
tB
(
)
==
lO\
Ol\
ll\
O\
O\
O\
OOl
.
GetObje\
ctB
(
)
)
;
if
(
lO\
lllOOl\
OOO
==
&
lOOll\
l\
OO\
O\
OOl\

)
{
lOOll\
l\
OOOO\
Ol
.
Ge\
tObjectB
(
)
->
lOOllOl\
llOOO\

.
lO\
Olllll\
ll
(
&
lOl\
llOOlOO\
O
)
;
lOOlllO\
OO\
O\
Ol
.
Get\
Obj\
ect\
B
(
)
->
lOOll\
Ollllll
(
)
;
brea\
k
;
}
}
}
lOOl\
lO\
ll\
Olll\

.
lO\
Oll\
llll\
l\

(
&
lOOlll\
OO\
OOOl
)
;
lOOll\
O\
llllll\

(
)
;
}
void\

Dynam\
icObject
::
Remove\
J\
oi\
ntsToOb\
jec\
t
(
Dyna\
m\
icOb\
ject
*
lO\
ll\
l\
OOOllO
)
{
for\

(
Jo\
intItera\
t\
o\
r
lOlOOl\
OOlO
=
lO\
Oll\
OllOll\
l
.
lOlOOOOlO\
O
(
)
;
!
lO\
lOOlOOlO
.
AtEnd
(
)
;
)
{
Phys\
ics\
J\
oint
&
lOOlll\
OOO\
OO\
l\

=
*
lOl\
O\
O\
l\
OO\
lO\

;
++
lOlOOlOOlO
;
TA\
_\
A\
SS\
ERT
(
lO\
Olll\
OOOOOl\

.
GetObjec\
tA\

(
)
==
thi\
s\

)
;
if
(
lOOlllOOOOOl\

.
Ge\
tObjec\
tB\

(
)
==
lOll\
l\
O\
O\
O\
llO
)
Remo\
veJ\
o\
int
(
lOO\
l\
l\
lOOOO\
Ol
)
;
}
if
(
lO\
lllOOOllO\

)
{
for\

(
Join\
tI\
terat\
o\
r
lOlOO\
lOO\
l\
O
=
lOlllOO\
Ol\
l\
O\

->
lOO\
llO\
ll\
Olll\

.
lOlOOOO\
lOO
(
)
;
!
lOlOOlOOl\
O
.
At\
End
(
)
;
)
{
PhysicsJoint
&
lOOlllOO\
O\
O\
O\
l
=
*
lOlOOl\
OO\
l\
O
;
++
lOlO\
Ol\
O\
O\
lO
;
TA_\
AS\
S\
ERT
(
lOOl\
llOOOOOl
.
Ge\
t\
O\
b\
jectA
(
)
==
lOlllO\
O\
O\
l\
lO
)
;
if\

(
lOOlllOOOOOl
.
GetO\
bjec\
tB
(
)
==
this
)
Remov\
e\
J\
o\
int
(
lO\
Oll\
lO\
OO\
OOl
)
;
}
}
}
void
DynamicObject
::
lO\
OllOlllOOl
(
)
{
Clear\
LineIntersect\
ions
(
)
;
if
(
lO\
Oll\
OOlOl\
O\
O\

)
{
Col\
lision\
ObjectCombo
*
lOOll\
OOlO\
O\
ll
=
Ge\
tCol\
l\
isionOb\
jec\
tCombo
(
)
;
if\

(
lOOll\
OOlO\
Ol\
l
)
{
int
lOO\
lll\
lOlOll
=
lOOllO\
Ol\
OOll
->
GetMa\
x\
NumL\
ineCo\
ll\
i\
sio\
ns\

(
)
;
if\

(
lOOl\
l\
ll\
OlOl\
l\

!=
lO\
O\
l\
lOll\
OllO\

.
lOOOll\
lOOl\

(
)
)
{
lOOllOllO\
llO
.
Fi\
nal\
i\
s\
e
(
)
;
lO\
O\
llOllOll\
O
.
Init\
ialise
(
lO\
Ol\
lllOl\
O\
ll
,
lOOl\
ll\
lOl\
Ol\
l
)
;
lOOll\
OllO\
llO
.
lOOllllO\
lO\

(
)
;
Cl\
e\
arLi\
neI\
n\
t\
e\
rsections
(
)
;
}
}
}
}
lO\
l\
OO\
OOOOlO\
l
*
Dyna\
mi\
cObject
::
lOl\
O\
OOOOOll\
O\

(
Dynam\
ic\
O\
bject
*
llO\
O\
lOOl\
OOl
,
bo\
ol
lOl\
OOO\
OOOll\
l
)
{
TA_ASSER\
T
(
llO\
OlOOlOO\
l
)
;
#ifdef _DEBUG
if
(
lO\
OlOOO\
l\
lO
)
{
int
llO\
llOOlOl
=
0
;
lOl\
OOOOO\
l\
O\
OO
*
lOl\
O\
OOOOl\
OOl
=
lOOllOl\
lOOlO\

;
for
(
;
lOlOO\
OOOlOOl\

;
lO\
lOOOOOl\
OOl
=
lO\
lOOOOOlO\
Ol\

->
llOOOOl\
l\
lll
)
llOllOOlOl
++
;
TA\
_A\
SSERT\

(
llO\
l\
lO\
Ol\
O\
l
==
lO\
O\
llOll\
OOll\

)
;
llO\
llOOlOl
=
0
;
lOl\
OOOOOlOOl
=
ll\
OOlOO\
lOOl\

->
lOOllOllOOlO\

;
for\

(
;
lOlOOO\
OOlOOl\

;
lO\
lOOO\
OO\
lOOl\

=
lOlOO\
OOOlOO\
l
->
ll\
OOOO\
lll\
ll\

)
llOllOOlOl
++
;
TA\
_\
ASSE\
R\
T
(
llOll\
OOlOl\

==
llOOlOOlOOl
->
lO\
Ol\
l\
OllOOl\
l\

)
;
}
#endif 
lOl\
OOO\
O\
O\
lOOO
*
lOlOO\
OOOl\
OOl\

;
if
(
lOOllOll\
OO\
l\
l\

<=
ll\
O\
O\
lOOlO\
Ol
->
lO\
OllOl\
lO\
Ol\
l
)
{
lO\
lO\
OOOOlOOl\

=
lOOllOll\
O\
Ol\
O
;
fo\
r
(
;
lO\
lOOOOOlOO\
l\

;
lOlOOOOOlOOl
=
lOl\
O\
O\
OOOlOOl
->
llO\
OOO\
lll\
ll
)
{
lOlOOOOOOlO\
l
*
lOl\
OOOO\
O\
lOlO
=
lOl\
OOO\
OOlOOl
->
lO\
lOOOOOl\
OlO\

;
if\

(
lOlOOOOOlO\
l\
O
->
lOlOOOOOlOll
==
this
)
{
if\

(
lO\
lOO\
OOOl\
OlO
->
lOlO\
OOOOll\
OO
==
llOO\
lO\
Ol\
OOl
)
return
lOlOOOOO\
lOl\
O\

;
}
else
{
TA_AS\
SER\
T\

(
lOlOOOOOl\
OlO
->
lOlOO\
OOO\
ll\
O\
O\

==
th\
is
)
;
if
(
lOlOO\
OOOlOl\
O\

->
lOl\
OOOOOl\
Oll
==
llOO\
l\
OOlOOl
)
ret\
urn
lOlO\
OO\
O\
O\
l\
Ol\
O
;
}
}
}
else
{
lO\
l\
O\
O\
OOOlOOl\

=
llOOlOO\
l\
OOl
->
lOO\
llOl\
lOOlO
;
for
(
;
lOlO\
OO\
OO\
lO\
Ol
;
lOlOOOOO\
l\
OOl\

=
lO\
l\
OOOOOlOOl
->
llO\
OOOlllll\

)
{
lOlOOOO\
OO\
l\
Ol
*
lOlOOOOO\
l\
O\
lO\

=
lOl\
OOOOO\
lO\
Ol
->
lO\
lOOOOOlO\
l\
O
;
if
(
lOlO\
O\
OOOl\
OlO\

->
lOlOO\
OOOlOll
==
llOOl\
OO\
lOOl\

)
{
if
(
lOlOOOOOl\
O\
lO
->
lO\
l\
OOOOOl\
lOO
==
thi\
s
)
return\

lOlO\
OOO\
OlO\
lO
;
}
el\
se
{
TA_ASS\
ERT
(
lOl\
O\
OOOOlO\
l\
O
->
lO\
lO\
O\
OOOll\
OO
==
ll\
OOl\
OOl\
OOl\

)
;
if
(
lOlOO\
OOOlOlO\

->
lO\
lOOOOOlO\
l\
l
==
this
)
re\
t\
ur\
n
lOlO\
O\
OOOlO\
lO
;
}
}
}
if\

(
lOlO\
OOOOOlll
)
re\
tu\
rn\

lOlOOOOOllOl
(
llOOl\
O\
O\
l\
OOl\

)
;
else
re\
turn
0
;
}
lOlOOOOOOlOl
*
Dy\
n\
am\
icObje\
ct
::
lOlO\
OO\
O\
O\
ll\
Ol
(
DynamicObj\
ect
*
llO\
OlOOlOO\
l
)
{
TA_AS\
S\
ERT
(
lOOllOl\
llOl\
O
)
;
lO\
lOO\
OOOOl\
Ol
*
lOlOOOOOlOlO
=
lOO\
ll\
Ol\
l\
lOlO\

->
GetPh\
ys\
ics
(
)
.
lOlOOOOO\
l\
llO
(
)
.
lOl\
OOOOOll\
ll
(
)
;
if
(
!
lOlOOOO\
Ol\
Ol\
O
)
retu\
rn
0
;
lOlO\
OO\
OOlO\
l\
O
->
lO\
lOO\
OO\
OlOll
=
thi\
s
;
lO\
lOOOOOl\
Ol\
O
->
lOl\
O\
OOOOll\
OO
=
llOOlOOl\
OOl
;
lOlOOOOOlOlO
->
lOlO\
OOO\
lO\
O\
O\
O
=
0
;
lOOll\
OlllOlO
->
Ge\
tPhy\
sics
(
)
.
lO\
lO\
OOOO\
lll\
O
(
)
.
lOlO\
O\
OOlOO\
Ol\

(
lO\
lO\
O\
OOOl\
Ol\
O
)
;
lOlOOOOOl\
Ol\
O
->
lO\
lO\
OOOl\
OOlO
.
llOOOOll\
lll\

=
lO\
Oll\
O\
ll\
OOlO
;
if
(
lOlOO\
O\
OO\
lOlO
->
lOlOOOO\
lO\
OlO
.
llO\
O\
OO\
lllll
)
{
TA_AS\
SERT
(
lOlOOOOO\
lO\
lO
->
lOlOOOOlO\
OlO
.
ll\
OOOOlllll\

->
llO\
OOO\
l\
OlO\
l\

==
&
lO\
Ol\
lOllO\
Ol\
O
)
;
lO\
lOOOOOlOlO
->
lO\
lOOO\
O\
lOOlO
.
llOOOOlll\
ll
->
llOO\
OOl\
OlOl\

=
&
lO\
lOOOOO\
l\
O\
lO
->
lOlOOOOlOOlO
.
llO\
OO\
O\
ll\
lll
;
}
lO\
lOOOO\
O\
l\
OlO
->
lOlOOO\
OlO\
Ol\
O
.
llOO\
O\
O\
lOlOl\

=
&
lOOllOllOOlO\

;
lO\
O\
llOl\
lO\
OlO
=
&
lOl\
OOOOOl\
Ol\
O
->
lOlOOOOlOOlO
;
lOl\
O\
O\
OOOlO\
lO
->
lOlOOOOlOOlO
.
lOlO\
OOOOlOlO
=
lOlOO\
OO\
OlO\
l\
O
;
lOOl\
lO\
l\
lOOl\
l
++
;
TA_AS\
S\
ERT
(
llOOlOOlOO\
l
)
;
lOl\
OOO\
OOlOlO
->
lO\
lOOOOl\
O\
O\
ll
.
ll\
O\
OOOlll\
ll\

=
ll\
O\
OlOO\
lO\
O\
l
->
lOOllO\
llOOlO
;
if\

(
lO\
l\
OOOOOl\
Ol\
O
->
lO\
l\
OO\
OO\
lOOll
.
llOO\
OOll\
l\
ll
)
{
TA_\
ASS\
E\
RT
(
lOlOOOO\
Ol\
Ol\
O
->
lOl\
OOO\
OlO\
O\
ll
.
llOOO\
Olllll
->
llOOOOlOlO\
l
==
&
llOOlOO\
l\
OOl\

->
lOOl\
lO\
llO\
Ol\
O\

)
;
lOlOOOOOl\
O\
lO
->
lOlOO\
OOlO\
O\
ll
.
llO\
OO\
Olllll
->
ll\
O\
O\
OOlO\
l\
Ol\

=
&
lOlOOOOOl\
OlO\

->
lO\
l\
OOOOlOOll
.
ll\
OOO\
Ol\
ll\
ll
;
}
lOlOOOO\
OlOlO
->
lO\
lOOOOlOOll
.
llOO\
O\
OlOlOl
=
&
llOOlOOlOO\
l
->
lOOll\
OllO\
O\
lO\

;
llOOlOOlO\
O\
l
->
lO\
O\
llO\
ll\
OO\
lO
=
&
lO\
lOOOOOlOlO
->
lOlOO\
OO\
lO\
O\
l\
l
;
lO\
lO\
OOO\
OlOlO
->
lO\
l\
O\
OOOl\
O\
O\
ll
.
lO\
lOOO\
OOlOl\
O\

=
lOlOOO\
OOlOlO
;
llOOlO\
OlOOl
->
lOOllOll\
OOll
++
;
retu\
r\
n
lOlO\
O\
OOOlOlO
;
}
void
Dynam\
i\
cObj\
ect
::
lO\
l\
O\
OO\
OlOlO\
O
(
int\

lOlOOOOlOlOl
)
{
for
(
lOl\
OO\
OOO\
lOOO
*
lOlO\
OOOOlOOl
=
lO\
O\
l\
lO\
ll\
OOlO
;
lOlOO\
O\
OOlOOl\

;
lO\
lOOOOOlOOl
=
lOlOOO\
OOlOOl\

->
ll\
O\
O\
OOl\
l\
lll\

)
{
lO\
lOO\
O\
OO\
OlO\
l
*
lOlOOOO\
Ol\
OlO\

=
lOlOOO\
OOlOOl
->
lOl\
OO\
OO\
OlOlO
;
lOl\
O\
OOO\
O\
lO\
lO
->
lOlO\
OOO\
OlO\
l\
l
->
lOlOO\
OOlOllO
(
lOlOO\
O\
OlO\
lOl
)
;
if
(
lOlOOO\
OO\
lOl\
O\

->
lOl\
O\
O\
OOOllOO
)
lOl\
OOOOOlOlO
->
lOl\
OOO\
OOll\
OO\

->
lOlOO\
O\
Ol\
OllO
(
lOlOOOOlOlOl
)
;
}
}
voi\
d
Dynam\
ic\
Object
::
lOlOOOOl\
Olll
(
int\

lOl\
OO\
OOlOl\
Ol
)
{
{
JointIt\
erator
lOlOOlOOlO
=
lOO\
l\
lOll\
Olll\

.
lO\
lO\
OOO\
l\
OO
(
)
;
fo\
r\

(
;
!
lO\
lO\
Ol\
OO\
l\
O
.
At\
End
(
)
;
++
lO\
lOOlOOl\
O
)
{
Ph\
ysicsJoint
*
lOll\
l\
OOlOOO\

=
&
*
lOlOOlOOlO
;
if
(
lO\
l\
llO\
OlO\
O\
O
->
IsCol\
li\
sion\
Dis\
able\
d\
Be\
t\
w\
eenO\
bj\
ects\

(
)
)
{
TA\
_A\
S\
SER\
T
(
lO\
lllOO\
lOO\
O\

->
GetObjectA
(
)
==
this
)
;
if
(
lOl\
ll\
OOlOOO
->
Get\
Ob\
jectB
(
)
)
lOlllOO\
lOO\
O
->
GetOb\
jectB
(
)
->
lOlOOOO\
lOllO
(
lO\
lOOOO\
lOlOl
)
;
}
}
}
{
Lis\
t\

<
PhysicsJoin\
t
*
>
::
It\
er\
ato\
r
lOlOOl\
OOl\
O
=
lOO\
llO\
l\
llO\
O\
O
.
lO\
lO\
OOOlOO
(
)
;
fo\
r
(
;
!
lOlOO\
lOOlO\

.
AtE\
nd
(
)
;
++
lOlOOl\
OOlO
)
{
Physics\
J\
o\
int
*
&
lOlllOO\
lOO\
O\

=
*
lOl\
O\
Ol\
OOl\
O
;
if
(
lOl\
ll\
OO\
lOOO
->
IsCo\
llisio\
nDisab\
ledBetwe\
e\
nO\
bjec\
ts
(
)
)
{
TA_ASS\
ERT
(
lO\
l\
llOOlOOO\

->
Ge\
t\
Object\
B
(
)
==
this
)
;
TA_AS\
SERT
(
lOll\
lOOlOOO
->
Get\
Ob\
jectA\

(
)
)
;
lOl\
llOOl\
O\
O\
O
->
Get\
O\
bj\
e\
c\
tA
(
)
->
lO\
lOOO\
O\
lOllO
(
lOl\
O\
OOO\
l\
Ol\
Ol
)
;
}
}
}
}
voi\
d\

DynamicOb\
j\
e\
ct
::
lOlO\
OOO\
ll\
O\
OO
(
vo\
id
(
TAC\
_CAL\
L
*
lOlOOOOll\
O\
Ol
)
(
lO\
lOOO\
OOO\
l\
Ol\

&
lOl\
OOO\
Oll\
OlO
,
void
*
lOOlllOOOO
)
,
vo\
id
*
lO\
OlllO\
OOO
)
{
TA\
_\
ASSERT
(
lOlOOOOllOOl
)
;
fo\
r
(
lOlOOO\
OOlOOO\

*
lOlOOOO\
OlOOl
=
lO\
Ol\
lOllOO\
lO
;
lOlO\
OO\
OOlO\
Ol
;
lOlOO\
OO\
OlO\
O\
l
=
lO\
lO\
OO\
OOlOOl\

->
llO\
OOO\
l\
ll\
ll
)
{
lOl\
OOOOOO\
lOl
*
lOlO\
O\
OOOlOl\
O
=
lO\
l\
OOO\
OO\
lOOl
->
lOlOOOO\
OlOlO
;
TA\
_ASSE\
RT
(
lOlOO\
OOOlOl\
O
)
;
lOl\
O\
OOOl\
lOO\
l
(
*
lOlOOO\
OO\
l\
OlO
,
lO\
O\
l\
llOO\
OO
)
;
}
}
void
Dyna\
micObje\
ct
::
lOlOO\
OOllOll\

(
)
{
lO\
lO\
O\
O\
OO\
lOOO\

*
lOlOOO\
OOlOOl
=
lOOll\
O\
llOOlO\

;
fo\
r
(
;
lOl\
OOO\
O\
OlOOl
;
)
{
lOl\
OOOOOOlOl
*
lOlOOOOOlOlO
=
lOlO\
OO\
OOlOOl
->
lO\
lOOO\
OOlOl\
O\

;
lOlOOOO\
OlOOl
=
lO\
lOOOOOlOOl\

->
llOOOOll\
lll
;
TA_\
ASSER\
T
(
lOO\
llOl\
ll\
OlO
)
;
lOOl\
lOll\
lOlO
->
Ge\
tPhysics\

(
)
.
lO\
lOO\
OO\
OlllO
(
)
.
lO\
lOOOOl\
ll\
OO
(
*
lOl\
O\
O\
OOO\
l\
OlO\

)
;
}
}
void
Dynam\
icO\
bject\

::
lOl\
OO\
OOll\
lOl
(
)
{
lOlOOO\
OOlOO\
O
*
lOl\
OOO\
O\
OlOO\
l
=
lO\
OllOl\
lOOlO\

;
fo\
r\

(
;
lOlOO\
OO\
OlOOl
;
)
{
lOl\
OO\
OOOOlOl\

*
lOlOO\
O\
O\
OlOlO
=
lOl\
OOOO\
OlOOl
->
lOlOOOO\
OlOlO
;
lO\
lOOOOOl\
OOl
=
lO\
lOO\
OOOlOOl
->
ll\
OO\
OOlllll
;
TA_ASSE\
R\
T
(
lOO\
ll\
Oll\
lOlO
)
;
if\

(
(
lOlOOO\
OOlOl\
O
->
lOlOOOOOlO\
ll
->
lOlO\
OO\
O\
l\
l\
llO
(
)
||
lO\
lOOOOOl\
OlO
->
lOlOOOO\
OlOl\
l
->
lOlOOO\
Ollll\
l
(
)
)
&&
(
lOlOOOOOlO\
lO
->
lOlOOOOOllO\
O\

->
lOlOOOOll\
llO
(
)
||
lO\
l\
O\
OOO\
Ol\
OlO
->
lOlO\
O\
OO\
O\
l\
l\
OO\

->
lO\
lOO\
OO\
l\
l\
l\
ll
(
)
)
)
{
lOOllO\
lllOlO\

->
GetPhysics
(
)
.
lOl\
OOO\
OOll\
lO
(
)
.
lOlO\
OOlOOO\
OO
(
*
lO\
lOOOO\
O\
lOl\
O\

)
;
}
}
}
void
Dy\
namicO\
bject
::
lOlOOOlOOOO\
l
(
)
{
lOlOO\
OOOlOOO
*
lOl\
OO\
OOOlOOl\

=
lOOl\
lOl\
l\
O\
OlO\

;
for
(
;
lOlOOO\
O\
OlOO\
l
;
)
{
lOlOOO\
OO\
OlOl\

*
lOl\
OOO\
OOlO\
lO
=
lOlO\
OOOOlOOl
->
lOlOOO\
OOlOlO
;
lOl\
O\
O\
OO\
Ol\
OOl\

=
lOl\
O\
OOO\
OlOO\
l
->
llOOOOl\
llll
;
if\

(
!
lOlOOOOOlOlO
->
lOlOOOOOl\
O\
ll\

->
Is\
InMovin\
gLis\
t\

(
)
&&
!
lOlOOOOO\
lOlO\

->
lOl\
OOOOOll\
OO
->
Is\
InM\
ov\
ingL\
ist
(
)
)
{
TA_\
A\
SSER\
T
(
lOOll\
OlllOl\
O
)
;
lOO\
llOll\
lO\
lO
->
GetP\
h\
ys\
i\
c\
s
(
)
.
lO\
lO\
OO\
OO\
ll\
lO
(
)
.
lO\
lOOO\
Oll\
lOO\

(
*
lOlO\
OOOO\
lOlO
)
;
}
}
}
void
DynamicO\
b\
ject\

::
lOl\
O\
OOlOOOlO
(
lO\
lOOOO\
OOlOl
&
lOlOOOOllO\
l\
O
)
{
lOOllOll\
OOll
--
;
TA_AS\
SER\
T
(
lOlOO\
OOl\
lOlO
.
lOlOOOO\
OlOl\
l
==
th\
i\
s
||
lOl\
OOOO\
l\
lO\
lO
.
lOlOOOOO\
llOO
==
this
)
;
TA_ASSE\
RT
(
lO\
OllOll\
O\
Oll
>=
0
)
;
}
void
Dyna\
mi\
cO\
bje\
c\
t
::
lO\
lOOOl\
O\
OOll
(
)
{
lOOllOlOOlll
=
lOO\
lOl\
lllO\
Ol
;
lO\
OllOlOlOOO\

=
lOO\
lOl\
lll\
Ol\
l
;
}
vo\
id
DynamicOb\
j\
ect
::
lOl\
OOO\
l\
OOlO\
O
(
)
{
lOO\
lOlll\
l\
OO\
l
=
lOO\
ll\
OlOOlll
;
lOO\
lOl\
l\
llO\
ll\

=
lO\
Oll\
OlOlOOO
;
}
voi\
d
Dyn\
amic\
Obje\
ct
::
lOlO\
OOlOOlO\
l
(
flo\
a\
t
lOOlllO\
O\
llOl
,
float\

lOlOOO\
lOOll\
O\

)
{
lOOlllOlOllO
+=
(
lOOlOll\
l\
lOOl
*
lOO\
l\
llOOllOl
-
lOO\
lllOlOl\
l\
O\

)
*
lOlO\
OOlOOl\
lO
;
}
void
Dyn\
am\
icObjec\
t
::
lOlOOOl\
O\
Ol\
ll\

(
)
{
TA_ASSERT\

(
lO\
OllO\
l\
llOlO\

)
;
{
Joint\
Iterator
lOl\
OOl\
OOlO
=
lOOllOl\
lOl\
l\
l
.
lOlOOO\
Ol\
OO
(
)
;
for\

(
;
!
lOlOO\
l\
OOlO\

.
AtEnd
(
)
;
++
lOlOOlOOlO
)
{
PhysicsJoint
*
lOlllOOlOO\
O
=
&
*
lOl\
OOlOOl\
O
;
TA_\
ASSERT
(
lO\
lllO\
OlOOO
->
GetObjectA
(
)
==
this
)
;
if\

(
lOlllOOl\
OOO
->
Get\
Ob\
jec\
tB
(
)
)
{
if
(
!
lO\
l\
llOOlOO\
O
->
GetObject\
B
(
)
->
IsI\
nMovingLis\
t
(
)
&&
lOl\
ll\
OOlO\
O\
O\

->
GetO\
bjec\
tB
(
)
->
Add\
edTo\
P\
hysi\
cs
(
)
)
{
lOOllO\
lllOlO
->
GetP\
h\
ys\
ic\
s
(
)
.
Set\
Dynami\
cObj\
e\
ctIsMov\
ing\

(
lO\
ll\
lOOlOOO
->
Ge\
tObje\
ctB
(
)
)
;
}
}
}
}
{
List
<
Phys\
icsJoi\
nt
*
>
::
Iter\
ato\
r
lOlO\
O\
lOOlO
=
lO\
O\
llOll\
lOOO
.
lO\
lOOOOlOO\

(
)
;
for
(
;
!
lOl\
OOlOOl\
O
.
AtEn\
d
(
)
;
++
lOlOOlOOlO
)
{
Phy\
si\
cs\
J\
o\
int
*
&
lOlll\
OOlOOO\

=
*
lOl\
OOlO\
OlO\

;
TA\
_AS\
S\
ERT
(
lOlllOOlO\
OO\

->
Ge\
tO\
bject\
B
(
)
==
th\
i\
s
)
;
if
(
!
lO\
lllOO\
l\
OOO
->
Ge\
tObj\
ect\
A
(
)
->
IsI\
nMov\
ingList\

(
)
&&
lOl\
llO\
OlO\
O\
O\

->
GetOb\
j\
ectA
(
)
->
Added\
T\
oPh\
ys\
ic\
s\

(
)
)
{
lO\
Ol\
lO\
ll\
lO\
lO\

->
Ge\
tPh\
ys\
ics\

(
)
.
Se\
t\
D\
yna\
mi\
cObje\
ct\
IsMovin\
g
(
lOll\
lOOl\
O\
O\
O
->
Ge\
tObj\
ectA
(
)
)
;
}
}
}
}
voi\
d
Dyna\
mic\
Ob\
j\
ect\

::
lOl\
OOO\
lOlOOO
(
)
{
}
voi\
d\

Dyna\
m\
icOb\
jec\
t
::
lOlOOOlOlOOl
(
Dynami\
cObject
*
llOOlOOlOO\
l
)
{
floa\
t\

lOl\
OOOl\
OOlO
=
(
GetCenterOf\
M\
as\
s
(
)
-
llOO\
lO\
O\
l\
OOl
->
GetC\
enterOfMass
(
)
)
.
Dot\

(
lO\
OllO\
ll\
l\
O\
l\
O
->
GetPhy\
sics
(
)
.
GetGr\
avity
(
)
)
;
fl\
o\
at
llO\
l\
OlOl\
llO
;
llOlOl\
Oll\
lO\

=
0.05f
;
float
lOl\
OO\
OlOlOl\
O\

=
lOOllOOl\
lOO\
l
*
llO\
lOlOlllO
;
ll\
OOl\
OOlO\
Ol\

->
lOOllOOllOOl
=
Max
(
llOOlO\
OlOO\
l
->
lO\
OllO\
Ol\
lO\
Ol
,
lO\
lOOO\
l\
OlOlO\

)
;
}
vo\
id
Dyn\
a\
m\
icO\
bj\
e\
ct
::
lOlOOOlOlO\
ll
(
fl\
oa\
t
lOlOOOlOl\
lOO\

,
float
lOlOOOl\
OllOl
)
{
flo\
at
lOO\
OOOlllO
=
Ge\
t\
LinearV\
el\
ocit\
y\

(
)
.
Get\
M\
agni\
tude
(
)
+
Ge\
tAn\
gul\
arV\
el\
oc\
it\
y
(
)
.
GetMagni\
t\
u\
de
(
)
;
lOOOO\
O\
l\
l\
l\
O\

*=
50.0f
*
GetMas\
s
(
)
;
if
(
lOOOOOlllO
>
lOOllOOllO\
Ol
)
lOOl\
lOOllO\
O\
l\

+=
(
lOOOO\
OlllO
-
lOO\
llOO\
l\
lOOl\

)
*
lOl\
OOOlOllOO
;
else
lOOl\
lOOllOOl
+=
(
lOOOOO\
lllO
-
lO\
Oll\
OOllOOl\

)
*
lOlOOOlO\
l\
lOl
;
}
void
Dyn\
a\
mi\
cO\
bject
::
lOlOOOlO\
lllO\

(
)
{
TA\
_ASSER\
T
(
lOOll\
Ol\
llO\
ll
==
0
)
;
if
(
!
lOOllOll\
l\
Oll
)
{
lOOOllllOO
(
lO\
OllOll\
lOll
,
u8
,
lOlOOO\
lOll\
ll
)
;
}
}
void\

Dyna\
micO\
bject
::
lOl\
O\
OOl\
l\
O\
OO\
O
(
)
{
TA\
_\
ASSERT\

(
lO\
OllOll\
lO\
ll
)
;
if
(
lO\
O\
l\
lOlllO\
ll
)
{
lOlOOOll\
lO
(
lOOl\
lOlllOl\
l
,
u8
)
;
lOOllO\
lllOll
=
0
;
}
}
vo\
id
Dyn\
amic\
O\
bje\
ct\

::
lOOl\
lOll\
ll\
ll
(
)
{
fo\
r
(
lOl\
O\
OOO\
O\
l\
OOO
*
lOlO\
OOOOlOOl
=
lOO\
llOl\
lOOlO
;
lOlO\
OO\
O\
OlOOl
;
lO\
lOO\
OOOlOO\
l\

=
lOlOOOO\
OlO\
Ol
->
llOOOOlllll
)
{
lOlOOO\
OOO\
lOl
*
lO\
lO\
OO\
O\
O\
lOl\
O
=
lOlO\
OOOOlOOl\

->
lO\
lOOOOO\
lO\
l\
O
;
lOlO\
O\
OOOlO\
lO\

->
lOlO\
llOO\
Ol
|=
lO\
l\
OOO\
OOOlOl
::
lOl\
O\
OOl\
lO\
O\
Ol
;
}
}
bo\
ol\

Dy\
na\
m\
i\
cObj\
ect
::
IsAll\
owe\
dToC\
ol\
l\
ideWith
(
const\

Dyn\
amic\
O\
bje\
c\
t
&
lOl\
OO\
Ol\
lO\
OlO\

)
cons\
t
{
if
(
lO\
OllO\
lOllOO
!=
lO\
l\
OOOl\
lO\
OlO\

.
lOOllO\
lOllOO
)
re\
turn
true\

;
if\

(
lOOllOlO\
lllO
&
lOlOOOl\
lOOlO
.
lO\
Oll\
O\
lOllO\
l
)
ret\
urn\

false
;
else\

re\
t\
ur\
n
tr\
u\
e
;
}
void
Dyna\
mi\
c\
Object
::
SetU\
serGro\
upItemId
(
in\
t\

lOlOO\
OllOOll
)
{
lO\
O\
OOO\
Ol\
lO\

(
lO\
lO\
O\
Oll\
O\
O\
ll
>=
0
,
"DynamicObject::SetUserGroupItemId. Invalid value for nUserGroupItemId.")
;
lOOOOOOll\
O
(
lO\
lO\
O\
OllOOll\

<
32
,
"DynamicObject::SetUserGroupItemId. Invalid value for nUserGroupItemId.")
;
lOOllO\
lO\
l\
lO\
l
=
1
<<
lO\
lOOOllOOll
;
}
void\

Dynami\
cO\
bj\
ect
::
Di\
s\
allo\
wC\
ollisio\
nWit\
hU\
serGrou\
pItemId
(
in\
t
lOlOO\
O\
l\
lOOll\

)
{
lOO\
O\
OOO\
l\
lO
(
lOl\
OOO\
llOOll\

>=
0
,
"DynamicObject::SetUserGroupItemId. Invalid value for nUserGroupItemId.")
;
lOO\
O\
OO\
OllO
(
lO\
lOO\
OllOOll
<
32
,
"DynamicObject::SetUserGroupItemId. Invalid value for nUserGroupItemId.")
;
lOOllOlOlllO\

|=
1
<<
lOlOOO\
llOOll
;
}
void
Dyna\
m\
ic\
Ob\
je\
c\
t
::
Al\
lowCo\
l\
l\
isionWi\
thUserG\
ro\
u\
p\
It\
emI\
d
(
int
lOlOO\
O\
l\
lOO\
l\
l
)
{
lO\
OOOO\
O\
ll\
O
(
lOlOO\
OllO\
O\
l\
l\

>=
0
,
"DynamicObject::SetUserGroupItemId. Invalid value for nUserGroupItemId.")
;
lO\
OOOOO\
llO\

(
lOl\
OOOl\
lOOll\

<
32
,
"DynamicObject::SetUserGroupItemId. Invalid value for nUserGroupItemId.")
;
lOOllO\
lOl\
llO
&=
~
(
1
<<
lOlOOOll\
OOll
)
;
}
int\

Dyn\
ami\
cObject
::
Cr\
eateUs\
erGro\
up
(
)
{
stat\
ic
in\
t\

lO\
lOOO\
l\
l\
Ol\
OO\

=
0
;
ret\
urn
++
lO\
lO\
OOll\
O\
lO\
O
;
}
Dy\
namicO\
bje\
ct
*
TAC\
_CAL\
L
Dyna\
m\
i\
cOb\
j\
e\
ct
::
Cre\
a\
teN\
e\
w
(
)
{
Dyn\
amicObject
*
lOl\
OllOO\
l\
ll
;
lOOO\
O\
Ol\
lO\
O\
O
(
lOlO\
llOOll\
l
,
Dyn\
amicObject
)
;
return
lOlOl\
lO\
Olll
;
}
Dyn\
ami\
cOb\
ject
::
Dyn\
amicObj\
ect\

(
)
:
Phys\
icsOb\
j\
ect
(
)
,
Spac\
eDivisionOb\
ject
(
)
{
lOO\
llOlllOlO\

=
0
;
lOlOl\
OlOOlO
=
0.0f
;
lOO\
lOl\
l\
ll\
OlO
=
0.0f
;
lOOll\
OOl\
OllO\

.
Set\
ToIdentity
(
)
;
lOOllO\
OlOl\
ll\

.
SetToIdentity
(
)
;
lOO\
llOOllOll
.
Se\
t\
To\
Identity
(
)
;
lOOllOOll\
lO\
O
.
Set\
T\
oId\
en\
tity
(
)
;
lO\
OllOOlll\
Ol
=
1.0f
;
lO\
OllOOlll\
lO
=
-
1.0f
;
lOO\
lllOlOO\
ll
=
1.0f
;
lOO\
llO\
Ol\
lll\
l
=
0.0f
;
lOOllOlOOOOO
=
1.0f
;
lOOllOlO\
OO\
Ol
=
0
;
lllO\
lOl\
l\
lO
=
0
;
lO\
OllO\
lOOO\
l\
O
=
0
;
lO\
Ol\
l\
Ol\
OO\
Oll\

.
Clea\
r
(
)
;
lOO\
lO\
lllOOll\

.
Cle\
ar
(
)
;
lO\
OllOlOOlO\
O
.
Cl\
ear\

(
)
;
lO\
O\
llO\
lO\
OlO\
l
.
Clea\
r
(
)
;
lOOllOlOOllO
.
Clear
(
)
;
lOO\
llOlll\
lOO\

.
Clear
(
)
;
lOO\
l\
lO\
lll\
lOl\

.
Cl\
e\
ar
(
)
;
lOOll\
Olll\
l\
lO
.
Cl\
ear
(
)
;
lOOlOllll\
OOl
.
Cle\
ar\

(
)
;
lO\
O\
lOl\
lllOl\
l
.
Clear
(
)
;
lOOl\
l\
Ol\
OO\
lll
.
Clear
(
)
;
lOOllOlO\
lOOO
.
Cle\
a\
r
(
)
;
lO\
OllOlO\
l\
OlO\

=
0
;
lOOl\
lOlOlOll
.
Initialise
(
k_v3Zero
,
k_v3\
Z\
er\
o
)
;
lO\
O\
l\
l\
Ol\
Ol\
lOO
=
-
1
;
lOO\
llO\
lO\
l\
lOl
=
0
;
lO\
Ol\
lOlO\
ll\
lO
=
0
;
lOOll\
OOlOl\
OO
=
0
;
lOOllOl\
O\
ll\
ll\

=
0
;
lOO\
l\
lOllOO\
OO
=
0
;
lO\
Oll\
OllOOOl
=
0
;
lOOllOl\
lOO\
lO
=
0
;
lOOllO\
ll\
OOl\
l\

=
0
;
lO\
O\
llOllOl\
O\
O\

=
0
;
lOOllOll\
OlO\
l
=
-
1
;
lOO\
l\
l\
OlllO\
ll
=
0
;
}
Dy\
na\
m\
icObject
::
~
Dyn\
am\
icO\
bj\
ect
(
)
{
Final\
i\
s\
e
(
)
;
}
voi\
d
Dyn\
am\
icOb\
jec\
t\

::
Init\
i\
aliseCommon
(
)
{
TA_A\
SSE\
RT
(
lOO\
ll\
Ol\
ll\
OlO
==
0
)
;
lOl\
OOO\
llO\
l\
Ol
=
lO\
Oll\
OOlOOlO
++
;
TA\
_\
ASSER\
T\

(
(
s32
)
lO\
l\
OOOllOl\
O\
l
>
0
)
;
TA_\
AS\
SE\
R\
T
(
lOOllOOlllll\

==
0.0f
)
;
TA_A\
SSERT
(
lO\
Ol\
lOlOOO\
OO
=
1.0f
)
;
TA_\
ASSE\
RT
(
lOO\
llO\
l\
O\
OOO\
l\

==
0
)
;
TA\
_\
ASSE\
RT
(
lllOlO\
lllO
==
0
)
;
lllOl\
OlllO
|=
lOl\
OOOll\
Ol\
lO
;
lOOllOlOll\
O\
O
=
-
1
;
lOOllOlOl\
l\
Ol
=
0
;
lOOl\
lOlOl\
llO\

=
0
;
lOOllOOlllOl
=
1.0f
;
lO\
OllO\
Olll\
lO
=
-
1.0f
;
lOO\
l\
llOl\
OOl\
l
=
1.0f
;
lO\
OllOlO\
lOOl
=
0
;
lOOllOll\
OOl\
O\

=
0
;
lOO\
llO\
llO\
Oll
=
0
;
lOOl\
l\
Oll\
Ol\
O\
O
=
0
;
lOOl\
lO\
l\
lOl\
Ol
=
-
1
;
lOOllOOllO\
OO\

=
1.0f
;
lOO\
llOO\
llO\
O\
l
=
0.0f
;
TA\
_A\
S\
SE\
RT
(
lOO\
llOlllO\
ll
==
0
)
;
}
void
DynamicObj\
ect
::
Clea\
rLin\
e\
I\
n\
tersections
(
)
{
fo\
r\

(
int
lllOOOOOlO\

=
0
;
lllOOOOO\
l\
O\

<
lO\
Ol\
lOll\
OllO\

.
lOOOlllOOl
(
)
;
lll\
O\
OOOOlO
++
)
{
Line\
Interse\
ction
&
lOOlll\
l\
OlllO
=
lOO\
llO\
llOllO\

[
lllO\
O\
OOO\
lO\

]
;
lOOllllOlllO
.
lOllOOlO\
OO\
l
=
-
1.0f
;
if
(
lOO\
lll\
l\
O\
l\
ll\
O\

.
lOll\
lOOOllO
)
{
lO\
Oll\
llOll\
lO\

.
lOlll\
O\
O\
Ol\
lO
->
Release
(
)
;
lOOl\
l\
llOll\
l\
O
.
lOll\
lO\
OOl\
l\
O\

=
0
;
}
if
(
lO\
Oll\
llOlllO
.
lOlOllOO\
OOl\

)
{
lOOl\
lllOlllO
.
lOl\
OllO\
OOOl\

->
Re\
lea\
se\

(
)
;
lOOllllO\
l\
l\
lO
.
lOl\
OllOO\
OOl
=
0
;
}
}
}
}
