//---------------------------------------------------------------------------------
// File Name: zpta024.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#define TA_PHYSICS_INTERNAL
#define lOllOllOOOO
#include "../Physics/zpta011.h"
#ifndef TA_RANDFUNC_H
#include "../Common/RandFunc.h"
#endif //
#ifndef lOOOOlOlOl
#include "../Common/zcta006.h"
#endif //
#ifndef TA_STACKALLOC_H
#include "../Common/StackAlloc.h"
#endif //
#ifndef llllOOOOlOl
#include "../Physics/zpta010.h"
#endif //
#ifndef llOOlOlllll
#include "../Physics/zpta001.h"
#endif //
namespace\

TA
{
co\
nst
flo\
a\
t
llOOlOlOlll\
O
=
0.05f
;
con\
s\
t
float
llO\
OlOlO\
llll
=
llO\
OlO\
lOlllO
*
ll\
OO\
l\
O\
l\
OlllO\

;
const
float
llOOlOllOOO\
O
=
0.1f
;
ty\
p\
ed\
e\
f
flo\
at
llOOlOllOO\
O\
l\

;
typ\
e\
de\
f\

lOl\
OO\
OO\
O\
OlOl
*
llOO\
lOllO\
Ol\
O\

;
#ifdef TA_MSVC
#pragma pack(push, 4)
st\
ruct
ll\
O\
OlOll\
OOll
{
llOOlOll\
OOO\
l\

lOOOlOOllO
;
llO\
Ol\
O\
l\
lO\
Ol\
O
lOOlllOOOl
;
}
;
#pragma pack(pop)
#else
struct
ll\
O\
O\
l\
Oll\
O\
Oll
{
ll\
OO\
lOl\
lOOO\
l\

lOOO\
l\
OOl\
lO
;
llOOlO\
llOOlO
lOOll\
lOOOl
;
}
;
#endif
vo\
id
lOllO\
lOlllO\

(
Co\
llisi\
o\
n
*
lOllOl\
O\
llll\

,
Col\
l\
i\
si\
on
*
lOOO\
OOO\
lll\
l
)
{
TA_ASSER\
T
(
lO\
OO\
O\
OOl\
lll
->
lOOO\
O\
OOllll
==
0
)
;
lOOO\
OO\
Ollll\

->
lO\
OOO\
OOllll
=
lOllO\
lOllll
->
lOOO\
OOO\
l\
ll\
l
;
lOl\
lOlOll\
ll
->
lO\
OOOOOllll
=
lOOOOOOlll\
l
;
}
lOlOl\
llOlllO\

::
lOlOlll\
OlllO
(
)
{
lOOll\
OlllOlO\

=
0
;
llOOlO\
l\
lOlOO
=
0
;
ll\
OO\
lO\
llOlO\
l
=
0
;
lOllOlO\
ll\
OOl
=
0
;
llOO\
lO\
llO\
llO\

=
false
;
llO\
OlOllOll\
l\

=
fal\
se
;
}
lO\
lOl\
l\
l\
Olll\
O
::
~
lO\
lOll\
l\
OlllO
(
)
{
Finalise
(
)
;
}
vo\
id\

lO\
lOl\
llOl\
llO\

::
lOl\
lllOlOl\
lO
(
bo\
ol\

ll\
OOlO\
l\
llOOO\

,
int
lO\
llOllOOlll
)
{
TA\
_A\
SSERT
(
lO\
Oll\
O\
lllO\
lO
)
;
Ph\
y\
sics
&
lOlOl\
Ol\
OOlOl
=
lO\
OllO\
l\
l\
l\
OlO\

->
GetP\
hys\
ics
(
)
;
const
int
llO\
OlOlllO\
Ol\

=
lOOllO\
lllO\
lO
->
lOlOllllOOll
>
lOOll\
OlllOlO\

->
lO\
lOllll\
OO\
l\
O\

?
lOOllO\
l\
llOlO
->
lOl\
Ol\
lllOO\
ll
:
lO\
Oll\
O\
lll\
OlO
->
lOl\
O\
l\
l\
ll\
OOlO
;
lOOll\
lOO\
OO\
l
(
llOO\
lOl\
lOOll
,
lOlllOOOOO\
lO
,
llO\
O\
l\
Ol\
l\
lOOl
)
;
Vec3
llOO\
Oll\
O\
OOOO
=
lOlOlOlOOlO\
l
.
GetGr\
avity
(
)
;
float
ll\
OO\
OllOOOO\
l\

=
lO\
lOlOl\
O\
O\
lOl\

.
GetGrav\
ity
(
)
.
GetMagnit\
ud\
e
(
)
;
llOOOllOOOO\
l
*=
0.2f
;
llOOOll\
OOOOO\

.
x
+=
Ra\
ndFunc\

::
Ta\
Ran\
dBet\
weenPosNeg
(
llOO\
OllOOO\
O\
l
)
;
llOOO\
llO\
O\
O\
O\
O
.
y
+=
Rand\
Func\

::
TaRa\
n\
dBet\
ween\
PosNeg
(
llOO\
OllOOOO\
l
)
;
llOO\
Ol\
lO\
OO\
OO
.
z
+=
Ran\
d\
Fun\
c
::
Ta\
Ra\
nd\
B\
etween\
P\
osNeg
(
llO\
OOllOOOOl\

)
;
if
(
!
lOl\
lO\
l\
lOllOO
(
)
)
{
in\
t
lOlllOO\
OOOOl\

=
0
;
lO\
l\
Oll\
lOO\
O\

<
lOlOOOOOOl\
Ol
>
::
lOlOlll\
OOl
::
Iter\
ator
lOllll\
OO\
Ol\
ll\

=
llOOlOlllOl\
O
.
lOlOOOO\
l\
O\
O
(
)
;
while\

(
!
lOllllO\
OOlll
.
AtEnd
(
)
)
{
lO\
lOOOOOOlO\
l\

&
lOlOO\
OOllOl\
O
=
*
lOl\
lllOOOl\
ll\

;
++
lOl\
lll\
OOOll\
l
;
TA\
_ASS\
ERT
(
lOlll\
OO\
OOO\
O\
l
<
lOOl\
lOll\
lOlO
->
lOlOlll\
lOO\
ll
)
;
llO\
OlOll\
OOll
&
lOOlOOlll\
O\
O\

=
lOlllO\
OO\
OO\
l\
O
[
lOlllOOO\
OOOl
++
]
;
lOOlO\
Oll\
l\
OO
.
lOO\
l\
l\
lOOOl
=
&
lOl\
OOOOllOlO
;
lOOl\
OO\
l\
l\
lOO
.
lO\
OOlOOllO
=
0.0f
;
in\
t
llOOlOO\
lOOO\
O
=
0
;
lOl\
Ol\
l\
lOO\
O
<
Co\
llis\
ion
>
::
lOl\
OlllO\
Ol
::
It\
er\
at\
or
lOlOlllOOOO\
O
=
lOlOOO\
OllOlO
.
lO\
lO\
lllO\
OOll
.
lOlOOOOlOO
(
)
;
for
(
;
!
lOlOlll\
OOOOO\

.
AtE\
nd\

(
)
;
++
lOlOlllOOOOO
)
{
Col\
l\
isi\
on
&
llOl\
l\
llOl\
Ol\

=
*
lOlOlllO\
OO\
OO
;
lO\
OlOOlllOO
.
lO\
OO\
lOO\
llO
-=
llO\
OOl\
lOOOOO\

.
Dot\

(
llOlll\
lOlOl\

.
lO\
OOOlllll
)
;
llOOlO\
OlO\
OOO
++
;
}
if
(
llO\
OlOOlOOO\
O
)
lOOlOOll\
lOO
.
lOOOlO\
Oll\
O
/=
(
flo\
a\
t\

)
ll\
O\
OlOOlOOOO
;
llOOl\
OlllOlO\

.
lOOl\
l\
lllll
(
&
lOlO\
OO\
Ol\
lOl\
O
)
;
}
lOOOlllllO
<
llOOlO\
ll\
O\
O\
ll\

>
::
lO\
O\
O\
llllll
(
lOlll\
OO\
OOOl\
O
,
lOlll\
O\
OOOOO\
l
)
;
for
(
int
lOO\
OllOOOl\

=
lO\
lllOOO\
OOOl\

-
1
;
lOOO\
l\
lOO\
O\
l
>=
0
;
lOOOll\
O\
O\
Ol
--
)
{
llOOlOll\
OOll
&
lO\
OlOOll\
lOO
=
lOll\
lOO\
OOOlO
[
lOOO\
llOO\
Ol
]
;
TA\
_\
A\
SSERT
(
(
lO\
O\
lOOl\
l\
lO\
O
.
lOO\
lll\
OOOl
->
lOlOl\
lO\
OOl
&
lO\
lOOOOO\
Ol\
Ol
::
lOlOl\
ll\
Olll\
l\

)
==
0
)
;
ll\
OOl\
OlllO\
lO\

.
lOlOlOOOOl
(
lOOl\
OO\
lllOO\

.
lO\
Olll\
O\
OOl
)
;
}
}
if
(
!
lOll\
Ol\
lO\
ll\
OO
(
)
||
lOll\
O\
ll\
O\
Ol\
l\
l
!=
0
)
{
int
lOlllO\
OOOO\
Ol
=
0
;
ll\
OOOOO\
O\
llOO\

llO\
OlOlll\
Oll
=
llO\
O\
lOllllOO
.
lO\
lOOOOlOO
(
)
;
while\

(
!
llOO\
lO\
l\
l\
lO\
ll
.
At\
End
(
)
)
{
Dy\
namicObj\
ect
*
&
lO\
l\
llOOOl\
lO
=
*
llOOlOlll\
Oll\

;
++
llOOlOlllO\
l\
l\

;
if
(
lOllO\
llOllOO
(
)
&&
lO\
lllOO\
O\
llO\

->
Ge\
t\
Joi\
n\
t\
It\
e\
rator
(
)
.
AtEn\
d
(
)
&&
lOl\
l\
lO\
OOllO
->
lOlOOll\
OO\
l\
l\
O
(
)
.
AtEnd
(
)
)
con\
tinue
;
TA_A\
SSERT\

(
lOlllOO\
OOO\
Ol
<
lO\
OllO\
lllOl\
O
->
lOlOllllOOll
)
;
llOOlOllOOl\
l
&
lO\
OlOOll\
lOO
=
lO\
l\
ll\
OO\
OOOlO
[
lOlll\
O\
OOOO\
Ol\

++
]
;
lO\
Ol\
OOll\
lOO
.
lOOl\
llOOOl
=
(
lOl\
O\
OOOOOl\
Ol
*
)
&
lOlll\
O\
OOl\
lO
;
int
lOlO\
lOO\
OlOOO
=
lOlllOOOllO
->
GetID\

(
)
;
lOOlOOll\
lO\
O
.
lOO\
OlO\
OllO
=
(
flo\
at
)
lOlOlOO\
OlO\
OO
;
llOOlOl\
ll\
lOO
.
lO\
Oll\
lllll
(
&
lOll\
lOOOll\
O
)
;
}
lOO\
OlllllO
<
llOOlOllOOll\

>
::
lOOOllll\
ll
(
lOlllOO\
OO\
OlO
,
lOlllOO\
OO\
OOl
)
;
for\

(
in\
t
lOO\
O\
l\
lOOO\
l\

=
lOll\
lOOOOO\
Ol
-
1
;
lOOO\
llOOOl
>=
0
;
lO\
O\
O\
l\
lOO\
Ol
--
)
{
ll\
OOlOl\
lO\
O\
l\
l
&
lO\
OlOOlllOO
=
lOlllOOOOO\
l\
O
[
lOOOl\
l\
OOOl
]
;
llOOl\
OllllOO\

.
lOlOlO\
O\
OOl
(
(
Dynami\
c\
Objec\
t
*
*
)
lOOlO\
OlllOO
.
lO\
Olll\
OOOl
)
;
}
}
#ifdef llOOlOllllOl
llO\
OlOll\
O\
O\
ll
lOl\
ll\
OO\
OOOlO
[
lOOl\
l\
OlllOlO
->
lOlOllllOO\
Ol
]
;
int\

lOll\
l\
OO\
OOOOl
=
0
;
for
(
Iter\
ator
lOlO\
O\
lOOl\
O
=
lOlO\
OOO\
lOO
(
)
;
!
lOlOOlOOlO
.
AtEn\
d
(
)
;
)
{
TA_AS\
SERT
(
lOlllOOO\
O\
OOl
<
lO\
OllO\
lllOlO\

->
lO\
lOl\
lllOOOl
)
;
llOOl\
Oll\
OOll
&
lOOlOOlllOO
=
lO\
l\
llOO\
O\
OOlO
[
lOlllOO\
OO\
OOl
++
]
;
lOOlOOlllO\
O
.
ll\
Ol\
lOlO\
lOl
=
&
*
lOlOOlOOlO\

;
++
lOl\
OO\
l\
OOlO
;
lOOlOOll\
lOO
.
lOOllOO\
lllO
=
(
u64\

)
(
lOOlOOlllOO
.
ll\
Ol\
lOl\
OlO\
l
->
GetObj\
ectA
(
)
->
GetID
(
)
)
<<
32
;
lOOlOOlllOO
.
lOOllOO\
l\
l\
l\
O
+=
(
u64
)
lOOlOOll\
l\
OO\

.
llOllOlOlO\
l
->
GetOb\
jec\
tB
(
)
->
GetI\
D
(
)
;
lO\
lOlllOOO
<
Coll\
isi\
on
>
::
lOlO\
l\
llO\
Ol
::
lOOl\
O\
O\
Ol\
lOO
(
lOOlOOll\
l\
O\
O
.
ll\
OllOl\
OlOl\

)
;
}
if
(
ll\
OOlOl\
llO\
OO
)
{
Dy\
nam\
i\
cOb\
ject\

*
ll\
OO\
lO\
llll\
lO
=
0
;
Dynam\
icOb\
ject
*
llOOlOllllll\

=
0
;
Iterator
ll\
O\
O\
llOOOO\
OO
;
Iterator
llO\
O\
llOOOOOl
;
ll\
OOl\
lOOOO\
lO
::
lOOOllllll
(
lOl\
llOO\
OOOlO
,
lOll\
lOO\
OOOOl
)
;
Vec3
llOOllOOOOl\
l
=
k_v3\
Un\
itY\

;
for
(
in\
t\

lO\
OOllOO\
Ol
=
lOll\
lO\
OOOOOl\

-
1
;
lOOOll\
O\
OOl
>=
0
;
lOO\
Oll\
OOOl
--
)
{
llOOlOllOOll
&
lO\
O\
lOO\
lllO\
O\

=
lOlllOOOO\
OlO\

[
lOO\
OllO\
OOl
]
;
if
(
ll\
OOlOlllllO
!=
lO\
Ol\
O\
Ol\
ll\
OO\

.
llOll\
O\
lO\
lOl
->
lOllO\
OO\
lOll\

||
llOO\
lOl\
l\
ll\
ll\

!=
lOOlOOl\
ll\
OO
.
llO\
llOlO\
lO\
l\

->
GetO\
bjec\
tB\

(
)
)
{
llOOlOlllllO
=
lOOl\
OOlllO\
O
.
llOl\
lOlOlOl
->
lOl\
lO\
OOl\
Oll
;
llOOlOlll\
l\
ll
=
lOOlO\
O\
lllOO
.
ll\
OllO\
lOlO\
l
->
Get\
Obje\
ctB
(
)
;
ll\
OOl\
lOOOlO\
O\

.
lO\
lOlOOOOl
(
lOOlOOlllOO
.
ll\
OllO\
lOl\
O\
l
)
;
llOO\
l\
l\
OOO\
OOl\

=
llOO\
ll\
OOOOOO\

=
llOOllO\
OO\
lOO
.
lOlOO\
OOl\
OO
(
)
;
ll\
OO\
l\
lOO\
O\
Oll
.
Clear
(
)
;
for
(
in\
t
lOOlOOlO\
l\
O
=
lOOOl\
lOOOl
;
lOO\
lOO\
lOlO
>=
0
;
lO\
O\
lOO\
lOlO
--
)
{
llOOl\
OllOOll
&
llOOllO\
OOl\
O\
l
=
lOlllO\
O\
OOO\
lO
[
lOOlOOlOlO
]
;
if
(
ll\
OOllOOO\
lOl
.
llOll\
OlOlO\
l\

->
lOllO\
OOlOll\

!=
lOO\
lO\
Ol\
llOO
.
llO\
l\
lOlOl\
Ol\

->
lO\
ll\
OOOlOll
||
llOOl\
l\
O\
OO\
lO\
l
.
ll\
OllOl\
OlOl
->
GetO\
b\
ject\
B
(
)
!=
lOOlOO\
ll\
l\
OO\

.
llOll\
Ol\
OlO\
l
->
Get\
Ob\
jectB
(
)
)
bre\
a\
k
;
ll\
OOllOOOO\
ll
+=
llO\
OllO\
O\
Ol\
Ol\

.
llOl\
lOlOlOl\

->
lO\
O\
OlOOOO\
O
;
}
float
lOl\
l\
ll\
OOll
=
llO\
O\
llOOOO\
ll
.
Get\
M\
ag\
n\
it\
u\
de
(
)
;
if\

(
lO\
ll\
llOO\
ll\

>
0.0f
)
llOO\
l\
lOOO\
Oll
/=
lO\
ll\
llOO\
ll\

;
els\
e\

llOOl\
lOOOOll
=
k_\
v3Un\
i\
t\
Y
;
}
else
{
TA_AS\
SERT
(
lOOlO\
Oll\
lOO
.
ll\
Ol\
lOlOlOl
)
;
Col\
lision
&
llOlll\
lOlOl
=
*
lOOlOOll\
lO\
O
.
ll\
OllOlO\
lO\
l\

;
bool
llOOllO\
O\
O\
llO
=
tr\
u\
e
;
if
(
(
ll\
Olll\
lOlOl
.
lOl\
Oll\
OOO\
l
&
(
Co\
llisi\
on
::
FLAG_JOINT
||
Coll\
isio\
n
::
FLA\
G_J\
OINT_L\
IMIT
)
)
==
0
)
{
if
(
llOOll\
O\
OO\
Ol\
l
.
Do\
t
(
llOl\
l\
l\
l\
OlOl
.
lO\
O\
O\
lOOO\
OO\

)
<
-
0.01f
)
{
llOOllOOO\
llO
=
fals\
e\

;
}
els\
e
{
It\
erator
lO\
lOO\
lOO\
lO\

=
llOOllOO\
OOOl
;
for\

(
;
0
;
)
{
Co\
l\
l\
isio\
n
&
ll\
OOll\
OOOlll
=
*
lOl\
OOl\
O\
Ol\
O
;
if
(
(
llOOllOOOlll
.
lO\
l\
O\
llOOOl
&
(
Col\
lision
::
FLAG_JOI\
NT
||
Coll\
ision
::
FLAG_JO\
I\
N\
T_\
L\
IMI\
T
)
)
==
0
&&
(
llOl\
lllOlO\
l
.
lOOOOlll\
l\
l
-
llOOllOOO\
lll\

.
lOO\
O\
Olll\
ll
)
.
GetMagn\
itu\
deSq\
rd
(
)
<
ll\
OO\
lOlOllll\

&&
llOlll\
l\
Ol\
O\
l
.
lO\
OO\
lOO\
OO\
O
.
Dot
(
llOOll\
O\
OO\
lll
.
lOOOl\
OOOOO
)
>
1.0f
-
llO\
OlO\
l\
lOOOO
)
{
ll\
OOllOOOllO
=
fa\
lse
;
if
(
llOOl\
l\
O\
OOlll
.
ll\
lOllllOO
>
llOllllO\
l\
Ol
.
lllO\
llllO\
O
)
llOOll\
OOO\
ll\
l
.
ll\
lO\
ll\
llOO
=
llOllllOl\
Ol
.
lllO\
llllOO
;
if
(
llOOl\
l\
O\
O\
Olll
.
lOll\
OOlOOOl
<
llOll\
llOlO\
l
.
lOllOOl\
OOOl\

)
llO\
OllOOOlll
.
lOllOOlOO\
O\
l
=
ll\
Ol\
l\
llO\
lO\
l
.
lOllOOlOOOl
;
ll\
OOllO\
OO\
lll
.
lOl\
OllOOO\
l
|=
llOllll\
OlOl\

.
lO\
lOl\
lOOO\
l\

&
Coll\
ision\

::
FLAG\
_CO\
NSTRAI\
N_IN_B\
OTH_DIRECTIONS
;
}
if\

(
lOlOO\
lOOl\
O
==
llO\
Oll\
OOO\
O\
OO\

)
break\

;
++
lO\
l\
O\
OlOOlO
;
}
}
}
if
(
llOOllO\
OO\
llO
)
{
ll\
OOllOOOlOO
.
lOlOlOOO\
Ol
(
lO\
OlO\
Oll\
l\
OO
.
llO\
llOl\
OlOl\

)
;
ll\
OOllOOOOO\
l
=
llOOll\
OOOlOO
.
lOlO\
OOOl\
OO
(
)
;
}
else\

{
ll\
OOl\
OllOlOO\

--
;
llOOl\
lOO\
lOOO
->
llOOl\
lOO\
l\
OOl
(
lOO\
lOO\
ll\
lO\
O\

.
llO\
l\
lOlOl\
Ol
)
;
lOOl\
OOlllO\
O
.
llO\
llOl\
OlOl
=
0
;
}
}
}
}
el\
se\

{
llO\
O\
llOO\
O\
OlO
::
lOO\
Oll\
llll\

(
lOlll\
OOO\
OO\
lO\

,
lO\
lllOOOOO\
Ol
)
;
for\

(
int
lOOOllOOOl
=
lOlll\
OOOOO\
Ol
-
1
;
lOOOllOO\
Ol
>=
0
;
lOOO\
l\
lO\
OOl\

--
)
{
ll\
OO\
lO\
llO\
Oll\

&
lOOlOO\
lllOO
=
lO\
lllOOOOOlO
[
lO\
OOll\
O\
OOl
]
;
llOOllOOOlO\
O
.
lOlOlOOO\
Ol
(
lO\
OlOOlll\
OO\

.
ll\
Ol\
l\
O\
l\
OlO\
l\

)
;
}
}
#endif
}
vo\
id
lO\
lO\
lllO\
ll\
l\
O
::
llOOll\
O\
OlO\
l\
O
(
)
{
}
boo\
l
lO\
lO\
lllO\
l\
l\
l\
O
::
lO\
llO\
ll\
Oll\
OO\

(
)
{
if
(
!
llOO\
Ol\
O\
OOllO
(
)
)
{
if
(
lOll\
Olll\
Ol\
Ol
(
)
>
lOOllOlllO\
lO\

->
lO\
l\
Oll\
l\
l\
O\
l\
OO
)
return
true
;
if
(
lOl\
l\
Ollll\
OO\
O
(
)
>
lOO\
llOl\
llOlO
->
lOl\
Oll\
l\
l\
OlOl
)
ret\
urn
true\

;
ret\
ur\
n\

fals\
e
;
}
ret\
urn
tru\
e\

;
}
bo\
ol
lOlOl\
llOlllO
::
ll\
OOllOO\
lOll
(
const
lOlOOOO\
OO\
lOl
*
lO\
lOOO\
OOlOl\
O\

)
{
TA_ASS\
ERT
(
lOlO\
OOOO\
l\
OlO
)
;
ret\
urn
llOOlOl\
llO\
l\
O
.
lOOlOOO\
lO\
ll
(
lOlOOOOO\
lO\
lO
)
;
}
#ifdef _DEBUG
vo\
id
lOl\
O\
ll\
lOlllO
::
llO\
OllOOll\
OO
(
)
{
int
llO\
OlOO\
l\
O\
O\
OO
=
0
;
Iterato\
r
lOl\
O\
ll\
lOOOOO
=
lOlOll\
lO\
OOOO\

=
lOlOO\
O\
O\
lOO\

(
)
;
for
(
;
!
lOl\
Ol\
ll\
OO\
OOO
.
AtE\
n\
d
(
)
;
++
lOlOll\
lOOOOO\

)
{
Col\
lision\

*
llOll\
Ol\
Ol\
Ol
=
&
*
lO\
l\
OlllOO\
O\
OO\

;
for
(
;
ll\
O\
llOl\
Ol\
Ol\

;
llOl\
l\
OlOl\
Ol
=
llO\
llOlOl\
Ol
->
GetNext
(
)
)
{
llOOlOOlO\
OOO\

++
;
}
}
TA\
_ASSER\
T
(
llOO\
lOOlOOOO\

==
llOOlOllOlOO\

)
;
}
#endif //
vo\
id
lOl\
O\
l\
ll\
Ol\
ll\
O
::
Ini\
tialise
(
llllOll\
OlOO
*
lO\
l\
OOl\
lOOO\
Ol\

,
lOllOlOl\
lOlO
*
ll\
OOllO\
O\
lOOO\

)
{
TA_ASSERT\

(
lOlOOl\
lOOOO\
l\

)
;
lOO\
llO\
l\
llO\
lO
=
lOlO\
O\
l\
l\
OOOOl\

;
llOOl\
Oll\
Ol\
OO
=
0
;
llOOllOOllOl
.
Fi\
nalise
(
)
;
lOllO\
lO\
llOOl
=
ll\
OO\
llOOl\
O\
OO
;
llO\
O\
lOl\
lOllO
=
false
;
llOOlOllOlll
=
false\

;
}
void
lOl\
Ol\
llOll\
lO
::
Finalise\

(
)
{
lO\
O\
llOll\
l\
Ol\
O
=
0
;
TA\
_ASSER\
T
(
ll\
OO\
l\
OllllOO
.
lO\
O\
OlllOOl\

(
)
==
0
)
;
llOOl\
O\
llOl\
OO\

=
0
;
llOOlO\
ll\
llOO\

.
Finalise
(
)
;
llOOllOOllOl\

.
Fi\
nalise
(
)
;
}
inlin\
e
void
lOlOlllOlllO
::
lO\
l\
OOOOlOO\
Ol
(
lOlOOOOO\
OlO\
l
&
lO\
lO\
OOOllOlO\

)
{
TA_A\
S\
SERT\

(
(
lOl\
OO\
OOllO\
l\
O
.
lOl\
OllO\
OOl
&
lOlO\
OOOOOlOl
::
lOlOlllOlll\
l
)
==
0
)
;
ll\
OOl\
Olll\
OlO
.
lOlOlOOOOl\

(
&
lOlOOO\
OllO\
lO\

)
;
TA\
_A\
SS\
ERT
(
lO\
lOOOOl\
lO\
lO
.
lOl\
OOOOlOOO\
O
==
0
)
;
lOl\
O\
OOO\
l\
l\
OlO
.
lOl\
O\
OO\
O\
lOO\
OO
=
thi\
s
;
}
lOllOlOl\
lOl\
O
::
lOllOl\
O\
llOlO
(
)
{
lO\
Ol\
lOlllO\
lO
=
0
;
llOOll\
OOll\
lO
=
0
;
ll\
OO\
ll\
O\
Oll\
ll
=
0
;
llOOl\
lOlOOOO
=
0
;
}
lOllOlO\
llOl\
O
::
~
lOllOl\
Ol\
lO\
lO
(
)
{
Fi\
n\
alise
(
)
;
}
void
lOllOl\
O\
l\
lOlO
::
Initia\
l\
ise
(
llllOllOlOO
*
lOlOOl\
lOO\
OOl\

,
int
llOOll\
O\
l\
O\
O\
Ol
)
{
TA_\
ASSERT
(
lOlOOllO\
O\
OO\
l
)
;
lOO\
l\
lOl\
llOlO\

=
lOlOO\
llO\
OOOl
;
llOOllOlOOl\
O\

.
In\
itialise
(
lOO\
l\
lOl\
llOl\
O\

->
lOlOllllOO\
Ol
)
;
llO\
OllOlOO\
ll
.
Init\
i\
alis\
e
(
lO\
Ol\
l\
O\
ll\
l\
Ol\
O
->
lOlO\
ll\
llOOOl
)
;
llOOl\
lOlO\
lOO
.
In\
itia\
li\
se
(
lO\
O\
ll\
O\
lllOlO
->
lOlOllllO\
OOl
)
;
llOOl\
l\
OO\
lllO
=
ll\
OOll\
Ol\
OOOl
;
ll\
OOl\
l\
OlOlOl
.
Initi\
ali\
se
(
lOOllOl\
llOl\
O\

->
lOlO\
ll\
llOOl\
l
)
;
ll\
OO\
llO\
lOOO\
O
=
0
;
ll\
OO\
llOOl\
lll\

=
0
;
}
void
lOllO\
lOl\
lO\
l\
O
::
Fin\
a\
lise\

(
)
{
Clear
(
)
;
ll\
OOllOl\
OOlO
.
Fina\
li\
se
(
)
;
llOOl\
l\
OlOO\
ll\

.
Finali\
se
(
)
;
llOO\
llO\
lO\
lOO
.
Fi\
nali\
se
(
)
;
llOOllOlOllO
.
Finali\
se
(
)
;
llOOl\
lOO\
lll\
O
=
0
;
llO\
OllOO\
llll
=
0
;
}
Col\
li\
sion
*
lO\
l\
lOlOllO\
lO
::
ll\
OOO\
OlllOll
(
lOlOOOOO\
OlOl
&
lOlOO\
OOllO\
lO
,
co\
nst
Col\
l\
i\
sio\
n
&
llOll\
llO\
lOl
)
{
TA\
_AS\
S\
ER\
T
(
(
lOlOO\
O\
OllO\
lO
.
lOlOOOO\
Ol\
Ol\
l
==
ll\
O\
llllOlO\
l\

.
GetO\
bje\
c\
tA
(
)
&&
lO\
lOO\
OOll\
OlO
.
lOlOOOOOll\
OO
==
llO\
llllOlOl
.
Get\
Ob\
j\
ect\
B\

(
)
)
||
(
lO\
l\
OOO\
Oll\
OlO
.
lOlO\
OOOOlO\
ll\

==
llOllllOlO\
l
.
Ge\
t\
Obj\
e\
ctB
(
)
&&
lOl\
O\
OO\
Ol\
l\
Ol\
O
.
lOlO\
OOO\
Ol\
l\
O\
O
==
ll\
Ol\
l\
llO\
lO\
l\

.
Ge\
tOb\
jec\
tA
(
)
)
)
;
Col\
lision\

*
ll\
OOl\
l\
Ol\
O\
ll\
l
=
ll\
OO\
llOl\
O\
OlO
.
Alloc
(
)
;
if
(
!
ll\
OOl\
lOlO\
l\
l\
l
)
re\
tu\
r\
n
0
;
llOOllOOllll\

++
;
*
ll\
OO\
ll\
O\
lOlll
=
llOllllOlOl
;
ll\
OO\
l\
lOlOll\
l\

->
lOllOlOOlOl
(
0
)
;
lOlOOO\
OllOlO\

.
lO\
lOl\
llOO\
Oll
.
lO\
lOl\
O\
OOO\
l
(
llOO\
ll\
OlO\
lll\

)
;
retu\
rn
llO\
OllOl\
Olll
;
}
voi\
d\

lOllO\
lO\
llO\
lO
::
ll\
OOl\
OOll\
Oll
(
Co\
llisi\
on
&
llO\
O\
ll\
Ol\
l\
O\
O\
O
,
con\
st
Colli\
s\
ion
&
ll\
Ol\
ll\
lOl\
Ol
)
{
Collisi\
on
*
llOOl\
lOl\
Oll\
l
=
llOOll\
Ol\
OOlO\

.
Alloc\

(
)
;
if\

(
!
llOOllOl\
Olll
)
return
;
ll\
OOllO\
O\
llll\

++
;
*
llOO\
llO\
lOlll
=
llO\
llllOlO\
l\

;
llOOll\
OlO\
l\
l\
l\

->
lOllO\
lO\
OlOl
(
0
)
;
lOllOlOll\
lO\

(
&
llOOllOl\
lOO\
O
,
llOOllOlOlll
)
;
}
void\

lOllOlOllO\
lO
::
llOOl\
OO\
llO\
l\
O
(
lO\
lOOOOOOlOl
&
lOlOO\
O\
OllO\
lO
,
Collis\
i\
on
&
llO\
llllOlOl
)
{
TA_\
A\
SSERT\

(
(
lOlO\
OO\
Ol\
lOlO\

.
lO\
lOOO\
O\
Ol\
Oll
==
llOllllOlOl
.
GetObj\
ectA\

(
)
&&
lOlOOO\
Oll\
Ol\
O
.
lO\
lO\
OO\
OO\
llOO\

==
ll\
Ollll\
OlO\
l
.
Get\
ObjectB
(
)
)
||
(
lO\
lO\
OOOll\
OlO
.
lOl\
OOOOO\
lOll
==
llOll\
llOl\
Ol
.
Get\
Ob\
je\
ctB
(
)
&&
lOl\
OOO\
OllO\
l\
O
.
lO\
l\
OOO\
O\
Ol\
lOO
==
ll\
Ol\
l\
l\
lOlOl\

.
GetOb\
ject\
A
(
)
)
)
;
Collis\
i\
o\
n
*
llO\
O\
ll\
Ol\
Olll
=
llOOllOlOOlO\

.
Alloc
(
)
;
if
(
!
llOOll\
Ol\
Ol\
ll\

)
retu\
rn
;
llOO\
l\
lOO\
ll\
ll
++
;
*
ll\
OOl\
l\
OlOlll
=
ll\
Ollll\
OlOl\

;
llOOl\
l\
OlOl\
ll
->
lOllOl\
O\
Ol\
Ol
(
0
)
;
lO\
lO\
OO\
OllOlO
.
lOlOl\
l\
lOO\
Ol\
l\

.
lOlO\
lOOOOl
(
llOOll\
O\
lOl\
l\
l
)
;
}
stati\
c
void
ll\
OOl\
lOllO\
Ol
(
Vec3
llOOllO\
llOlO
[
3
]
,
int\

&
llOO\
ll\
OllOll\

,
Vec\
3
&
lOllll\
O\
llO
,
cons\
t
Vec\
3\

&
lOOOlOOOOO
)
{
switch
(
ll\
OOl\
l\
Oll\
Ol\
l\

)
{
case
0
:
llO\
OllOllOl\
O
[
0
]
=
lO\
OO\
lOOO\
OO\

;
llO\
Oll\
OllOl\
l\

++
;
break
;
case
1
:
{
float
lOlOO\
Ol\
O\
O\
l\
O\

=
llOOl\
l\
Oll\
Ol\
O\

[
0
]
.
Dot
(
lO\
O\
Ol\
OO\
O\
OO
)
;
if\

(
lOlOOOl\
OOl\
O
<
0.99f
)
{
llOOllOl\
lO\
l\
O\

[
1
]
=
lOOOlO\
OOOO
;
llOOllOll\
Oll
++
;
if
(
lOlOOOlOOlO
<
-
0.98f
)
llOOllOllO\
ll
=
4
;
}
}
brea\
k
;
ca\
se
2
:
if
(
llOO\
llOllOlO
[
0
]
.
Dot
(
lO\
OO\
l\
OOOOO
)
<
0.99f
&&
llOOllOll\
OlO
[
1
]
.
Dot
(
lOOOlOOOO\
O
)
<
0.99f
)
{
llOOll\
Oll\
Ol\
l
++
;
llO\
Ol\
lOllOlO\

[
2
]
=
lOOOlO\
OOOO
;
lO\
lll\
lO\
llO
=
(
llOOl\
lOllOl\
O
[
2
]
-
llOOllOllOlO
[
0
]
)
.
Cross\

(
llO\
O\
ll\
Ol\
lOlO
[
1
]
-
llO\
OllOllOlO
[
0
]
)
.
Get\
Normal
(
)
;
float
lOlOllOl\
ll
=
lOlll\
lOllO
.
Dot
(
llO\
O\
llOll\
OlO
[
2
]
)
;
if\

(
lOl\
OllOlll
<
0.0f
)
{
lOll\
llOllO
=
-
lOll\
ll\
OllO
;
lOlOllOlll
=
-
lO\
lOllOlll
;
}
if
(
lOlOllOlll
<
0.1f
)
llOOllO\
llO\
l\
l
=
4
;
}
bre\
ak
;
cas\
e\

3
:
if
(
lO\
llll\
Ol\
lO\

.
Dot
(
lOOOlOO\
OOO
-
llOO\
ll\
OllOlO
[
0
]
)
<
-
0.01f
)
{
Ve\
c\
3
lOll\
OOOOl\
l\
OO\

=
(
llO\
OllOllOlO
[
0
]
-
lO\
OOlOOOOO\

)
.
Cro\
ss
(
llOOll\
Ol\
lOlO
[
1
]
-
lOOOlOOO\
OO
)
.
GetNorm\
al\

(
)
;
Vec\
3
lOl\
l\
OO\
OOllOl\

=
(
llO\
Ol\
lO\
ll\
OlO
[
1
]
-
lOOOlO\
OOOO
)
.
Cross
(
llO\
Ol\
l\
OllOl\
O
[
2
]
-
lO\
OOlOO\
OOO
)
.
GetNor\
mal\

(
)
;
Vec\
3
llOOllOlllOO\

=
(
llOO\
llOllOl\
O
[
2
]
-
lOOOl\
OOOO\
O
)
.
Cross
(
llOOllO\
llOlO
[
0
]
-
lOOOlO\
O\
OOO
)
.
GetN\
o\
r\
mal
(
)
;
if
(
lOllOOOOllO\
O
.
Dot
(
lO\
llll\
O\
ll\
O
)
<
0
)
lOll\
O\
OO\
OllOO
=
-
lO\
llOOOO\
llOO\

;
if
(
lO\
ll\
OO\
OO\
llO\
l
.
Dot
(
lOllllO\
llO
)
<
0
)
lO\
ll\
OOOO\
l\
lOl
=
-
lO\
l\
lO\
OOOl\
l\
Ol
;
if
(
ll\
OOllOlllOO\

.
Dot
(
lO\
llllOl\
lO\

)
<
0
)
ll\
OOll\
Oll\
lO\
O
=
-
llOOl\
lOlllOO\

;
floa\
t\

lOll\
lOlllO\

=
lOllOOOOllOO\

.
Dot
(
lOOOlO\
O\
OO\
O\

-
llOOllOllOlO
[
2
]
)
;
float
lOll\
llOOOO\

=
lOl\
lOOOOll\
O\
l
.
Dot\

(
lOOO\
lO\
O\
OO\
O
-
llOO\
l\
lO\
l\
lOlO
[
0
]
)
;
flo\
at\

llOOllOlllOl\

=
llOOl\
lO\
l\
l\
lO\
O
.
Dot\

(
lOO\
O\
l\
OO\
OOO
-
llO\
Oll\
Oll\
OlO
[
1
]
)
;
if\

(
lOlllOlll\
O
<
lO\
llllOOOO
)
{
if
(
lO\
lllOlllO
<
llOOllOlll\
Ol\

)
{
lOllll\
O\
l\
l\
O
=
lOllOOO\
OllOO
;
llOOl\
lO\
l\
lOl\
O
[
2
]
=
lOOOlOOOOO
;
}
el\
se
{
lOlll\
lOll\
O
=
ll\
O\
OllOlllOO
;
llOOl\
lOl\
lOlO
[
1
]
=
lOOO\
lO\
OOOO
;
}
}
els\
e\

{
if\

(
lOl\
lllOOOO
<
llOOllOlllOl
)
{
lOllll\
OllO
=
lOllOO\
OOll\
O\
l
;
llOO\
l\
lOllOlO\

[
0
]
=
lOOOlOOOOO
;
}
el\
se
{
lO\
ll\
l\
lOll\
O\

=
ll\
OO\
llOlll\
O\
O
;
ll\
OOllOllOlO
[
1
]
=
lOO\
OlOOOO\
O
;
}
}
float
lOlOll\
Olll\

=
lOl\
lllO\
l\
lO
.
Dot\

(
llO\
Ol\
lOllOl\
O
[
2
]
)
;
if
(
lOl\
O\
llOll\
l
<
0.1f
)
ll\
OOl\
l\
O\
ll\
O\
ll\

=
4
;
}
brea\
k
;
case\

4
:
break
;
}
}
void
lOll\
OlOllOl\
O
::
lO\
llll\
O\
lOlOl
(
)
{
for
(
lOl\
l\
llOOOl\
lO\

lOllllOO\
Olll\

=
llOOlO\
ll\
lOlO
.
lO\
lO\
OO\
O\
lOO\

(
)
;
!
lOllllOOOlll
.
AtEnd
(
)
;
)
{
lOlO\
O\
OOOOlOl
&
lOlOOOO\
llOlO
=
*
lO\
ll\
ll\
OOOlll\

;
++
lOll\
l\
lO\
OOll\
l
;
if
(
lO\
lOOO\
Ol\
lOl\
O
.
lO\
lOlllOOOl\
l\

.
lO\
O\
OOOl\
OOlO\

(
)
)
continue
;
TA_\
ASSERT
(
lOlOOO\
Ol\
lO\
lO
.
lOlO\
OOOO\
l\
Ol\
l
)
;
TA_A\
SSE\
RT
(
lOl\
O\
OOO\
l\
l\
O\
l\
O
.
lOlOOOOOl\
l\
O\
O
)
;
if
(
lOl\
O\
OOOllOlO
.
lOlOO\
OOOlOll
->
Ghost
(
)
||
lOlO\
OOO\
ll\
O\
lO
.
lO\
lOOOOOllOO
->
Ghost
(
)
)
continue
;
Dynami\
cO\
bj\
e\
c\
t
*
lOl\
lOO\
OlOll\

=
0
;
lOlOlllOlllO\

*
llO\
Oll\
O\
llllO
=
0
;
if\

(
lO\
lOOOOll\
OlO
.
lOlOO\
OOOlOll
->
lO\
lOO\
l\
lllOOO
(
)
)
{
lOllOOOl\
O\
ll
=
lO\
l\
O\
OOO\
llO\
lO\

.
lOl\
OOOOO\
lOll
;
ll\
OOl\
lOllllO
=
(
lOlO\
lllOll\
l\
O
*
)
lOl\
lOO\
O\
l\
O\
l\
l\

->
lOlOO\
l\
l\
OO\
lOl
(
)
;
}
Dynam\
icObje\
ct
*
lOll\
O\
OOll\
OO\

=
0
;
lO\
lO\
l\
llOlll\
O
*
llOOllOl\
llll
=
0
;
if
(
lOlOOOOll\
OlO
.
lOl\
OOOOO\
llO\
O
->
lO\
lOOlll\
lOOO
(
)
)
{
lO\
llOO\
OllOO
=
lOlOOO\
Ol\
lO\
lO\

.
lOlOO\
OOOllO\
O
;
llOO\
l\
l\
O\
lllll
=
(
lO\
lOl\
llOlllO
*
)
lOll\
OO\
OllOO
->
lOlOO\
ll\
OOlO\
l
(
)
;
}
TA_ASSERT
(
lO\
llOOOlOl\
l\

||
lOllOOO\
llO\
O
)
;
if
(
ll\
OOllO\
l\
ll\
lO
)
{
if
(
ll\
O\
O\
llOll\
lll
)
{
if
(
ll\
O\
Ol\
l\
Ollll\
O
!=
llO\
Ol\
l\
Ol\
lll\
l
)
llOOllOl\
llll
=
llOOllOll\
l\
lO
=
llO\
OlllOO\
OOO
(
llOOllO\
ll\
llO
,
llOO\
llOlllll
)
;
}
else\

{
ll\
OOll\
Olllll\

=
llOOl\
lO\
l\
lll\
O
;
if
(
lOll\
O\
O\
Oll\
OO
)
llOO\
lllOO\
OOl
(
lOllOOOllOO
,
llOOllOl\
l\
ll\
l
)
;
}
}
else
if
(
llOOl\
lOl\
l\
lll
)
{
llOOl\
lO\
l\
l\
llO
=
ll\
O\
O\
llOlllll
;
if\

(
lO\
l\
lOOOl\
O\
ll
)
llO\
Oll\
l\
OOOO\
l\

(
lOllOO\
Ol\
Oll
,
ll\
O\
Oll\
O\
llllO
)
;
}
else
{
llOOll\
Ol\
lll\
l
=
llOOl\
lOllllO
=
llO\
O\
lllOOOl\
O
(
lOllOOOlO\
l\
l
,
lO\
llO\
O\
Ol\
lOO
)
;
}
TA\
_ASSERT
(
llOOllOllll\
O
==
llOOl\
lOll\
ll\
l\

)
;
if\

(
llOOl\
lOllll\
O\

)
{
ll\
OO\
lO\
ll\
lO\
lO
.
lO\
Ol\
llll\
ll
(
&
lOlOO\
OO\
llO\
lO\

)
;
llOOll\
Oll\
l\
l\
O
->
lOlOO\
OOlOOO\
l
(
lOlO\
OOOll\
OlO\

)
;
}
}
Itera\
t\
or\

llOOll\
lOOO\
l\
l
=
llOOll\
Ol\
O\
llO\

.
lOl\
OOO\
O\
l\
OO
(
)
;
for
(
;
!
llOOll\
lOO\
Oll
.
AtEnd
(
)
;
)
{
lOlO\
l\
l\
lO\
lllO\

&
lO\
l\
lOllOlOlO
=
*
llOOl\
llOOOll
;
++
llOOlllOOOll\

;
Ve\
c\
3\

llO\
OllOllO\
lO\

[
3
]
;
int
llOO\
llOllOll
=
0
;
Ve\
c3
lO\
llllO\
llO\

;
int
llOO\
lO\
O\
lOO\
OO
=
0
;
in\
t
llOOl\
l\
l\
OOlOO
=
0
;
int
llO\
Ol\
l\
l\
OOlOl
=
0
;
lOlOl\
llO\
ll\
lO
::
lOllllO\
OOllO
lOl\
ll\
l\
OOOlll\

=
lO\
llOl\
lOl\
OlO\

.
llO\
OlOlllOlO\

.
lO\
lOO\
OOlOO
(
)
;
for
(
;
!
lO\
lll\
lOOO\
lll\

.
AtEnd\

(
)
;
)
{
lOl\
OOO\
OOOlOl
&
lOlOOOO\
llOlO\

=
*
lO\
ll\
llOOOlll
;
++
lOl\
lllO\
OOl\
l\
l
;
lOlO\
OOOO\
O\
lOl
::
Colli\
si\
onI\
te\
rator
lOlOlllOOOO\
O
=
lO\
lOOOO\
llOlO\

.
lOlOlll\
O\
OOl\
l
.
lO\
lO\
OO\
Ol\
OO\

(
)
;
if
(
lOlOlllOOOOO
.
At\
E\
n\
d
(
)
)
{
TA_ASSER\
T
(
lOlOOOO\
llOlO
.
lOlOOO\
OlO\
OOO
!=
0
)
;
TA_AS\
SERT
(
lOlO\
OO\
OllOlO
.
lOlOOOOlOOOO
==
&
lOllOl\
lOlOlO\

)
;
TA\
_A\
S\
SERT
(
(
lOl\
O\
OOOllOl\
O
.
lOlOllO\
OOl
&
lO\
lO\
OOOOOlOl
::
lOlOl\
llO\
l\
ll\
l
)
==
0
)
;
lOl\
OO\
O\
OllO\
l\
O\

.
lOl\
OOOOlO\
OOO
->
ll\
OOlOll\
lOlO\

.
lOO\
ll\
lll\
l\
l
(
&
lO\
l\
OOOOllOlO
)
;
lOlOO\
OOllOlO
.
lO\
lO\
OOO\
l\
OO\
OO
=
0
;
llOOlllOOllO
(
&
lOlOOOOll\
OlO
)
;
}
else\

{
fo\
r\

(
;
!
lO\
lOlllOOO\
O\
O
.
AtEnd
(
)
;
)
{
Collision
*
ll\
Oll\
OlOlOl
=
&
*
lOlOlllOOOOO\

;
++
lO\
lO\
lll\
OOO\
OO\

;
int
lOl\
Ol\
lO\
OOl
=
0
;
if
(
!
llOll\
OlO\
l\
Ol
->
GetObjec\
tA
(
)
->
Is\
I\
nMovin\
g\
List
(
)
||
(
llOll\
Ol\
OlOl
->
lOlOll\
OOOl\

&
Collision
::
FLAG\
_OBJECT\
A_\
SO\
LID
)
)
lOl\
O\
llOOOl
|=
Collision
::
FLAG\
_OBJECTA_SOLI\
D\
_IN\
TER\
NAL
;
if\

(
!
llOll\
O\
l\
OlO\
l\

->
GetObj\
ec\
t\
B
(
)
->
IsI\
nMovi\
ngLi\
st
(
)
||
(
llOllOlOlOl
->
lOlO\
llOOOl
&
Col\
l\
ision
::
FLA\
G\
_OBJECTB_S\
O\
LI\
D
)
)
lO\
lOllOO\
Ol
|=
Collision
::
FLAG_OBJECTB\
_SOLID_INTER\
NAL\

;
llOl\
lOlOlOl\

->
lOlOllO\
OOl
&=
~
(
Col\
li\
s\
i\
on\

::
FLA\
G_OBJECTA\
_S\
OL\
ID_INTERNAL
|
Collis\
ion
::
FLA\
G\
_OB\
JECTB_SOLID_IN\
T\
E\
RN\
A\
L\

)
;
llO\
llOl\
OlOl
->
lOlOllO\
OO\
l
|=
lOlOll\
OOOl\

;
in\
t
llOllOOlOl
=
0
;
for
(
Colli\
si\
on
*
lOO\
OOOOlll\
l
=
llO\
llOlO\
lOl
->
Ge\
tN\
ex\
t
(
)
;
lOO\
O\
OOOll\
ll
;
lO\
OO\
OOO\
lll\
l
=
lOO\
OOOOllll\

->
GetNext
(
)
)
{
lOOOOO\
Olll\
l
->
lOlO\
l\
l\
OO\
Ol
&=
~
(
Collisi\
o\
n
::
FLAG\
_O\
BJECT\
A_SO\
L\
ID_INTER\
NA\
L
|
Colli\
si\
on
::
FLAG_OBJECTB\
_\
S\
OLI\
D_I\
NTERN\
AL
)
;
lOOO\
O\
OOllll
->
lO\
l\
O\
llOOO\
l
|=
lOl\
Oll\
OOO\
l\

;
llO\
llO\
Ol\
Ol
++
;
}
if
(
ll\
OllOlOlOl
->
lOlOllOOOl
&
Collisi\
on
::
FLAG_OBJE\
C\
T\
B_SOLID_I\
N\
TE\
R\
NA\
L
)
{
if
(
llOll\
O\
l\
OlOl
->
lOl\
OllO\
OOl\

&
Coll\
isio\
n
::
FL\
AG_OBJECTA_SOLID\
_\
INTERN\
AL\

)
{
llOOll\
l\
OOlO\
O
++
;
lOlOOOOllOlO\

.
lOlO\
ll\
lOO\
Oll
.
lOO\
lllll\
ll
(
llOll\
OlO\
lOl
)
;
ll\
OOllOO\
lO\
Ol
(
ll\
Oll\
Ol\
O\
lOl
)
;
continue\

;
}
}
else
if
(
llOllO\
lOlOl\

->
lOlOll\
OOOl
&
Collisi\
on
::
FLAG\
_OB\
J\
EC\
T\
A_SOLID\
_IN\
T\
E\
RN\
AL
)
{
TA_ASS\
ERT\

(
(
llOl\
lOlOlO\
l
->
lOlOllOO\
Ol
&
Coll\
i\
sion
::
FLAG_OB\
J\
ECTB_S\
OLID_I\
NTE\
R\
NAL
)
==
0
)
;
ll\
Oll\
OlOl\
O\
l
->
lOl\
lO\
lO\
l\
O\
lO
(
)
;
for
(
Collisi\
on
*
lOOOO\
OO\
llll
=
llOllOlOlO\
l
->
Ge\
t\
Next\

(
)
;
lO\
OOOO\
Oll\
ll
;
lO\
OOOOOlll\
l
=
lO\
OOO\
OOlll\
l
->
GetNext
(
)
)
{
lOOOOOOll\
ll
->
lOl\
lOlOlO\
lO
(
)
;
}
}
el\
se
{
TA_AS\
SE\
RT
(
llOllOlOlOl
->
GetO\
bj\
e\
ctA\

(
)
->
lOlOOl\
lOO\
lOl
(
)
==
ll\
Oll\
OlOl\
O\
l
->
GetObjectB
(
)
->
lOlOOllOO\
lOl\

(
)
)
;
}
if\

(
(
!
ll\
O\
ll\
Ol\
OlO\
l
->
Ge\
tO\
b\
j\
ect\
A\

(
)
->
IsInMoving\
Li\
st
(
)
&&
!
ll\
Oll\
O\
lOlOl
->
GetObject\
A\

(
)
->
Move\
m\
entD\
i\
s\
able\
d\

(
)
)
||
(
!
llO\
llOl\
O\
l\
Ol
->
Ge\
tObj\
ect\
B\

(
)
->
IsInMo\
vingL\
i\
s\
t
(
)
&&
!
llOllO\
l\
O\
lO\
l
->
GetObjectB
(
)
->
Mo\
ve\
m\
ent\
Disab\
led
(
)
)
)
{
llOOlllOOlOl
+=
llO\
llO\
OlOl\

+
1
;
if\

(
llO\
llOl\
O\
lOl
->
lOlOllOOOl
&
Coll\
ision
::
FLAG\
_JOI\
NT\

)
{
llOOl\
llO\
OlOl
+=
(
ll\
O\
l\
lOOlOl
+
1
)
*
4
;
llOO\
l\
l\
OllO\
ll\

=
4
;
}
el\
se
{
if\

(
(
llOl\
lOlO\
lOl
->
lOlOl\
lOO\
Ol\

&
Co\
l\
lision
::
FLAG_\
F\
RICTI\
ON
)
==
0
)
{
if\

(
llO\
l\
lOlOlOl\

->
GetOb\
je\
ct\
A\

(
)
->
IsInMo\
vingList\

(
)
)
ll\
OOllOllOOl
(
llOOllO\
llO\
l\
O
,
llOOl\
l\
OllOl\
l
,
lOlll\
lO\
llO\

,
llOllOlO\
lOl
->
GetNorma\
l
(
)
)
;
else
llOO\
llOllOOl
(
llOOll\
Oll\
Ol\
O
,
llOOllOllO\
l\
l\

,
lOll\
llOl\
lO
,
-
llOll\
OlO\
l\
Ol
->
Ge\
t\
No\
r\
m\
a\
l
(
)
)
;
}
}
}
if
(
!
lOl\
l\
Ol\
l\
O\
lO\
lO
.
llOO\
l\
Oll\
Ol\
l\
O\

&&
!
lOllOllOlO\
lO
.
ll\
O\
Ol\
OllOlll
)
{
if
(
(
llO\
llOlO\
lOl
->
Get\
ObjectA\

(
)
->
In\
f\
in\
iteMa\
s\
s
(
)
||
(
ll\
OllOl\
OlOl
->
lOlO\
llO\
OO\
l
&
Co\
ll\
isio\
n\

::
FLAG_\
OBJE\
CTA_\
S\
OL\
I\
D
)
)
&&
ll\
Oll\
OlOl\
O\
l
->
Get\
O\
bjectA
(
)
->
IsIn\
Movi\
ng\
Li\
s\
t
(
)
&&
(
llOl\
l\
O\
lOlOl
->
GetOb\
je\
ctA\

(
)
->
GetL\
inearVeloc\
ity\

(
)
.
GetMagn\
itud\
e
(
)
>
0.0f
||
llOllOlO\
lOl
->
Get\
Obj\
ectA
(
)
->
Ge\
tAngu\
l\
a\
rVe\
l\
oc\
ity\

(
)
.
GetMagni\
tude
(
)
>
0.0f
)
)
lOl\
lOllOlOlO
.
llOOlOllOlll\

=
tru\
e\

;
if\

(
(
llO\
l\
lOlOlOl
->
Get\
ObjectB\

(
)
->
Infini\
teMass
(
)
||
(
ll\
Oll\
OlOl\
Ol\

->
lOlOl\
lOOOl\

&
Collis\
i\
on
::
FLA\
G_O\
BJECTB\
_SOLID
)
)
&&
llOllOlO\
lOl\

->
GetO\
bjec\
tB
(
)
->
IsI\
nMovi\
ngLi\
st\

(
)
&&
(
llOllOlOlOl
->
Ge\
tObject\
B
(
)
->
Get\
Line\
arVelocity
(
)
.
Get\
Magn\
itude
(
)
>
0.0f
||
llOllOl\
O\
lOl
->
GetOb\
jectB\

(
)
->
GetAngularV\
elocity
(
)
.
Ge\
tMag\
nitu\
d\
e
(
)
>
0.0f
)
)
lOll\
OllO\
lO\
l\
O
.
llOOlOllOlll
=
true
;
}
ll\
OO\
lOOl\
OOO\
O
+=
ll\
Ol\
l\
O\
OlOl\

+
1
;
}
if
(
lOl\
O\
O\
OO\
llOlO
.
lOlO\
OOOOlOl\
l
->
IsForceFast\
SolverEnabl\
ed
(
)
||
lOlO\
OOOllOlO
.
lOlOOOOOll\
OO\

->
IsForce\
Fas\
tSol\
v\
erEna\
bled\

(
)
)
lO\
llOl\
l\
Ol\
Ol\
O
.
lOl\
lOllllllO\

(
true
)
;
}
}
lOllOl\
lO\
lOlO
.
ll\
OOl\
OllOlOO
=
llOOlO\
Ol\
OOO\
O
;
if
(
llO\
O\
l\
lOllO\
ll\

==
4
&&
llO\
O\
ll\
lOOlOl
*
3
>
ll\
O\
O\
lOO\
lOO\
OO\

)
lOl\
lOl\
lOlOl\
O\

.
lO\
llOll\
l\
l\
llO
(
true\

)
;
lOllOll\
Ol\
OlO
.
llOOlOllOlO\
l
=
lOllOllOlOlO\

.
llOOl\
Oll\
llOO\

.
lOOO\
lll\
OOl
(
)
;
if
(
lO\
ll\
OllOlOl\
O
.
ll\
OOlO\
l\
lOlOO\

==
0
)
{
lOlOlll\
OlllO
::
llO\
OO\
O\
O\
Ol\
lOO
llO\
O\
OOOOll\
Ol\

=
lOllOll\
OlOlO
.
llO\
O\
lOllllO\
O
.
lO\
lOOOOl\
O\
O
(
)
;
whil\
e
(
!
llOOO\
OOOllO\
l
.
AtEnd
(
)
)
{
Dy\
n\
am\
i\
c\
Object\

*
*
ll\
OO\
l\
llOOll\
l\

=
&
*
llOOO\
OOO\
llOl\

;
++
llOOOO\
OOll\
Ol
;
if
(
(
*
llOOl\
l\
lO\
Ol\
ll\

)
->
lOlOOll\
O\
OlO\
l\

(
)
!=
0
)
{
(
*
ll\
OO\
lllOO\
lll\

)
->
lOlOOllOOOll\

(
0
)
;
(
*
ll\
OOll\
lOO\
lll
)
->
Release
(
)
;
(
*
llOO\
ll\
lOOlll
)
=
0
;
}
lO\
ll\
Ol\
lOlOl\
O\

.
llOOlOllllOO\

.
lOOl\
llllll
(
ll\
O\
Ol\
l\
lOOlll\

)
;
llOOllOlOOl\
l
.
Free
(
llOOlllO\
Olll
)
;
}
lOlOlllOOO\

<
lOlOOOOO\
O\
l\
Ol
>
::
lOl\
Ol\
llO\
O\
l
::
Ite\
ra\
tor
lOllllOO\
Ol\
ll\

=
lOl\
l\
Oll\
OlO\
lO
.
llOOlOl\
l\
l\
Ol\
O
.
lOlO\
O\
OO\
l\
OO
(
)
;
while
(
!
lO\
llllOOOl\
l\
l
.
AtE\
nd
(
)
)
{
lO\
lO\
OOOOOlOl
&
lOlO\
OO\
Ol\
lO\
l\
O
=
*
lOlll\
lOOOlll
;
++
lOl\
ll\
lOOOlll
;
TA_ASSER\
T
(
lOlOO\
OOllOlO
.
lOlO\
OOOlOOOO
!=
0
)
;
TA_AS\
SE\
R\
T
(
lOl\
O\
OOOll\
O\
l\
O\

.
lOl\
OO\
O\
O\
lOO\
O\
O
==
&
lOll\
O\
llOlOlO
)
;
TA_\
AS\
SE\
RT
(
(
lOlO\
OOOl\
lO\
l\
O
.
lOlOllO\
OOl
&
lOlOOOOOO\
lOl
::
lOlOll\
l\
Ol\
lll
)
==
0
)
;
lOlOOOOl\
lOlO
.
lOlOOOOlOO\
OO
->
llOO\
lOl\
ll\
Ol\
O\

.
lOOlll\
l\
lll
(
&
lO\
l\
OOOO\
llOl\
O\

)
;
lOl\
OO\
O\
O\
llOlO
.
lOl\
OOOOlOOO\
O
=
0
;
llOOll\
l\
O\
O\
l\
lO
(
&
lOlOOOO\
llOl\
O
)
;
}
lO\
ll\
O\
llOlO\
lO
.
Finalise\

(
)
;
llOO\
ll\
OlOllO
.
lOO\
lllll\
l\
l
(
&
lOl\
l\
OllOlOlO\

)
;
llOOll\
OlOlO\
O
.
Fr\
e\
e
(
&
lOllOl\
l\
OlO\
l\
O\

)
;
}
}
}
void\

lO\
llO\
l\
Ol\
lOlO\

::
ll\
O\
Ol\
llO\
lOOO
(
lOlOO\
OOOOl\
Ol\

&
lO\
lOO\
OOllOlO
)
{
int\

ll\
OOlOOlO\
OOO
=
0
;
fo\
r\

(
lOlO\
lllO\
O\
O
<
Coll\
is\
ion\

>
::
lOl\
Oll\
lOOl\

::
Iterator
lOlO\
O\
lOOlO
=
lOlOOOOllO\
l\
O
.
lO\
lO\
lllOOO\
l\
l
.
lO\
lOOOOlOO
(
)
;
!
lO\
lOOlO\
O\
lO\

.
At\
En\
d
(
)
;
)
{
Coll\
isi\
on\

&
ll\
OllllOlOl
=
*
lO\
lOOl\
OOlO
;
++
lOlOOlOOlO
;
if
(
llOl\
lllOlOl\

.
lOl\
OllOOOl
&
(
Col\
l\
is\
ion
::
FLAG\
_\
F\
R\
ICTION\

)
)
{
lOlOOO\
OllOlO
.
lO\
lOlllOO\
Oll\

.
lOO\
llll\
lll
(
&
ll\
Olll\
lO\
lOl
)
;
ll\
OOll\
OOlO\
Ol
(
&
llOl\
lllOl\
Ol\

)
;
co\
n\
ti\
n\
ue
;
}
llOOlOOl\
O\
OO\
O
++
;
llO\
l\
l\
ll\
Ol\
Ol
.
lOllOOlO\
OlO
=
0.0f
;
ll\
OllllOlOl
.
lOllOO\
lOll\
O
.
Cl\
ea\
r\

(
)
;
llO\
llllOlOl\

.
lO\
llOOl\
O\
lll
.
Cl\
ear\

(
)
;
llOllll\
OlOl
.
lOlOllOO\
Ol
&=
~
(
Co\
llision
::
FL\
AG_\
FRI\
CTION\
_\
G\
E\
NERA\
T\
IN\
G_\
IMPULS\
E\

|
Co\
l\
lisio\
n
::
FLA\
G\
_M\
ARKED
|
Coll\
is\
ion\

::
FL\
AG_\
R\
E\
STIT\
UT\
I\
ON_CALCU\
LATED
)
;
}
if
(
llOOlO\
OlOOOO
==
0
)
{
lO\
l\
O\
OOOlllOO
(
lOl\
OOOOllOl\
O\

)
;
ret\
urn
;
}
TA\
_ASSE\
RT
(
lOlO\
OOOllOlO
.
lOlOO\
OOl\
OOOO\

==
0
)
;
TA_ASSE\
RT
(
lO\
lOOO\
O\
l\
lO\
lO
.
lOlOOO\
O\
Ol\
O\
ll
)
;
TA_ASSERT
(
lOl\
OOOOllOlO\

.
lO\
lO\
OOOOl\
lO\
O
)
;
Dy\
nam\
icOb\
ject
*
lOll\
OOOlO\
ll\

=
0
;
lO\
l\
OlllO\
lll\
O
*
llOO\
llOllllO
=
0
;
if
(
lO\
l\
O\
O\
OOllOlO
.
lOlO\
OOO\
O\
lOll
->
lOl\
OOllllOOO
(
)
)
{
lO\
llOO\
OlOll
=
lOl\
OOOOl\
lO\
lO
.
lO\
lOOOOOl\
Oll\

;
llOOl\
lOllllO
=
(
lO\
l\
Ol\
llOlllO
*
)
lOllOO\
Ol\
Oll
->
lOl\
O\
Oll\
O\
OlOl
(
)
;
}
DynamicObj\
ect
*
lOl\
lO\
OOl\
l\
O\
O
=
0
;
lO\
lOl\
l\
lOl\
llO
*
llOO\
llOll\
l\
ll
=
0
;
if
(
lOl\
OOOOllOlO
.
lO\
lO\
O\
OOOllO\
O
->
lO\
l\
O\
O\
llllOOO
(
)
)
{
lOl\
lO\
OOllOO
=
lOlO\
OO\
OllO\
lO\

.
lOlOOOOOll\
OO
;
llOO\
llOl\
llll\

=
(
lOlOll\
lOlllO
*
)
lOllOOO\
ll\
O\
O
->
lOlOOl\
lO\
O\
lOl\

(
)
;
}
TA_A\
SSERT\

(
lOllOOOlOl\
l
||
lOl\
lOO\
O\
l\
lOO
)
;
if
(
llO\
OllOllllO\

)
{
if
(
llOO\
llO\
l\
llll
)
{
if
(
llO\
OllOl\
ll\
lO
!=
llOOllO\
llll\
l\

)
llOOllO\
ll\
l\
ll
=
ll\
OOllOll\
llO
=
llO\
Oll\
lOOOO\
O
(
ll\
OOllOllllO
,
llO\
Ol\
l\
O\
lllll
)
;
}
els\
e
{
llO\
O\
llO\
lllll
=
llOOllOllllO
;
if
(
lOl\
lOO\
Ol\
lOO
)
llO\
O\
l\
llOOOOl
(
lOll\
O\
O\
OllOO
,
llOOllOll\
lll
)
;
}
}
els\
e
if\

(
llOOllOlllll
)
{
ll\
OO\
llOll\
llO
=
ll\
OOll\
O\
ll\
lll\

;
if
(
lO\
l\
lOOOlOl\
l
)
llOO\
lllO\
OOOl
(
lO\
llO\
OOl\
Oll
,
ll\
O\
Ol\
lOllllO
)
;
}
el\
se
{
llOOllOlllll
=
llOOllO\
llllO
=
llOOl\
llO\
OO\
lO
(
lOl\
l\
OOOlOll
,
lOll\
OO\
OllOO
)
;
}
TA_ASSERT
(
llOOllOllllO
==
ll\
OO\
l\
lOlll\
ll\

)
;
TA_\
A\
SSERT
(
llOOllOllllO
)
;
lOlOOOOllOlO\

.
lO\
lOOOOlOOOO\

=
llOO\
llOllllO
;
TA_AS\
S\
ERT
(
lOlO\
O\
OOllOl\
O
.
lOlOl\
l\
OOOl
&
lOlOOO\
OOO\
lOl
::
lOlOl\
l\
lO\
l\
ll\
l
)
;
lO\
lO\
OOOllO\
lO
.
lOlOllOOOl
&=
~
lOlOO\
OOO\
Ol\
Ol
::
lOl\
Olll\
Oll\
l\
l\

;
ll\
OO\
l\
llOl\
OOl
.
lOOlll\
llll
(
&
lOlOOOOllOlO
)
;
llOOllOllll\
O
->
ll\
OOlOlllOlO\

.
lOlOl\
O\
OOOl
(
&
lOlO\
O\
O\
Ol\
lOl\
O
)
;
llOOl\
lO\
llllO
->
llO\
O\
lOll\
OlOO\

+=
llOO\
l\
O\
OlOOO\
O
;
}
vo\
id
lOllO\
l\
OllOlO
::
Cle\
ar
(
bo\
ol
llOO\
lllOlO\
lO
)
{
TA_ASSERT
(
lO\
ll\
ll\
O\
lO\
l\
OO
(
)
==
0
)
;
TA\
_ASSERT
(
llO\
OlllOlO\
Ol
.
lOOOO\
OlOOlO
(
)
)
;
llOOlllOl\
O\
Ol
.
llO\
llOlOlO
(
ll\
O\
Ol\
OlllOlO
)
;
Iterato\
r
ll\
OOl\
l\
lO\
O\
Oll
=
llOOll\
O\
l\
OllO\

.
lOlOO\
OO\
l\
O\
O
(
)
;
whil\
e
(
!
ll\
OOl\
llOOOll
.
AtEnd\

(
)
)
{
lO\
l\
O\
ll\
lOlllO
&
ll\
OO\
l\
ll\
OlOll\

=
*
ll\
OOlll\
O\
OOl\
l
;
++
llO\
Ol\
llOO\
Oll
;
lOl\
O\
l\
llO\
OO
<
lO\
lO\
OOOO\
Ol\
Ol
>
::
lOlO\
lllOO\
l\

::
Ite\
ra\
t\
or
lOllll\
O\
OOlll
=
llOOlllOlOll
.
ll\
O\
OlOlllO\
lO
.
lOl\
O\
O\
OO\
lOO
(
)
;
while
(
!
lOl\
lll\
OOO\
lll
.
AtEnd
(
)
)
{
lOlOO\
OOOO\
lO\
l
&
lOl\
OOOOllOlO
=
*
lO\
llllOO\
Ol\
ll
;
++
lO\
lll\
lOO\
O\
lll
;
TA_ASS\
E\
RT
(
lO\
lO\
OOOllO\
lO
.
lOlO\
OO\
OlO\
OO\
O
!=
0
)
;
TA_ASS\
ERT
(
lOl\
OOOO\
llO\
lO
.
lOlOOOOlOOOO\

==
&
ll\
OOll\
l\
OlOll
)
;
TA_\
ASSERT
(
(
lOl\
OOOOllO\
lO\

.
lO\
lOllOOOl
&
lOlOOO\
OO\
OlO\
l
::
lOlOl\
ll\
Ol\
lll
)
==
0
)
;
lOlOO\
OO\
ll\
Ol\
O
.
lOlOOO\
O\
lOOOO\

->
ll\
O\
OlOlll\
OlO
.
lO\
Ollll\
lll\

(
&
lO\
l\
OOOOl\
lO\
lO
)
;
lO\
lOO\
O\
Ol\
l\
O\
lO
.
lOlOOO\
OlOOOO
=
0
;
TA_ASSERT
(
lO\
l\
OOOOllOl\
O
.
lO\
lOOOOO\
l\
Ol\
l
)
;
TA_\
A\
SSERT
(
lO\
lO\
OO\
OllOl\
O
.
lO\
lO\
OOOOl\
l\
OO
)
;
if
(
!
lOlOOOOllOlO
.
lO\
lOll\
l\
OOOll\

.
lOOOOOl\
O\
Ol\
O
(
)
&&
!
lOlOOOO\
llO\
lO
.
lOlOOOOO\
lOl\
l\

->
Ghost\

(
)
&&
!
lOlOOOOllOl\
O
.
lO\
lOOOOOl\
lOO
->
Gh\
o\
st
(
)
)
{
if
(
!
lOlOOOOllOlO
.
lO\
lOOO\
OOllO\
O
->
InfiniteM\
a\
s\
s
(
)
&&
!
lOlOOOO\
llOlO
.
lOlOO\
OOOll\
OO\

->
Move\
me\
ntDisabled\

(
)
)
lOl\
OOO\
Oll\
OlO
.
lOlOO\
OOOl\
O\
l\
l\

->
lOlOOOlOlOOl
(
lOlOO\
OOll\
OlO
.
lOl\
O\
OOOOllO\
O
)
;
if
(
!
lOl\
O\
OO\
OllOlO
.
lOlO\
OO\
O\
OlOll
->
Infi\
n\
ite\
Ma\
ss\

(
)
&&
!
lOlO\
O\
OOllOl\
O
.
lOlOOOOOl\
Oll
->
Movemen\
tD\
isa\
bled
(
)
)
lOlOOOOl\
lOlO
.
lOlOOOOOllOO
->
lOl\
O\
O\
OlO\
l\
O\
Ol
(
lOlOOOO\
ll\
Ol\
O
.
lOlOO\
OO\
OlOll\

)
;
}
lOlOO\
OOlOO\
Ol
(
&
lOlOOOOl\
lO\
lO
)
;
}
lOlOl\
llO\
lll\
O\

::
llOOO\
OOO\
ll\
OO
llO\
OOOOOl\
lOl
=
llOOlllO\
lOll
.
llOOl\
Oll\
ll\
OO
.
lOlOOOO\
lOO
(
)
;
while
(
!
llO\
OOOOOll\
Ol
.
AtEnd
(
)
)
{
Dynamic\
Object
*
*
llO\
Ol\
l\
lOOlll
=
&
*
llOOOOOO\
llOl
;
++
llO\
OOOOOllOl
;
if
(
(
*
llOOlllOOlll
)
->
lOlO\
O\
l\
lO\
OlOl
(
)
!=
0
)
{
(
*
ll\
OO\
lllOOlll
)
->
lOlOO\
llOOOll
(
0
)
;
(
*
llOOll\
lOOlll
)
->
Relea\
se
(
)
;
(
*
llOOlllO\
Olll
)
=
0
;
}
llOO\
lllOlOll\

.
ll\
OOlOllllOO
.
lOO\
ll\
llll\
l
(
llOOll\
lOO\
lll
)
;
llOOllOl\
OO\
l\
l
.
Free
(
llOO\
lll\
OO\
l\
ll
)
;
}
llOOlllOlOl\
l\

.
Fin\
a\
lise
(
)
;
llOOl\
lO\
l\
Oll\
O
.
lOOll\
ll\
lll
(
&
llO\
OlllOlOll\

)
;
llOOl\
l\
Ol\
OlOO\

.
Fre\
e
(
&
ll\
OOlllO\
lO\
l\
l\

)
;
}
TA\
_ASSE\
RT
(
llOOllOlOl\
l\
O
.
lO\
lO\
OOOl\
OO
(
)
.
AtEnd
(
)
)
;
TA_A\
SS\
ER\
T
(
llOOlOlllOl\
O
.
lOOOO\
OlOO\
lO
(
)
)
;
if\

(
llOOlllOlOlO
)
{
TA\
_ASSERT\

(
llOOl\
Ol\
llO\
lO
.
lOOOOO\
l\
OOlO
(
)
)
;
lO\
lOlll\
OOO
<
lOlOOO\
O\
O\
OlOl
>
::
lOOlO\
OOll\
l\
l
::
Iterator
lOll\
ll\
OOOlll
=
llOO\
l\
llOlOOl\

.
lO\
lO\
O\
O\
OlOO
(
)
;
while\

(
!
lOlll\
lOOOlll
.
AtEn\
d\

(
)
)
{
lOlOOOOOO\
lOl\

&
lOlOOOOll\
Ol\
O
=
*
lOllllOOOlll
;
++
lO\
l\
lllOOOlll\

;
TA_ASS\
E\
RT\

(
lOl\
O\
OO\
OllOl\
O
.
lOlOOOOOlOl\
l\

)
;
TA_ASS\
E\
R\
T
(
lOlOOOOllOlO
.
lOlOOO\
OOl\
lOO
)
;
lOl\
OO\
OOl\
l\
OlO\

.
lO\
l\
O\
ll\
OOOl
|=
lOlO\
O\
OOO\
Ol\
O\
l
::
lOlOlllOl\
l\
ll
;
if
(
(
lOl\
OOOO\
l\
lOl\
O
.
lOl\
OOOOO\
lOl\
l
->
IsInMov\
ingList
(
)
||
lOlO\
OOOllOl\
O
.
lOl\
OO\
OO\
O\
llO\
O
->
Is\
I\
n\
Mo\
vingL\
ist\

(
)
)
&&
lOl\
OOOOl\
l\
O\
lO
.
lOlOOOOOlOl\
l
->
lOlOOOOllllO\

(
)
&&
lOlOOOOll\
OlO
.
lOlOOO\
OO\
llOO\

->
lOlOOOO\
lll\
lO
(
)
&&
(
lOlOOOOllO\
l\
O
.
lOlO\
llO\
OOl\

&
lO\
lOOOOOOl\
Ol
::
lO\
lO\
OO\
llO\
OOl
)
==
0
)
{
if\

(
lOlO\
O\
OOl\
l\
OlO
.
lOlOOOOOlOll
->
lO\
lOOOOlll\
lO\

(
)
&&
lOlOOOOllOlO\

.
lOlO\
OOO\
Ol\
lOO\

->
lOl\
OO\
OOllll\
O
(
)
)
{
if
(
!
lO\
lO\
OOO\
llOlO\

.
lOlOl\
l\
lOOOll
.
lOlO\
OOOlOO
(
)
.
AtEnd
(
)
)
ll\
OO\
lllOlOO\
O
(
lO\
lOO\
OOll\
OlO\

)
;
}
}
else
{
lOlO\
OOO\
lllO\
O
(
lOlO\
OO\
OllO\
l\
O
)
;
}
}
}
else
{
TA_\
A\
SSERT
(
llOO\
lOlllOlO
.
lOO\
OOO\
lO\
OlO
(
)
)
;
lOlOl\
llO\
OO
<
lOlOOO\
OO\
OlOl\

>
::
lOOlOOO\
llll
::
Itera\
tor
lOl\
l\
llOOO\
lll
=
llOO\
lllOlO\
Ol
.
lOlOOOOlOO
(
)
;
wh\
i\
le\

(
!
lOl\
lllOOOlll
.
AtEnd
(
)
)
{
lOl\
OO\
OOOOl\
Ol
&
lOlOO\
OO\
llOlO
=
*
lOllllOOOlll
;
++
lOllll\
OOOlll
;
lOlOOOOllOlO
.
lOlOllOO\
Ol
|=
lOlO\
OOOO\
OlOl\

::
lO\
lOll\
lOllll
;
lO\
l\
OOOO\
ll\
lOO
(
lOlO\
O\
OOllOlO
)
;
}
TA\
_A\
SS\
ERT
(
ll\
OO\
llOlOlOl
.
lOOlOOlOOl\
O
(
)
==
lOOllOlllOlO
->
lOlOllll\
OOll
)
;
TA_ASSE\
R\
T
(
llOOl\
lOl\
OO\
lO
.
lOOl\
O\
OlO\
OlO
(
)
==
lOOllOlll\
OlO
->
lOlOllllOOOl
)
;
}
}
vo\
id
lO\
llOlOl\
l\
O\
lO
::
llO\
OlOOOl\
OO\
O
(
lOlOOOOOOlO\
l
&
lOlOOOO\
l\
lOlO\

)
{
TA_ASSERT
(
lOlOO\
OOl\
lOlO
.
lOlO\
OO\
O\
lOOOO
!=
0
)
;
TA_A\
SS\
E\
RT
(
(
lOl\
OO\
O\
O\
l\
lOlO
.
lO\
l\
Oll\
OO\
Ol
&
lOlOOOOO\
OlOl
::
lO\
lOlllOl\
l\
ll
)
==
0
)
;
lOlOO\
OOllOlO
.
lOlOOOOlOOO\
O\

->
llO\
O\
lO\
l\
llO\
lO
.
lOOl\
llllll
(
&
lOl\
O\
OO\
O\
ll\
OlO
)
;
lOlOOO\
O\
llOlO
.
lO\
lOOOOl\
OOOO
=
0
;
TA_ASSE\
RT
(
lOl\
OO\
OOl\
lOl\
O
.
lOlO\
OOO\
O\
lOl\
l
)
;
TA_\
ASS\
ERT\

(
lOl\
OO\
OO\
llOlO\

.
lOlOO\
OOO\
llOO
)
;
lOlOOOOlO\
O\
Ol\

(
&
lO\
lOOOOllOlO\

)
;
}
void
lOllOl\
OllOlO
::
lOl\
O\
OOlO\
OOOO
(
lOlOOOOOO\
l\
Ol
&
lOlOO\
OOll\
Ol\
O
)
{
lOl\
Oll\
lOO\
O
<
Collis\
io\
n
>
::
lOlOll\
lOOl
::
It\
er\
ato\
r
lOlOlllOO\
O\
OO
=
lOlOO\
OO\
llO\
lO
.
lO\
l\
OlllOOO\
ll\

.
lO\
lOOOOl\
OO
(
)
;
whil\
e\

(
!
lOlOl\
ll\
O\
O\
O\
OO
.
AtEn\
d\

(
)
)
{
Coll\
isi\
o\
n
&
llOl\
lllOlO\
l
=
*
lOlOlllOOOOO
;
++
lOlOl\
ll\
OOOO\
O
;
lOlO\
OOOllOlO\

.
lOl\
O\
lll\
OO\
Oll
.
lOO\
ll\
lll\
ll\

(
&
ll\
Oll\
l\
l\
Ol\
Ol
)
;
llO\
Oll\
OOlO\
O\
l
(
&
llOllll\
OlO\
l
)
;
}
}
void
lOl\
lO\
lOl\
lOlO
::
lO\
lOOOO\
lllO\
O
(
lOlOO\
OOOOlOl
&
lO\
lOOOOl\
lOlO
)
{
lOl\
OOOlOOOOO
(
lOlO\
OOOllOlO
)
;
if
(
lOlO\
OO\
OllOl\
O\

.
lOlOOOOl\
OOOO
)
{
TA_ASS\
ERT
(
(
lO\
lOOOOllOlO\

.
lOlOllOO\
O\
l
&
lO\
lO\
O\
OOOOlOl
::
lOl\
OlllOll\
ll
)
==
0
)
;
lOlOOOOl\
lOlO
.
lO\
l\
O\
O\
OOlO\
OOO\

->
llOOl\
Ol\
ll\
OlO
.
lOOll\
l\
llll
(
&
lOlO\
O\
OOllOlO
)
;
}
el\
se
{
if\

(
lOlOOOOl\
lOlO
.
lOl\
OllOOOl
&
lOl\
OOO\
OOOlO\
l
::
lOlOlll\
Ollll
)
{
lO\
l\
OOO\
Oll\
OlO
.
lOlO\
llO\
O\
Ol
&=
~
lOlOO\
OOOO\
lOl
::
lOl\
O\
l\
llOlll\
l
;
ll\
OO\
l\
llO\
lOOl
.
lOOl\
l\
lll\
ll
(
&
lOl\
OO\
OO\
ll\
OlO\

)
;
}
else\

{
ll\
OO\
lO\
lll\
OlO
.
lOO\
lllllll
(
&
lOlO\
OOOll\
Ol\
O
)
;
}
}
lOlOO\
OOllOl\
O
.
lOlOll\
O\
OOl
&=
~
lO\
lOOOO\
OOlOl
::
lO\
l\
OOO\
ll\
OOOl
;
if
(
lOl\
OOOOll\
OlO
.
lOl\
O\
O\
O\
OOlOll\

)
lOlOO\
OO\
llO\
lO
.
lOlOOOOOlOll
->
lOlOO\
OlOO\
OlO\

(
lOlOOOOllO\
lO
)
;
if
(
lOl\
OOOOl\
l\
Ol\
O\

.
lOlOO\
O\
O\
OllOO
)
lOlOOO\
OllOlO\

.
lOlOOOO\
Ol\
lOO
->
lOlOOOl\
O\
OOlO\

(
lO\
lOOOOl\
lOl\
O
)
;
TA_A\
SSERT\

(
lOlOOOO\
ll\
O\
l\
O\

.
lOlOOOOlOOlO
.
lOlO\
O\
OOO\
lOlO
==
&
lO\
lOOOOll\
Ol\
O
)
;
TA_AS\
S\
ER\
T\

(
lOlOOOOll\
OlO
.
lOlO\
OOOl\
OOl\
l
.
lOlOOOO\
O\
lOl\
O
==
&
lOlO\
OOO\
llOlO\

)
;
if
(
lO\
lOOOOllOlO
.
lOl\
O\
OOOl\
OOlO
.
llOO\
O\
Ol\
ll\
l\
l\

)
{
TA_ASSERT\

(
lOlOO\
O\
OllOlO
.
lOlO\
O\
OOlOOlO
.
llOO\
O\
Olllll
->
llO\
OO\
OlOlOl
==
&
lOlOO\
O\
O\
l\
lO\
lO
.
lO\
l\
OOOO\
lOO\
lO
.
llOOOOl\
ll\
ll
)
;
lO\
lOOOOllO\
lO
.
lOl\
OO\
O\
Ol\
O\
Ol\
O
.
llOO\
OOlllll
->
llOOO\
Ol\
OlOl
=
lOlO\
OOOllOl\
O
.
lOlOOOOlOOl\
O
.
ll\
OO\
OOlOlOl
;
}
if
(
lOlOOO\
Ol\
lOlO
.
lOlOO\
OOl\
OOlO
.
ll\
OOOOlOl\
Ol\

)
{
TA_A\
S\
SER\
T
(
*
lO\
l\
OOO\
OllOlO
.
lOl\
OO\
O\
Ol\
OOl\
O
.
ll\
O\
OOOlOl\
Ol
==
&
lOl\
OOO\
OllO\
lO\

.
lOl\
OOOOlO\
O\
lO
)
;
*
lOl\
OOOOllOlO
.
lOlOOO\
OlO\
OlO
.
llOOOO\
lOl\
Ol\

=
lOlOO\
O\
Ol\
l\
Ol\
O
.
lO\
lO\
OO\
OlOOlO
.
llOOO\
Olllll
;
}
if
(
lOl\
OO\
OO\
llOlO
.
lOl\
OOO\
O\
lO\
O\
ll
.
llOO\
OOlll\
ll
)
{
TA_ASSERT
(
lOlOO\
OOll\
OlO\

.
lOl\
OOOOl\
O\
Ol\
l
.
llO\
OO\
Olllll
->
llOOOO\
lOl\
Ol
==
&
lOlOOOOllO\
lO
.
lOlOO\
OO\
lOOll
.
llOOOOll\
lll
)
;
lOlOOOOllO\
lO\

.
lOl\
OO\
OOlO\
Oll
.
llOOOO\
lllll
->
llOOOO\
lOlOl
=
lOlOOO\
OllOlO
.
lOlOO\
OO\
l\
OOll
.
llOOOO\
l\
OlOl
;
}
if
(
lOl\
O\
OOOl\
lO\
lO
.
lO\
lOOO\
OlOOl\
l
.
llO\
O\
O\
OlOlOl\

)
{
TA_A\
SSERT
(
*
lO\
lOO\
OOllOl\
O
.
lOlO\
OOO\
l\
OOll
.
llOOOOlOl\
Ol\

==
&
lO\
lO\
OOOll\
OlO
.
lOlOOOOlO\
O\
ll
)
;
*
lOlOOOO\
ll\
OlO
.
lOlOOOOlOOll
.
llOO\
OOlOlOl
=
lOlOO\
OOllO\
l\
O
.
lOlOOOOlOOll
.
llOOO\
O\
lll\
ll
;
}
llO\
OllOlO\
lOl
.
Fr\
ee\

(
&
lOlOO\
OOl\
lOlO\

)
;
}
lO\
lOOOOOOlOl\

*
lOllOlOllOl\
O\

::
lOlOO\
OO\
O\
llll\

(
)
{
lOlOOO\
O\
OOlOl
*
lOlOOO\
OO\
lO\
l\
O
=
llOOllOlO\
lO\
l\

.
Alloc
(
)
;
if
(
!
lOlOOOO\
O\
lOl\
O\

)
ret\
u\
r\
n
0
;
lOlOO\
OOOlO\
lO
->
lOlO\
l\
l\
OO\
Ol
=
0
;
retur\
n\

lOlO\
O\
OO\
O\
l\
OlO\

;
}
void\

lOll\
OlOllO\
lO\

::
lOl\
O\
O\
OOlO\
OOl
(
lOlOOOOOOlO\
l\

*
lOlOOOOO\
lO\
l\
O\

)
{
TA_\
ASSERT
(
lOlOOOOOlOl\
O\

)
;
TA_ASSE\
RT
(
lOlOOO\
OOl\
Ol\
O
->
lOlO\
OO\
OOl\
O\
ll
)
;
TA_AS\
SE\
RT
(
lOlOOO\
OOlO\
lO\

->
lOlOOOOOllOO
)
;
TA_AS\
S\
ERT
(
lO\
lOO\
OOO\
lOlO
->
lOlOOO\
OlOOOO
==
0
)
;
TA\
_ASSERT
(
(
lOl\
OOO\
OOl\
OlO\

->
lOlOl\
lOOOl
&
lOlOOOOOO\
l\
Ol
::
lOlOl\
l\
lOl\
lll
)
==
0
)
;
lOl\
OOOOOl\
OlO
->
lOlO\
llOO\
Ol
|=
lOlOOO\
OOO\
lOl\

::
lOlOlllOlll\
l
;
if
(
lOl\
O\
OOOOl\
OlO
->
lOl\
O\
OOOO\
lO\
l\
l\

->
Get\
Col\
l\
is\
ionOb\
jec\
tCo\
mplex
(
)
==
0
)
llOOlllOlOOl
.
lOO\
lOOOOlOO
(
lO\
lOOOOOl\
OlO
)
;
else
llO\
OlllOlOOl
.
lO\
lOlOOOOl
(
lOl\
O\
OOOOlO\
lO
)
;
}
voi\
d
lOl\
lOlOllOl\
O\

::
ll\
OOll\
lO\
OllO
(
lOlOO\
OOO\
OlO\
l
*
lOlOOOOO\
l\
Ol\
O
)
{
TA_AS\
S\
ERT\

(
lOlOO\
OOOlOlO
)
;
TA_\
ASSERT
(
lO\
l\
OOOOO\
lOl\
O
->
lO\
l\
OOOOO\
l\
Oll\

)
;
TA_\
A\
SSE\
R\
T
(
lOlOOO\
OOlOlO\

->
lOlOOO\
OOll\
OO\

)
;
TA_A\
SSERT
(
lOl\
OOOO\
O\
lOlO
->
lO\
lOOOOlOO\
OO
==
0
)
;
TA_ASS\
ERT
(
(
lOlOOOOOlOl\
O\

->
lOlOll\
OOOl
&
lOlOOOOOO\
l\
Ol
::
lOl\
O\
lll\
Ol\
ll\
l
)
==
0
)
;
ll\
OOlOl\
llOlO
.
lOlOlOO\
OOl
(
lOlO\
O\
OOOlOlO\

)
;
}
lOlOOO\
OO\
Ol\
Ol
*
lOllO\
lOllOlO
::
lOl\
lll\
OlOOlO
(
)
{
lOlOO\
OOO\
OlOl
*
lOlOOOOOlOlO
=
(
lOl\
OO\
OO\
OOl\
O\
l
*
)
ll\
O\
O\
lllOlOOl\

.
lO\
OlO\
OOlllO
(
)
;
if
(
!
lO\
lOO\
OO\
OlO\
l\
O
)
ret\
urn
0
;
TA_\
A\
S\
SE\
RT
(
lOlO\
OOOOlOlO
->
lOlOl\
l\
O\
OO\
l
&
lOlO\
O\
OO\
OOlOl\

::
lOlOll\
l\
Ol\
ll\
l
)
;
lO\
lOOOO\
O\
l\
O\
lO
->
lOlOl\
lOOO\
l
&=
~
lOl\
OO\
O\
OOOlOl\

::
lOlOl\
l\
lOllll\

;
ll\
OOl\
ll\
O\
lOOl
.
lOOll\
ll\
ll\
l\

(
lO\
lO\
OOOO\
lO\
lO
)
;
llOO\
lO\
l\
ll\
OlO
.
lOl\
OlO\
O\
O\
O\
l\

(
lOlOOOOOlO\
lO
)
;
return
lOlOO\
OOO\
lOl\
O\

;
}
lO\
lOOO\
OOOlOl\

*
lOll\
O\
lOl\
l\
Ol\
O
::
lOll\
llO\
lOlOO
(
)
{
retu\
rn
(
lOl\
OOOOOOl\
O\
l
*
)
llOOl\
llOl\
OOl\

.
lO\
Ol\
OOO\
l\
ll\
O\

(
)
;
}
lOlOlllOl\
llO
*
lOllOl\
O\
l\
lOlO
::
llOOlllOO\
OOO\

(
lOl\
O\
l\
ll\
OlllO
*
llO\
OllO\
l\
lll\
O
,
lOlO\
lllOlllO
*
llO\
OllOlllll
)
{
TA_ASSERT
(
ll\
OOllOllllO
)
;
TA_ASSERT
(
llOOll\
O\
l\
lll\
l
)
;
if\

(
llO\
OllO\
llllO
->
llOOlOllOl\
O\
O
+
llOOll\
Olllll
->
llOOlOllOlOO
+
1
>
llO\
Ol\
lOOl\
l\
l\
O
)
{
re\
turn
0
;
}
lO\
l\
O\
l\
llOl\
llO
::
llOO\
OOO\
OllOO
ll\
OO\
lOlllOl\
l
=
llOO\
llOlll\
ll\

->
llOOlOllllOO
.
lOlOOOOl\
OO
(
)
;
while
(
!
llOO\
lOlllO\
ll
.
AtEn\
d
(
)
)
{
Dy\
namicOb\
ject\

*
&
lOlllO\
O\
Oll\
O\

=
*
ll\
OOlOl\
llOll
;
++
llOO\
lOlllOll
;
llOO\
llO\
llll\
l
->
llOOl\
Ollll\
O\
O
.
lOOlllllll\

(
&
lOlllOOOllO
)
;
ll\
O\
O\
llOllll\
O
->
llOOl\
O\
llll\
OO
.
lO\
l\
O\
l\
OOOOl
(
&
lOl\
l\
lO\
OOllO
)
;
if
(
lOl\
llO\
OOllO\

->
lOlOOll\
OOlOl
(
)
==
0
)
lOlllOOOllO
->
Add\
Ref
(
)
;
lOlllOOOllO
->
lOl\
O\
O\
llOOO\
ll
(
llOOll\
O\
l\
l\
ll\
O
)
;
}
llO\
Ol\
lOllllO
->
ll\
OOlOllO\
lO\
O
+=
ll\
OO\
llO\
l\
l\
lll
->
ll\
OOlOllOlOO\

;
llO\
Ol\
lOllll\
O\

->
lO\
llOl\
lll\
ll\
O
(
llOOllOllllO
->
ll\
OOOlOOOl\
lO
(
)
||
llO\
Oll\
Ollll\
l
->
llOOO\
lOOOl\
lO
(
)
)
;
lOlOlllOOO
<
lOl\
OO\
OOOOlOl\

>
::
lOl\
OlllO\
Ol
::
It\
erator
lOl\
lll\
OOOl\
l\
l
=
ll\
OOl\
lOl\
ll\
l\
l
->
llOOlOlllOlO\

.
lOlO\
OO\
Ol\
O\
O\

(
)
;
wh\
ile
(
!
lO\
ll\
llO\
OOlll\

.
AtEnd\

(
)
)
{
lO\
l\
OO\
OOOOlOl\

&
lOlO\
OOOllO\
lO
=
*
lOl\
lll\
O\
OOlll\

;
++
lOllllOOOlll
;
TA_A\
S\
SE\
R\
T\

(
(
lOl\
OOO\
OllOlO
.
lOlO\
llOO\
Ol\

&
lOlOO\
OOO\
OlOl\

::
lO\
lOlllOllll
)
==
0
)
;
ll\
OOl\
lO\
ll\
lll
->
llO\
O\
lOll\
l\
OlO
.
lOO\
lll\
ll\
l\
l\

(
&
lOlOO\
OOl\
lOl\
O
)
;
ll\
OO\
l\
lOllll\
O
->
llO\
OlO\
l\
llOlO
.
lOlOlOO\
O\
Ol\

(
&
lOlOOO\
Ol\
lO\
lO
)
;
TA_ASS\
E\
RT\

(
lOl\
OO\
OO\
llOlO
.
lOl\
OO\
O\
OlOOOO
==
llOOllO\
lll\
l\
l
)
;
TA_ASSERT
(
ll\
OOl\
lOllllO\

)
;
lOlO\
OOOllOlO\

.
lO\
lO\
OOOlOO\
O\
O
=
llOOllO\
ll\
l\
l\
O
;
}
llOOll\
Ol\
llll
->
Fin\
alise
(
)
;
llO\
OllOlOllO
.
lOOllll\
lll\

(
llO\
OllOllll\
l
)
;
llOOllOlOlO\
O
.
Free
(
llOO\
l\
lOllll\
l
)
;
return
llOOllOllll\
O
;
}
lO\
l\
Ol\
l\
lO\
lllO
*
lO\
llOlOllOlO\

::
ll\
OO\
l\
l\
lOOOl\
O\

(
Dy\
nam\
ic\
Obj\
e\
ct\

*
lOlOOOOOlO\
ll
,
Dynam\
ic\
O\
bject\

*
lOl\
OOOOOl\
lOO
)
{
TA_ASS\
E\
RT
(
lOlOO\
OO\
OlOll
||
lOlOOOOOl\
lOO
)
;
lOlOl\
l\
lOll\
l\
O
*
ll\
OOlllOll\
OO
=
llOOl\
lO\
lO\
l\
O\
O
.
All\
oc\

(
)
;
TA_AS\
SERT\

(
llO\
Ol\
llOl\
lOO
)
;
llOOllO\
lOllO
.
lOlOlO\
O\
O\
Ol\

(
ll\
OOlllO\
llOO
)
;
llOO\
l\
llO\
llO\
O
->
In\
i\
tial\
is\
e\

(
lO\
OllOlllOlO
,
this
)
;
if
(
lO\
l\
OOOO\
OlO\
ll
)
llO\
OlllOOOOl
(
lO\
lO\
O\
O\
OOl\
O\
ll
,
llOOl\
llO\
ll\
OO
)
;
if\

(
lOlOOO\
O\
Ol\
lO\
O\

)
llOOlllOOOOl\

(
lO\
lOOO\
O\
O\
llOO\

,
llO\
O\
l\
llO\
llOO
)
;
re\
turn
llO\
Oll\
lOl\
lOO
;
}
in\
line\

vo\
id
lOll\
OlOllOlO
::
llOOl\
llO\
OOOl\

(
Dyna\
mi\
cObject
*
lOlO\
OO\
OO\
l\
Ol\
l
,
lOlOlllO\
ll\
l\
O\

*
llOOlll\
Ol\
lOO
)
{
TA_ASS\
ERT
(
lOlOOO\
OOlOl\
l\

)
;
TA\
_ASS\
ERT
(
!
lOlOO\
OOOlOll
->
InfiniteMass
(
)
)
;
TA_ASSERT
(
!
lOl\
OOOOOl\
Oll\

->
Mov\
emen\
tD\
isabl\
ed
(
)
)
;
Dynamic\
Obje\
ct
*
*
llOOlll\
OllOl
=
llOO\
llOlOO\
ll
.
Allo\
c
(
)
;
TA_\
ASS\
ER\
T\

(
llOO\
l\
l\
lO\
llOl
)
;
*
ll\
O\
OlllO\
llOl
=
lOlO\
O\
OO\
O\
lOll
;
llOOl\
llOllOO
->
llOOlOll\
llO\
O
.
lOlO\
lOOO\
Ol
(
llOO\
ll\
l\
Oll\
Ol
)
;
TA\
_ASSE\
RT
(
lO\
lO\
OOO\
OlO\
l\
l
->
lOlOOllOOlOl
(
)
==
0
)
;
if\

(
lOlOOOOOl\
Oll
->
lOlOOl\
lOO\
lO\
l\

(
)
==
0
)
lO\
lOO\
OO\
Ol\
Ol\
l
->
Ad\
dR\
ef
(
)
;
lOlO\
OO\
OOl\
O\
l\
l
->
lOlO\
O\
llOOO\
ll
(
llOOlllOl\
lOO\

)
;
}
void\

lO\
l\
l\
OlOllO\
lO\

::
ll\
OOlll\
Ol\
llO
(
lO\
lOll\
l\
O\
lll\
O
&
llOO\
lllOlOll\

)
{
lOlO\
ll\
lOOO\

<
lOlOO\
OOOOlOl
>
::
lOl\
OlllOO\
l
::
Iterato\
r
lOl\
l\
llOO\
Olll\

=
ll\
OOl\
l\
l\
OlOl\
l
.
llO\
OlOlll\
Ol\
O
.
lOlOOO\
Ol\
O\
O\

(
)
;
while
(
!
lOl\
ll\
lOOOlll
.
AtEn\
d
(
)
)
{
lOlO\
OO\
OOOlO\
l\

&
lO\
lOO\
OOllOlO
=
*
lOlll\
l\
OOO\
lll
;
++
lOl\
lllOOOl\
ll
;
TA\
_AS\
SERT\

(
lO\
lOOOOllOlO
.
lOlOOOOl\
OOOO
==
&
llOOlllOl\
Oll
)
;
lOlOOOOlllO\
O
(
lOlOOOOl\
lOlO\

)
;
}
}
void
lOllO\
lO\
llOl\
O
::
ll\
OOl\
l\
OOlOO\
l
(
Collis\
ion\

*
llOl\
lOl\
OlOl
)
{
for
(
Colli\
sion
*
lOOOOOO\
llll
=
llOllOl\
Ol\
Ol
;
lO\
O\
OOOOllll
;
)
{
lO\
OOOOO\
llll
=
llOllOl\
O\
lOl
->
GetN\
ext\

(
)
;
llOOl\
lO\
lO\
O\
lO
.
Free\

(
llOllOlOlOl\

)
;
llOOllOOlll\
l
--
;
ll\
OllOlOlO\
l
=
lO\
O\
OOOOl\
lll
;
}
}
}
