//---------------------------------------------------------------------------------
// File Name: zpta025.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#define TA_PHYSICS_INTERNAL
#include "PhysicsJoint.h"
#ifndef TA_DYNAMICOBJECT_H
#include "DynamicObject.h"
#endif //
names\
p\
a\
ce\

TA
{
PhysicsJoint
::
Phys\
icsJoint
(
)
{
lllO\
lOlllO
=
llO\
Oll\
llO\
l\
OO
;
llO\
Ollll\
OlOl
.
Cl\
ea\
r
(
)
;
ll\
OOl\
l\
llOllO
.
Cle\
ar\

(
)
;
llOOll\
llOlll\

=
0
;
ll\
OOll\
ll\
lOOO
=
0
;
llOOlll\
llO\
Ol
.
Cle\
a\
r\

(
)
;
llOOll\
l\
ll\
Ol\
O
.
Cle\
ar
(
)
;
llOOlllllO\
ll
=
0.0f
;
llO\
Olllll\
l\
O\
O
.
Se\
tT\
o\
I\
denti\
ty
(
)
;
llOOllll\
llO\
l
.
Se\
tToI\
d\
enti\
ty
(
)
;
llOOl\
l\
lll\
llO\

.
Cl\
ea\
r
(
)
;
llOOlll\
lllll
.
Cl\
ear\

(
)
;
llO\
l\
OO\
OOOO\
OO
.
Cle\
a\
r
(
)
;
llO\
lOOO\
OOOO\
l\

=
0
;
lOOllO\
ll\
OOOl\

=
0
;
}
Ph\
ysicsJoint
::
~
Physic\
sJoint\

(
)
{
Fina\
l\
ise
(
)
;
}
void\

PhysicsJoin\
t
::
Initiali\
seEule\
rConstraint\

(
const
Vec3
&
lOOO\
Ol\
llll
,
cons\
t
Mat33
&
llOlOOOOOOlO
,
co\
nst
EulerAngl\
es\

&
lOOlllll\
OOll
,
con\
st
Eule\
rA\
ngles\

&
lOO\
l\
llllOlOO
)
{
TA\
_ASSERT
(
ll\
OOllllOl\
ll\

)
;
if
(
llOO\
l\
llllOOO
)
{
Initiali\
s\
e\
EulerConst\
ra\
intEx
(
lOOO\
Ol\
llll\

/
llOO\
llllO\
l\
ll
->
GetFra\
me
(
)
,
lOO\
OO\
ll\
ll\
l
/
llOO\
ll\
l\
l\
lOOO
->
GetFra\
me
(
)
,
llO\
lOOOOO\
OlO\

,
llOOl\
l\
llOlll
->
GetFra\
me
(
)
.
m33R\
otation
,
llOOll\
lllOOO
->
GetFrame
(
)
.
m33Rotation\

,
lOOlllll\
OOll
,
lO\
Olll\
l\
l\
O\
lOO
)
;
}
else
{
Initialise\
Eu\
l\
erCon\
s\
trai\
n\
tEx
(
lOOO\
O\
l\
l\
lll
/
ll\
OOlll\
l\
O\
lll\

->
GetFr\
am\
e
(
)
,
lOO\
O\
O\
ll\
lll
,
ll\
O\
l\
OOOOOO\
lO\

,
llOO\
llllOlll
->
Get\
Frame
(
)
.
m3\
3Ro\
tation
,
k_m33\
Identity
,
lO\
OlllllOOll
,
lOO\
l\
llll\
O\
l\
OO
)
;
}
}
vo\
i\
d
Phy\
sicsJo\
in\
t\

::
In\
i\
ti\
a\
l\
is\
eEul\
erCon\
stra\
i\
ntE\
x
(
co\
nst
Vec\
3
&
llOlOOOOOOll
,
const\

Vec3
&
llO\
l\
OOOO\
OlOO
,
const
Mat\
33
&
llO\
lOOOOOOl\
O
,
const
Mat\
33
&
llOl\
OO\
OOO\
lO\
l\

,
co\
nst
Ma\
t\
33
&
llOl\
OOOOOl\
lO
,
cons\
t
EulerAngl\
es
&
lOOll\
lll\
OOll
,
con\
st
EulerAngles
&
lOOl\
l\
ll\
lO\
lOO
)
{
llOlOOO\
OO\
lll\

=
TYPE\
_EULER_A\
N\
GLE_C\
ONS\
TRAINT\

;
lllOlO\
ll\
lO
=
0
;
ll\
OOllllOlOl
=
llOlOOO\
OOOl\
l
;
llOOl\
lll\
OllO
=
llOl\
OOOOOlOO
;
llOOlll\
l\
l\
l\
OO
=
llOl\
OOO\
OOOl\
O\

/
llO\
lOOO\
OOlOl
;
llOOllllll\
Ol
=
llOlOOOOO\
OlO
/
llO\
lOO\
OO\
Ol\
lO
;
ll\
O\
Oll\
ll\
lllO
=
lOOll\
lllOO\
ll\

;
ll\
O\
Ollllllll\

=
lOOl\
llllOlOO
;
ll\
O\
lOO\
OOOOOO
.
Cle\
ar
(
)
;
lOOllOllll\
ll\

(
)
;
}
void
Physics\
Joi\
nt
::
Initi\
al\
i\
s\
eHing\
e\

(
co\
nst
Ve\
c\
3
&
lOOOOllll\
l
,
co\
n\
st
Ve\
c\
3\

&
ll\
Ol\
OO\
OOlOOO
,
float
lO\
Ollll\
lOlll
,
float\

lOOl\
ll\
l\
llOOO
)
{
lOO\
OOOOll\
O\

(
llOlOOOO\
l\
OOO
.
IsNorm\
a\
li\
s\
ed
(
)
,
"PhysicsJoint::ResetAsTypeHinge. v3HingeAxis isn't normalised.")
;
TA
::
Mat\
33
ll\
O\
l\
OO\
O\
O\
l\
OOl
;
llOlOOO\
Ol\
O\
Ol
.
v3Y
=
ll\
OlOOOOl\
OO\
O
;
int\

lOO\
O\
lO\
OOlO\
O
[
3
]
;
llOlO\
O\
OOlOOO
.
GetAxisOrde\
r
(
lOOOlO\
OO\
lOO
)
;
Vec\
3\

lO\
OOlOO\
OlO\
l
=
Vec3
::
GetUn\
itVect\
or
(
lOOOl\
OOOlOO\

[
2
]
)
;
ll\
O\
lO\
OOOlOOl
.
v3X
=
ll\
OlOOO\
Ol\
OO\
O
.
Cro\
ss\

(
lOO\
O\
lOO\
OlOl
)
;
llO\
lOOO\
Ol\
OO\
l
.
v3X
.
Normalise
(
)
;
llO\
l\
OOOO\
lO\
Ol
.
v3\
Z
=
llOlOOOOl\
O\
Ol
.
v3X
.
Cross\

(
llO\
lO\
OOO\
lOO\
l
.
v3Y\

)
;
In\
i\
ti\
a\
li\
se\
Eule\
rC\
o\
ns\
t\
raint
(
lOOOOll\
lll
,
ll\
O\
lOOOOlOOl
,
EulerAn\
gle\
s
(
0.0f
,
lOOlllllO\
l\
l\
l
,
0.0f
)
,
Eul\
erAn\
g\
les
(
0.0f
,
lOOl\
lllllOOO
,
0.0f
)
)
;
}
vo\
i\
d
Ph\
ysicsJ\
o\
int\

::
In\
it\
ia\
l\
ise\
Hin\
geEx\

(
const
Vec\
3
&
ll\
OlO\
OOOOOll
,
co\
nst
Vec3
&
llO\
lOOO\
OO\
lOO
,
co\
nst
Vec3
&
ll\
Ol\
O\
OOOlO\
OO
,
const\

Vec3
&
llO\
l\
OO\
OO\
lOlO\

,
const\

Ma\
t\
33
&
llOlOOOOO\
lO\
l\

,
const
Mat\
33
&
llOlO\
O\
OOOllO
,
fl\
oa\
t
lOO\
lll\
llOl\
ll\

,
fl\
oat
lOO\
llll\
llOO\
O\

)
{
lOO\
OOOOllO\

(
llOlO\
OO\
Ol\
OOO
.
IsNor\
ma\
lised
(
)
,
"PhysicsJoint::ResetAsTypeHinge. v3HingeAxis isn't normalised.")
;
lO\
OOOO\
OllO
(
ll\
OlOOOOl\
O\
l\
O
.
IsN\
orma\
li\
se\
d
(
)
,
"PhysicsJoint::ResetAsTypeHinge. v3HingeCenterDirection isn't normalised.")
;
TA
::
Mat33
llOlOOOOlOO\
l
;
ll\
O\
lOOO\
Ol\
OO\
l\

.
SetToLo\
o\
kAt
(
llO\
lOOOO\
lO\
lO
,
ll\
OlOOOO\
lOO\
O
)
;
Ini\
ti\
aliseE\
u\
lerConstraintEx\

(
ll\
OlOO\
OOOOll
,
llOlOOOOOl\
OO\

,
ll\
Ol\
OOOOl\
OOl
,
llOl\
OOOOOlOl
,
llOlOO\
OOOllO\

,
TA
::
EulerAn\
gles
(
0.0f
,
lOOllll\
lOlll
,
0.0f
)
,
TA
::
EulerAn\
gle\
s
(
0.0f
,
lO\
OllllllOOO
,
0.0f
)
)
;
lO\
Oll\
Ol\
lll\
ll
(
)
;
}
void
Phy\
si\
c\
sJo\
int
::
Initiali\
seBall\
And\
S\
ocket\

(
const
Ve\
c3\

&
lO\
O\
O\
Olllll
,
con\
s\
t
Vec3\

&
ll\
Ol\
O\
OOOlOll
,
floa\
t
lOOllll\
llOOO\

)
{
TA_A\
SSERT
(
llOOllll\
Oll\
l
)
;
if
(
llO\
Oll\
lllO\
OO
)
{
Init\
i\
aliseBallA\
n\
dSocket\
Ex
(
lOOO\
Olllll
/
llOOll\
ll\
O\
lll\

->
GetFram\
e
(
)
,
lOOOOl\
llll
/
llOO\
llll\
lOOO
->
GetFr\
ame
(
)
,
llOlOO\
O\
OlOl\
l
/
llOOl\
lll\
Ol\
ll
->
Ge\
tFrame
(
)
.
m33R\
otation
,
-
llOlOOOOlOll
/
llOO\
ll\
ll\
l\
O\
O\
O
->
GetFrame\

(
)
.
m3\
3Ro\
tation
,
lOOllllll\
OOO
)
;
}
else
{
InitialiseBallA\
nd\
Sock\
etE\
x\

(
lOOOOll\
ll\
l\

/
llOOllllO\
l\
l\
l
->
GetF\
rame\

(
)
,
lOO\
OOll\
ll\
l
,
ll\
OlOOOOlOll\

/
llOO\
ll\
llOlll
->
Ge\
tF\
ra\
m\
e\

(
)
.
m33Rota\
ti\
on
,
-
ll\
OlO\
OOOlOll
,
lOOll\
lll\
l\
O\
OO\

)
;
}
}
void
PhysicsJoint\

::
Initiali\
seBall\
AndS\
o\
cket\
Ex\

(
co\
nst
Vec\
3\

&
llOlO\
OOOOO\
ll
,
co\
nst\

Ve\
c3
&
ll\
OlOOOOOlOO
,
co\
nst\

Vec3
&
llOlOO\
OOllOO
,
cons\
t
Vec3
&
llOlOOOOllOl
,
flo\
at
lOOl\
l\
l\
lllOOO
)
{
TA_\
ASS\
E\
RT\

(
ll\
O\
O\
llllOll\
l
)
;
llOlOO\
OOOlll
=
TY\
PE_BALL_AN\
D\
_\
S\
OC\
K\
ET
;
lllOlOl\
llO
=
0
;
llOO\
llll\
OlOl\

=
ll\
OlO\
OO\
O\
OO\
ll\

;
llO\
O\
l\
lllOl\
lO\

=
llOl\
OOOOOlOO\

;
llOOl\
llllO\
Ol\

=
llOl\
OO\
OO\
llOO\

;
TA_\
A\
SSE\
RT
(
ll\
O\
O\
lllllO\
Ol
.
IsN\
o\
rma\
l\
i\
s\
ed
(
)
)
;
ll\
OOlllll\
OlO
=
llO\
lOOO\
OllOl
;
TA\
_\
ASSERT
(
llOOl\
llllO\
lO
.
IsNor\
m\
a\
li\
s\
e\
d
(
)
)
;
llOOlllllOl\
l
=
lOOllllllOOO
;
ll\
O\
l\
OO\
O\
OO\
OOO
.
Cle\
ar\

(
)
;
lOOll\
Ollllll
(
)
;
}
vo\
id
Phy\
si\
cs\
J\
oint\

::
InitialiseLi\
mitedBal\
lAn\
dSoc\
k\
e\
t
(
const
Vec3
&
lOO\
O\
O\
l\
llll\

,
co\
nst
Mat33
&
llOlOOOO\
O\
OlO
,
float
lOOll\
l\
lllO\
l\
l
,
flo\
at
lOOlllllllOO
)
{
TA_AS\
S\
ERT
(
llOOll\
ll\
Olll\

)
;
if
(
llO\
Ollll\
lOO\
O
)
{
Initialise\
L\
im\
ite\
d\
B\
allAndS\
ocket\
Ex
(
lOOOOl\
llll
/
llO\
O\
ll\
l\
lOlll
->
Get\
F\
r\
am\
e\

(
)
,
lOOOOl\
ll\
ll\

/
ll\
OOllll\
lO\
OO
->
Get\
F\
rame
(
)
,
llO\
lOOOOOOlO\

,
llOOl\
lllOlll\

->
GetFr\
a\
me\

(
)
.
m33R\
o\
t\
ation
,
llO\
OlllllOO\
O
->
GetFram\
e\

(
)
.
m33R\
otat\
i\
on
,
lOOll\
lll\
lOll
,
lOOl\
llll\
l\
lO\
O\

)
;
}
else\

{
Initialise\
LimitedBa\
ll\
A\
ndSo\
ck\
etEx
(
lOOOO\
lllll
/
ll\
O\
OllllOlll
->
GetFr\
a\
me
(
)
,
lO\
OOOlll\
l\
l\

,
llOlOO\
OOOO\
l\
O
,
llOOl\
lllO\
lll
->
Ge\
tFrame\

(
)
.
m33Rota\
t\
i\
on
,
k_m33\
I\
dentity
,
lOOllllllOl\
l
,
lOO\
l\
llll\
l\
l\
OO
)
;
}
}
voi\
d
Phys\
icsJoint
::
Initialis\
eLi\
mi\
te\
d\
Ba\
llAnd\
SocketE\
x
(
co\
ns\
t
Vec3
&
llOlOO\
OOOO\
ll\

,
const\

Vec\
3
&
llOl\
OOOOOlOO
,
co\
ns\
t
Mat3\
3
&
llOl\
O\
O\
OOOOlO
,
const
Mat3\
3
&
llOlOOOOOlOl
,
con\
st
Mat33
&
llOlOOOO\
OllO
,
fl\
oat\

lOO\
llllllOll
,
fl\
o\
at
lOOlllll\
llOO
)
{
llO\
l\
OOOOOlll
=
TYP\
E_L\
IMITED_B\
ALL_AND_\
S\
OCKET
;
lllOlOll\
lO\

=
0
;
llOOlll\
lO\
lOl
=
llOlOOO\
O\
O\
Ol\
l
;
llOOl\
lllOl\
lO\

=
llOlOOOOO\
l\
O\
O
;
llOO\
l\
lll\
llOO
=
llOlO\
OOO\
O\
O\
l\
O
/
llOlOO\
OOO\
l\
O\
l
;
llO\
O\
ll\
llll\
O\
l
=
ll\
OlO\
OO\
OOO\
lO
/
ll\
OlOOOOO\
llO
;
llO\
OlllllllO
.
Cl\
ea\
r
(
)
;
llOOll\
lll\
llO\

.
x
=
-
lOO\
l\
l\
ll\
lllOO
;
llOOlll\
llllO
.
y
=
-
lOOl\
lllllOll
;
llOOll\
ll\
ll\
ll\

.
Cle\
ar
(
)
;
ll\
O\
Ol\
llllll\
l
.
x
=
lOO\
lllllll\
OO
;
ll\
OOlll\
llll\
O\

.
y
=
lO\
Ollll\
llOl\
l
;
llOl\
OO\
OO\
OOOO\

.
Clear
(
)
;
lO\
Oll\
Ollll\
ll
(
)
;
}
voi\
d\

PhysicsJoin\
t
::
Init\
ialiseS\
qua\
reSocket
(
con\
st
Ve\
c3
&
lOOOOllll\
l
,
cons\
t
Mat3\
3
&
llOl\
OOOOO\
O\
l\
O
,
fl\
oat
lOO\
l\
l\
lllllO\
l
,
floa\
t
lO\
Ol\
llll\
lllO
,
fl\
oat
lO\
Olllllllll
,
float
lOlOOOOOO\
OOO\

,
float\

lOlO\
O\
OOO\
OOOl
,
fl\
oat
lOlOO\
OOO\
O\
O\
l\
O\

)
{
TA_A\
SSERT\

(
llO\
OllllOl\
l\
l
)
;
if
(
llOOl\
l\
l\
llOOO
)
{
Initialis\
eSquare\
So\
cketEx
(
lOOOO\
ll\
l\
ll
/
ll\
OO\
lll\
lOll\
l
->
Get\
Fr\
ame
(
)
,
lOOO\
Ol\
ll\
ll
/
llO\
O\
l\
ll\
llO\
OO
->
GetFr\
am\
e
(
)
,
llOlOO\
OOO\
OlO
,
llOO\
llll\
O\
ll\
l\

->
Ge\
tFr\
a\
me\

(
)
.
m33Rotat\
io\
n
,
llO\
OlllllOOO
->
Get\
Fr\
am\
e\

(
)
.
m3\
3Rota\
t\
io\
n\

,
lOOll\
ll\
lllOl
,
lOOllllllllO
,
lO\
O\
llllll\
l\
ll
,
lO\
lOOOOOOO\
O\
O
,
lOlOO\
OOO\
OO\
O\
l
,
lOlOOO\
OOOO\
lO\

)
;
}
el\
se
{
Initialis\
eSquar\
e\
So\
cketE\
x
(
lOO\
OO\
ll\
ll\
l\

/
llOOl\
lll\
O\
lll
->
GetFra\
me
(
)
,
lOO\
OOlllll
,
llOlOOOOOOlO\

,
ll\
OOllllO\
ll\
l\

->
GetFra\
me
(
)
.
m3\
3R\
ot\
a\
tio\
n
,
k_\
m33\
I\
den\
tit\
y
,
lOOllll\
lllOl
,
lOOll\
llll\
ll\
O
,
lOOllll\
llll\
l
,
lO\
lOOOOOOO\
OO
,
lOl\
OOOOOO\
OO\
l
,
lO\
lOOOOO\
OO\
lO
)
;
}
}
void
Ph\
ysic\
sJ\
o\
int
::
InitialiseSquare\
Sock\
etEx
(
const\

Vec3
&
llOlOOOOOOl\
l\

,
co\
ns\
t\

Ve\
c\
3
&
ll\
OlOOO\
OOlO\
O
,
const
Ma\
t\
33
&
ll\
OlOOOOOOlO
,
cons\
t
Mat33
&
ll\
OlOOOOO\
l\
Ol\

,
const
Mat33\

&
llOlOO\
O\
OOllO
,
float
lO\
Olll\
llllOl\

,
fl\
oat\

lOO\
lll\
lll\
llO
,
flo\
at
lOOlllll\
llll
,
float\

lOl\
OOOOOO\
O\
OO
,
flo\
at
lOlO\
OOOOOO\
Ol\

,
fl\
oat
lOl\
OO\
OOO\
O\
OlO\

)
{
llO\
l\
OOO\
OOll\
l
=
TYPE_S\
QUARE_SO\
CK\
ET
;
lllOl\
Ol\
ll\
O
=
0
;
ll\
OOllllOl\
Ol
=
llOlO\
O\
OO\
OOll
;
llOOll\
ll\
Oll\
O\

=
llOlOOOOO\
lOO
;
llOOlll\
ll\
l\
OO\

=
ll\
O\
l\
OO\
OO\
O\
O\
l\
O\

/
llOl\
OOOO\
OlOl
;
llOO\
llllllOl
=
llOlOOOOOOl\
O
/
llOl\
O\
OOOOllO
;
llOOll\
lll\
ll\
O\

.
In\
itialise\

(
lO\
Olllll\
l\
lOl
,
lOOll\
l\
ll\
llll
,
lOl\
OOOO\
OO\
OOl
)
;
ll\
OOlllll\
l\
ll\

.
Init\
ialise\

(
lOO\
l\
lll\
ll\
l\
l\
O
,
lOl\
OOOOOO\
OOO
,
lOlOO\
OOOOO\
lO
)
;
const
float
ll\
OlOOOOll\
lO\

=
0.01f
;
if\

(
llOO\
l\
l\
l\
l\
lllO
.
x
>
-
llOlOOOO\
lll\
O\

)
ll\
O\
Olll\
lll\
lO
.
x
=
-
llOlOOOOl\
ll\
O
;
if\

(
llOO\
lllll\
lll
.
x
<
llO\
l\
O\
OOOll\
l\
O
)
llO\
Olll\
lllll
.
x
=
llO\
lOOO\
OlllO
;
if
(
llOOlllllllO
.
y
>
-
llOlOOO\
Oll\
lO\

)
llOOl\
l\
lllll\
O
.
y
=
-
llO\
lOOOOl\
llO
;
if
(
llO\
O\
lll\
lllll\

.
y
<
llOlOO\
OOl\
llO
)
llOOl\
l\
ll\
l\
lll\

.
y
=
llOl\
OOOO\
l\
llO
;
if
(
llO\
Ol\
llllllO\

.
z
>
-
llOlOOOO\
lllO
)
ll\
O\
O\
l\
lllll\
lO
.
z
=
-
llOlOOOO\
lll\
O\

;
if
(
llOO\
l\
ll\
l\
l\
lll
.
z
<
llO\
lOOO\
O\
lll\
O\

)
llOOll\
l\
l\
llll
.
z
=
llOlOO\
OOlll\
O
;
llOl\
OOOOO\
OOO
.
Cle\
ar
(
)
;
lOOl\
lOl\
lll\
ll
(
)
;
}
void\

Ph\
ysic\
sJo\
int
::
Init\
i\
aliseSlider
(
co\
nst\

Ve\
c3
&
lllOOO\
lOO\
Ol\

,
co\
n\
s\
t
Vec3
&
llOl\
OOOOl\
ll\
l
,
cons\
t
Vec3
&
llOl\
OOOlOO\
OO
)
{
TA_\
ASSE\
R\
T
(
llO\
OllllOl\
ll
)
;
if
(
llO\
OlllllO\
OO
)
{
Initialise\
Sli\
derEx\

(
lllO\
OOlOOOl\

/
llO\
Ollll\
O\
ll\
l
->
Ge\
tFram\
e
(
)
,
llOlO\
OO\
Ollll
/
llOO\
l\
llll\
O\
OO
->
GetF\
r\
a\
m\
e
(
)
,
llO\
lOO\
O\
lOOO\
O
/
llOOlllllOOO
->
GetF\
ram\
e\

(
)
)
;
}
el\
se
{
Ini\
tialiseSliderEx
(
lllOOOlOOOl
/
ll\
OO\
ll\
llOll\
l
->
GetFra\
me
(
)
,
ll\
OlOO\
O\
Ollll\

,
ll\
O\
lOOOl\
OO\
OO\

)
;
}
}
vo\
id\

Phy\
sic\
sJo\
i\
nt\

::
Initialise\
SliderEx
(
co\
n\
st
Vec3
&
ll\
Ol\
O\
OOO\
OO\
l\
l
,
cons\
t\

Ve\
c3
&
llOl\
O\
OOlOOOl
,
const\

Vec\
3\

&
llOlOOOlOOlO
)
{
llOlOOOO\
O\
lll
=
TYPE_LIN\
E\
AR_SLID\
ER
;
lllO\
lOlll\
O\

=
0
;
ll\
OOll\
llOl\
Ol
=
ll\
OlOOO\
O\
OO\
ll
;
ll\
OO\
l\
lllOllO
=
llOlOO\
O\
lOOOl\

;
ll\
OO\
llll\
lOOl
=
ll\
OlO\
O\
Ol\
OOlO
;
lOOl\
lOlllll\
l\

(
)
;
}
voi\
d
PhysicsJo\
i\
nt\

::
Initial\
iseRo\
tation\
Constr\
ai\
nt
(
const
Mat33
&
llOl\
OOO\
OO\
O\
lO
,
co\
n\
st
Eul\
erAngl\
es\

&
lOO\
lllll\
OOl\
l
,
con\
st
Eu\
l\
er\
Angl\
es
&
lOOlll\
l\
lO\
lOO
)
{
TA_ASSER\
T\

(
llO\
O\
llllO\
lll
)
;
if
(
llOOlllllOOO
)
{
In\
itiali\
s\
eRotationCon\
s\
tr\
ai\
nt\
E\
x
(
llOl\
OO\
OO\
O\
O\
l\
O
,
llOOllllO\
l\
ll
->
Get\
F\
ra\
me\

(
)
.
m33Rotation\

,
llOO\
ll\
l\
llO\
OO
->
GetF\
r\
a\
m\
e
(
)
.
m33R\
otat\
i\
on
,
lOOlllllOOll
,
lOOlllllOlOO\

)
;
}
else
{
In\
itial\
iseRotatio\
nConstr\
ai\
n\
tE\
x
(
llOlO\
O\
OO\
O\
Ol\
O\

,
llOOllll\
Ol\
ll\

->
Get\
Fr\
ame
(
)
.
m33Ro\
tat\
ion
,
k_m33Ident\
ity
,
lOOlllllOOll
,
lOOll\
l\
llOlOO
)
;
}
}
void
Ph\
ys\
i\
csJ\
oint
::
In\
it\
i\
al\
ise\
Rotat\
ionCo\
nstraintEx
(
con\
st
Mat3\
3
&
llOlOOOOOOl\
O
,
cons\
t
Mat33
&
llOlOOOOOlOl\

,
const
Mat\
3\
3
&
llOlOO\
OOOl\
l\
O\

,
const
Euler\
Angles
&
lO\
OlllllO\
Oll
,
co\
ns\
t
Eul\
er\
Angl\
e\
s
&
lOOlllllO\
l\
OO
)
{
llO\
lO\
OOO\
O\
lll
=
TY\
PE\
_R\
OTA\
TIO\
N_CONST\
RAI\
NT
;
lllOl\
Ol\
llO
=
0
;
llOOll\
llOlOl\

.
Clear\

(
)
;
llOOl\
l\
ll\
O\
llO
.
Cle\
ar
(
)
;
ll\
OO\
l\
lll\
l\
lO\
O
=
llOlOOOOOOlO
/
ll\
Ol\
O\
O\
O\
OOlOl\

;
ll\
OOllllllOl
=
llOlOOOO\
OO\
lO
/
ll\
O\
lOOOOOllO
;
llO\
Olll\
lll\
lO
=
lOO\
llll\
l\
O\
Oll
;
llO\
Ol\
l\
l\
lllll\

=
lO\
O\
ll\
lllOlOO
;
ll\
O\
lOOOOO\
OO\
O\

.
Clear
(
)
;
lO\
OllOllllll
(
)
;
}
voi\
d\

PhysicsJo\
int\

::
Initiali\
se\
Vector\
Constraint
(
const
Ve\
c3
&
llOlOOO\
O\
lOll
,
float
lO\
Ol\
l\
lll\
lOO\
O\

)
{
TA_ASSERT
(
llOO\
lll\
lOlll
)
;
if
(
ll\
O\
Oll\
lllOOO
)
{
Init\
ia\
lis\
e\
Vecto\
rC\
on\
straintEx
(
llOlOOO\
OlOll\

/
ll\
OOllll\
Oll\
l
->
Ge\
tFra\
m\
e\

(
)
.
m33R\
ot\
ation
,
llOlOOOOl\
Oll
/
llOO\
l\
llll\
OOO
->
Get\
Frame
(
)
.
m3\
3Ro\
ta\
tion
,
lOOllllllOO\
O
)
;
}
el\
se\

{
Ini\
t\
ialiseVectorC\
onstr\
ain\
t\
Ex
(
llOl\
OOO\
OlOll\

/
llOOl\
ll\
lOll\
l\

->
GetFra\
me
(
)
.
m33Ro\
tat\
ion
,
ll\
O\
l\
O\
OOO\
lOll
,
lOOllllllO\
OO
)
;
}
}
vo\
id
Physic\
sJ\
oin\
t
::
Initialis\
eV\
ectorC\
ons\
t\
r\
ai\
ntE\
x
(
const
Vec3
&
ll\
OlOOO\
Ol\
l\
OO\

,
co\
nst
Vec3
&
ll\
OlOOO\
OllOl
,
floa\
t
lOOl\
ll\
ll\
l\
O\
OO
)
{
ll\
OlOOOOO\
lll\

=
TY\
P\
E_VEC\
TOR_C\
O\
NSTRAINT
;
lllO\
l\
OlllO
=
0
;
ll\
OOllllO\
lO\
l
.
Cl\
ear
(
)
;
llO\
OllllOllO\

.
Clear
(
)
;
llOOl\
l\
ll\
lOOl
=
llOlOOOOll\
OO
;
TA_ASSERT
(
ll\
OOl\
llllO\
Ol
.
IsNormalise\
d
(
)
)
;
llOO\
ll\
l\
llOlO
=
ll\
OlOOOOllOl
;
TA_\
ASSERT
(
llOOlllllOlO
.
IsNor\
malised\

(
)
)
;
llOOllll\
lOll
=
lO\
Oll\
lll\
lOO\
O
;
llOlOO\
OOOOOO
.
Clear
(
)
;
lO\
OllO\
l\
lllll
(
)
;
}
void
Ph\
y\
s\
i\
c\
s\
J\
o\
int
::
Rese\
t
(
const\

Vec\
3
&
ll\
l\
OOOlOOOl
,
const\

Vec\
3
&
lllOO\
OlOOOO
,
co\
ns\
t
Ma\
t33
&
llOl\
OOO\
lO\
Oll
,
const\

Eu\
ler\
A\
ngles\

&
lO\
OlllllOOll
,
cons\
t\

Euler\
A\
ngles
&
lOOlllllOlO\
O\

)
{
ll\
OlOOOOOlll
=
TYPE_\
EULE\
R_ANG\
LE_CO\
NSTRAINT
;
lllOlO\
l\
l\
lO
=
0
;
llO\
Ol\
lllOlO\
l
=
lllOO\
OlO\
OOl
;
llO\
Olll\
lO\
llO
=
lllOOO\
lOO\
OO\

;
llOOlll\
lllO\
O\

=
llOl\
OOOlOO\
ll\

;
llO\
Oll\
ll\
l\
lOl\

=
llOlOOOlOOl\
l\

;
llOOl\
ll\
ll\
llO\

=
lOOlllll\
OOll
;
ll\
OOl\
l\
llllll
=
lO\
O\
l\
lll\
l\
O\
lO\
O
;
ll\
OlOOOO\
OOOO\

.
Clear
(
)
;
lOOllOll\
ll\
ll
(
)
;
}
void
Phy\
sicsJoin\
t
::
ResetA\
sT\
yp\
eHin\
ge\

(
cons\
t
Vec\
3
&
lll\
OOOl\
OO\
Ol\

,
const
Vec3
&
lllO\
O\
OlOOO\
O
,
const
Vec3
&
llOlOOOlOlOO
,
con\
st\

Ve\
c\
3
&
llOlOO\
OlOlO\
l
,
fl\
oat
lO\
Olll\
l\
l\
Ol\
ll
,
float
lOO\
l\
lllll\
OOO\

)
{
lOOOOOO\
llO\

(
llOlOOOl\
O\
lOO
.
Is\
Norm\
a\
lised
(
)
,
"PhysicsJoint::ResetAsTypeHinge. v3HingeAxis isn't normalised.")
;
lOOOOOO\
llO
(
llOlOOO\
lOlOl
.
IsNormalised\

(
)
,
"PhysicsJoint::ResetAsTypeHinge. v3HingeNormal isn't normalised.")
;
TA
::
Mat33
llO\
l\
OO\
O\
O\
lO\
Ol
;
llOlOOOOlOO\
l
.
SetToLo\
o\
kA\
t
(
ll\
OlOOO\
lOl\
Ol\

,
llOl\
O\
OOlOlO\
O
)
;
Reset\

(
lllOOO\
l\
OOOl
,
lll\
OOOlO\
O\
O\
O
,
llOlOOO\
O\
lOOl
,
TA\

::
Eule\
rAng\
l\
es
(
0.0f
,
lO\
Oll\
l\
llOlll
,
0.0f
)
,
TA
::
Eule\
rA\
ngl\
es
(
0.0f
,
lOOllllllOO\
O
,
0.0f
)
)
;
lOOllO\
l\
lllll
(
)
;
}
void
Phys\
i\
csJoin\
t\

::
Re\
s\
etAs\
T\
ypeSocket
(
const
Vec3
&
lll\
OO\
OlOOOl
,
co\
n\
st
Vec3
&
lllO\
OOlOOOO
,
con\
st\

Vec3
&
llOlOO\
O\
lOll\
O
,
cons\
t
Vec3
&
llOlO\
OOlO\
ll\
l
,
float\

lO\
Ollll\
llO\
O\
O
)
{
ll\
OlO\
OO\
O\
O\
l\
ll
=
TYPE_BALL_AND_SOCKE\
T\

;
lll\
OlOll\
lO\

=
0
;
llO\
Oll\
l\
lOlOl
=
lllOO\
OlOOOl
;
llOO\
ll\
llO\
llO
=
lllO\
OOl\
OOOO\

;
llO\
O\
lllllOOl
=
ll\
OlOOOlO\
l\
l\
O\

;
TA\
_\
ASS\
E\
RT
(
ll\
OO\
lllll\
O\
Ol\

.
Is\
Normali\
sed\

(
)
)
;
llOO\
lllllOlO
=
llO\
l\
OO\
OlOll\
l
;
TA\
_A\
SS\
ERT
(
llOOlllllOl\
O
.
Is\
Normalised
(
)
)
;
llOOll\
lllOll
=
lOO\
l\
ll\
l\
l\
lOOO
;
llOlO\
O\
OOOO\
O\
O
.
Cle\
ar
(
)
;
lOOl\
lOlllll\
l
(
)
;
}
void
PhysicsJoint
::
ResetAsTy\
peLimit\
e\
dS\
ocke\
t
(
con\
s\
t
Vec3
&
lllOO\
O\
lOOOl
,
const
Vec\
3
&
lllOOOlOOOO
,
const
Mat\
33
&
llO\
lOOO\
l\
OOl\
l
,
floa\
t
lO\
Oll\
llll\
Ol\
l\

,
float\

lOOlllll\
l\
l\
OO\

)
{
ll\
OlOOOOO\
lll\

=
TYPE_LIM\
IT\
E\
D_BALL_AN\
D_S\
OC\
K\
ET
;
lll\
OlO\
l\
llO
=
0
;
ll\
OO\
llllOlO\
l
=
lll\
OOO\
lOO\
Ol\

;
llOOllllOllO
=
ll\
l\
O\
OO\
lOO\
OO
;
ll\
O\
Ol\
l\
llllOO
=
llO\
lOO\
Ol\
O\
Ol\
l\

;
llOOlll\
l\
llOl
=
llOl\
O\
O\
OlOOll
;
llO\
OlllllllO\

.
Cl\
ear
(
)
;
ll\
OOlllll\
l\
lO
.
x
=
-
lOOll\
lllllOO
;
llO\
Oll\
lllllO
.
y
=
-
lO\
OllllllOl\
l\

;
llO\
Ol\
ll\
l\
l\
lll
.
Clea\
r\

(
)
;
llO\
Oll\
l\
llll\
l\

.
x
=
lO\
O\
llll\
ll\
lOO\

;
ll\
OOl\
llllllO\

.
y
=
lOO\
l\
l\
l\
l\
l\
lOll
;
llO\
lOOO\
OO\
OOO
.
Cl\
e\
ar\

(
)
;
lOOllOl\
lllll
(
)
;
}
voi\
d
Physics\
Jo\
in\
t
::
ResetA\
sT\
yp\
eSqu\
a\
reSocket\

(
const
Ve\
c\
3
&
lllO\
OO\
l\
OOO\
l
,
co\
n\
st\

Vec\
3
&
lll\
O\
OOl\
OOOO
,
con\
s\
t
Mat33\

&
llOlOO\
OlOOll
,
fl\
oat
lO\
Ol\
ll\
llll\
Ol
,
float\

lOOlll\
lll\
llO
,
flo\
at
lOOll\
l\
lllll\
l
,
floa\
t
lO\
lOO\
OOO\
OO\
OO
,
float\

lOlO\
OOOOOOOl
,
fl\
o\
at\

lOlOOO\
OO\
OO\
lO
)
{
llOl\
OO\
OO\
O\
l\
ll
=
TYPE\
_SQUAR\
E_SO\
CK\
ET
;
lllO\
l\
Ol\
llO\

=
0
;
llOO\
l\
l\
l\
lOl\
Ol
=
lllO\
OOlOOOl
;
llO\
Ol\
ll\
lOl\
lO
=
lll\
OO\
OlO\
OO\
O
;
llO\
Ol\
lll\
llOO
=
llO\
lOOOlOOll
;
llO\
O\
l\
ll\
lllO\
l
=
llOlOOOl\
OO\
l\
l\

;
llO\
Olll\
l\
ll\
lO\

.
Init\
i\
a\
l\
ise
(
lO\
Ollll\
lllOl
,
lOOllll\
l\
llll\

,
lOlOOOOOOOOl
)
;
llOOlll\
l\
llll
.
Initialis\
e
(
lO\
Ollllll\
llO\

,
lO\
lOOOO\
OOOO\
O
,
lO\
lOOOOO\
OOl\
O
)
;
co\
nst
float\

llOlOOOO\
lllO\

=
0.01f
;
if
(
llOOl\
llll\
l\
lO\

.
x
>
-
llOl\
OO\
OO\
lllO
)
llOOlllllllO
.
x
=
-
ll\
Ol\
OOOOll\
lO
;
if
(
ll\
O\
O\
lllllll\
l\

.
x
<
llOlOOOOlllO\

)
ll\
OOlll\
lll\
ll
.
x
=
llO\
lO\
OOOlllO
;
if
(
ll\
OO\
llllll\
lO
.
y
>
-
llOlOOO\
Oll\
l\
O
)
llOO\
lllllllO
.
y
=
-
llOlO\
OOOl\
llO
;
if
(
llOOllllll\
ll
.
y
<
llOlO\
OOOlllO\

)
llO\
Ollllllll
.
y
=
ll\
OlOOOOlllO
;
if
(
llOOl\
lll\
lllO
.
z
>
-
llO\
lO\
OO\
Oll\
lO
)
ll\
OO\
lllllll\
O
.
z
=
-
llOlOOO\
Ol\
llO
;
if
(
ll\
OOllll\
lll\
l
.
z
<
llO\
lOOOO\
l\
llO\

)
llOOlll\
l\
llll
.
z
=
llO\
l\
OOO\
O\
lllO
;
llOlOOOO\
O\
OOO\

.
Clear\

(
)
;
lOO\
llOllllll
(
)
;
}
void\

PhysicsJoint
::
ResetAsTyp\
eSlid\
er\

(
const
Vec\
3\

&
lllO\
OOl\
OO\
Ol
,
const
Vec\
3
&
llOl\
OOOOl\
l\
ll
,
con\
st
Vec\
3
&
ll\
OlO\
O\
OlOOOO
)
{
llO\
lOOOOO\
l\
ll
=
TYPE_\
LINEAR_\
SLI\
DE\
R
;
lll\
OlOl\
l\
l\
O
=
0
;
llO\
Oll\
l\
lO\
lOl
=
lll\
OOOlOOO\
l
;
ll\
OOllll\
OllO\

=
llOl\
OOOOll\
ll
;
llOOlll\
l\
lOOl
=
llOlOOOl\
O\
OOO
;
lOOllO\
ll\
lll\
l
(
)
;
}
voi\
d
Physic\
sJoint
::
Re\
set\
AsTypeRotationC\
o\
n\
st\
rai\
nt
(
co\
n\
st\

Ma\
t\
33
&
llO\
l\
OOOlOO\
l\
l
,
co\
nst
Eul\
er\
Angl\
e\
s
&
lOOlll\
llO\
Oll\

,
co\
nst
Eul\
e\
rAng\
le\
s
&
lO\
O\
lll\
ll\
OlOO\

)
{
ll\
Ol\
OO\
OOOlll
=
TY\
PE_ROTATI\
ON_\
C\
ONS\
TRAI\
NT
;
ll\
lOlOlll\
O
=
0
;
llOOlll\
lOlO\
l
.
Cle\
a\
r
(
)
;
llOO\
llllO\
ll\
O
.
Cle\
a\
r
(
)
;
llOOllllllOO
=
llOlOOOl\
OO\
l\
l
;
llOO\
lllll\
l\
Ol
=
ll\
Ol\
OOOlOOll
;
llO\
Ollll\
ll\
l\
O
=
lOO\
l\
llll\
OO\
ll
;
llOOl\
lll\
llll
=
lOOll\
l\
ll\
OlOO
;
llO\
l\
OO\
OOOO\
O\
O
.
Cl\
ear
(
)
;
lO\
OllOllll\
ll
(
)
;
}
vo\
id
Phy\
s\
i\
csJoint
::
Re\
se\
tAs\
Type\
Vector\
C\
on\
s\
tra\
i\
nt
(
cons\
t
Vec3\

&
llO\
lOOOlO\
llO
,
co\
ns\
t
Vec3
&
ll\
Ol\
OOOlOlll
,
float
lOOl\
lll\
llO\
OO
)
{
llOlOOOOOlll
=
TYPE_\
VEC\
TO\
R_CON\
STRA\
I\
N\
T
;
lllOlOlllO
=
0
;
llOOllllOlOl
.
Clear
(
)
;
ll\
OOll\
l\
lOllO\

.
Clear
(
)
;
llOO\
ll\
lllOOl
=
llOlOOOlO\
llO
;
TA_ASSERT
(
llO\
Ollll\
lO\
Ol
.
IsNor\
mali\
se\
d
(
)
)
;
ll\
OOllll\
l\
OlO
=
ll\
OlOOO\
l\
Olll
;
TA_\
ASS\
ERT\

(
llOO\
ll\
lllOlO
.
IsNorma\
lised
(
)
)
;
llOOlllll\
Oll
=
lOOllll\
llO\
OO
;
llOlOOOO\
OOOO
.
Cle\
ar
(
)
;
lOOllOll\
llll
(
)
;
}
fl\
oat
Ph\
ysicsJ\
oint\

::
llOl\
OOOllOOO
(
Ve\
c3
&
llO\
l\
OOO\
llOO\
l
,
Ve\
c3
*
lO\
lOllll\
llOl
)
{
fl\
oa\
t
lOO\
OOl\
lO\
OOl
;
fl\
o\
at
lOO\
OOl\
l\
OO\
lO\

;
Sin\
And\
C\
os\

(
GetM\
in\
Angles
(
)
.
x
,
lOO\
OOllO\
OOl
,
lOO\
OO\
llOOl\
O
)
;
Vec\
3
lO\
l\
llllll\
lOl
(
0.0f
,
lO\
OOOllOOlO
,
lOOOO\
ll\
OO\
Ol\

)
;
SinAndCo\
s
(
GetMaxAng\
le\
s
(
)
.
x
,
lOO\
OO\
l\
lOOOl\

,
lOOOOl\
lOOl\
O
)
;
Vec\
3
lOllll\
lllllO\

(
0.0f
,
lOOOOllOO\
lO\

,
lO\
OOOllOOOl\

)
;
SinAndCos
(
GetM\
inA\
ngles
(
)
.
z
,
lOOO\
OllO\
OOl\

,
lO\
OOOllO\
OlO
)
;
Ve\
c3
lOll\
lll\
lll\
ll
(
lO\
O\
OOllOOOl\

,
lOOO\
Ol\
lOO\
l\
O
,
0.0f
)
;
SinAnd\
C\
os
(
GetM\
a\
xAngl\
es
(
)
.
z
,
lOOOOl\
lOOOl
,
lOOOOllOO\
l\
O
)
;
Vec\
3
llOOOOOOOO\
OO
(
lOOOOllOO\
Ol
,
lOO\
OOllO\
O\
l\
O
,
0.0f
)
;
Vec3
lOOOl\
OO\
OOll
=
llOlOOOllOO\
l
;
Vec\
3
ll\
OlOOOl\
lOlO
[
4
]
;
llOl\
OOOll\
OlO\

[
0
]
=
lOl\
lllll\
lll\
O
.
Cros\
s
(
llOOOO\
O\
O\
OO\
O\
O
)
;
llO\
l\
OO\
O\
llOlO\

[
1
]
=
llOOOO\
OOO\
OO\
O
.
Cross\

(
lO\
llllllllOl
)
;
ll\
OlOOOll\
OlO\

[
2
]
=
lOll\
l\
lllll\
Ol\

.
Cross
(
lOlllllll\
l\
ll
)
;
llO\
l\
OO\
O\
llO\
l\
O
[
3
]
=
lO\
lllll\
lllll
.
Cro\
ss
(
lOlllll\
llllO
)
;
const
floa\
t
llOlOOOllOll
=
0.01f
;
float\

llO\
lOOOl\
llOO
=
lOO\
OlOOO\
Oll
.
Dot
(
llOlOOO\
llOlO
[
0
]
)
;
flo\
a\
t
llOl\
OOOl\
llOl
=
lOOOlOO\
OOll\

.
Dot
(
llOlO\
OOllO\
lO
[
1
]
)
;
float
llOl\
OOOll\
llO
=
lO\
OOlOOOO\
ll
.
Dot
(
llO\
lOOOl\
l\
OlO
[
2
]
)
;
float
llOlOO\
Ol\
l\
ll\
l
=
lOO\
OlOO\
O\
Oll
.
Dot\

(
ll\
OlO\
OO\
llOlO
[
3
]
)
;
int
llOlOOl\
OOOOO
=
0
;
int
llO\
lOOlO\
OOOl\

=
-
1
;
float
lOOO\
llOOll\
OO
=
llO\
lO\
OOll\
lOO
;
float\

lO\
O\
Oll\
O\
OllOl
=
k_fMaxFlo\
at
;
if\

(
lOO\
O\
llOOllOO
>
ll\
Ol\
OO\
OlllOl
)
{
llOl\
OOlO\
OOOl
=
ll\
OlOOlO\
OOOO\

;
llOlOOlOOOOO
=
1
;
lOOOll\
OOll\
Ol
=
lO\
O\
Oll\
OOllOO
;
lOO\
Oll\
OOllOO\

=
ll\
O\
lOOO\
lllO\
l
;
}
el\
s\
e
if
(
lOOOl\
lO\
OllOl
>
llOl\
O\
O\
OlllOl
)
{
llO\
lOO\
lOOOOl
=
1
;
lOOO\
llOOllOl\

=
llOl\
O\
OOlll\
Ol
;
}
if\

(
lOO\
Oll\
OOllO\
O\

>
ll\
OlO\
OOll\
llO
)
{
llOlOOlOOOOl
=
llOlOOlOOOOO
;
llO\
lOOl\
OO\
OO\
O\

=
2
;
lOOOllO\
OllO\
l
=
lOOOl\
lOOllOO\

;
lOOOllOO\
llOO
=
llO\
l\
O\
O\
Ollll\
O
;
}
else\

if
(
lOO\
O\
l\
l\
O\
OllOl
>
llOlOOOl\
ll\
lO
)
{
llO\
lO\
OlOOOOl
=
2
;
lOOOllOOllOl
=
llOlOOOllllO
;
}
if\

(
lO\
OOllOOllOO
>
llOlOO\
Ol\
llll\

)
{
llOl\
OOl\
OOO\
Ol
=
llO\
l\
OO\
lOO\
OOO
;
llO\
l\
OOlOOOOO
=
3
;
lO\
OOllOOl\
l\
Ol\

=
lOOOllOOllOO
;
lOOOll\
O\
Ol\
lOO
=
llOlO\
OO\
ll\
lll
;
}
else
if
(
lOO\
OllO\
OllOl
>
llOlOOOlll\
ll
)
{
ll\
OlOOlO\
OOOl
=
3
;
lOOO\
llOOllOl
=
llO\
lO\
OOlllll
;
}
TA_ASSERT\

(
llO\
l\
O\
OlOOOOl\

!=
-
1
)
;
if\

(
lO\
O\
OllOOllOO
<
-
0.01f
)
{
lO\
OO\
l\
OOOOll\

-=
llOlOOO\
ll\
O\
l\
O
[
llO\
l\
OOlO\
OOO\
O
]
*
lOOOl\
lO\
OllOO
;
if
(
lOOOllOO\
ll\
Ol\

>
0
)
{
}
el\
se\

{
swit\
ch
(
llOlO\
OlOOOOO
)
{
ca\
se
0
:
if
(
llO\
lOOlOOOOl
==
3
)
lOO\
OlOOOOl\
l
=
lOllll\
l\
l\
lllO
;
else
if
(
llOlOOlOOO\
Ol
==
1
)
lOOO\
l\
OOO\
Oll
=
llOOOOO\
O\
OOOO
;
break\

;
case
1
:
if
(
llOlOO\
l\
O\
OO\
Ol
==
0
)
lOOOlO\
OO\
Ol\
l\

=
llOOOOOOO\
O\
OO
;
el\
se
if
(
llOlOOl\
OO\
OO\
l\

==
2
)
lOO\
OlOO\
O\
Oll
=
lOlll\
lllllOl
;
brea\
k\

;
ca\
se
2
:
if\

(
ll\
O\
lO\
O\
l\
OO\
OOl
==
1
)
lOOOl\
O\
O\
OO\
ll\

=
lOl\
ll\
ll\
l\
l\
lOl\

;
else
if
(
llOl\
OO\
lO\
OOOl\

==
3
)
lOOOlOO\
OOl\
l
=
lOlllll\
l\
llll
;
bre\
ak
;
ca\
s\
e
3
:
if
(
llOlOOlO\
O\
OOl
==
2
)
lOOOlOOOO\
l\
l\

=
lO\
ll\
llllll\
ll
;
else
if
(
ll\
OlO\
OlOOO\
Ol
==
0
)
lOOOl\
O\
OO\
Oll\

=
lOlllllll\
llO
;
bre\
ak
;
defa\
ult
:
lllO\
OO\
ll\
lO
;
}
}
if
(
lOl\
O\
l\
l\
llllO\
l\

)
{
Ve\
c3
lOO\
O\
lOOOOO
=
ll\
OlO\
OOl\
lOO\
l
.
Cro\
ss\

(
lOOO\
lOOOOl\
l\

.
Cross\

(
ll\
OlOOOllOO\
l\

)
)
;
flo\
a\
t
lOl\
l\
l\
lO\
Oll\

=
lOOOlO\
OOOO
.
GetMag\
nit\
u\
de\

(
)
;
if
(
lO\
lll\
lOOll
>
0.0000001f
)
*
lOlOllllllOl
=
lOO\
OlOOOOO
/
lO\
lll\
lOOl\
l
;
els\
e
*
lOlO\
llllllOl
=
llOl\
OOOllOlO
[
llOlOOlOOOOO\

]
;
ll\
O\
lOOOll\
lO\
O
=
lOl\
lllOOll
;
}
}
el\
s\
e
{
if
(
lOlOlll\
lllOl
)
{
Ve\
c3
lOOOl\
O\
OO\
O\
O
=
llO\
lOO\
Ol\
lOOl
.
Cro\
ss
(
lO\
O\
O\
lOO\
OO\
ll\

.
Cr\
o\
ss
(
ll\
O\
l\
O\
OOllOOl
)
)
;
flo\
a\
t
lOllllO\
Oll
=
lOOOlOOOOO
.
GetMagnitu\
de
(
)
;
if
(
lOllllO\
Oll
>
0.0000001f
)
*
lOlOl\
l\
llllOl
=
lOOOlOOOOO
/
lOl\
ll\
l\
OOll
;
else
*
lOl\
O\
llllllOl
=
llOlOO\
OllO\
lO\

[
llOlO\
OlOO\
OOO
]
;
}
}
ll\
OlOOOl\
l\
O\
Ol
=
lOO\
O\
l\
O\
O\
OOll
;
re\
turn\

ll\
O\
l\
OOO\
l\
llOO
;
}
vo\
id\

Phy\
sicsJo\
i\
nt
::
Initia\
lise
(
Dynam\
i\
cObje\
ct\

*
lOlOO\
OO\
OlOl\
l\

,
Dy\
na\
micObjec\
t
*
lOl\
OOOOOl\
lOO
)
{
TA_AS\
SER\
T
(
llOOl\
lllO\
lll\

==
0
)
;
TA_ASSERT
(
ll\
OO\
lllllOOO
==
0
)
;
llOOllllO\
lll
=
lOlOOO\
OOl\
Ol\
l\

;
llOO\
lll\
llOOO
=
lO\
lOOOO\
O\
l\
lOO
;
#ifdef llOlOOlOOOlO
llOOlll\
lOll\
l\

->
AddR\
ef
(
)
;
if\

(
ll\
OOllll\
lOOO
)
llOO\
l\
llllOOO
->
AddRe\
f
(
)
;
#endif //
}
void\

Phy\
s\
icsJ\
oin\
t
::
Fina\
l\
i\
se
(
)
{
ll\
O\
O\
l\
l\
llOl\
Ol
.
Clea\
r
(
)
;
llOOllllOll\
O
.
Cle\
ar\

(
)
;
if\

(
llOOllll\
O\
ll\
l\

)
{
#ifdef llOlOOlOOOlO
llOOll\
l\
lOlll
->
Rele\
ase
(
)
;
#endif //
ll\
OOllllO\
l\
ll\

=
0
;
}
if\

(
llOO\
lllll\
OOO\

)
{
#ifdef llOlOOlOOOlO
ll\
OOl\
lll\
lOOO
->
Rel\
ea\
se
(
)
;
#endif //
ll\
OOl\
l\
lllO\
OO
=
0
;
}
llOl\
OOOOOOOO
.
Cle\
a\
r
(
)
;
}
void
Ph\
ysics\
Joint
::
lOO\
ll\
Ollllll\

(
)
{
if
(
llO\
Oll\
ll\
O\
ll\
l
)
llO\
Oll\
ll\
Oll\
l
->
lO\
O\
llOlll\
lll
(
)
;
if
(
ll\
OO\
ll\
l\
l\
l\
OOO
)
llOOl\
l\
l\
l\
l\
O\
OO
->
lOOllOllll\
ll
(
)
;
}
}
